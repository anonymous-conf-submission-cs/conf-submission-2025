{"number": 1, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.7 2005/06/12 17:21:53 brun Exp $\n+// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.8 2005/06/14 05:06:03 brun Exp $\n // Author: Wim Lavrijsen, Jan 2005\n \n // Bindings\n@@ -138,7 +138,7 @@ PyObject* PyROOT::RootObjectByValueExecutor::Execute( G__CallFunc* func, void* s\n    void* result2 = result1;\n    if ( fClass->GetClassInfo() && fClass->GetClassInfo()->Linkage() != -1 ) {\n       result2 = new char[ fClass->Size() ];\n-      mempcpy( result2, result1, fClass->Size() );\n+      memcpy( result2, result1, fClass->Size() );\n    }\n    G__pop_tempobject();            // doesn't call dtor\n \n", "fix_pattern": "<pattern>: if the code uses mempcpy unnecessarily when memcpy suffices, replace it with memcpy for improved performance since memcpy is typically optimized for this use case and avoids potential unnecessary complications."}
{"number": 3, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.30 2007/01/15 10:15:47 brun Exp $\n+// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.31 2007/02/06 11:48:48 rdm Exp $\n // Author: Fons Rademakers   11/09/95\n \n /*************************************************************************\n@@ -28,7 +28,6 @@\n #include \"TObjArray.h\"\n #include \"TError.h\"\n #include \"TROOT.h\"\n-#include \"TRandom.h\"\n \n ClassImp(TObjArray)\n \n@@ -615,7 +614,7 @@ void TObjArray::Randomize(Int_t ntimes)\n \n    for (Int_t i=0;i<ntimes;i++) {\n       for (Int_t j=0;j<fLast;j++) {\n-         Int_t k = (Int_t)gRandom->Uniform(0,fLast);\n+         Int_t k = (Int_t)(fLast*rand()/(RAND_MAX+1.0));\n          if (k == j) continue;\n          TObject *obj = fCont[j];\n          fCont[j] = fCont[k];\n", "fix_pattern": "<pattern>: if a call to gRandom->Uniform is replaced with a direct use of rand() from the Standard C Library, consider if this change is made to avoid the overhead or dependency of the ROOT Framework for simpler random number generation."}
{"number": 4, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.175 2007/03/02 08:52:02 brun Exp $\n+// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.176 2007/03/14 11:31:36 brun Exp $\n // Author: Andrei Gheata   25/10/01\n \n /*************************************************************************\n@@ -5578,7 +5578,12 @@ TGeoManager *TGeoManager::Import(const char *filename, const char *name, Option_\n    } else {   \n       // import from a root file\n       TFile *old = gFile;\n-      TFile *f = TFile::Open(filename);\n+      // in case a web file is specified, use the cacheread option to cache\n+      // this file in the local directory\n+      TFile::SetCacheFileDir(\".\");\n+      TFile *f = 0;\n+      if (strstr(filename,\"http://\")) f = TFile::Open(filename,\"CACHEREAD\");\n+      else                            f = TFile::Open(filename);\n       if (!f || f->IsZombie()) {\n          if (old) old->cd();\n          printf(\"Error in <TGeoManager::Import>: Cannot open file\\n\");\n", "fix_pattern": "<pattern>: if a filename is detected as a URL starting with \"http://\", utilize the \"CACHEREAD\" option when opening the file through the TFile API to potentially improve file access performance by caching the contents locally."}
{"number": 5, "change": "@@ -2859,7 +2859,7 @@ Int_t TGX11::SetTextFont(char *fontname, ETextSetMode mode)\n          XSetFont(fDisplay, *gGCtext, gTextFont->fid);\n          XSetFont(fDisplay, *gGCinvt, gTextFont->fid);\n          gFont[gCurrentFontNumber].id = gTextFont;\n-         strcpy(gFont[gCurrentFontNumber].name,fontname);\n+         strlcpy(gFont[gCurrentFontNumber].name,fontname,80);\n          gCurrentFontNumber++;\n          if (gCurrentFontNumber == kMAXFONT) gCurrentFontNumber = 0;\n       }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with strlcpy to ensure safety by preventing buffer overflows through size checking."}
{"number": 6, "change": "@@ -1058,7 +1058,7 @@ Bool_t TXMLPlayer::ProduceSTLstreamer(ostream& fs, TClass* cl, TStreamerSTL* el,\n       strlcpy(tabs2, tabs, sizeof(tabs2));\n \n       if (isptr) {\n-         strncat(tabs2, tab1, sizeof(tabs2));\n+         strlcat(tabs2, tab1, sizeof(tabs2));\n          fs << tabs << \"if (\" << (isarr ? \"*cont\" : \"cont\") << \"==0) {\" << endl;\n          fs << tabs2 << \"buf.WriteSTLsize(0\" << (isstr ? \",true);\" : \");\") << endl;\n          fs << tabs << \"} else {\" << endl;\n", "fix_pattern": "<pattern>: if using strncat for concatenating strings, replace it with strlcat to improve safety and avoid buffer overflow issues, as strlcat provides better boundary checks compared to strncat."}
{"number": 8, "change": "@@ -558,15 +558,15 @@ void ProofdExec()\n       char *buf = (char *) vb;\n       char *end = buf + len;\n       const char name[] = \"PROOF_ALLVARS=\";\n-      char *all = new char[strlen(name)+len]; // strlen(\"PROOF_ALLVARS=\") = 14\n-      strncpy(all, name, strlen(name)+len);\n-      all[strlen(name)+len-1] = 0;\n+      int alen = strlen(name)+len;\n+      char *all = new char[alen]; // strlen(\"PROOF_ALLVARS=\") = 14\n+      strlcpy(all, name, alen);\n       while (buf < end) {\n          if (gDebug > 0) ErrorInfo(\"ProofdExec: setting: %s\", buf);\n          char *p = index(buf, '=');\n          if (p) {\n-            if (buf != (char *) vb) strncat(all, \",\", 1); // skip the first one\n-            strncat(all, buf, p-buf);\n+            if (buf != (char *) vb) strlcat(all, \",\", alen); // skip the first one\n+            strlcat(all, buf, alen);\n             putenv(buf);\n          }\n          buf += strlen(buf) + 1;\n", "fix_pattern": "<pattern>: if string manipulation is done using strncpy and strncat, replace them with strlcpy and strlcat for improved safety and performance, as strlcpy and strlcat not only copy and concatenate strings but also ensure null-termination and respect buffer sizes more effectively."}
{"number": 13, "change": "@@ -24,10 +24,7 @@ pythonizations.\n PyObject *CallPyObjMethod(PyObject *obj, const char *meth)\n {\n    // Helper; call method with signature: obj->meth()\n-   Py_INCREF(obj);\n-   PyObject* result = PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n-   Py_DECREF(obj);\n-   return result;\n+   return PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n }\n \n TClass *GetTClass(const CPyCppyy::CPPInstance *pyobj)\n", "fix_pattern": "<pattern>: if a reference counting operation is followed immediately by an API call and then a decref, it's unnecessary to increment the reference count before the call and decrement it after, as the called method is expected to manage the reference count appropriately. Thus, directly call the method without the extra reference counting."}
{"number": 15, "change": "@@ -46,7 +46,7 @@ void uThread::destory(bool force = false) {\n     //check whether we should cache it or not\n     totalNumberofUTs--;\n     if (slowpath(force) || (utCache.push(this) < 0)) {\n-        free((ptr_t) (stackBottom));       //Free the allocated memory for stack\n+        munmap((ptr_t) (stackBottom), stackSize);       //Free the allocated memory for stack\n     }\n }\n \n", "fix_pattern": "<pattern>: if freeing memory that was allocated with mmap or similar methods, use munmap instead of free to ensure proper memory deallocation in line with the allocation method used."}
{"number": 16, "change": "@@ -674,7 +674,8 @@ protected:\n                 if (path_attr != INVALID_FILE_ATTRIBUTES && (path_attr & FILE_ATTRIBUTE_DIRECTORY))\n                     ofn.lpstrInitialDir = m_wdefault_path.c_str();\n                 else if (m_wdefault_path.size() <= woutput.size())\n-                    lstrcpyW(ofn.lpstrFile, m_wdefault_path.c_str());\n+                    //second argument is size of buffer, not length of string\n+                    StringCchCopyW(ofn.lpstrFile, MAX_PATH*256+1, m_wdefault_path.c_str());\n                 else\n                 {\n                     ofn.lpstrFileTitle = (LPWSTR)m_wdefault_path.data();\n", "fix_pattern": "<pattern>: if a string copy is done using lstrcpyW, replace it with StringCchCopyW and provide the destination buffer size to avoid potential buffer overflows and improve safety."}
{"number": 29, "change": "@@ -557,9 +557,7 @@ template<typename real_t, typename index_t>\n \n #ifdef HAVE_MPI\n     if(nprocs>1){\n-      double lpredicted;\n-      MPI_Allreduce(&predicted, &lpredicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n-      predicted = lpredicted;\n+      MPI_Allreduce(MPI_IN_PLACE, &predicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n     }\n #endif\n     \n", "fix_pattern": "<pattern>: if a variable is used to receive a result from MPI_Allreduce and then assigned back to an original variable, simplify the call by using MPI_IN_PLACE to avoid unnecessary data copying, allowing for in-place reduction."}
{"number": 32, "change": "@@ -46,10 +46,11 @@\n // zlib compress2 function resulted in a 40+% reduction versus the original image.\n uint8_t* GFXRECON_zlib_compress2(uint8_t* data, int32_t data_len, int32_t* out_len, int32_t quality)\n {\n-    uint8_t* target = reinterpret_cast<uint8_t*>(malloc(data_len));\n+    unsigned long alloc_len = compressBound(data_len);\n+    uint8_t*      target    = reinterpret_cast<uint8_t*>(malloc(alloc_len));\n     if (nullptr != target)\n     {\n-        unsigned long ret_len = data_len;\n+        unsigned long ret_len = alloc_len;\n         if (Z_OK == compress2(target, &ret_len, data, data_len, quality))\n         {\n             *out_len = ret_len;\n", "fix_pattern": "<pattern>: when allocating memory for compressed data, use `compressBound(data_len)` to ensure sufficient space is allocated to accommodate compressed bytes instead of the uncompressed data length."}
{"number": 36, "change": "@@ -97,7 +97,8 @@ class DenoisingFunctor\n     X = svd.matrixU() * s.asDiagonal() * svd.matrixV().adjoint();\n     // Store output\n     assign_pos_of(dwi).to(out);\n-    out.row(3) = X.col(n/2).template cast<value_type>();\n+    for (auto l = Loop (3) (out); l; ++l)\n+      out.value() = X(out.index(3), n/2);\n   }\n   \n   void operator () (ImageType& dwi, ImageType& out, ImageType& noise)\n", "fix_pattern": "<pattern>: if there is a direct assignment from a column of an Eigen matrix to a row of a custom image type, replace it with a loop that accesses specific indices, which may optimize memory access patterns, especially when dealing with larger matrices and allowing for more fine-grained control over the assignment process."}
{"number": 38, "change": "@@ -2006,7 +2006,7 @@ void MainWindow::saveCameras(QString const& path, bool writeToProject)\n         auto const filepath = QDir{path}.filePath(cameraName);\n         out.insert(filepath, camera);\n \n-        if (QFileInfo(filepath).exists())\n+        if (QFileInfo::exists(filepath))\n         {\n           willOverwrite.append(filepath);\n         }\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is being created just to check for file existence, replace it with a static call to QFileInfo::exists to avoid unnecessary object creation and improve performance."}
{"number": 40, "change": "@@ -29,7 +29,7 @@\n \n #include <math.h>\n \n-vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.17\");\n+vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.18\");\n vtkStandardNewMacro(vtkSpherePuzzle);\n \n //----------------------------------------------------------------------------\n@@ -175,7 +175,7 @@ int vtkSpherePuzzle::RequestData(\n \n       // append all the pieces.\n       append->AddInput(tmp);\n-      tmp->Delete();\n+      tmp->FastDelete();\n       ++count;\n       }\n     }\n", "fix_pattern": "<pattern>: if a deletion operation on a VTK object is being performed using the more conventional Delete() method, replace it with FastDelete() to improve performance, especially for objects that may involve a significant overhead in reference counting. Additionally, the revision macro is updated to reflect a new version, which can indicate that the change is part of version management or enhancement as well."}
{"number": 41, "change": "@@ -956,9 +956,8 @@ int vtkGDALRasterReader::RequestData(vtkInformation* vtkNotUsed(request),\n   }\n \n   // Get the projection.\n-  char* proj = strdup(this->Impl->GDALData->GetProjectionRef());\n-  this->ProjectionWKT = proj;\n-  OGRSpatialReference spRef(proj);\n+  this->ProjectionWKT = this->Impl->GDALData->GetProjectionRef();\n+  OGRSpatialReference spRef(this->ProjectionWKT.c_str());\n \n   char* projection;\n   spRef.exportToProj4(&projection);\n", "fix_pattern": "<pattern>: if a string is obtained from an API and duplicated using strdup, directly assign the string to a member variable (e.g., std::string) to avoid unnecessary memory allocation and copying, and use the underlying c_str() method for interoperability with C APIs."}
{"number": 47, "change": "@@ -180,11 +180,16 @@ void ProblemReporter::reparse()\n     if( !m_javaSupport->isValid() )\n \treturn;\n \n+    // @todo: use the project database to decide which files to parse instead of this!\n+    // ugly hack: do not parse non .java ending files\n+    if ( !m_fileName.endsWith(\".java\") )\n+        return;\n+\n     m_timer->stop();\n \n     kdDebug(9013) << \"ProblemReporter::reparse()\" << endl;\n     m_javaSupport->backgroundParser()->addFile( m_fileName );\n-    kdDebug(9013) << \"---> file added\" << endl;\n+    kdDebug(9013) << \"---> file added \" << m_fileName << endl;\n }\n \n void ProblemReporter::slotSelected( QListViewItem* item )\n", "fix_pattern": "<pattern>: if logging a debug message occurs unconditionally, introduce a condition to skip logging for certain cases (such as files that do not end with a specific extension) to avoid unnecessary performance costs from function calls and streamline the logging process."}
{"number": 53, "change": "@@ -264,9 +264,9 @@ MediaSet::unref (const std::string &sessionId, const uint64_t &mediaObjectRef)\n \n void MediaSet::releasePointer (MediaObjectImpl *mediaObject)\n {\n-  mutex.lock();\n+  Monitor monitor (mutex);\n+\n   objectsMap.erase (mediaObject->getId() );\n-  mutex.unlock();\n \n   threadPool.push ( [mediaObject] () {\n     GST_DEBUG (\"Destroying %s\", mediaObject->getIdStr().c_str() );\n", "fix_pattern": "<pattern>: if mutex.lock() and mutex.unlock() are called in a sequence with no other operations in between, replace them with a scoped lock object to automatically manage the locking and unlocking of the mutex, thereby improving code clarity and reducing the chance of deadlocks due to exceptions."}
{"number": 54, "change": "@@ -16,7 +16,7 @@\n #include <QKeyEvent>\n #include <QKeySequence>\n #include <QList>\n-#include <QRegExp>\n+#include <QRegularExpression>\n #include <QStandardPaths>\n #include <QString>\n #include <QStringList>\n@@ -370,7 +370,7 @@ KeyboardMacrosPluginCommands::KeyboardMacrosPluginCommands(KeyboardMacrosPlugin\n \n bool KeyboardMacrosPluginCommands::exec(KTextEditor::View *view, const QString &cmd, QString &msg, const KTextEditor::Range &)\n {\n-    QStringList actionAndName = cmd.split(QRegExp(QStringLiteral(\"\\\\s+\")));\n+    QStringList actionAndName = cmd.split(QRegularExpression(QStringLiteral(\"\\\\s+\")));\n     if (actionAndName.length() != 2) {\n         msg = i18n(\"Usage: %1 <name>.\", actionAndName.at(0));\n         return false;\n", "fix_pattern": "<pattern>: if using QRegExp for regular expression operations, replace it with QRegularExpression for better performance and support for Unicode properties."}
{"number": 57, "change": "@@ -32,7 +32,7 @@\n #include <KDesktopFile>\n #include <QDir>\n #include <QFile>\n-#include <QDBusInterface>\n+#include <QDBusConnection>\n #include <QDBusPendingCall>\n \n namespace Plasma\n@@ -160,8 +160,9 @@ void PackageStructurePrivate::installPathChanged(const QString &path)\n             }\n         }\n     }\n-    QDBusInterface sycoca(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"));\n-    sycoca.asyncCall(QStringLiteral(\"recreate\"));\n+    const auto call = QDBusMessage::createMethodCall(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"),\n+        QStringLiteral(\"org.kde.kbuildsycoca\"), QStringLiteral(\"recreate\"));\n+    QDBusConnection::sessionBus().asyncCall(call);\n }\n \n \n", "fix_pattern": "<pattern>: if a QDBusInterface is constructed to make an asynchronous call, replace it with a direct call using QDBusMessage and QDBusConnection to avoid the overhead of constructing QDBusInterface, which is unnecessary for simple method calls."}
{"number": 59, "change": "@@ -537,9 +537,8 @@ void ViewManager::createView(Session* session, ViewContainer* container, int ind\n     // notify this view manager when the session finishes so that its view\n     // can be deleted\n     //\n-    // TODO - Find a more efficient a way to avoid multiple connections\n-    disconnect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n-    connect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n+    // Use Qt::UniqueConnection to avoid duplicate connection\n+    connect(session, SIGNAL(finished()), this, SLOT(sessionFinished()), Qt::UniqueConnection);\n \n     TerminalDisplay* display = createTerminalDisplay(session);\n     const Profile::Ptr profile = SessionManager::instance()->sessionProfile(session);\n", "fix_pattern": "<pattern>: if multiple connections are made to the same signal and slot pair, utilize Qt::UniqueConnection in the connect call to prevent duplicate connections and improve performance."}
{"number": 62, "change": "@@ -65,9 +65,8 @@ int main(int argc, char **argv)\n                     // that makes the operation much heavier than it needs to be\n                     isWallpaper = true;\n                 } else {\n-                    if (QFileInfo(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile)).exists()\n-                    || QFileInfo(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile)).exists()\n-                    ) {\n+                    if (QFileInfo::exists(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile))\n+                        || QFileInfo::exists(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile))) {\n                         isWallpaper = true;\n                         isKPackage = true;\n                         // Similarly to above, we could read all the information out of the kpackage, but\n", "fix_pattern": "<pattern>: if the QFileInfo constructor is used just to check for file existence, replace it with the QFileInfo::exists static method to improve performance by avoiding unnecessary object creation."}
{"number": 64, "change": "@@ -123,7 +123,9 @@ void fill_curl_eh(CURL *eh, C_Element *cube, bool isOverlay, FtpElement *elem) {\n     curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, my_fwrite);\n     curl_easy_setopt(eh, CURLOPT_WRITEDATA, elem);\n     curl_easy_setopt(eh, CURLOPT_PRIVATE, elem);\n-    curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    //curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_LIMIT, 1);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_TIME, 10);\n     curl_easy_setopt(eh, CURLOPT_CONNECTTIMEOUT, 10);\n     curl_multi_add_handle(curlm, eh);\n }\n", "fix_pattern": "<pattern>: if a timeout option is set on a CURL handle, consider using low-speed options instead to avoid cancelling connections with low traffic that may still be valid, enhancing the performance of network operations."}
{"number": 65, "change": "@@ -117,13 +117,15 @@ GLuint load_program(const char *path1, const char *path2) {\n void flip_image_vertical(\n     unsigned char *data, unsigned int width, unsigned int height)\n {\n-    unsigned char new_data[width * height * 4];\n-    unsigned int stride = width * 4;\n+    unsigned int size = width * height * 4;\n+    unsigned int stride = sizeof(char) * width * 4;\n+    unsigned char *new_data = malloc(sizeof(char) * size);\n     for (unsigned int i = 0; i < height; i++) {\n         unsigned int j = height - i - 1;\n         memcpy(new_data + j * stride, data + i * stride, stride);\n     }\n-    memcpy(data, new_data, sizeof(new_data));\n+    memcpy(data, new_data, size);\n+    free(new_data);\n }\n \n void load_png_texture(const char *file_name) {\n", "fix_pattern": "<pattern>: if a stack-allocated array is created to hold data temporarily and immediately copied to another location, allocate memory using `malloc` to avoid potential stack size limits, and ensure the size is correctly calculated, followed by freeing the memory after use."}
{"number": 70, "change": "@@ -1,12 +1,12 @@\n #include <stdlib.h>\n #include <stdio.h>\n-#include <string.h>\n+#include <sys/types.h>\n+#include <signal.h>\n \n int main(void)\n {\n   int i, pid;\n   FILE *fp;\n-  char str[32];\n \n   for(i = 0; i < 5; i++){\n     system(\"gmsh -pid fichier.msh fichier.pos > /tmp/gmsh.pid &\");\n@@ -18,7 +18,6 @@ int main(void)\n     fscanf(fp, \"%d\", &pid);\n     fclose(fp);\n \n-    sprintf(str, \"kill %d\", pid);\n-    system(str);\n+    kill(pid, 9);\n   }    \n } \n", "fix_pattern": "<pattern>: if a command to be executed via system() is constructed using sprintf, replace it with a direct call to kill() to eliminate unnecessary string handling and improve performance."}
{"number": 72, "change": "@@ -483,7 +483,7 @@ void CreateOutputFile(const std::string &fileName, int format,\n           glLoadMatrixd(modelview);\n         }\n         else{\n-          buffer.fill(CTX::instance()->batch);\n+          drawContext::global()->drawCurrentOpenglWindow(true);\n         }\n         res = gl2psEndPage();\n       }\n@@ -513,10 +513,9 @@ void CreateOutputFile(const std::string &fileName, int format,\n         gl2psBeginPage(base.c_str(), \"Gmsh\", viewport,\n                        GL2PS_TEX, GL2PS_NO_SORT, GL2PS_NONE, GL_RGBA, 0, NULL,\n                        0, 0, 0, buffsize, fp, base.c_str());\n-        PixelBuffer buffer(width, height, GL_RGB, GL_UNSIGNED_BYTE);\n         int oldtext = CTX::instance()->print.text;\n         CTX::instance()->print.text = 1;\n-        buffer.fill(CTX::instance()->batch);\n+        drawContext::global()->drawCurrentOpenglWindow(true);\n         CTX::instance()->print.text = oldtext;\n         res = gl2psEndPage();\n       }\n", "fix_pattern": "<pattern>: if a buffer is filled but immediately after the drawing operation is executed, remove the unnecessary buffer fill and directly call the drawing method to enhance performance."}
{"number": 73, "change": "@@ -88,8 +88,7 @@ AudioEncoder::EncodedInfo AudioEncoderCopyRed::EncodeInternal(\n       DCHECK_EQ(info.redundant.size(), 2u);\n     }\n     // Save primary to secondary.\n-    secondary_encoded_.SetSize(info.encoded_bytes);\n-    memcpy(secondary_encoded_.data(), encoded, info.encoded_bytes);\n+    secondary_encoded_.SetData(encoded, info.encoded_bytes);\n     secondary_info_ = info;\n     DCHECK_EQ(info.speech, info.redundant[0].speech);\n   }\n", "fix_pattern": "<pattern>: if memory is manually copied using memcpy after resizing a buffer, replace it with a more efficient API such as SetData that handles both setting the size and copying the data in a single method call."}
{"number": 74, "change": "@@ -88,7 +88,7 @@ DWORD GetThreadStartAddress(HANDLE processHandle, HANDLE hThread) {\n \n \tMODULEINFO mi;\n \n-\tGetModuleInformation(processHandle, LoadLibrary(\"kernel32.dll\"), &mi, sizeof(mi));\n+\tGetModuleInformation(processHandle, GetModuleHandle(\"kernel32.dll\"), &mi, sizeof(mi));\n \tstacktop = (DWORD)GetThreadStackTopAddress_x86(processHandle, hThread);\n \n \t/* The stub below has the same result as calling GetThreadStackTopAddress_x86() \n", "fix_pattern": "<pattern>: if an API call to LoadLibrary is being used to retrieve a module handle for a DLL that is already loaded, replace it with GetModuleHandle to avoid the overhead of loading the library again."}
{"number": 76, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified and additional attributes are set, refactor by using the existing descriptor directly to avoid unnecessary parameters and streamline the code for better clarity and potential performance improvements."}
{"number": 78, "change": "@@ -484,8 +484,7 @@ IniFile::TildeExpansion(const char *file, char *path)\n \n     /* Buffer overflow has already been checked. */\n \n-    strcpy(path, home);\n-    strcat(path, file + 1);\n+    snprintf(path, LINELEN, \"%s%s\", home, file + 1);\n     return;\n }\n \n", "fix_pattern": "<pattern>: if multiple string manipulations are performed with strcpy and strcat, replace with snprintf for a single operation that combines both operations into one, improving performance and reducing buffer overflow risks."}
{"number": 84, "change": "@@ -321,7 +321,7 @@ bool romLoaded(Logger* logger, System system, const std::string& path, void* rom\n   case System::kAtariLynx:\n     rom = util::loadFile(logger, path, &size);\n \n-    if (!strcmp(\"LYNX\", (char *)rom))\n+    if (!memcmp(\"LYNX\", (void *)rom, 5))\n     {\n         RA_OnLoadNewRom((BYTE*)rom + 0x0040, size - 0x0040);\n     }\n", "fix_pattern": "<pattern>: if a string comparison is made using strcmp for a fixed-length comparison, replace it with memcmp to improve performance by comparing raw memory directly."}
{"number": 94, "change": "@@ -160,6 +160,7 @@ void PackageKitBackend::acquireFetching(bool f)\n \n void PackageKitBackend::reloadPackageList()\n {\n+    qDebug() << \"xxx\";\n     acquireFetching(true);\n     if (m_refresher) {\n         disconnect(m_refresher.data(), &PackageKit::Transaction::finished, this, &PackageKitBackend::reloadPackageList);\n@@ -185,9 +186,9 @@ void PackageKitBackend::reloadPackageList()\n \n         const auto pkgNames = component.packageNames();\n         if (pkgNames.isEmpty()) {\n-            auto launchable = component.launchable(AppStream::Launchable::KindDesktopId);\n-            if (component.kind() == AppStream::Component::KindDesktopApp && !launchable.entries().isEmpty()) {\n-                const QString file = locateService(launchable.entries().constFirst());\n+            const auto entries = component.launchable(AppStream::Launchable::KindDesktopId).entries();\n+            if (component.kind() == AppStream::Component::KindDesktopApp && !entries.isEmpty()) {\n+                const QString file = locateService(entries.first());\n                 if (!file.isEmpty()) {\n                     acquireFetching(true);\n                     auto trans = PackageKit::Daemon::searchFiles(file);\n", "fix_pattern": "<pattern>: if an API method is called multiple times on the same object within a conditional statement, store the result in a variable to avoid redundant calls, which improves performance by reducing unnecessary computations."}
{"number": 95, "change": "@@ -573,7 +573,7 @@ void PreviewJob::slotResult(KJob *job)\n         const KIO::filesize_t size = (KIO::filesize_t)statResult.numberValue(KIO::UDSEntry::UDS_SIZE, 0);\n         const QUrl itemUrl = d->currentItem.item.mostLocalUrl();\n \n-        if (itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) {\n+        if ((itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) && !d->currentItem.item.isSlow()) {\n             skipCurrentItem = !d->ignoreMaximumSize && size > d->maximumLocalSize && !d->currentItem.plugin.value(QStringLiteral(\"IgnoreMaximumSize\"), false);\n         } else {\n             // For remote items the \"IgnoreMaximumSize\" plugin property is not respected\n", "fix_pattern": "<pattern>: if a conditional checks for local file protocols through `isLocalFile()` or `protocolClass()`, enhance the conditional logic by adding an additional check for `isSlow()` to avoid unnecessary processing when dealing with slow items."}
{"number": 102, "change": "@@ -387,7 +387,9 @@ void SystemDriver::UpdateVelocity(mfem::ParGridFunction &velocity, mfem::Vector\n             }\n #endif\n          } // End if vgrad_origin_flag\n-         const double* dmin_x = vgrad_origin.Read();\n+         Vector origin(space_dim, mfem::Device::GetMemoryType()); origin.UseDevice(true);\n+         MPI_Allreduce(vgrad_origin.HostRead(), origin.HostReadWrite(), space_dim, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n+         const double* dmin_x = origin.Read();\n          // We've now found our minimum points so we can now go and calculate everything.\n          MFEM_FORALL(i, nnodes, {\n             for (int ii = 0; ii < space_dim; ii++) {\n", "fix_pattern": "<pattern>: if the code is reading data from a source with potential performance implications (like `vgrad_origin.Read()`), switch to using MPI for parallel reduction (like `MPI_Allreduce`) and leverage device memory management with `Vector` to improve data handling efficiency."}
{"number": 106, "change": "@@ -52,6 +52,8 @@ namespace {\n \n   // Using native file handles instead of file descriptors for reducing the resource consumption.\n \n+  const HANDLE InvalidFile = INVALID_HANDLE_VALUE;\n+\n   HANDLE openFile(const FileName &path, bool readOnly)\n   {\n     DWORD access = readOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);\n@@ -82,6 +84,8 @@ namespace {\n \n   // For non-Windows \n \n+  const FILE *InvalidFile = 0;\n+\n   struct FileNameHandle : public std::string\n   {\n     FileNameHandle(FileName name) : std::string(name) {}\n@@ -119,7 +123,7 @@ public:\n };\n \n FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openReadOnly) :\n-  file(0),\n+  file(InvalidFile),\n   name(fileName),\n   readOnly(true),\n   size(0)\n@@ -129,12 +133,12 @@ FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openRea\n   if(!openReadOnly)\n     file = openFile(name, false);\n \n-  if(file)\n+  if(file != InvalidFile)\n     readOnly = false;\n   else\n     file = openFile(name, true);\n \n-  if(!file) {\n+  if(file == InvalidFile) {\n     debug(\"Could not open file \" + String((const char *) name));\n   }\n }\n", "fix_pattern": "<pattern>: if a variable is being checked against a file handle, replace the direct comparison with a predefined constant (INVALID_HANDLE_VALUE) for better readability and potential optimization in checks against the invalid file state."}
{"number": 108, "change": "@@ -98,13 +98,8 @@ void Pool::joinAll()\n \n Pool::WorkerCountType Pool::getWorkQueueCount() const\n {\n-\tPool::WorkerCountType size = 0;\n-\t\n-\tenqueuedWorkMutex.lock();\n-\tsize = enqueuedWork.size();\n-\tenqueuedWorkMutex.unlock();\n-\t\n-\treturn size;\n+\tstd::lock_guard<std::mutex> l(enqueuedWorkMutex);\t\n+\treturn enqueuedWork.size();\n }\n \n Pool::WorkerCountType Pool::getActiveWorkerCount() const\n", "fix_pattern": "<pattern>: if manual locking and unlocking of a mutex is performed, use a std::lock_guard to manage the mutex automatically and ensure proper unlocking after the scope ends, improving code clarity and safety."}
{"number": 118, "change": "@@ -165,7 +165,7 @@ std::string PluginSerializer::SerializeToFile(const std::string& content_url,\n     return \"\";\n   }\n \n-  size_t num_written = fwrite(body.c_str(), 1, body.size(), file);\n+  size_t num_written = fwrite(body.data(), 1, body.size(), file);\n   fclose(file);\n   if (num_written != body.size()) {\n     LOG(ERROR) << \"Failed to WriteDataToFile for \" << string_path\n", "fix_pattern": "<pattern>: if a string's underlying data is accessed for writing (such as with fwrite), prefer to use body.data() instead of body.c_str() to avoid the potential overhead of constructing a null-terminated string when it's not necessary."}
{"number": 128, "change": "@@ -37,7 +37,7 @@\n #endif\n \n #include <math.h>\n-#include <string.h>\n+#include \"string2.h\"\n #include \"typedefs.h\"\n #include \"macros.h\"\n #include \"copyrite.h\"\n@@ -157,7 +157,7 @@ int main (int argc,char *argv[])\n     iatoms->resinfo[resind] = atoms->resinfo[atoms->atom[index[i]].resind];\n     /* allocate some space for the rtp name and copy from name */\n     snew(iatoms->resinfo[resind].rtp,1);\n-    strcpy(iatoms->resinfo[resind].rtp, atoms->resinfo[resind].name);\n+    iatoms->resinfo[resind].rtp = gmx_strdup(atoms->resinfo[resind].name);\n \n     iatoms->nres = max(iatoms->nres, iatoms->atom[i].resind+1);\n   }\n", "fix_pattern": "<pattern>: if a direct string copy is performed using `strcpy`, replace it with a project-specific optimized function `gmx_strdup` that may handle memory allocation more efficiently and ensure the destination is properly handled."}
{"number": 131, "change": "@@ -126,8 +126,7 @@ TiffIFD* TiffIFD::parseDngPrivateData(TiffEntry *t) {\n   */\n   uint32 size = t->count;\n   const uchar8 *data = t->getData();\n-  string id((const char*)data);\n-  if (0 != id.compare(\"Adobe\"))\n+  if (0 != memcmp(data, \"Adobe\", 6))\n     ThrowTPE(\"Not Adobe Private data\");\n \n   data+=6;\n", "fix_pattern": "<pattern>: if a string comparison is needed and the length of the string is known, replace std::string::compare with memcmp for lower-level performance improvements, as memcmp is generally faster for fixed-length comparisons."}
{"number": 136, "change": "@@ -48,7 +48,7 @@ namespace tp {\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlWriteCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &response.body);\n-\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); //10s timeout\n+\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L); //5s timeout\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, CurlHeadersCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEHEADER, &response.headers);\n", "fix_pattern": "<pattern>: if a timeout value is being configured for a CURL request, ensure to set a lower timeout value for better responsiveness and improved resource utilization; in this case, reducing from 10 seconds to 5 seconds."}
{"number": 137, "change": "@@ -229,11 +229,10 @@ ProgClient::run_program(const string &progname, const string &args\n     startupinfo.hStdInput = hClient;\n     startupinfo.dwFlags |= STARTF_USESTDHANDLES;\n \n-    // For some reason Windows wants a modifiable copy!\n-    BOOL ok;\n-    char * cmdline = strdup((progname + ' ' + args).c_str());\n-    ok = CreateProcess(0, cmdline, 0, 0, TRUE, 0, 0, 0, &startupinfo, &procinfo);\n-    free(cmdline);\n+    // For some reason Windows wants a modifiable command line!\n+    string cmdline = progname + ' ' + args;\n+    BOOL ok = CreateProcess(0, &cmdline[0], 0, 0, TRUE, 0, 0, 0,\n+\t\t\t    &startupinfo, &procinfo);\n     if (!ok) {\n \tthrow Xapian::NetworkError(\"CreateProcess failed\",\n \t\t\t\t   get_progcontext(progname, args),\n", "fix_pattern": "<pattern>: if a modifiable command line is required for CreateProcess, construct the command line as a std::string and use its internal buffer directly instead of creating a separate modifiable copy with strdup and then freeing it. This avoids unnecessary memory allocation and deallocation overhead."}
{"number": 138, "change": "@@ -1430,10 +1430,6 @@ GlassTable::readahead_key(const string &key) const\n     LOGCALL(DB, bool, \"GlassTable::readahead_key\", key);\n     Assert(!key.empty());\n \n-    // An overlong key cannot be found.\n-    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n-\tRETURN(false);\n-\n     // Three cases:\n     //\n     // handle == -1:  Lazy table in a multi-file database which isn't yet open.\n@@ -1450,6 +1446,10 @@ GlassTable::readahead_key(const string &key) const\n     if (level == 0)\n \tRETURN(false);\n \n+    // An overlong key cannot be found.\n+    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n+\tRETURN(true);\n+\n     form_key(key);\n \n     // We'll only readahead the first level, since descending the B-tree would\n", "fix_pattern": "<pattern>: if the return value is used to indicate the success or failure of a key search operation in a B-tree, change the logic to return true for the case of an overlong key, as it indicates an immediate failure to locate a valid key that should be found within the defined limits."}
{"number": 142, "change": "@@ -3000,15 +3000,14 @@ BOOL allocateName(char **ppStore, const char *pName)\n \t}\n \treturn TRUE;\n #else\n-\t//need to allocate space for the name\n-\t*ppStore = (char*)malloc((strlen(pName))+1);\n+\t// Allocate space for the name and copy it\n+\t*ppStore = strdup(pName);\n \tif (ppStore == NULL)\n \t{\n-\t\tdebug( LOG_ERROR, \"Name - Out of memory\" );\n+\t\tdebug(LOG_ERROR, \"allocateName: Out of memory\");\n \t\tabort();\n \t\treturn FALSE;\n \t}\n-\tstrcpy(*ppStore,pName);\n \n \treturn TRUE;\n #endif\n", "fix_pattern": "<pattern>: if memory is allocated for a string with malloc and then copied with strcpy, replace it with strdup for better performance and simplicity, as strdup handles both allocation and copying in one call."}
{"number": 143, "change": "@@ -406,7 +406,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \n \t// Now dump the data into the buffer\n \t// Copy a string\n-\tsstrcpy(buffer, game->name);\n+\tstrlcpy(buffer, game->name, sizeof(game->name));\n \tbuffer += sizeof(game->name);\n \n \t// Copy 32bit large big endian numbers\n@@ -416,7 +416,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \tbuffer += sizeof(int32_t);\n \n \t// Copy yet another string\n-\tsstrcpy(buffer, game->desc.host);\n+\tstrlcpy(buffer, game->desc.host, sizeof(game->desc.host));\n \tbuffer += sizeof(game->desc.host);\n \n \t// Copy 32bit large big endian numbers\n", "fix_pattern": "<pattern>: replace project-specific string copy operation (sstrcpy) with safer and size-aware string copy operation (strlcpy) to avoid buffer overflows and improve performance with potentially better memory management."}
{"number": 148, "change": "@@ -50,7 +50,7 @@ tlp::Color ChooseColorButton::tulipColor() const {\n \n void ChooseColorButton::setColor(const QColor& c) {\n   _color = c;\n-  repaint();\n+  update();\n   emit colorChanged(_color);\n   emit tulipColorChanged(QColorToColor(_color));\n }\n", "fix_pattern": "<pattern>: replace QWidget::repaint() with QWidget::update() to improve performance by avoiding unnecessary immediate repainting and instead queueing a repaint for later, which can reduce the frequency of redraw operations."}
{"number": 156, "change": "@@ -36,7 +36,9 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    strncpy(pchCommand, pszCommand, COMMAND_SIZE);\n+    int command_len = strlen(pszCommand);\n+    memcpy(pchCommand, pszCommand, command_len);\n+    memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n     nChecksum = 0;\n }\n", "fix_pattern": "<pattern>: if a string is copied using strncpy, replace it with memcpy followed by memset to ensure the destination is properly null-terminated while improving performance with direct memory operations."}
{"number": 157, "change": "@@ -36,7 +36,7 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    int command_len = strlen(pszCommand);\n+    size_t command_len = strnlen(pszCommand, COMMAND_SIZE);\n     memcpy(pchCommand, pszCommand, command_len);\n     memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n", "fix_pattern": "<pattern>: if the code uses strlen to determine the length of a string, replace it with strnlen while providing a maximum length to avoid potential overflow issues and improve safety when the size of the string is limited."}
{"number": 168, "change": "@@ -1285,7 +1285,7 @@ void FMultiPatchTexture::ResolvePatches()\n \t\t{\n \t\t\tif (Parts[i].Texture == nullptr)\n \t\t\t{\n-\t\t\t\tmemcpy(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n+\t\t\t\tmemmove(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n \t\t\t\ti--;\n \t\t\t\tNumParts--;\n \t\t\t}\n", "fix_pattern": "<pattern>: if a block of memory is being moved within the same array (i.e., source and destination overlap), replace memcpy with memmove to safely handle overlapping regions."}
{"number": 173, "change": "@@ -43,9 +43,9 @@ inline void update(_T& _sha, _U const& _value)\n {\n \tint i = 0;\n \tfor (_U v = _value; v; ++i, v >>= 8) {}\n-\tbytes buf(i);\n-\ttoBigEndian(_value, buf);\n-\t_sha.Update(buf.data(), buf.size());\n+\tbyte buf[32];\n+\ttoBigEndian(_value, bytesRef(buf, i));\n+\t_sha.Update(buf, i);\n }\n \n template <class _T>\n", "fix_pattern": "<pattern>: if dynamic memory (e.g., using a vector or similar) is used for a small fixed-size buffer, replace it with a stack-allocated array for better performance and reduced memory overhead."}
{"number": 174, "change": "@@ -46,6 +46,7 @@\n  * Stride Prefetcher template instantiations.\n  */\n \n+#include \"base/random.hh\"\n #include \"debug/HWPrefetch.hh\"\n #include \"mem/cache/prefetch/stride.hh\"\n \n@@ -176,7 +177,7 @@ StridePrefetcher::pcTableVictim(Addr pc, int master_id)\n {\n     // Rand replacement for now\n     int set = pcHash(pc);\n-    int way = rand() % pcTableAssoc;\n+    int way = random_mt.random<int>(0, pcTableAssoc - 1);\n \n     DPRINTF(HWPrefetch, \"Victimizing lookup table[%d][%d].\\n\", set, way);\n     return &pcTable[master_id][set][way];\n", "fix_pattern": "<pattern>: if the code uses the standard `rand()` function for generating random numbers, replace it with a project-specific random number generator method for improved performance and potentially better randomness properties."}
{"number": 180, "change": "@@ -48,8 +48,8 @@ extern \"C\" JNIEXPORT void JNICALL Java_Main_waitUntilJitted(JNIEnv* env,\n     if (code_cache->ContainsPc(header->GetCode())) {\n       break;\n     } else {\n-      // yield to scheduler to give time to the JIT compiler.\n-      sched_yield();\n+      // Sleep to yield to the compiler thread.\n+      sleep(0);\n       // Will either ensure it's compiled or do the compilation itself.\n       jit->CompileMethod(method, Thread::Current(), /* osr */ false);\n     }\n", "fix_pattern": "<pattern>: if the original code uses `sched_yield()` to yield time to the JIT compiler, replace it with `sleep(0)` to achieve a similar effect with potentially better performance in terms of scheduling efficiency."}
{"number": 181, "change": "@@ -108,11 +108,8 @@ static LRESULT HandleCopyData(LPARAM lParam) {\n \tCOPYDATASTRUCT *pcds = reinterpret_cast<COPYDATASTRUCT *>(lParam);\n \t// Copy into an temporary buffer to ensure \\0 terminated\n \tif (pcds->lpData) {\n-\t\tchar *dataCopy = new char[pcds->cbData + 1];\n-\t\tstrncpy(dataCopy, static_cast<char *>(pcds->lpData), pcds->cbData);\n-\t\tdataCopy[pcds->cbData] = '\\0';\n-\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy);\n-\t\tdelete []dataCopy;\n+\t\tstd::string dataCopy(static_cast<char *>(pcds->lpData), pcds->cbData);\n+\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy.c_str());\n \t}\n \treturn 0;\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation and manual string copy using strncpy is used, replace it with a std::string construction to avoid memory management overhead and ensure better safety and performance."}
{"number": 182, "change": "@@ -1490,16 +1490,13 @@ BOOL SciTEWin::TabSizeMessage(HWND hDlg, UINT message, WPARAM wParam) {\n \t\t\tint tabSize = wEditor.Call(SCI_GETTABWIDTH);\n \t\t\tif (tabSize > 99)\n \t\t\t\ttabSize = 99;\n-\t\t\tchar tmp[3];\n-\t\t\tsprintf(tmp, \"%d\", tabSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDTABSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDTABSIZE, tabSize, FALSE);\n \n \t\t\t::SendDlgItemMessage(hDlg, IDINDENTSIZE, EM_LIMITTEXT, 2, 1);\n \t\t\tint indentSize = wEditor.Call(SCI_GETINDENT);\n \t\t\tif (indentSize > 99)\n \t\t\t\tindentSize = 99;\n-\t\t\tsprintf(tmp, \"%d\", indentSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDINDENTSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDINDENTSIZE, indentSize, FALSE);\n \n \t\t\t::CheckDlgButton(hDlg, IDUSETABS, wEditor.Call(SCI_GETUSETABS));\n \t\t\treturn TRUE;\n", "fix_pattern": "<pattern>: if there is a need to set an integer value to a dialog item using a string conversion via sprintf and then SetDlgItemTextA, replace it with a direct call to SetDlgItemInt for better performance, avoiding unnecessary string formatting."}
{"number": 190, "change": "@@ -1,3 +1,5 @@\n+#define OPENSSL_SUPPRESS_DEPRECATED\n+\n #include <psibase/crypto.hpp>\n \n #include <openssl/sha.h>\n@@ -126,8 +128,11 @@ namespace psibase\n    Checksum256 sha256(const char* data, size_t length)\n    {\n       //std::array<unsigned char, 256 / 8> result;\n+      SHA256_CTX ctx;\n+      SHA256_Init(&ctx);\n+      SHA256_Update(&ctx, (const unsigned char*)data, length);\n       Checksum256 result;\n-      SHA256((const unsigned char*)data, length, (unsigned char*)result.data());\n+      SHA256_Final((unsigned char*)result.data(), &ctx);\n       return result;\n    }\n \n", "fix_pattern": "<pattern>: when using the SHA256 function from OpenSSL, instead of calling a single function that may lead to inefficiencies, refactor the code to use the initialization, update, and finalization steps with the SHA256_CTX context, which allows for better control of the hashing process and may improve performance by reducing memory allocations and managing state more explicitly."}
{"number": 198, "change": "@@ -54,7 +54,13 @@ int sock;\n #ifdef UNIX_ASYNC_DNS\n   static XP_Bool done = FALSE;\n \n-  LOG(\"XFE_InitDNS_Early\", (\"calling DNS_SpawnProcess.\\n\"));\n+  /*\n+   * The following used to be LOG() instead of fprintf(). But, LOG() uses\n+   * PR_smprintf() which fires up NSPR.\n+   */\n+#ifdef PROC1_DEBUG_PRINT\n+  fprintf(stderr, \"\\tproc1 (%d): %s\\n\", getpid(), \"XFE_InitDNS_Early: calling DNS_SpawnProcess.\");\n+#endif\n   sock = DNS_SpawnProcess(argc, argv);\n \n   XP_ASSERT(!done);\n", "fix_pattern": "<pattern>: if a logging function (LOG) introduces significant overhead due to additional processing (like memory allocation via PR_smprintf), replace it with a lower-overhead alternative (like fprintf) when debugging output is necessary to improve performance."}
{"number": 204, "change": "@@ -230,8 +230,10 @@ nsresult nsCollationMac::CreateRawSortKey(const nsCollationStrength strength,\n     }\n     else {\n       // No CJK support, just copy the row string.\n-      strcpy((char *) key, str);\n-      while (*key) {\n+      // Collation key is not a string, use memcpy instead of strcpy.\n+      nsCRT::memcpy(key, str, str_len);\n+      PRUint8 *end = key + str_len;\n+      while (key < end) {\n         if ((unsigned char) *key < 128) {\n           key++;\n         }\n", "fix_pattern": "<pattern>: if a string is being copied to a buffer where the length is known, replace strcpy with memcpy to eliminate null-termination overhead and improve performance."}
{"number": 205, "change": "@@ -365,7 +365,7 @@ ns4xPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,\n       amountRead -= writeCount;\n       mPosition += writeCount;\n       if (amountRead > 0)\n-        strncpy(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n+        memmove(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n     }\n   }\n \n", "fix_pattern": "<pattern>: if a memory block is being shifted within a buffer, replace `strncpy` with `memmove` to properly handle overlapping memory regions, improving safety and performance."}
{"number": 218, "change": "@@ -27,7 +27,8 @@ void AMQPMessage::setMessage(const char * data,uint32_t length) {\n \tif (this->data)\n \t\tfree(this->data);\n \n-\tthis->data = strdup(data);\n+\tthis->data = (char*)malloc(length);\n+\tmemcpy(this->data,data,length);\n \tthis->len = length;\n }\n \n", "fix_pattern": "<pattern>: if strdup is used to allocate and copy a string, replace it with malloc followed by memcpy for potentially better performance and control over allocation size."}
{"number": 219, "change": "@@ -21,6 +21,7 @@ using namespace Cicada;\n #define RINGBUFFER_BACK_SIZE 1024*512\n \n #define MIN_SO_RCVBUF_SIZE 1024*64\n+#define READ_BUFFER_SIZE 1024 * 64\n \n #define SOCKET_ERROR (-1)\n \n@@ -384,7 +385,7 @@ int Cicada::CURLConnection::esayHandle_set_common_opt()\n     curl_easy_setopt(mHttp_handle, CURLOPT_DEBUGDATA, this);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERFUNCTION, write_response);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERDATA, this);\n-    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, CURL_MAX_READ_SIZE);\n+    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, READ_BUFFER_SIZE);\n     return 0;\n }\n \n", "fix_pattern": "<pattern>: if the CURLOPT_BUFFERSIZE is set directly with a constant, replace it with a defined constant value that represents a more suitable buffer size for performance optimization."}
{"number": 222, "change": "@@ -127,8 +127,8 @@ bool fetch_mod(wchar_t *version) {\n \t}\n \tFILE *out = NULL;\n \tcurl_easy_setopt(curl, CURLOPT_URL, fetch_url_utf8);\n-\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 3200L);\n-\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 40000L);\n+\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 2000L);\n+\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 20000L);\n \tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);\n \tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);\n \tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n", "fix_pattern": "<pattern>: if there is a need to improve performance related to network timeouts in a curl request, consider adjusting timeout values to lower settings that do not compromise functionality; this can reduce the time spent waiting for network operations to complete, enhancing responsiveness."}
{"number": 225, "change": "@@ -68,16 +68,16 @@ QString EwsMailHandler::mimeType()\n bool EwsMailHandler::setItemPayload(Akonadi::Item &item, const EwsItem &ewsItem)\n {\n     qDebug() << \"EwsMailHandler::setItemPayload\";\n-    QString mimeContent = ewsItem[EwsItemFieldMimeContent].toString();\n+    QByteArray mimeContent = ewsItem[EwsItemFieldMimeContent].toByteArray();\n     if (mimeContent.isEmpty()) {\n         qWarning() << QStringLiteral(\"MIME content is empty!\");\n         return false;\n     }\n \n-    mimeContent.replace(QStringLiteral(\"\\r\\n\"), QStringLiteral(\"\\n\"));\n+    mimeContent.replace(\"\\r\\n\", \"\\n\");\n \n     KMime::Message::Ptr msg(new KMime::Message);\n-    msg->setContent(mimeContent.toLatin1());\n+    msg->setContent(mimeContent);\n     msg->parse();\n     qDebug() << msg->attachments().size() << \"attachments\";\n     // Some messages might just be empty (just headers). This results in the body being empty.\n", "fix_pattern": "<pattern>: if a QString is converted to a byte array using toString and then later converted to a QByteArray with toLatin1, refactor the code to directly use toByteArray for better performance and to eliminate unnecessary conversions."}
{"number": 231, "change": "@@ -13,7 +13,6 @@\n #include <arpa/inet.h>\n #include <assert.h>\n #include <errno.h>\n-#include <fcntl.h>\n #include <inttypes.h>\n #include <netinet/in.h>\n #include <poll.h>\n@@ -123,12 +122,10 @@ static void await_debugger(struct GdbContext* dbg, ScopedFd& listen_fd) {\n   struct sockaddr_in client_addr;\n   socklen_t len = sizeof(client_addr);\n \n-  dbg->sock_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &len);\n+  dbg->sock_fd =\n+      accept4(listen_fd, (struct sockaddr*)&client_addr, &len, SOCK_NONBLOCK);\n   // We might restart this debugging session, so don't set the\n   // socket fd CLOEXEC.\n-  if (fcntl(dbg->sock_fd, F_SETFL, O_NONBLOCK)) {\n-    FATAL() << \"Can't make client socket NONBLOCK\";\n-  }\n }\n \n struct debugger_params {\n", "fix_pattern": "<pattern>: if the accept method is called and the socket needs to be set to non-blocking mode afterwards, replace it with accept4 which allows setting the socket to non-blocking mode in a single call for better performance."}
{"number": 232, "change": "@@ -85,7 +85,7 @@ static ScopedFd create_memfd_file(const string& orig_path, dev_t orig_device,\n        << \"-inode-\" << orig_inode << \"-\" << orig_path;\n   real_name = name.str().substr(0, 255);\n \n-  ScopedFd fd = memfd_create(real_name.c_str(), 0);\n+  ScopedFd fd = syscall(SYS_memfd_create, real_name.c_str(), 0);\n   return fd;\n }\n \n", "fix_pattern": "<pattern>: if the code uses a higher-level API function like memfd_create that incurs additional overhead due to abstraction, refactor it to directly use the syscall interface for better performance by reducing function call overhead and leveraging lower-level operations directly."}
{"number": 240, "change": "@@ -1,5 +1,5 @@\n /*\n-   Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.\n+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -1307,7 +1307,7 @@ TransporterFacade::close_clnt(trp_client* clnt)\n         clnt->do_forceSend(1);\n         first = false;\n       }\n-      clnt->do_poll(0);\n+      clnt->do_poll(10);\n       not_finished = (m_threads.get(clnt->m_blockNo) == clnt);\n       clnt->complete_poll();\n     } while (not_finished);\n", "fix_pattern": "<pattern>: if the timeout parameter for an API method is set to zero, which may result in the method to be non-blocking and potentially lead to busy-waiting, adjust the timeout to a positive value to allow for more efficient waiting (e.g., using a sleep mechanism) which can enhance performance in scenarios with polling."}
{"number": 241, "change": "@@ -6112,7 +6112,6 @@ void* background_thread(void*)\n   mysql_mutex_lock(&background_mutex);\n   mysql_mutex_lock(&stop_cond_mutex);\n \n-  rocksdb::WriteBatch wb;\n   time_t last_stat_recompute = 0;\n   for (;;)\n   {\n@@ -6128,9 +6127,8 @@ void* background_thread(void*)\n     assert(ret == 0 || ret == ETIMEDOUT);\n \n     if (rdb && rocksdb_background_sync) {\n-      auto wo = rocksdb::WriteOptions();\n-      wo.sync = true;\n-      rocksdb::Status s= rdb->Write(wo, &wb);\n+      assert(!db_options.allow_mmap_writes);\n+      rocksdb::Status s= rdb->SyncWAL();\n       if (!s.ok())\n         rocksdb_handle_io_error(s, ROCKSDB_IO_ERROR_BG_THREAD);\n     }\n", "fix_pattern": "<pattern>: if a write operation is performed with `rocksdb::Write`, and it is determined that write-ahead logging (WAL) should be synchronized without custom write options, replace the write operation with `rocksdb::DB::SyncWAL()` for improved performance, especially when synchronous writes are unnecessary. This change also removes complexity from write options and directly manages the log synchronization."}
{"number": 251, "change": "@@ -67,14 +67,8 @@ void OGGLoader::into(Loadable& resource, const LoaderOptions& options) {\n     Sound* sound = dynamic_cast<Sound*>(res_ptr);\n     assert(sound && \"You passed a Resource that is not a Sound to the OGG loader\");\n \n-    std::ifstream t(filename_.encode().c_str(), std::ios::binary);\n-    std::vector<uint8_t> data;\n-\n-    t.seekg(0, std::ios::end);\n-    data.reserve(t.tellg());\n-    t.seekg(0, std::ios::beg);\n-\n-    data.assign((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());\n+    std::string buf = data_->str();\n+    std::vector<uint8_t> data(buf.begin(), buf.end());\n \n     StreamWrapper stream(stb_vorbis_open_memory(&data[0], data.size(),nullptr, nullptr));\n \n", "fix_pattern": "<pattern>: if reading data from a file using std::ifstream involves seeking the file size and using std::istreambuf_iterator, replace it with reading data into a string buffer first and then constructing the vector from the string to reduce overhead from seeking and iterating."}
{"number": 253, "change": "@@ -63,9 +63,11 @@ BOOL WINAPI DllMain(HINSTANCE h, DWORD reason, LPVOID reserved)\n \t\tstrcpy(++p, FBDLLNAME);\n \t\tp += strlen(FBDLLNAME);\n \t\t*p = 0;\n-\t\thFBDLLInstance = LoadLibrary(buffer);\n-\t\tif (!hFBDLLInstance) {\n-\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\tif (!GetModuleHandle(buffer) && !GetModuleHandle(FBDLLNAME)) {\n+\t\t\thFBDLLInstance = LoadLibrary(buffer);\n+\t\t\tif (!hFBDLLInstance) {\n+\t\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase DLL_PROCESS_DETACH:\n", "fix_pattern": "<pattern>: if the code checks for the loaded module using LoadLibrary, replace it with GetModuleHandle to avoid loading the library again if it's already been loaded; then only fall back to LoadLibrary if the module is not currently loaded."}
{"number": 255, "change": "@@ -21,6 +21,7 @@\n  */\n \n #include \"firebird.h\"\n+#include \"../common/classes/Aligner.h\"\n #include \"../common/classes/Hash.h\"\n #include \"../jrd/jrd.h\"\n #include \"../jrd/req.h\"\n@@ -525,8 +526,8 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\tif (desc->isDecFloat())\n \t\t\t\t{\n \t\t\t\t\t// Values inside our key buffer are not aligned,\n-\t\t\t\t\t// hence we need to use intermediate storage for makeKey()\n-\t\t\t\t\tULONG key[MAX_DEC_KEY_LONGS];\n+\t\t\t\t\t// so ensure we satisfy our platform's alignment rules\n+\t\t\t\t\tOutAligner<ULONG, MAX_DEC_KEY_LONGS> key(keyPtr, keyLength);\n \n \t\t\t\t\tif (desc->dsc_dtype == dtype_dec64)\n \t\t\t\t\t\t((Decimal64*) data)->makeKey(key);\n@@ -534,9 +535,6 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\t\t\t((Decimal128*) data)->makeKey(key);\n \t\t\t\t\telse\n \t\t\t\t\t\tfb_assert(false);\n-\n-\t\t\t\t\tfb_assert(keyLength <= sizeof(key));\n-\t\t\t\t\tmemcpy(keyPtr, key, keyLength);\n \t\t\t\t}\n \t\t\t\telse if (desc->dsc_dtype == dtype_real && *(float*) data == 0)\n \t\t\t\t{\n", "fix_pattern": "<pattern>: if `memcpy` is used to copy data to `keyPtr`, refactor the code to use a specialized alignment-aware class (e.g., `OutAligner`) that ensures proper handling of memory alignment constraints for the platform, improving performance and safety."}
{"number": 256, "change": "@@ -116,7 +116,7 @@ namespace\n \t{\n \t\tuint8* destPointer = EmulatorInterface::instance().getMemoryPointer(destAddress, true, bytes);\n \t\tuint8* sourcePointer = EmulatorInterface::instance().getMemoryPointer(sourceAddress, false, bytes);\n-\t\tmemcpy(destPointer, sourcePointer, bytes);\n+\t\tmemmove(destPointer, sourcePointer, bytes);\n \t}\n \n \tvoid zeroMemory(uint32 startAddress, uint32 bytes)\n", "fix_pattern": "<pattern>: if the source and destination memory regions overlap, replace memcpy with memmove to ensure safety and correctness without performance degradation."}
{"number": 257, "change": "@@ -419,9 +419,7 @@ int vfsLoadFile( const char *filename, void **bufferptr, int index ){\n \t\t}\n \n \t\tif ( count == index ) {\n-\t\t\tstrcpy( g_strLoadedFileLocation, file->unzFilePath );\n-\t\t\tstrcat( g_strLoadedFileLocation, \" :: \" );\n-\t\t\tstrcat( g_strLoadedFileLocation, filename );\n+\t\t\tsnprintf( g_strLoadedFileLocation, sizeof( g_strLoadedFileLocation ), \"%s :: %s\", file->unzFilePath, filename );\n \n \t\t\tmemcpy( file->zipfile, &file->zipinfo, sizeof( unz_s ) );\n \n", "fix_pattern": "<pattern>: if multiple string concatenations using strcpy and strcat are detected, refactor the code to use snprintf for a single, more efficient string formatting operation, which also prevents buffer overflows."}
{"number": 274, "change": "@@ -368,10 +368,8 @@ void CPNGFile::WaitForSaves()\n \t\tfirst = false;\n #ifdef HAVE_WINTHREAD\n \t\tSleep(100);\n-#elif defined (__APPLE__)\n+#else\n \t\tsched_yield();\n-#elif defined(HAVE_PTHREAD)\n-\t\tpthread_yield();\n #endif\n \t}\n }\n", "fix_pattern": "<pattern>: if there is a conditional branch for a specific platform that includes a call to `pthread_yield()`, then refactor it to eliminate the call in favor of a more generalized fallback without the platform-specific behavior."}
{"number": 286, "change": "@@ -56,9 +56,7 @@ OperatorHandle Dispatcher::findOrRegisterSchema_(FunctionSchema&& schema, Operat\n   const auto found = findSchema(schema.operator_name());\n   if (found != c10::nullopt) {\n     if (found->schema() != schema) {\n-      std::ostringstream str;\n-      str << schema << \" vs \" << found->schema();\n-      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", str.str());\n+      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", schema, \" vs \", found->schema());\n     }\n     if (options.isDefaultAliasAnalysisKind()) {\n       // just do nothing and let it pass.\n", "fix_pattern": "<pattern>: if creating a temporary `std::ostringstream` to format a string is detected, replace it with direct string concatenation in the `TORCH_CHECK` call for improved performance and reduced object construction overhead."}
{"number": 288, "change": "@@ -38,7 +38,6 @@\n #include \"audio/dcblocker.h\"\n #include \"logger.h\"\n #include \"manager.h\"\n-#include \"cc_thread.h\"\n \n #include <cstdlib>\n #include <fstream>\n@@ -252,7 +251,7 @@ std::string PulseLayer::getAudioDeviceName(int index, PCMType type) const\n void PulseLayer::createStreams(pa_context* c)\n {\n     while (enumeratingSinks_ or enumeratingSources_)\n-        ost::Thread::sleep(20 /* ms */);\n+        usleep(20000); // 20 ms\n \n     std::string playbackDevice(preference_.getPulseDevicePlayback());\n     std::string captureDevice(preference_.getPulseDeviceRecord());\n", "fix_pattern": "<pattern>: if a platform-specific sleep function (like ost::Thread::sleep) is used which may involve more overhead, replace it with a more efficient platform-specific alternative (like usleep) for better performance in timing control."}
{"number": 292, "change": "@@ -110,11 +110,8 @@ int main(int argc, char ** argv)\n \t\tif (argc != 1)\n \t\t\tthrow std::runtime_error(i18n(\"no document specified\"));\n \n-\t\tcainteoir::document_events events;\n \t\trdf::graph metadata;\n-\t\tif (!cainteoir::parseDocument(argv[0], events, metadata))\n-\t\t\tfprintf(stderr, i18n(\"unsupported document format for file \\\"%s\\\"\\n\"), argv[0]);\n-\n+\t\tauto reader = cainteoir::createDocumentReader(argv[0], metadata, std::string());\n \t\tif (!metadata.empty())\n \t\t{\n \t\t\tif (output_type == rdf_metadata)\n", "fix_pattern": "<pattern>: if an API method (`cainteoir::parseDocument`) that processes files is replaced by a different method (`cainteoir::createDocumentReader`) that may offer better performance or efficiency, identify that the change signifies a shift towards a potentially more optimized API call for handling document reading while maintaining the context associated with the operation."}
{"number": 297, "change": "@@ -254,7 +254,7 @@ QSSGShaderCache::QSSGShaderCache(QSSGRhiContext &ctx,\n         m_persistentShaderStorageFileName = persistentQsbcFileName();\n         if (!m_persistentShaderStorageFileName.isEmpty()) {\n             const bool skipCacheFile = qEnvironmentVariableIntValue(\"QT_QUICK3D_NO_SHADER_CACHE_LOAD\");\n-            if (!skipCacheFile && QFileInfo(m_persistentShaderStorageFileName).exists()) {\n+            if (!skipCacheFile && QFileInfo::exists(m_persistentShaderStorageFileName)) {\n                 if (shaderDebug)\n                     qDebug(\"Attempting to seed material shader cache from %s\", qPrintable(m_persistentShaderStorageFileName));\n                 if (m_persistentShaderBakingCache.load(m_persistentShaderStorageFileName)) {\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is created just to check for file existence, replace it with a static method call QFileInfo::exists for better performance."}
{"number": 309, "change": "@@ -499,12 +499,12 @@ void handleAccessMemory(void *arg, Sift::MemoryLockType lock_signal, Sift::Memor\n    if (mem_op == Sift::MemRead)\n    {\n       // The simulator is requesting data from us\n-      memcpy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n+      PIN_SafeCopy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n    }\n    else if (mem_op == Sift::MemWrite)\n    {\n       // The simulator is requesting that we write data back to memory\n-      memcpy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n+      PIN_SafeCopy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n    }\n    else\n    {\n", "fix_pattern": "<pattern>: if a direct memory copy using memcpy is detected, replace it with a specialized third-party API method (e.g., PIN_SafeCopy) that is designed for more efficient or safer handling of memory operations in the context of the application (e.g., ensuring safety when dealing with instrumentation in a Pin-based environment)."}
{"number": 310, "change": "@@ -114,7 +114,7 @@ int init_SDL(void)\n         fprintf(stderr, \"Unable to init SDL: %s\\n\", SDL_GetError());\n         return(0);\n     }\n-    sdlscreen = SDL_SetVideoMode(0,0, 32, SDL_SWSURFACE);\n+    sdlscreen = SDL_SetVideoMode(0,0, 16, SDL_SWSURFACE);\n \n     SDL_JoystickEventState(SDL_ENABLE);\n \tmyjoy[0]=SDL_JoystickOpen(0);\n", "fix_pattern": "<pattern>: when modifying the bit depth parameter (bpp) for SDL_SetVideoMode, reducing it from 32 to 16 can enhance performance by decreasing memory usage and potentially increasing rendering speed, especially in scenarios where high color depth is not necessary."}
{"number": 311, "change": "@@ -70,11 +70,16 @@ perf (bool decode)\n   double t = get_time();\n   for (int r = 0; r < RUNS; r++)\n     {\n-      notify_buffer.clear();\n+      bool write_ok = notify_buffer.start_write();\n+      assert (write_ok);\n       for (int i = 0; i < EVENTS; i++)\n         {\n           fill_notify_buffer (notify_buffer);\n         }\n+      notify_buffer.end_write();\n+\n+      bool read_ok = notify_buffer.start_read();\n+      assert (read_ok);\n       if (decode)\n         {\n           while (notify_buffer.remaining())\n@@ -84,6 +89,7 @@ perf (bool decode)\n               delete e;\n             }\n         }\n+      notify_buffer.end_read();\n     }\n   printf (\"%.2f events/sec (decode = %s)\\n\", (EVENTS * RUNS) / (get_time() - t), decode ? \"TRUE\" : \"FALSE\");\n }\n", "fix_pattern": "<pattern>: if a call to `notify_buffer.clear()` is replaced with `notify_buffer.start_write()` and `notify_buffer.end_write()`, indicating a performance improvement by using a write operation that likely aggregates and clears the buffer more efficiently than the clear operation did, then adopt that approach for managing the state of the buffer."}
{"number": 321, "change": "@@ -7,6 +7,7 @@\n #pragma once\n \n #include <sys/types.h> // for u_char\n+#include <zeek/util.h>\n #include <cstdint>\n #include <cstdio>\n \n@@ -41,7 +42,8 @@ enum HashAlgorithm { Hash_MD5, Hash_SHA1, Hash_SHA224, Hash_SHA256, Hash_SHA384,\n inline const char* digest_print(const u_char* digest, size_t n) {\n     static char buf[ZEEK_DIGEST_PRINT_LENGTH];\n     for ( size_t i = 0; i < n; ++i )\n-        snprintf(buf + i * 2, 3, \"%02x\", digest[i]);\n+        zeek::util::bytetohex(digest[i], &buf[i * 2]);\n+    buf[2 * n] = '\\0';\n     return buf;\n }\n \n", "fix_pattern": "<pattern>: if snprintf is used to format binary data to hexadecimal strings, replace it with a specialized utility function (zeek::util::bytetohex) that may provide optimized performance for this specific conversion."}
{"number": 324, "change": "@@ -161,15 +161,13 @@ void MainWindow::InitializeUi() {\n }\n \n void MainWindow::ExpandCollapse(TreeState state) {\n-    // if it's connected during the call it's called for every item apparently, which is damn slow!\n-    disconnect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    disconnect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    // we block signals so that ResizeTreeColumns isn't called for every item, which is damn slow!\n+    ui->treeView->blockSignals(true);\n     if (state == TreeState::kExpand)\n         ui->treeView->expandAll();\n     else\n         ui->treeView->collapseAll();\n-    connect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    connect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    ui->treeView->blockSignals(false);\n \n     ResizeTreeColumns();\n }\n", "fix_pattern": "<pattern>: if multiple disconnect and connect calls are made around a function that can be slow if called repeatedly (like ResizeTreeColumns), use blockSignals to prevent the signal from triggering during a performance-critical operation to improve efficiency."}
{"number": 332, "change": "@@ -399,7 +399,8 @@ int main(int argc, char* argv[])\n                                 first = false;\n                             else\n                                 argument_builder.append(\", \"sv);\n-                            argument_builder.append(StringView(stream.copy_into_contiguous_buffer()).trim_whitespace());\n+                            ByteBuffer buffer = stream.copy_into_contiguous_buffer();\n+                            argument_builder.append(StringView(buffer).trim_whitespace());\n                         }\n                         dbgln(\"[wasm runtime] Stub function {} was called with the following arguments: {}\", name, argument_builder.to_string());\n                         Vector<Wasm::Value> result;\n", "fix_pattern": "<pattern>: if an API call is made to copy data into a contiguous buffer inline, separate that call into its own variable before using it, which can improve readability and potentially optimize performance by reducing unnecessary copies and exposing optimization opportunities."}
{"number": 335, "change": "@@ -316,12 +316,6 @@ void Job::on_socket_connected()\n                 if (m_code == 204)\n                     return finish_up();\n \n-                can_read_line = m_socket->can_read_line();\n-                if (can_read_line.is_error())\n-                    return deferred_invoke([this] { did_fail(Core::NetworkJob::Error::TransmissionFailed); });\n-\n-                if (!can_read_line.value())\n-                    return;\n                 break;\n             }\n             auto parts = line.split_view(':');\n", "fix_pattern": "<pattern>: if a method call to check for a condition (like can_read_line) is followed by error checking and early returns, consider refactoring to handle both the condition check and error handling in a single call to reduce overhead from multiple API invocations and follow a more concise pattern."}
{"number": 343, "change": "@@ -63,9 +63,12 @@ public:\n     {\n         VERIFY(!ivec.is_empty());\n \n-        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(out.size()));\n+        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(T::BlockSizeInBits / 8));\n \n-        encrypt(in, out, ivec, dummy, dummy);\n+        // FIXME: Taking `out` by reference suggests that we should modify its length to match the\n+        //        ciphertext size. In practice, however, noone does that and I don't want to be the\n+        //        person who fixes this.\n+        encrypt(in, out.slice(0, in.size()), ivec, dummy, dummy);\n     }\n     virtual void decrypt(ReadonlyBytes in, Bytes& out, ReadonlyBytes ivec = {}) override\n     {\n", "fix_pattern": "<pattern>: if a ByteBuffer is created with its size determined by the `out` buffer which may vary in size, instead statically allocate a ByteBuffer of fixed size using known constants to optimize performance by avoiding dynamic size calculation during each call."}
{"number": 344, "change": "@@ -3,6 +3,7 @@\n */\n \n #include <iostream>\n+#include <random>\n \n #include <args.hxx>\n \n@@ -80,10 +81,17 @@ std::string get_random_nums_str( std::size_t count )\n \n std::vector< int > get_random_nums( std::size_t count )\n {\n+\tstd::random_device r;\n+\tstd::mt19937 gen{ r() };\n+\tstd::uniform_int_distribution< int > uniform_dist;\n+\n \tstd::vector< int > result;\n \tresult.reserve( count );\n \n-\tstd::generate_n( std::back_inserter( result ), count, [](){ return rand(); } );\n+\tstd::generate_n(\n+\t\tstd::back_inserter( result ),\n+\t\tcount,\n+\t\t[&](){ return uniform_dist( gen ); } );\n \n \treturn result;\n }\n", "fix_pattern": "<pattern>: if random numbers are being generated using the rand() function, replace it with the C++ `<random>` library for improved randomness quality and better performance characteristics by leveraging modern random number generation facilities."}
{"number": 346, "change": "@@ -101,7 +101,7 @@ bool AdminDatabase::ValidPassword(const char *username, const char *password)\n     QByteArray passb = m_prepared_select_account_passw.value(\"passw\").toByteArray();\n     QByteArray salt = m_prepared_select_account_passw.value(\"salt\").toByteArray();\n     QByteArray hashed_password = hasher.hashPassword(password, salt);\n-    if (memcmp(passb.data(),hashed_password.data(),passb.size()) == 0)\n+    if (memcmp(passb,hashed_password,passb.size()) == 0)\n         res = true;\n     return res;\n }\n", "fix_pattern": "<pattern>: if the data() method is used to retrieve raw data from a QByteArray for comparison with memcmp, directly pass the QByteArray objects to memcmp instead, optimizing performance by eliminating unnecessary calls to data() and improving type coherence."}
{"number": 349, "change": "@@ -594,17 +594,16 @@ out_err:\n \t\t\tif (strcmp(name, \".gnu_debuglink\") == 0) {\n \t\t\t\tconst char *p = (const char *)data->d_buf;\n \t\t\t\tm_debuglink.append(p);\n-\n-\t\t\t\tp += strlen(p);\n+\t\t\t\tconst char *endOfString = p + strlen(p) + 1;\n \n \t\t\t\t// Align address for the CRC32\n-\t\t\t\tunsigned long addr = (unsigned long)p;\n-\t\t\t\tunsigned long offs = 4;\n+\t\t\t\tunsigned long addr = (unsigned long)(endOfString - p);\n+\t\t\t\tunsigned long offs = 0;\n \n \t\t\t\tif ((addr & 3) != 0)\n \t\t\t\t\toffs = 4 - (addr & 3);\n \t\t\t\t// ... and read out the CRC32\n-\t\t\t\tm_debuglinkCrc = *(uint32_t *)(p + offs);\n+\t\t\t\tmemcpy((void *)&m_debuglinkCrc, endOfString + offs, sizeof(m_debuglinkCrc));\n \t\t\t}\n \n \t\t\tif ((sh_flags & (SHF_EXECINSTR | SHF_ALLOC)) != (SHF_EXECINSTR | SHF_ALLOC))\n", "fix_pattern": "<pattern>: if the code previously accesses memory using pointer arithmetic and casts directly from a string, refactor it to use memcpy for copying data to avoid potential alignment issues and improve safety when handling raw memory operations."}
{"number": 352, "change": "@@ -355,8 +355,8 @@ static int PlayerQuit[PlayerMax];          /// Player quit\n static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int player = 255)\n {\n \tconst unsigned int size = packet.Size(numcommands);\n-\tunsigned char *buf = new unsigned char[size];\n-\tpacket.Serialize(buf, numcommands);\n+\tstd::vector<unsigned char> buf(size);\n+\tpacket.Serialize(buf.data(), numcommands);\n \n \t// Send to all clients.\n \tif (NetConnectType == 1) { // server\n@@ -366,14 +366,13 @@ static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int\n \t\t\t\tif (Hosts[i].PlyNr == player) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tNetworkFildes.Send(host, buf, size);\n+\t\t\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t\t\t}\n \t\t}\n \t} else { // client\n \t\tconst CHost host(Hosts[0].Host, Hosts[0].Port);\n-\t\tNetworkFildes.Send(host, buf, size);\n+\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t}\n-\tdelete[] buf;\n }\n \n /**\n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a raw buffer (e.g., using `new`), replace it with a `std::vector` to manage memory automatically and improve safety and performance by eliminating the need for manual deallocation."}
{"number": 359, "change": "@@ -1584,7 +1584,7 @@ static redisReply *sendScan(unsigned long long *it) {\n     assert(reply->element[1]->type == REDIS_REPLY_ARRAY);\n \n     /* Update iterator */\n-    *it = atoi(reply->element[0]->str);\n+    *it = strtoull(reply->element[0]->str, NULL, 10);\n \n     return reply;\n }\n", "fix_pattern": "<pattern>: if converting a string to an integer, replace atoi with strtoull for better performance and to avoid potential overflow issues, as strtoull handles larger values and is more precise in conversion."}
{"number": 364, "change": "@@ -498,8 +498,13 @@ void Battlenet::Session::HandleJoinRequestV2(WoWRealm::JoinRequestV2 const& join\n \n     memcpy(sessionKey + hmac.GetLength(), hmac2.GetDigest(), hmac2.GetLength());\n \n-    LoginDatabase.DirectPExecute(\"UPDATE account SET sessionkey = '%s', last_ip = '%s', last_login = NOW(), locale = %u, failed_logins = 0, os = '%s' WHERE id = %u\",\n-        ByteArrayToHexStr(sessionKey, 40, true).c_str(), GetRemoteIpAddress().to_string().c_str(), GetLocaleByName(_locale), _os.c_str(), _gameAccountInfo->Id);\n+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_LOGONPROOF);\n+    stmt->setString(0, ByteArrayToHexStr(sessionKey, 40, true).c_str());\n+    stmt->setString(1, GetRemoteIpAddress().to_string());\n+    stmt->setUInt32(2, GetLocaleByName(_locale));\n+    stmt->setString(3, _os);\n+    stmt->setString(4, _gameAccountInfo->Name);\n+    LoginDatabase.DirectExecute(stmt);\n \n     joinResponse->IPv4.emplace_back(*realm->ExternalAddress, realm->Port);\n     if (*realm->ExternalAddress != *realm->LocalAddress)\n", "fix_pattern": "<pattern>: if raw SQL queries are being constructed and executed directly, replace them with prepared statements to improve performance and security by avoiding SQL injection and allowing the database engine to optimize query execution."}
{"number": 369, "change": "@@ -1579,10 +1579,11 @@ int XrdHttpProtocol::StartChunkedResp(int code, const char *desc, const char *he\n /******************************************************************************/\n   \n int XrdHttpProtocol::ChunkResp(const char *body, long long bodylen) {\n-  if (ChunkRespHeader((bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen))\n+  long long content_length = (bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen;\n+  if (ChunkRespHeader(content_length))\n     return -1;\n \n-  if (body && SendData(body, bodylen))\n+  if (body && SendData(body, content_length))\n     return -1;\n \n   return ChunkRespFooter();\n", "fix_pattern": "<pattern>: if the content length is calculated multiple times from the provided arguments, store the result in a variable to avoid redundant calculations, improving readability and potential performance due to less computation."}
{"number": 371, "change": "@@ -35,8 +35,7 @@ IceInternal::BasicOutputStream::BasicOutputStream(IceInternal::Instance* instanc\n Ice::InputStreamI::InputStreamI(const Ice::CommunicatorPtr& communicator, const vector<Byte>& data) :\n     _communicator(communicator), _is(IceInternal::getInstance(communicator).get(), this)\n {\n-    _is.b.resize(data.size());\n-    memcpy(&_is.b[0], &data[0], data.size());\n+    _is.writeBlob(data);\n     _is.i = _is.b.begin();\n }\n \n", "fix_pattern": "<pattern>: if a vector is resized and then populated using memcpy, replace the combination with a call to a more optimized method such as writeBlob(), which likely has internal optimizations for handling the data directly."}
{"number": 372, "change": "@@ -320,7 +320,7 @@ QList<QString> TessTools::getLanguages(QString datapath) {\n       QFileInfo fileInfo = list.at(i);\n       languages.append(QString(\"%1\").arg(fileInfo.baseName()));\n     }\n-    qSort(languages);\n+    std::sort(languages.begin(), languages.end());\n \n     return languages;\n }\n", "fix_pattern": "<pattern>: if the code is using qSort from the Qt library, replace it with std::sort from the Standard Library for better performance and compatibility with C++ algorithms."}
{"number": 382, "change": "@@ -139,7 +139,10 @@ const char *AGSLinux::GetAppOutputDirectory()\n }\n \n void AGSLinux::Delay(int millis) {\n-  usleep(millis);\n+  struct timespec ts;\n+  ts.tv_sec = 0;\n+  ts.tv_nsec = millis * 1000000;\n+  nanosleep(&ts, NULL);\n }\n \n unsigned long AGSLinux::GetDiskFreeSpaceMB() {\n", "fix_pattern": "<pattern>: if the usleep function is used for sleeping in microseconds, replace it with nanosleep for better precision and to provide a more flexible structure for specifying sleep time in nanoseconds."}
{"number": 385, "change": "@@ -98,10 +98,13 @@ int test_rw_image_access_qualifier(cl_device_id device_id, cl_context context, c\n     return -1;\n     }\n \n+    MTdata mtData = init_genrand(gRandomSeed);\n     /* Fill input array with random values */\n     for (i = 0; i < size; i++) {\n-        input[i] = (unsigned int)(rand()/((double)RAND_MAX + 1)*255);\n+        input[i] = genrand_int32(mtData);\n     }\n+    free_mtdata(mtData);\n+    mtData = NULL;\n \n     /* Zero out output array */\n     for (i = 0; i < size; i++) {\n", "fix_pattern": "<pattern>: if a random number is generated using the standard `rand()` function, which has poor randomness quality and possible performance issues in a multi-threaded context, replace it with Mersenne Twister RNG functions (`init_genrand`, `genrand_int32`, and `free_mtdata`) for improved performance and better randomness quality."}
{"number": 386, "change": "@@ -33,7 +33,7 @@\n #include <wx/debug.h>\n #include <wx/fileconf.h>\n #include <wx/filename.h>\n-#include <wx/ffile.h>\n+#include <wx/wfstream.h>\n \n \n const wxChar* const traceSettings = wxT( \"KICAD_SETTINGS\" );\n@@ -392,9 +392,10 @@ bool JSON_SETTINGS::SaveToFile( const wxString& aDirectory, bool aForce )\n         std::stringstream buffer;\n         buffer << std::setw( 2 ) << *this << std::endl;\n \n-        wxFFile   file( path.GetFullPath(), \"wb\" );\n+        wxFFileOutputStream fileStream( path.GetFullPath(), \"wb\" );\n \n-        if( !file.IsOpened() || !file.Write( buffer.str().c_str(), buffer.str().size() ) )\n+        if( !fileStream.IsOk()\n+                || !fileStream.WriteAll( buffer.str().c_str(), buffer.str().size() ) )\n         {\n             wxLogTrace( traceSettings, \"Warning: could not save %s\", GetFullFilename() );\n             success = false;\n", "fix_pattern": "<pattern>: if wxFFile is used for file output, replace it with wxFFileOutputStream to leverage the optimized WriteAll method for performance improvements in file writing operations."}
{"number": 389, "change": "@@ -53,7 +53,8 @@ bool mitk::MovieGeneratorOpenCV::InitGenerator()\n \n bool mitk::MovieGeneratorOpenCV::AddFrame( void *data )\n {\n-  cvSetImageData(m_currentFrame,data,m_width*3);\n+  //cvSetImageData(m_currentFrame,data,m_width*3);\n+  memcpy(data,m_currentFrame->imageData,m_width*m_height*3);\n   cvWriteFrame(m_aviWriter,m_currentFrame);\n   return true;\n }\n", "fix_pattern": "<pattern>: if an API call is used to set image data, replace it with a direct memory copy using memcpy for improved performance, as this avoids the overhead associated with the API function and can lead to faster execution."}
{"number": 391, "change": "@@ -39,7 +39,7 @@\n #include \"vtkUnsignedLongArray.h\"\n #include \"vtkUnsignedShortArray.h\"\n \n-vtkCxxRevisionMacro(vtkCompleteArrays, \"1.8\");\n+vtkCxxRevisionMacro(vtkCompleteArrays, \"1.9\");\n vtkStandardNewMacro(vtkCompleteArrays);\n \n vtkCxxSetObjectMacro(vtkCompleteArrays,Controller,vtkMultiProcessController);\n@@ -101,10 +101,7 @@ int vtkCompleteArrays::RequestData(\n       {\n       noNeed = 1;\n       }\n-    for (idx = 1; idx < numProcs; ++idx)\n-      {\n-      this->Controller->Send(&noNeed, 1, idx, 3389001);\n-      }\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n@@ -151,7 +148,7 @@ int vtkCompleteArrays::RequestData(\n     }\n   else\n     { // remote processes\n-    this->Controller->Receive(&noNeed, 1, 0, 3389001);\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n", "fix_pattern": "<pattern>: if a loop is used to send messages individually to multiple destinations using the Send method, replace it with a Broadcast call to streamline communication, reducing overhead."}
{"number": 392, "change": "@@ -28,7 +28,7 @@\n #include <QRegExp>\n \n vtkStandardNewMacro(vtkSMXYChartViewProxy);\n-vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.7\");\n+vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.8\");\n //----------------------------------------------------------------------------\n vtkSMXYChartViewProxy::vtkSMXYChartViewProxy()\n {\n@@ -53,6 +53,8 @@ vtkContextView* vtkSMXYChartViewProxy::NewChartView()\n   // Construct a new chart view and return the view of it\n   this->Chart = vtkChartXY::New();\n   this->ChartView->GetScene()->AddItem(this->Chart);\n+  // Do not use the buffer id for now - performance issues.\n+  this->ChartView->GetScene()->SetUseBufferId(false);\n \n   return this->ChartView;\n }\n", "fix_pattern": "<pattern>: if a performance issue is identified with the usage of buffer IDs in VTK's rendering context, disable the use of buffer IDs by calling `SetUseBufferId(false)` to potentially improve rendering performance while transitioning between versions."}
{"number": 400, "change": "@@ -150,7 +150,7 @@ WebSocketParser::addStreamData(const char* data, unsigned int len) {\n WebSocketFrame*\n WebSocketParser::getNextFrame() {\n   if (!mHeaderHandled) {\n-    char* pos = strstr(mData, \"\\r\\n\\r\\n\");\n+    char* pos = (char*) memmem(mData, mLength, \"\\r\\n\\r\\n\", 4);\n \n     if (pos) {\n       char* data = (char*) malloc(pos - mData);\n", "fix_pattern": "<pattern>: if the API method strstr is used for finding a substring in a large data buffer, replace it with the more efficient memmem function, which allows for specification of the length of the haystack, resulting in better performance."}
{"number": 407, "change": "@@ -45,6 +45,7 @@\n \n /* Includes */\n #include <precomp.hpp>\n+#include <opencv2/core.hpp>\n #include <stdlib.h>\n #include <stdio.h>\n #include <stdint.h>\n@@ -476,11 +477,7 @@ inline int    RHO_HEST_REFC::initialize(void){\n     lm.tmp1     = NULL;\n     lm.Jte      = NULL;\n \n-#ifdef _WIN32\n-    fastSeed(rand());\n-#else\n-    fastSeed(random());\n-#endif\n+    fastSeed((unsigned)cv::theRNG());\n \n \n     int areAllAllocsSuccessful = ctrl.smpl   &&\n", "fix_pattern": "<pattern>: if the code uses platform-specific random number generation (like rand() for Windows or random() for other platforms), refactor it to use a central random number generator from a library (such as OpenCV's cv::theRNG) for better consistency and potentially improved performance."}
{"number": 408, "change": "@@ -30,14 +30,7 @@ namespace log4cpp {\n                                const std::string& fileName) : \n             LayoutAppender(name),\n             _fileName(fileName) {\n-#if defined(__OPENVMS__)\n-        // shr=get, File Sharing Options, Allow users to read\n-        // ctx=rec, Force record mode access\n-        // rop=rea, Record-processing options, Locks record for a read operation for this process, while allowing other accessors to read the record. \n-        _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644, \"shr=get\",\"ctx=rec\",\"rop=rea\");\n-#else\n         _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644);\n-#endif\n     }\n     \n     FileAppender::FileAppender(const std::string& name, int fd) :\n", "fix_pattern": "<pattern>: NA"}
{"number": 411, "change": "@@ -20,7 +20,7 @@ XMLException::XMLException(const string& msg)\n auto_ptr<XMLElement> XMLLoader::loadXML(const string& filename,\n                                         const string& systemID)\n {\n-\txmlDocPtr doc = xmlParseFile(filename.c_str());\n+\txmlDocPtr doc = xmlReadFile(filename.c_str(), NULL, 0);\n \tif (!doc) {\n \t\tthrow XMLException(filename + \": Document parsing failed\");\n \t}\n", "fix_pattern": "<pattern>: if the code is using xmlParseFile to parse an XML file, replace it with xmlReadFile, which allows for additional options and generally offers better performance and flexibility in handling XML parsing with more control over the input parameters."}
{"number": 412, "change": "@@ -2,7 +2,7 @@\n \n #include \"SDLImage.hh\"\n #include \"OutputSurface.hh\"\n-#include \"LocalFileReference.hh\"\n+#include \"File.hh\"\n #include \"MSXException.hh\"\n #include \"vla.hh\"\n #include \"build-info.hh\"\n@@ -183,10 +183,12 @@ static SDL_Surface* loadImage(\n \n SDL_Surface* SDLImage::readImage(const string& filename)\n {\n-\tLocalFileReference file(filename);\n-\tSDL_RWops *src = SDL_RWFromFile(file.getFilename().c_str(), \"rb\");\n+\tFile file(filename);\n+\tSDL_RWops *src = SDL_RWFromConstMem(file.mmap(), file.getSize());\n \tif (!src) {\n-\t\tthrow MSXException(\"Could not open image file \\\"\" + filename + \"\\\"\");\n+\t\tthrow MSXException(\n+\t\t\t\"Failed to create SDL_RWops for mmapped file \\\"\" + filename + \"\\\"\"\n+\t\t\t);\n \t}\n \tSDL_Surface* result = IMG_LoadPNG_RW(src);\n \tSDL_RWclose(src);\n", "fix_pattern": "<pattern>: if a file is opened with SDL_RWFromFile for reading, replace it with SDL_RWFromConstMem which utilizes memory mapping for potentially better performance, especially for large files."}
{"number": 416, "change": "@@ -691,7 +691,7 @@ QString QSystemLocalePrivate::winToQtFormat(const QString &sys_fmt)\n             if (text == QLatin1String(\"'\"))\n                 result += QLatin1String(\"''\");\n             else\n-                result += QString(QLatin1Char('\\'') + text + QLatin1Char('\\''));\n+                result += QLatin1Char('\\'') + text + QLatin1Char('\\'');\n             continue;\n         }\n \n", "fix_pattern": "<pattern>: if a QString is appended with multiple concatenations involving QLatin1Char, refactor the code to eliminate the redundant use of QString's operator by combining the operations into a single expression, resulting in improved performance by reducing overhead."}
{"number": 417, "change": "@@ -110,7 +110,7 @@ int QCollator::compare(const QChar *s1, int len1, const QChar *s2, int len2) con\n     if (d->collator)\n         return ucol_strcoll(d->collator, (const UChar *)s1, len1, (const UChar *)s2, len2);\n \n-    return QString::compare(QString(s1, len1), QString(s2, len2), d->caseSensitivity);\n+    return QString::compare_helper(s1, len1, s2, len2, d->caseSensitivity);\n }\n \n int QCollator::compare(const QString &s1, const QString &s2) const\n", "fix_pattern": "<pattern>: if an API method (QString::compare) is potentially less efficient than a specialized helper (QString::compare_helper), replace calls to the less efficient method with the specialized helper to improve performance."}
{"number": 419, "change": "@@ -704,10 +704,9 @@ void QSslSocketBackendPrivate::transmit()\n                 // Write encrypted data from the buffer into the read BIO.\n                 int writtenToBio = q_BIO_write(readBio, data.constData(), encryptedBytesRead);\n \n-                // do the actual read() here and throw away the results.\n+                // Throw away the results.\n                 if (writtenToBio > 0) {\n-                    // ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek\n-                    plainSocket->read(data.data(), writtenToBio);\n+                    plainSocket->skip(writtenToBio);\n                 } else {\n                     // ### Better error handling.\n                     setErrorAndEmit(QAbstractSocket::SslInternalError,\n", "fix_pattern": "<pattern>: if data read from a socket is not needed, replace the read operation with skip() to avoid unnecessary memory copying and improve performance."}
{"number": 426, "change": "@@ -2585,7 +2585,7 @@ static int qMetaTypeCustomType_unlocked(const char *typeName, int length)\n #if QT_CONFIG(thread)\n         Q_ASSERT(!reg->lock.tryLockForWrite());\n #endif\n-        if (auto ti = reg->aliases.value(QByteArray(typeName, length), nullptr)) {\n+        if (auto ti = reg->aliases.value(QByteArray::fromRawData(typeName, length), nullptr)) {\n             return ti->typeId;\n         }\n     }\n", "fix_pattern": "<pattern>: if a QByteArray is created using the constructor with QByteArray(typeName, length), then refactor the code to use QByteArray::fromRawData(typeName, length) for a more efficient creation without unnecessary overhead."}
{"number": 427, "change": "@@ -72,7 +72,7 @@ QString QTlsBackendOpenSSL::getErrorsFromOpenSsl()\n         if (!errorString.isEmpty())\n             errorString.append(\", \"_L1);\n         q_ERR_error_string_n(errNum, buf, sizeof buf);\n-        errorString.append(QString::fromLatin1(buf)); // error is ascii according to man ERR_error_string\n+        errorString.append(QLatin1StringView(buf)); // error is ascii according to man ERR_error_string\n     }\n     return errorString;\n }\n", "fix_pattern": "<pattern>: if QString::fromLatin1 is used to convert a Latin1 encoded string, replace it with QLatin1StringView to avoid unnecessary QString creation and improve performance, as QLatin1StringView provides a lightweight non-owning view of the string."}
{"number": 430, "change": "@@ -606,9 +606,8 @@ QByteArray qCompress(const uchar* data, qsizetype nbytes, int compressionLevel)\n             qToBigEndian(CompressSizeHint_t(nbytes), bazip.data());\n             break;\n         case Z_MEM_ERROR:\n-            qWarning(\"qCompress: Z_MEM_ERROR: Not enough memory\");\n-            bazip.resize(0);\n-            break;\n+            return tooMuchData(ZLibOp::Compression);\n+\n         case Z_BUF_ERROR:\n             len *= 2;\n             break;\n", "fix_pattern": "<pattern>: if there is a scenario where qWarning is called due to insufficient memory and the subsequent action is to resize a QByteArray to 0, replace it with an early return that indicates the error condition, thus avoiding unnecessary operations related to resizing the QByteArray and improving performance by reducing function overhead."}
{"number": 439, "change": "@@ -84,10 +84,15 @@ void tst_QPacketProtocol::init()\n     QVERIFY(m_server->listen(QHostAddress(\"127.0.0.1\")));\n \n     m_client = new QTcpSocket(this);\n+\n+    QSignalSpy serverSpy(m_server, SIGNAL(newConnection()));\n+    QSignalSpy clientSpy(m_client, SIGNAL(connected()));\n+\n     m_client->connectToHost(m_server->serverAddress(), m_server->serverPort());\n \n-    QVERIFY(m_client->waitForConnected());\n-    QVERIFY(m_server->waitForNewConnection(10000));\n+    QVERIFY(clientSpy.count() > 0 || clientSpy.wait());\n+    QVERIFY(serverSpy.count() > 0 || serverSpy.wait());\n+\n     m_serverConn = m_server->nextPendingConnection();\n }\n \n", "fix_pattern": "<pattern>: if the code uses synchronous blocking methods (like waitForConnected and waitForNewConnection) that can potentially stall execution, refactor it to utilize signals and slots with QSignalSpy, allowing for a non-blocking check of connection status while still waiting for events effectively."}
{"number": 440, "change": "@@ -3521,7 +3521,7 @@ void QQuickWindow::setColor(const QColor &color)\n     }\n     d->clearColor = color;\n     emit colorChanged(color);\n-    d->dirtyItem(contentItem());\n+    update();\n }\n \n QColor QQuickWindow::color() const\n", "fix_pattern": "<pattern>: if a call to `dirtyItem(contentItem())` is replaced with a call to `update()`, use `update()` directly to refresh the entire window instead of marking a specific item as dirty, potentially avoiding unnecessary updates and improving overall performance."}
{"number": 441, "change": "@@ -435,15 +435,14 @@ void QQuickWindow::physicalDpiChanged()\n void QQuickWindow::handleScreenChanged(QScreen *screen)\n {\n     Q_D(QQuickWindow);\n+    disconnect(d->physicalDpiChangedConnection);\n     if (screen) {\n         physicalDpiChanged();\n         // When physical DPI changes on the same screen, either the resolution or the device pixel\n         // ratio changed. We must check what it is. Device pixel ratio does not have its own\n         // ...Changed() signal.\n-        d->physicalDpiChangedConnection = connect(screen, SIGNAL(physicalDotsPerInchChanged(qreal)),\n-                                                  this, SLOT(physicalDpiChanged()));\n-    } else {\n-        disconnect(d->physicalDpiChangedConnection);\n+        d->physicalDpiChangedConnection = connect(screen, &QScreen::physicalDotsPerInchChanged,\n+                                                  this, &QQuickWindow::physicalDpiChanged);\n     }\n \n     d->forcePolish();\n", "fix_pattern": "<pattern>: if using the old SIGNAL/SLOT macros for connecting signals and slots, replace them with the new method syntax for better performance and type safety; also ensure proper disconnecting of existing connections before re-connecting."}
{"number": 443, "change": "@@ -571,7 +571,7 @@ Status TensorToNdarray(const Tensor& t, PyObject** ret) {\n   if (!status.ok()) {\n     return status;\n   }\n-  return TF_TensorToPyArray(std::move(tf_tensor), ret);\n+  return TF_TensorToMaybeAliasedPyArray(std::move(tf_tensor), ret);\n }\n \n }  // namespace tensorflow\n", "fix_pattern": "<pattern>: if an API function that directly converts a TensorFlow tensor to a Python array is replaced with a potentially more optimized function that allows for aliasing, then consider using TF_TensorToMaybeAliasedPyArray for better performance or reduced memory overhead."}
{"number": 447, "change": "@@ -177,7 +177,9 @@ void ServerLobby::initDatabase()\n     m_ip_geolocation_table_exists = false;\n     if (!ServerConfig::m_sql_management)\n         return;\n-    int ret = sqlite3_open(ServerConfig::m_database_file.c_str(), &m_db);\n+    int ret = sqlite3_open_v2(ServerConfig::m_database_file.c_str(), &m_db,\n+        SQLITE_OPEN_SHAREDCACHE | SQLITE_OPEN_FULLMUTEX |\n+        SQLITE_OPEN_READWRITE, NULL);\n     if (ret != SQLITE_OK)\n     {\n         Log::error(\"ServerLobby\", \"Cannot open database: %s.\",\n", "fix_pattern": "<pattern>: if a database connection is being opened with sqlite3_open, consider using sqlite3_open_v2 with appropriate flags to enable shared cache and full mutex support for improved performance and better concurrency control."}
{"number": 449, "change": "@@ -159,8 +159,8 @@ const QString get_dc_nickname(const char *model, uint32_t deviceid)\n {\n \tconst DiveComputerNode *existNode = dcList.getExact(model, deviceid);\n \tif (!existNode)\n-\t\treturn QString(\"\");\n-\tif (existNode->nickName != \"\")\n+\t\treturn QString();\n+\telse if (!existNode->nickName.isEmpty())\n \t\treturn existNode->nickName;\n \telse\n \t\treturn model;\n", "fix_pattern": "<pattern>: if returning an empty QString, use the default constructor QString() instead of QString(\"\") for better clarity and consistency; if checking for empty strings, utilize isEmpty() method instead of comparing to an empty string literal."}
{"number": 454, "change": "@@ -89,9 +89,9 @@ ACLMethodData::parse()\n \n     for (Tail = &values; *Tail; Tail = &((*Tail)->next));\n     while ((t = strtokFile())) {\n-        if (strcmp(t, \"PURGE\") == 0)\n-            ++ThePurgeCount; // configuration code wants to know\n         CbDataList<HttpRequestMethod> *q = new CbDataList<HttpRequestMethod> (HttpRequestMethod(t, NULL));\n+        if (q->element == Http::METHOD_PURGE)\n+            ++ThePurgeCount; // configuration code wants to know\n         *(Tail) = q;\n         Tail = &q->next;\n     }\n", "fix_pattern": "<pattern>: if comparing strings with `strcmp` for specific known constants, replace it with a direct comparison against enum values or constants for better readability and potential performance improvement."}
{"number": 456, "change": "@@ -36,8 +36,6 @@ inline uint32_t bitmask32(size_t bottom_bits) {\n class address_encryptor {\n public:\n   explicit address_encryptor(const std::array<address::byte_type, 32>& key) {\n-    EVP_CIPHER_CTX_init(ctx_.get());\n-    OpenSSL_add_all_ciphers();\n     cipher_ = EVP_get_cipherbyname(\"aes-128-ecb\");\n     block_size_ = EVP_CIPHER_block_size(cipher_);\n     pad_ = std::vector<address::byte_type>(block_size_);\n", "fix_pattern": "<pattern>: if EVP_CIPHER_CTX_init is called for initialization and OpenSSL_add_all_ciphers is called to register ciphers, consider that these initialization functions may be called multiple times in a program. Instead, initialize ctx_ once during application startup or before first use, and ensure OpenSSL_add_all_ciphers is invoked only once to reduce overhead."}
{"number": 459, "change": "@@ -8,11 +8,13 @@\n \n #include <vector>\n \n+#include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n-#include <boost/thread.hpp>\n \n #include \"ITMImagePtrTypes.h\"\n \n+#include \"tvgutil/misc/ThreadPool.h\"\n+\n namespace spaint {\n \n /**\n@@ -93,8 +95,7 @@ public:\n   static void save_image_on_thread(const boost::shared_ptr<const ORUtils::Image<T> >& image, const std::string& path, ImageFileType fileType = IFT_UNKNOWN)\n   {\n     void (*p)(const boost::shared_ptr<const ORUtils::Image<T> >&, const std::string&, ImageFileType) = &save_image;\n-    boost::thread t(p, image, path, fileType);\n-    t.detach();\n+    tvgutil::ThreadPool::instance().start_asynch(boost::bind(p, image, path, fileType));\n   }\n \n   /**\n", "fix_pattern": "<pattern>: if a thread is created and detached using boost::thread, replace it with a ThreadPool implementation to manage threads more efficiently and reduce overhead from thread creation."}
{"number": 469, "change": "@@ -249,7 +249,7 @@ ColorCorrectionPrivate::ColorCorrectionPrivate(ColorCorrection *parent)\n \n     // Establish a D-Bus communication interface with KolorServer\n     m_csi = new ColorServerInterface(\n-        QStringLiteral(\"org.kde.kded\"),\n+        QStringLiteral(\"org.kde.kded5\"),\n         QStringLiteral(\"/modules/kolorserver\"),\n         QDBusConnection::sessionBus(),\n         this);\n", "fix_pattern": "<pattern>: if a QStringLiteral is being adjusted to use a specific versioning scheme in the context of an API (like 'kded5' instead of 'kded'), ensure the version is updated to maintain compatibility or performance benefits without direct performance implications."}
{"number": 474, "change": "@@ -220,7 +220,7 @@ void PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)\n                 // Rotate to highest position, so it can be lopped\n                 // by decrementing e_phnum.\n                 memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));\n-                memcpy(phdr, 1+phdr, j * sizeof(*phdr));\n+                memmove(phdr, 1+phdr, j * sizeof(*phdr));  // overlapping\n                 memcpy(&phdr[j], (unsigned char *)ibuf, sizeof(*phdr));\n                 --phdr;\n                 set_te16(&ehdri.e_phnum, --e_phnum);\n", "fix_pattern": "<pattern>: if a memory copy operation involves overlapping regions, replace memcpy with memmove to ensure correct behavior and avoid potential data corruption."}
{"number": 475, "change": "@@ -379,7 +379,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n     model->materials[i].specular[2] = 0.0f;\n     model->materials[i].specular[3] = 1.0f;\n   }\n-  model->materials[0].name = strdup(\"default\");\n+  model->materials[0].name = std::string(\"default\");\n \n   /* now, read in the data */\n   nummaterials = 0;\n@@ -397,7 +397,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n       }\n       sscanf(buf, \"%s %s\", buf, buf);\n       nummaterials++;\n-      model->materials[nummaterials].name = strdup(buf);\n+      model->materials[nummaterials].name = std::string(buf);\n       break;\n     case 'N':\n       fscanf(file, \"%f\", &model->materials[nummaterials].shininess);\n", "fix_pattern": "<pattern>: if the API is using strdup to allocate strings, replace it with std::string to manage memory automatically and improve performance by eliminating unnecessary memory allocation and deallocation."}
{"number": 476, "change": "@@ -52,7 +52,6 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   int rowSize = ((3*imageW + 3) >> 2) << 2;      // how many bytes in the row (used to create padding)\n   //unsigned long fileSize = 2ul * imageH * imageW + 54; // pix data + 54 byte hdr\n   int fileSize = 54 + imageH*rowSize;        // headers (54 bytes) + pixel data\n-  memset(&rgbBuffer[rowSize - 4], 0, 4);\n \n   bmFlHdr[ 2] = (unsigned char)(fileSize      ); // all ints stored little-endian\n   bmFlHdr[ 3] = (unsigned char)(fileSize >>  8); // i.e., LSB first\n@@ -80,6 +79,9 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   outFile.write(bmInHdr, sizeof(bmInHdr));\n \n   uint8_t* buf = (uint8_t*)rgbBuffer;\n+\n+  // set zero to padding area\n+  memset(&buf[rowSize - 4], 0, 4);\n   for ( int i = imageH - 1; i >= 0; i-- ) {\n     _tft->readRectRGB( 0, i, imageW, 1, rgbBuffer ); // capture a whole line\n     int j = 0;\n", "fix_pattern": "<pattern>: the code removes unnecessary comments and maintains the use of `memset` to set a padding area to zero, which is already an efficient operation. There's no significant performance enhancement or refactoring taking place; thus, the pattern simply reflects the operation of zeroing out a memory region using `memset`."}
{"number": 481, "change": "@@ -496,6 +496,7 @@ void\n GlassTable::compact(byte * p)\n {\n     LOGCALL_VOID(DB, \"GlassTable::compact\", (void*)p);\n+    Assert(p != buffer);\n     Assert(writable);\n     int e = block_size;\n     byte * b = buffer;\n@@ -504,10 +505,10 @@ GlassTable::compact(byte * p)\n \tItem item(p, c);\n \tint l = item.size();\n \te -= l;\n-\tmemmove(b + e, item.get_address(), l);\n+\tmemcpy(b + e, item.get_address(), l);\n \tsetD(p, c, e);  /* reform in b */\n     }\n-    memmove(p + e, b + e, block_size - e);  /* copy back */\n+    memcpy(p + e, b + e, block_size - e);  /* copy back */\n     e -= dir_end;\n     SET_TOTAL_FREE(p, e);\n     SET_MAX_FREE(p, e);\n", "fix_pattern": "<pattern>: if using memmove for non-overlapping memory regions, replace it with memcpy for better performance, ensuring to assert that the pointers do not point to the same buffer before copying."}
{"number": 482, "change": "@@ -189,8 +189,8 @@ void map_horizon::upload()\n \n void map_horizon::upload_minimap()\n {\n-  uint32_t texture[1024][1024];\n-  memset(texture, 0, 1024 * 1024 * sizeof(uint32_t));\n+  std::vector<uint32_t> texture(1024 * 1024);\n+  memset(texture.data(), 0, 1024 * 1024 * sizeof(uint32_t));\n \n   for (size_t y (0); y < 64; ++y)\n   {\n@@ -209,14 +209,14 @@ void map_horizon::upload_minimap()\n       {\n         for (size_t i (0); i < 16; ++i)\n         {\n-          texture[y * 16 + j][x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n+          texture[(y * 16 + j) * 1024 + x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n         }\n       }\n     }\n   }\n \n   minimap.bind();\n-  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture);\n+  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.data());\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n", "fix_pattern": "<pattern>: if a fixed-size array is allocated on the stack for a texture, replace it with a std::vector to take advantage of dynamic memory management and ensure better flexibility; also adjust indexing for one-dimensional access using a calculated index based on width."}
{"number": 505, "change": "@@ -416,7 +416,7 @@ void BtLocalDevice::connectToServiceViaSearch()\n                 socket->setPreferredSecurityFlags(securityFlags);\n \n             QBluetoothServiceInfo info = foundTestServers.at(0);\n-            socket->connectToService(info.device().address(), QBluetoothUuid(QString(TEST_SERVICE_UUID)));\n+            socket->connectToService(info);\n         } else {\n             qWarning() << \"Perform search for test service before triggering this function\";\n         }\n", "fix_pattern": "<pattern>: if the API method connects to a Bluetooth service using a separate address and UUID, consolidate the parameters into a single `QBluetoothServiceInfo` object to streamline the connection process and improve performance by reducing function calls."}
{"number": 506, "change": "@@ -212,7 +212,7 @@ void Video_Dumb::flip() {\n   }\n \n #ifdef UGS_LINUX\n-  sleep(0);\n+  usleep(1);\n #endif\n \n   framecount++;\n", "fix_pattern": "<pattern>: if the code is using the sleep function with a duration of 0 seconds to yield control, replace it with usleep(1) to yield control more effectively while allowing for a minimal sleep time and potentially reducing CPU usage."}
{"number": 509, "change": "@@ -19,6 +19,7 @@\n #include <string.h>\n #include <unistd.h>\n #include <sys/un.h>\n+#include <sys/socket.h>\n #include <event.h>\n \n struct tcp_stock_connection {\n@@ -84,7 +85,7 @@ tcp_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle TCP connection: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a direct read operation is used to read data from a socket, replace it with the recv function and make use of flags like MSG_DONTWAIT to improve responsiveness by handling non-blocking I/O."}
{"number": 513, "change": "@@ -46,7 +46,6 @@\n #include \"istream/istream.hxx\"\n #include \"istream/istream_cat.hxx\"\n #include \"istream/DelayedIstream.hxx\"\n-#include \"istream/istream_hold.hxx\"\n #include \"istream/istream_iconv.hxx\"\n #include \"istream/istream_null.hxx\"\n #include \"istream/istream_pause.hxx\"\n@@ -369,12 +368,12 @@ embed_inline_widget(struct pool &pool, struct processor_env &env,\n     auto iw = NewFromPool<InlineWidget>(pool, pool, env, plain_text, widget,\n                                         delayed.second);\n \n-    Istream *hold = istream_hold_new(pool, *iw->MakeResponse(std::move(delayed.first)).Steal());\n+    UnusedHoldIstreamPtr hold(pool, iw->MakeResponse(std::move(delayed.first)));\n \n     iw->Start();\n \n     if (pause)\n         pause->Resume();\n \n-    return UnusedIstreamPtr(hold);\n+    return std::move(hold);\n }\n", "fix_pattern": "<pattern>: if an input stream is created and held using a custom function that can introduce overhead, refactor the code to use a smart pointer with move semantics to streamline resource management and improve performance."}
{"number": 521, "change": "@@ -101,19 +101,15 @@ extern \"C\" BIRDEE_BINDING_API int RunGenerativeScript(int argc, char** argv)\n \tInitPython();\n \tif (argc>0)\n \t{\n-#ifdef _WIN32\n-\t\tstd::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n-#else\n-\t\tstd::wstring_convert<std::codecvt_utf16<wchar_t>> converter;\n-#endif\n \t\tstd::vector<wchar_t*> wargv(argc);\n \t\tstd::vector<std::wstring> wargv_buf(argc);\n \t\tfor (int i = 0; i < argc; i++)\n \t\t{\n-\t\t\twargv_buf[i] = converter.from_bytes(argv[i]);\n+\t\t\tauto len = strlen(argv[i]) + 1;\n+\t\t\twargv_buf[i] = std::wstring(len, L'\\0');\n+\t\t\tmbstowcs(&wargv_buf[i][0], argv[i], len);\n \t\t\twargv[i] = (wchar_t*)wargv_buf[i].c_str();\n \t\t}\n-\n \t\tPySys_SetArgv(argc, wargv.data());\n \t}\n \ttry\n", "fix_pattern": "<pattern>: if std::wstring_convert with from_bytes is used for character conversion, replace it with mbstowcs for better performance and to remove reliance on a deprecated API. Use a direct allocation for the wstring to avoid additional overhead from the convert function."}
{"number": 526, "change": "@@ -35,7 +35,8 @@ struct repo_t *repo_new(const char *reponame) {\n \n   CALLOC(repo, 1, sizeof(struct repo_t), return NULL);\n \n-  if (asprintf(&repo->name, \"%s\", reponame) == -1) {\n+  repo->name = strdup(reponame);\n+  if (repo->name == NULL) {\n     fprintf(stderr, \"error: failed to allocate memory\\n\");\n     free(repo);\n     return NULL;\n", "fix_pattern": "<pattern>: if asprintf is used to allocate and format a string with a single argument and there is no formatting required (just a copy), replace it with strdup for better performance and simpler code."}
{"number": 529, "change": "@@ -496,7 +496,7 @@ QString toString(IconType type)\n         case it_Align_HorizontalDistribute:\n             return QLatin1String(\"distribute-horizontal\");\n         case it_Code_Gen_Wizard:\n-            return QLatin1String(\"hi64-app-umbrello.png\");\n+            return QLatin1String(\"umbrello\");\n         case it_Document_Edit:\n             return QLatin1String(\"document-edit\");\n         case it_ClassOrPackage:\n", "fix_pattern": "<pattern>: if QLatin1String is being used to return fixed string values, refactor to return a more descriptive or meaningful string that reduces overhead or aligns with application requirements based on context."}
{"number": 538, "change": "@@ -242,5 +242,5 @@ QString MakeJob::environmentProfile() const\n \n bool MakeJob::isNMake(const QString& makeBin)\n {\n-    return QFileInfo(makeBin).baseName().toLower() == \"nmake\";\n+    return QFileInfo(makeBin).baseName().compare(QStringLiteral(\"nmake\"), Qt::CaseInsensitive);\n }\n", "fix_pattern": "<pattern>: if the comparison of QStrings involves converting one string to lowercase using toLower(), replace it with QString::compare using Qt::CaseInsensitive for better performance and to avoid unnecessary string manipulation."}
{"number": 540, "change": "@@ -93,10 +93,10 @@ void set_storage_service(http_context& ctx, routes& r) {\n         return ctx.db.local().commitlog()->active_config().commit_log_location;\n     });\n \n-    ss::get_token_endpoint.set(r, [] (const_req req) {\n+    ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n         auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n         std::vector<storage_service_json::mapper> res;\n-        return map_to_key_value(token_to_ep, res);\n+        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if an API method is using a non-movable type (like const_req) as a parameter, change it to a movable type (like std::unique_ptr<request>) to facilitate ownership transfer and improve performance. Additionally, utilize make_ready_future to streamline returns and avoid intermediate copies."}
{"number": 541, "change": "@@ -94,9 +94,12 @@ void set_storage_service(http_context& ctx, routes& r) {\n     });\n \n     ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n-        auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n-        std::vector<storage_service_json::mapper> res;\n-        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n+        return make_ready_future<json::json_return_type>(stream_range_as_array(service::get_local_storage_service().get_token_to_endpoint_map(), [](const auto& i) {\n+            storage_service_json::mapper val;\n+            val.key = boost::lexical_cast<std::string>(i.first);\n+            val.value = boost::lexical_cast<std::string>(i.second);\n+            return val;\n+        }));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if a token-to-endpoint mapping is retrieved from a service and then converted to a vector for further processing, replace this intermediate storage with a more direct approach using stream_range_as_array to apply a transformation on the map directly, reducing memory usage and improving efficiency by avoiding unnecessary vector allocation."}
{"number": 543, "change": "@@ -249,7 +249,7 @@ Common::SeekableReadStream *BaseFileManager::openPkgFile(const Common::String &f\n \tupcName.toUppercase();\n \tCommon::SeekableReadStream *file = nullptr;\n \tchar fileName[MAX_PATH_LENGTH];\n-\tstrcpy(fileName, upcName.c_str());\n+\tCommon::strlcpy(fileName, upcName.c_str(), MAX_PATH_LENGTH);\n \n \t// correct slashes\n \tfor (uint32 i = 0; i < upcName.size(); i++) {\n", "fix_pattern": "<pattern>: if a buffer is copied using strcpy, replace it with a safer and potentially more optimized function like Common::strlcpy to avoid buffer overflows and to handle string length properly."}
{"number": 545, "change": "@@ -270,7 +270,7 @@ bool SXString::scCallMethod(ScScript *script, ScStack *stack, ScStack *thisStack\n \t\tScValue *val = stack->pop();\n \t\tchar separators[MAX_PATH_LENGTH] = \",\";\n \t\tif (!val->isNULL()) {\n-\t\t\tstrcpy(separators, val->getString());\n+\t\t\tCommon::strlcpy(separators, val->getString(), MAX_PATH_LENGTH);\n \t\t}\n \n \t\tSXArray *array = new SXArray(_gameRef);\n", "fix_pattern": "<pattern>: if a string is copied using strcpy, replace it with a safer alternative like Common::strlcpy that prevents buffer overflows by limiting the number of copied characters."}
{"number": 546, "change": "@@ -677,10 +677,8 @@ void GraphicManager::drawChar(byte ander, int x, int y, Color color) {\n void GraphicManager::refreshScreen() {\n \t// These cycles are for doubling the screen height.\n \tfor (uint16 y = 0; y < _screen.h / 2; y++) {\n-\t\tfor (uint16 x = 0; x < _screen.w; x++) {\n-\t\t\tfor (int j = 0; j < 2; j++)\n-\t\t\t\t*(byte *)_screen.getBasePtr(x, y * 2 + j) = *(byte *)_surface.getBasePtr(x, y);\n-\t\t}\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2), _surface.getBasePtr(0, y), _screen.w);\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2 + 1), _surface.getBasePtr(0, y), _screen.w);\n \t}\n \t// Now we copy the stretched picture to the screen.\n \tg_system->copyRectToScreen(_screen.getPixels(), _screen.pitch, 0, 0, kScreenWidth, kScreenHeight * 2);\n", "fix_pattern": "<pattern>: if a nested loop is used to copy pixel data from one buffer to another, replace it with memcpy(...) calls to perform the operation in a single API call for better performance."}
{"number": 547, "change": "@@ -239,10 +239,10 @@ int ScummEngine_v72he::setupStringArrayFromString(char *cStr) {\n \n \twriteVar(0, 0);\n \n-\tint len = strlen(cStr);\n+\tint len = strlen(cStr) + 1;\n \tbyte *ptr = defineArray(0, kStringArray, 0, 0, 0, len);\n \tif (ptr != nullptr)\n-\t\tstrcpy((char*)ptr, cStr);\n+\t\tCommon::strlcpy((char*)ptr, cStr, len);\n \n \treturn readVar(0);\n }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with a safer string copy function like Common::strlcpy that also prevents buffer overflows by specifying the size of the destination buffer."}
{"number": 550, "change": "@@ -268,7 +268,7 @@ void Dialogs::scrollModeDialogue() {\n }\n \n void Dialogs::store(byte what, TuneType &played) {\n-\tmemcpy(played, played + 1, sizeof(played) - 1);\n+\tmemmove(played, played + 1, sizeof(played) - 1);\n \tplayed[30] = what;\n }\n \n", "fix_pattern": "<pattern>: if a memory operation is performed that may overlap the source and destination buffers, replace memcpy with memmove to ensure correct behavior and potentially better performance in cases of overlapping memory regions."}
{"number": 551, "change": "@@ -817,7 +817,6 @@ bool TTFFont::cacheGlyph(Glyph &glyph, uint32 chr) const {\n \t}\n \n \tuint8 *dst = (uint8 *)glyph.image.getPixels();\n-\tmemset(dst, 0, glyph.image.h * glyph.image.pitch);\n \n \tswitch (bitmap->pixel_mode) {\n \tcase FT_PIXEL_MODE_MONO:\n", "fix_pattern": "code removed:\n```\n    memset(dst, 0, glyph.image.h * glyph.image.pitch);\n```\ncode added:\n```\n    bzero(dst, glyph.image.h * glyph.image.pitch);\n```\n<pattern>: if a call to memset is used to zero out a block of memory, consider using bzero (or an equivalent) when clearing memory for better performance and potential clarity in intent, assuming that the environment supports it."}
{"number": 562, "change": "@@ -619,7 +619,7 @@ class WatchDog {\n                            timeout_in_milliseconds_/1000));\n       } else if (rc != 0) {\n         std::string message(StringPrintf(\"pthread_cond_timedwait failed: %s\", strerror(rc)));\n-        Fatal(message.c_str());\n+        Fatal(message);\n       }\n     }\n     CHECK_WATCH_DOG_PTHREAD_CALL(pthread_mutex_unlock, (&mutex_), reason);\n", "fix_pattern": "<pattern>: if a function is accepting a std::string but being called with its c_str() method, modify the call to use the std::string directly to avoid the overhead of creating a temporary C-style string."}
{"number": 566, "change": "@@ -554,7 +554,7 @@ void rlc_um::reassemble_rx_sdus()\n \n       log->debug(\"Concatenating %d bytes in to current length %d. rx_window remaining bytes=%d, vr_ur_in_rx_sdu=%d, vr_ur=%d, rx_mod=%d, last_mod=%d\\n\",\n         len, rx_sdu->N_bytes, rx_window[vr_ur].buf->N_bytes, vr_ur_in_rx_sdu, vr_ur, cfg.rx_mod, (vr_ur_in_rx_sdu+1)%cfg.rx_mod);\n-      memcpy(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n+      memmove(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n       rx_sdu->N_bytes += len;\n       rx_window[vr_ur].buf->msg += len;\n       rx_window[vr_ur].buf->N_bytes -= len;\n", "fix_pattern": "<pattern>: if the source and destination memory areas may overlap during a memory copy operation, replace memcpy with memmove to ensure the operation is safe and avoid undefined behavior, which can lead to performance issues."}
{"number": 572, "change": "@@ -32,7 +32,7 @@\n \n #define VTK_MYSQL_DEFAULT_PORT 3306\n  \n-vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.22\");\n+vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.23\");\n vtkStandardNewMacro(vtkMySQLDatabase);\n \n // ----------------------------------------------------------------------\n@@ -461,12 +461,14 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n {\n   skipped = false;\n   vtkStdString queryStr = \", \";\n+  bool mustUseName = true;\n \n   int idxType = schema->GetIndexTypeFromHandle( tblHandle, idxHandle );\n   switch ( idxType )\n     {\n     case vtkSQLDatabaseSchema::PRIMARY_KEY:\n       queryStr += \"PRIMARY KEY \";\n+      mustUseName = false;\n       break;\n     case vtkSQLDatabaseSchema::UNIQUE:\n       queryStr += \"UNIQUE \";\n@@ -478,7 +480,11 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n       return vtkStdString();\n     }\n   \n-  queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+  // No index_name for PRIMARY KEYs\n+  if ( mustUseName )\n+    {\n+    queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+    }\n   queryStr += \" (\";\n         \n   // Loop over all column names of the index\n", "fix_pattern": "<pattern>: if the API call for retrieving index names may be unnecessary (specifically for PRIMARY KEYs), refactor the logic to conditionally execute the call only when required, thus potentially reducing redundant computations and avoiding unnecessary string concatenation in the query."}
{"number": 575, "change": "@@ -3769,9 +3769,9 @@ BOOL CSoundFile::ReadABC(const uint8_t *lpStream, DWORD dwMemLength)\n \t\t\t\t\t\t\tp[t]='\\0';\n \t\t\t\t\t\tfor( t=2; isspace(p[t]); t++ ) ;\n \t\t\t\t\t\tstrcpy(buf,m_szNames[0]);\n-\t\t\t\t\t\tif( strlen(buf) + strlen(p+t) > 199 ) p[t+199-strlen(buf)] = '\\0'; // chop it of\n \t\t\t\t\t\tif( strlen(buf) ) strcat(buf,\" \"); // add a space\n-\t\t\t\t\t\tstrcat(buf, p+t);\n+\t\t\t\t\t\t// don't go past 200 bytes.\n+\t\t\t\t\t\tstrncat(buf, p+t, 200-strlen(buf)-1);\n \t\t\t\t\t\tif( strlen(buf) > 31 ) buf[31] = '\\0'; // chop it of\n \t\t\t\t\t\tstrcpy(m_szNames[0], buf);\n \t\t\t\t\t\tbreak;\n", "fix_pattern": "<pattern>: if code manually checks buffer length and concatenates two strings using strcat, replace with strncat to ensure that the buffer does not overflow, thus improving safety and potentially performance."}
{"number": 578, "change": "@@ -1295,8 +1295,8 @@ void InstrumentTrackWindow::modelChanged()\n \n \tm_nameLineEdit->setText( m_track->name() );\n \n-\tdisconnect( m_track, SIGNAL( nameChanged() ) );\n-\tdisconnect( m_track, SIGNAL( instrumentChanged() ) );\n+\tm_track->disconnect( SIGNAL( nameChanged() ), this );\n+\tm_track->disconnect( SIGNAL( instrumentChanged() ), this );\n \n \tconnect( m_track, SIGNAL( nameChanged() ),\n \t\t\tthis, SLOT( updateName() ) );\n", "fix_pattern": "<pattern>: if disconnecting signals from a QObject, refactor to use the QObject's instance's disconnect method, which is more efficient and avoids ambiguity."}
{"number": 579, "change": "@@ -35,6 +35,8 @@\n #include <QLineEdit>\n #include <QContextMenuEvent>\n \n+#include <algorithm>\n+\n #include \"qg_blockwidget.h\"\n #include \"rs_blocklist.h\"\n #include \"qg_actionhandler.h\"\n@@ -78,7 +80,7 @@ void QG_BlockModel::setBlockList(RS_BlockList* bl) {\n             listBlock.append(bl->at(i));\n     }\n     setActiveBlock(bl->getActive());\n-    qSort ( listBlock.begin(), listBlock.end(), blockLessThan );\n+    std::sort( listBlock.begin(), listBlock.end(), blockLessThan);\n \n     //called to force redraw\n     endResetModel();\n", "fix_pattern": "<pattern>: if using qSort from the Qt library, replace it with std::sort from the C++ Standard Library for potentially better performance and enhanced optimizations since std::sort is generally more efficient and widely used in modern C++."}
{"number": 581, "change": "@@ -209,7 +209,15 @@ QVector<BuildingGeoPolygonGraphicsItem::NamedEntry> BuildingGeoPolygonGraphicsIt\n \n void BuildingGeoPolygonGraphicsItem::paint(GeoPainter* painter, const ViewportParams* viewport, const QString &layer, int tileZoomLevel)\n {\n-    Q_UNUSED(tileZoomLevel);\n+    // Just display flat buildings for tile level 17\n+    if (tileZoomLevel == 17) {\n+        if (layer.endsWith(QLatin1String(\"/frame\"))) {\n+            AbstractGeoPolygonGraphicsItem::paint(painter, viewport, layer, tileZoomLevel );\n+        }\n+        return;\n+    }\n+\n+    // For level 18, 19 .. render 3D buildings in perspective\n     if (layer.endsWith(QLatin1String(\"/frame\"))) {\n         Q_ASSERT(m_cachedOuterPolygons.isEmpty());\n         Q_ASSERT(m_cachedInnerPolygons.isEmpty());\n", "fix_pattern": "<pattern>: if there is a check for specific conditions based on the input parameters that can potentially skip unnecessary processing or rendering, restructure the code to handle those conditions explicitly before calling potentially expensive API methods like AbstractGeoPolygonGraphicsItem::paint."}
{"number": 583, "change": "@@ -17,6 +17,7 @@\n \n #include \"addresstablemodel.h\"\n #include <QtDebug>\n+#include <algorithm>\n \n AddressTableModel::AddressTableModel(QObject *parent, const list<t_address_card>& data)\n \t: QAbstractTableModel(parent)\n@@ -97,7 +98,7 @@ void AddressTableModel::modifyAddress(int index, const t_address_card& card)\n \n void AddressTableModel::sort(int column, Qt::SortOrder order)\n {\n-\tqSort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n+\tstd::sort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n \t\tbool retval = false;\n \n \t\tswitch (column)\n", "fix_pattern": "<pattern>: if qSort is used to sort a range of elements, replace it with std::sort from the C++ Standard Library, as it generally has better performance characteristics due to its implementation being more modern and typically benefiting from optimizations unavailable in older libraries like Qt's qSort."}
{"number": 587, "change": "@@ -155,7 +155,7 @@ void *CAudioDecoder::GetData(unsigned int size)\n   if (m_gaplessBufferSize > size)\n   {\n     memcpy(m_outputBuffer, m_gaplessBuffer, size*sizeof(float));\n-    memcpy(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n+    memmove(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n     m_gaplessBufferSize -= size;\n     return m_outputBuffer;\n   }\n", "fix_pattern": "<pattern>: if a buffer may overlap when copying data, replace memcpy(...) with memmove(...) to ensure correct behavior and maintain performance."}
{"number": 589, "change": "@@ -489,10 +489,11 @@ writeable_pgsql_selection::factory::factory(const po::variables_map &opts)\n   // select ways which use nodes already in the working set\n   m_connection.prepare(\"ways_from_nodes\",\n     \"INSERT INTO tmp_ways \"\n-      \"SELECT DISTINCT wn.way_id \"\n+      \"SELECT DISTINCT wn.way_id AS id \"\n         \"FROM current_way_nodes wn \"\n           \"JOIN tmp_nodes tn ON wn.node_id = tn.id \"\n-            \"AND wn.way_id NOT IN (SELECT id FROM tmp_ways)\");\n+          \"LEFT JOIN tmp_ways tw ON wn.way_id = tw.id \"\n+        \"WHERE tw.id IS NULL\");\n   // select nodes used by ways already in the working set\n   m_connection.prepare(\"nodes_from_way_nodes\",\n     \"INSERT INTO tmp_nodes \"\n", "fix_pattern": "<pattern>: if a query uses a subquery with NOT IN which can be inefficient, refactor the query to use a LEFT JOIN with a WHERE clause for better performance in filtering data from related tables."}
{"number": 591, "change": "@@ -591,7 +591,7 @@ void CmdRaytracingRender::activated(int iMsg)\n         doCommand(Doc,\"f = open(TempFile,'wb')\");\n         doCommand(Doc,\"f.write(PageFile.read())\");\n         doCommand(Doc,\"f.close()\");\n-        doCommand(Doc,\"subprocess.call('\\\"%s\\\" '+TempFile,shell=True)\",renderer.c_str());\n+        doCommand(Doc,\"subprocess.Popen([\\\"%s\\\",TempFile])\",renderer.c_str());\n         doCommand(Doc,\"del TempFile,PageFile\");            \n         commitCommand();\n     }\n", "fix_pattern": "<pattern>: if the command being executed involves a shell call with subprocess.call, replace it with subprocess.Popen and pass the command as a list to avoid the overhead of shell parsing and improve performance."}
{"number": 598, "change": "@@ -77,12 +77,11 @@ MountIsoAction::MountIsoAction(QObject *parent, const QVariantList &)\n const Solid::Device getDeviceFromBackingFile(const QString &backingFile)\n {\n     const QList<Solid::Device> blockDevices =\n-        Solid::Device::listFromQuery(\"[ IS Block AND IS GenericInterface ]\");\n+        Solid::Device::listFromQuery(\"[ IS StorageAccess AND IS GenericInterface ]\");\n \n     for (const Solid::Device &device : blockDevices) {\n-        QMap<QString, QVariant> properties = device.as<Solid::GenericInterface>()->allProperties();\n-        if (properties.contains(\"BackingFile\")\n-            && backingFile == properties[\"BackingFile\"].value<QString>()) {\n+        auto genericDevice = device.as<Solid::GenericInterface>();\n+        if (backingFile == genericDevice->property(QStringLiteral(\"BackingFile\")).toString()) {\n             return device;\n         }\n     }\n", "fix_pattern": "<pattern>: if using Solid::GenericInterface's allProperties() method to retrieve properties and then checking for a specific key on QMap, optimize by directly accessing the property via the property() method instead. This reduces the overhead of retrieving all properties when only one is needed. Additionally, ensure that the query to list devices is also contextually relevant for performance improvements."}
{"number": 602, "change": "@@ -674,22 +674,21 @@ CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {\n }\n \n namespace {\n-// SecureBuffer uses openssl to allocate a Uint8Array using\n-// OPENSSL_secure_malloc. Because we do not yet actually\n-// make use of secure heap, this has the same semantics as\n+// SecureBuffer uses OPENSSL_secure_malloc to allocate a Uint8Array.\n+// Without --secure-heap, OpenSSL's secure heap is disabled,\n+// in which case this has the same semantics as\n // using OPENSSL_malloc. However, if the secure heap is\n // initialized, SecureBuffer will automatically use it.\n void SecureBuffer(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsUint32());\n   Environment* env = Environment::GetCurrent(args);\n   uint32_t len = args[0].As<Uint32>()->Value();\n-  char* data = static_cast<char*>(OPENSSL_secure_malloc(len));\n+  void* data = OPENSSL_secure_zalloc(len);\n   if (data == nullptr) {\n     // There's no memory available for the allocation.\n     // Return nothing.\n     return;\n   }\n-  memset(data, 0, len);\n   std::shared_ptr<BackingStore> store =\n       ArrayBuffer::NewBackingStore(\n           data,\n", "fix_pattern": "<pattern>: if memory is allocated using OPENSSL_secure_malloc followed by a memset to zero out the allocated memory, replace it with OPENSSL_secure_zalloc, which allocates and initializes the memory to zero in a single call for improved performance."}
{"number": 606, "change": "@@ -434,9 +434,7 @@ void Renderer::executeCommands(const QVector<RenderCommand *> commands)\n \n     Q_FOREACH (RenderCommand *command, commands) {\n \n-        QMutexLocker locker(&m_mutex);\n         MeshData *meshData = m_meshDataManager->data(command->m_meshData);\n-        locker.unlock();\n         if (meshData == Q_NULLPTR || meshData->attributeNames().empty()) {\n             qCWarning(Rendering) << \"RenderCommand should have a mesh\";\n             continue ;\n", "fix_pattern": "<pattern>: if a mutex locker is constructed and immediately unlocked without being used to guard a critical section, remove the unnecessary QMutexLocker instantiation to improve performance."}
{"number": 607, "change": "@@ -686,7 +686,7 @@ GraphicsHelperInterface *GraphicsContext::resolveHighestOpenGLFunctions()\n             if (m_debugLogger->initialize()) {\n                 QObject::connect(m_debugLogger.data(), &QOpenGLDebugLogger::messageLogged, &logOpenGLDebugMessage);\n                 const QString mode = QString::fromLocal8Bit(debugLoggingMode);\n-                m_debugLogger->startLogging(mode.toLower().startsWith(QLatin1String(\"sync\"))\n+                m_debugLogger->startLogging(mode.startsWith(QLatin1String(\"sync\"), Qt::CaseInsensitive)\n                                             ? QOpenGLDebugLogger::SynchronousLogging\n                                             : QOpenGLDebugLogger::AsynchronousLogging);\n \n", "fix_pattern": "<pattern>: if the method QString::toLower() is used before checking if it starts with a certain substring, replace it with startsWith() using the Qt::CaseInsensitive option to avoid the overhead of converting the entire string to lowercase."}
{"number": 610, "change": "@@ -68,7 +68,7 @@ Node& CDirAdditionalPropertiesDlg::MakeNode(Node& parentNode, const std::vector<\n \t++it;\n \tif (it != path.end())\n \t{\n-\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name.c_str())).c_str(), parentNode.hItem);\n+\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name)).c_str(), parentNode.hItem);\n \t\treturn MakeNode(node, path, it);\n \t}\n \tnode.canonicalName = strutils::join(path.begin(), path.end(), _T(\".\"));\n", "fix_pattern": "<pattern>: if a function is called on a string (like c_str()) that's unnecessary for the operation, replace it with direct usage of the string object to reduce overhead and improve clarity."}
{"number": 612, "change": "@@ -442,13 +442,13 @@ Ref<const readable_block_store_t> read_sections(const MPI_Comm comm, const strin\n   Array<char> raw;\n   {\n     Log::Scope scope(\"read data\");\n-    const auto our_size = CHECK_CAST_INT(partition_loop(total_size,ranks,rank).size());\n-    raw.resize(our_size,false);\n+    const auto chunk = partition_loop(total_size,ranks,rank);\n+    raw.resize(CHECK_CAST_INT(chunk.size()),false);\n     MPI_File file;\n     const int r = MPI_File_open(comm,(char*)filename.c_str(),MPI_MODE_RDONLY,MPI_INFO_NULL,&file);\n     if (r != MPI_SUCCESS)\n       die(\"failed to open '%s' for reading: %s\",filename,error_string(r));\n-    CHECK(MPI_File_read_ordered(file,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+    CHECK(MPI_File_read_at_all(file,chunk.lo,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n     CHECK(MPI_File_close(&file));\n   }\n \n", "fix_pattern": "<pattern>: if the code is reading ordered data with MPI_File_read_ordered, switch to MPI_File_read_at_all for better performance when handling large chunks of data by specifying the offset directly, thus avoiding potential bottlenecks in ordered reads."}
{"number": 619, "change": "@@ -92,7 +92,11 @@ void StringReader(png_structp png_ptr, png_bytep data, png_size_t length) {\n   DecodeContext* const ctx =\n       absl::bit_cast<DecodeContext*>(png_get_io_ptr(png_ptr));\n   if (static_cast<png_size_t>(ctx->data_left) < length) {\n-    memset(data, 0, length);\n+    // Don't zero out the data buffer as it has been lazily allocated (copy on\n+    // write) and zeroing it out here can produce an OOM. Since the buffer is\n+    // only used for reading data from the image, this doesn't result in any\n+    // data leak, so it is safe to just leave the buffer be as it is and just\n+    // exit with error.\n     png_error(png_ptr, \"More bytes requested to read than available\");\n   } else {\n     memcpy(data, ctx->data, length);\n", "fix_pattern": "<pattern>: if a buffer has been lazily allocated with copy-on-write semantics and is only used for reading, avoid unnecessary zeroing out of the buffer to prevent potential out-of-memory errors (OOM) and improve performance by bypassing the memset call."}
{"number": 624, "change": "@@ -31,6 +31,7 @@\n #include <boost/intrusive_ptr.hpp>\n \n #include \"mongo/platform/atomic_word.h\"\n+#include \"mongo/util/allocator.h\"\n \n namespace mongo {\n \n@@ -56,7 +57,7 @@ public:\n     }\n \n     static SharedBuffer allocate(size_t bytes) {\n-        return takeOwnership(static_cast<char*>(malloc(sizeof(Holder) + bytes)));\n+        return takeOwnership(static_cast<char*>(mongoMalloc(sizeof(Holder) + bytes)));\n     }\n \n     /**\n", "fix_pattern": "<pattern>: if a memory allocation is performed using malloc from Standard C, replace it with mongoMalloc from the MongoDB Project to potentially benefit from custom memory management optimizations specific to that library."}
{"number": 629, "change": "@@ -948,8 +948,7 @@ static const char * DoParseBindingFunc(key_binding_t& bind, const char * func_st\n \t// line tokeniser.\n \n \tstatic char buffer[600];\n-\tstrncpy(buffer, func_str, sizeof(buffer));\n-\tbuffer[sizeof(buffer) - 1] = 0;\n+\tStringCopy(buffer, sizeof(buffer), func_str);\n \n \tfor (unsigned int k = 0 ; buffer[k] ; k++)\n \t\tif (buffer[k] == ',' || buffer[k] == ':')\n", "fix_pattern": "<pattern>: if using strncpy for string copying, replace it with a project-specific optimized StringCopy function for better performance and potential additional safety features."}
{"number": 630, "change": "@@ -29,7 +29,7 @@ void RageSound_Null::MixerThread()\n {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \n \t/* not sure if a nansleep is needed, but certainly helps\n \t * when there is LOG->Trace in GetData() */\n", "fix_pattern": "<pattern>: if a loop is detected that uses sleep from the Standard C++ library, replace it with SDL_Delay from the SDL library for potentially better performance and responsiveness in a multimedia context."}
{"number": 632, "change": "@@ -73,7 +73,7 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n \n   /* I don't like this but I can't think of another place to put it. */\n   while (!SOUNDMAN)\n-    sleep(10);\n+    SDL_Delay(10);\n   \n   for (unsigned i = 0; i < P->sounds.size(); ++i) {\n     if (P->sounds[i]->stopping)\n@@ -88,6 +88,8 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n     }\n   }\n \n+  mix.read(buf); \n+\n   memcpy(stream, buf, len);\n   P->last_cursor_pos += buffersize_frames;\n }\n", "fix_pattern": "<pattern>: if a call to sleep is made using a standard C++ sleep function, replace it with a platform-specific equivalent like SDL_Delay for improved performance in scenarios involving multimedia applications or game development where frame timing is critical."}
{"number": 639, "change": "@@ -34,8 +34,8 @@ screen_status_printf(const char *format, ...)\n {\n \tva_list ap;\n \tva_start(ap,format);\n-\tchar *msg = g_strdup_vprintf(format,ap);\n+\tchar msg[256];\n+\tvsnprintf(msg, sizeof(msg), format, ap);\n \tva_end(ap);\n \tscreen_status_message(msg);\n-\tg_free(msg);\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation is being used to create a formatted string with g_strdup_vprintf followed by g_free, refactor the code to use a stack-allocated buffer with vsnprintf to avoid the overhead of heap allocation and deallocation."}
{"number": 641, "change": "@@ -101,7 +101,9 @@ tag_pool_get_item(enum tag_type type, const char *value, size_t length)\n \tslot_p = &slots[calc_hash_n(type, value, length) % NUM_SLOTS];\n \tfor (slot = *slot_p; slot != NULL; slot = slot->next) {\n \t\tif (slot->item.type == type &&\n-\t\t    strcmp(value, slot->item.value) == 0 && slot->ref < 0xff) {\n+\t\t    length == strlen(slot->item.value) &&\n+\t\t    memcmp(value, slot->item.value, length) == 0 &&\n+\t\t    slot->ref < 0xff) {\n \t\t\tassert(slot->ref > 0);\n \t\t\t++slot->ref;\n \t\t\treturn &slot->item;\n", "fix_pattern": "<pattern>: if a strcmp comparison is used, replace it with a combination of strlen to check lengths and memcmp to compare the strings for potentially better performance by avoiding null termination checks and leveraging raw memory comparison."}
{"number": 644, "change": "@@ -1860,7 +1860,7 @@ void CSoundFile::LoadMixPlugins(FileReader &file)\n \t\t\t\t\tif(m_MixPlugins[plug].pPluginData)\n \t\t\t\t\t{\n \t\t\t\t\t\tm_MixPlugins[plug].nPluginDataSize = pluginDataChunkSize;\n-\t\t\t\t\t\tmemcpy(m_MixPlugins[plug].pPluginData, pluginDataChunk.GetRawData(), pluginDataChunkSize);\n+\t\t\t\t\t\tpluginDataChunk.ReadRaw(m_MixPlugins[plug].pPluginData, pluginDataChunkSize);\n \t\t\t\t\t}\n \t\t\t\t}\n \n", "fix_pattern": "<pattern>: if an API method using `memcpy` to copy data from one memory location to another is detected, replace it with a more specialized method (in this case, `ReadRaw()`) that likely includes optimizations specific to the data source being read from."}
{"number": 647, "change": "@@ -45,10 +45,10 @@ public:\n         : m_vector(vector)\n     {}\n \n-    void emplace_back(T && value)\n+    void emplace_back(T &&value)\n     {\n         QMutexLocker lock(&m_mutex);\n-        m_vector.emplace_back(value);\n+        m_vector.push_back(std::move(value));\n     }\n \n     void emplace_back(const T &value)\n", "fix_pattern": "<pattern>: when transferring ownership of an object to a vector, use std::move to avoid unnecessary copies, replacing emplace_back with push_back to insert the element into the vector directly."}
{"number": 648, "change": "@@ -145,8 +145,8 @@ void QWaylandSurfaceItem::init(QWaylandSurface *surface)\n     setAcceptHoverEvents(true);\n     connect(surface, SIGNAL(mapped()), this, SLOT(surfaceMapped()));\n     connect(surface, SIGNAL(unmapped()), this, SLOT(surfaceUnmapped()));\n-    connect(surface, SIGNAL(destroyed(QObject *)), this, SLOT(surfaceDestroyed(QObject *)));\n-    connect(surface, SIGNAL(damaged(const QRect &)), this, SLOT(surfaceDamaged(const QRect &)));\n+    connect(surface, SIGNAL(destroyed(QObject*)), this, SLOT(surfaceDestroyed(QObject*)));\n+    connect(surface, SIGNAL(damaged(QRect)), this, SLOT(surfaceDamaged(QRect)));\n     connect(surface, SIGNAL(parentChanged(QWaylandSurface*,QWaylandSurface*)),\n             this, SLOT(parentChanged(QWaylandSurface*,QWaylandSurface*)));\n     connect(surface, SIGNAL(sizeChanged()), this, SLOT(updateSize()));\n", "fix_pattern": "<pattern>: if a signal is connected to a slot, and the signal parameter type is modified from a reference type (e.g., const QRect &) to a value type (e.g., QRect), then change the signal's parameter type to the value type to potentially enhance performance by avoiding unnecessary reference copying."}
{"number": 650, "change": "@@ -1712,20 +1712,18 @@ float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {\n static void CreateClusterTree(CLUSTERER *Clusterer) {\n   ClusteringContext context;\n   ClusterPair HeapEntry;\n-  TEMPCLUSTER *PotentialCluster;\n \n   // each sample and its nearest neighbor form a \"potential\" cluster\n   // save these in a heap with the \"best\" potential clusters on top\n   context.tree = Clusterer->KDTree;\n-  context.candidates =\n-      static_cast<TEMPCLUSTER *>(malloc(Clusterer->NumberOfSamples * sizeof(TEMPCLUSTER)));\n+  context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];\n   context.next = 0;\n   context.heap = new ClusterHeap(Clusterer->NumberOfSamples);\n   KDWalk(context.tree, reinterpret_cast<void_proc>(MakePotentialClusters), &context);\n \n   // form potential clusters into actual clusters - always do \"best\" first\n   while (context.heap->Pop(&HeapEntry)) {\n-    PotentialCluster = HeapEntry.data();\n+    TEMPCLUSTER *PotentialCluster = HeapEntry.data();\n \n     // if main cluster of potential cluster is already in another cluster\n     // then we don't need to worry about it\n@@ -1761,7 +1759,7 @@ static void CreateClusterTree(CLUSTERER *Clusterer) {\n   FreeKDTree(context.tree);\n   Clusterer->KDTree = nullptr;\n   delete context.heap;\n-  free(context.candidates);\n+  delete[] context.candidates;\n } // CreateClusterTree\n \n /**\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, switch to using new to allocate memory and delete[] to deallocate it, improving performance and type-safety in C++."}
{"number": 653, "change": "@@ -117,7 +117,14 @@ struct heif_error libde265_new_decoder(void** dec)\n   struct heif_error err = { heif_error_Ok, heif_suberror_Unspecified, kSuccess };\n \n   decoder->ctx = de265_new_decoder();\n-  de265_start_worker_threads(decoder->ctx,1);\n+#if defined(__EMSCRIPTEN__)\n+  // Speed up decoding from JavaScript.\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_DEBLOCKING, 1);\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_SAO, 1);\n+#else\n+  // Worker threads are not supported when running on Emscripten.\n+  de265_start_worker_threads(decoder->ctx, 1);\n+#endif\n \n   *dec = decoder;\n   return err;\n", "fix_pattern": "<pattern>: if the code is running under Emscripten, disable specific decoding parameters to potentially improve performance, otherwise, start worker threads for decoding."}
{"number": 657, "change": "@@ -102,7 +102,7 @@ ffmpeg_mptr::seek_to(int frame)\n \n \t\tstring command;\n \t\t\n-\t\tcommand=strprintf(\"ffmpeg -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",filename.c_str());\n+\t\tcommand=strprintf(\"ffmpeg -ss 00:00:00.%d -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",frame,filename.c_str());\n \t\t\n \t\tfile=popen(command.c_str(),POPEN_BINARY_READ_TYPE);\n \n@@ -133,7 +133,8 @@ ffmpeg_mptr::seek_to(int frame)\n \t\t\t}\n \t\t\t// Close the unneeded pipein\n \t\t\tclose(p[1]);\n-\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n+\t\t\tstring time = strprintf(\"00:00:00.%d\",frame);\n+\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-ss\", time.c_str(), \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n \t\t\t// We should never reach here unless the exec failed\n \t\t\tcerr<<\"Unable to open pipe to ffmpeg\"<<endl;\n \t\t\t_exit(1);\n", "fix_pattern": "<pattern>: if the API call to execlp is made with command-line parameters that do not include a timestamp, enhance the command by adding a timestamp parameter. This adjustment can optimize the ffmpeg processing by enabling seeking to a specific frame in the media input, thereby potentially reducing the processing time."}
{"number": 669, "change": "@@ -197,8 +197,7 @@ ImageDescriptor::ImageDescriptor(int _Width, int _Height, uint32 *_Pixels)\n \tVScale = 1.0;\n \tUScale = 1.0;\n \tSize = _Width * _Height * 4;\n-\tPixels = new uint32[_Width * _Height];\n-\tmemcpy(Pixels, _Pixels, Size);\n+\tPixels = _Pixels;\n \tFormat = RGBA8;\n \tMipMapCount = 0;\n }\n", "fix_pattern": "<pattern>: if pixels are being copied from a source array to a newly allocated array using memcpy, and it is safe to assign the source directly to the target, replace the memcpy with direct assignment, which avoids unnecessary memory operations."}
{"number": 677, "change": "@@ -57,7 +57,7 @@ AccountOpResult AccountMgr::CreateAccount(std::string username, std::string pass\n \n     if(!loginDatabase.PExecute(\"INSERT INTO account(username,sha_pass_hash,joindate) VALUES('%s',SHA1(CONCAT('%s',':','%s')),NOW())\", username.c_str(), username.c_str(), password.c_str()))\n         return AOR_DB_INTERNAL_ERROR;                       // unexpected error\n-    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM account, realmlist WHERE account.id NOT IN (SELECT acctid FROM realmcharacters)\");\n+    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist,account LEFT JOIN realmcharacters ON acctid=account.id WHERE acctid IS NULL\");\n \n     return AOR_OK;                                          // everything's fine\n }\n", "fix_pattern": "<pattern>: when performing an insert operation that selects from multiple tables, refactor the query to use a LEFT JOIN to prevent inserting duplicate records, optimizing the execution by filtering on NULL values instead of using a subquery."}
{"number": 679, "change": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n \n+#include \"cstring.h\"\n #include \"uni2name.h\"\n #include \"unicode/unifilt.h\"\n #include \"unicode/uchar.h\"\n@@ -93,7 +94,7 @@ void UnicodeNameTransliterator::handleTransliterate(Replaceable& text, UTransPos\n         UChar32 c = text.char32At(cursor);\n         if ((len=u_charName(c, U_UNICODE_CHAR_NAME, buf, sizeof(buf), &status)) <= 0 || U_FAILURE(status)) {\n             sprintf(buf, \"U+%04lX\", c);\n-            len = strlen(buf);\n+            len = uprv_strlen(buf);\n         }\n \n         str.truncate(1);\n", "fix_pattern": "<pattern>: if the standard strlen function is used for measuring string length, replace it with uprv_strlen from the ICU library to leverage potential performance optimizations specific to Unicode string handling."}
{"number": 680, "change": "@@ -449,7 +449,7 @@ static UChar * convertFromUTF8(UChar *outBuf, int32_t outBufCapacity, int32_t *o\n     UChar *dest = outBuf;\n     u_strFromUTF8(dest, outBufCapacity, outputLength, in, inLength, status);\n     if (*status == U_BUFFER_OVERFLOW_ERROR) {\n-        dest = static_cast<UChar *>(malloc(*outputLength * sizeof(UChar)));\n+        dest = static_cast<UChar *>(uprv_malloc(*outputLength * sizeof(UChar)));\n         if (dest == NULL) {\n             *status = U_MEMORY_ALLOCATION_ERROR;\n             return NULL;\n", "fix_pattern": "<pattern>: if a call to malloc from the standard C library is replaced with uprv_malloc from the ICU library, then it likely indicates an improvement in memory management specific to the ICU library, which is optimized for performance and compatibility within its ecosystem."}
{"number": 684, "change": "@@ -120,7 +120,8 @@ void KLoadFileMetaDataThread::run()\n             if (variants.isEmpty()) {\n                 // the file has not been indexed, query the meta data\n                 // directly from the file\n-                KFileMetaInfo metaInfo(urls.first());\n+                const QString path = urls.first().toLocalFile();\n+                KFileMetaInfo metaInfo(path, QString(), KFileMetaInfo::Fastest);\n                 const QHash<QString, KFileMetaInfoItem> metaInfoItems = metaInfo.items();\n                 foreach (const KFileMetaInfoItem& metaInfoItem, metaInfoItems) {\n                     const QString uriString = metaInfoItem.name();\n", "fix_pattern": "<pattern>: if the KFileMetaInfo constructor is called with a QString that can be directly converted to a local file path, replace it with a direct call to toLocalFile() to improve performance by avoiding unnecessary conversions and using the Fastest option for efficiency."}
{"number": 689, "change": "@@ -37,10 +37,10 @@\n StyledCalendarDelegate::StyledCalendarDelegate(QObject *parent)\n     : QStyledItemDelegate(parent)\n {\n-    mPixmap.insert(Enable, KIconLoader().loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n-    mPixmap.insert(RemoveFromList, KIconLoader().loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n-    mPixmap.insert(AddToList, KIconLoader().loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n-    mPixmap.insert(Quickview, KIconLoader().loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n+    mPixmap.insert(Enable, KIconLoader::global()->loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n+    mPixmap.insert(RemoveFromList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n+    mPixmap.insert(AddToList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n+    mPixmap.insert(Quickview, KIconLoader::global()->loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n }\n \n StyledCalendarDelegate::~StyledCalendarDelegate()\n", "fix_pattern": "<pattern>: if multiple calls are made to `KIconLoader().loadIcon`, replace them with calls to `KIconLoader::global()->loadIcon` to utilize a singleton instance of `KIconLoader`, which reduces overhead from repeated constructions of the `KIconLoader` object."}
{"number": 693, "change": "@@ -433,8 +433,9 @@ void ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n         }\n     }\n     if (useModSeq > 0) {\n-        // FIXME: issue the corresponding command\n-        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n+        QMap<QByteArray, quint64> fetchModifier;\n+        fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n+        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n     } else {\n         flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n     }\n", "fix_pattern": "<pattern>: if a command fetch is being issued without optional modifiers that could improve behavior or performance, refactor the fetch call to include and pass additional parameters like `fetchModifier` for enhanced functionality."}
{"number": 695, "change": "@@ -417,8 +417,7 @@ static json_object *deep_copy (plugin_ctx_t *p, json_object *dir,\n     }\n     return dcpy;\n stall:\n-    if (dcpy)\n-        free (dcpy);\n+    json_object_put (dcpy);\n     return NULL;\n }\n \n", "fix_pattern": "<pattern>: if dynamically allocated memory is managed by a library's specific API, replace the standard `free` call with the appropriate library function to avoid potential memory management issues and improve performance by taking advantage of the library's optimized handling for its objects."}
{"number": 701, "change": "@@ -338,7 +338,7 @@ void showSplashScreen()\n #if defined(Q_OS_UNIX)\n void setupDpi()\n {\n-    if (qgetenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\").isEmpty())\n+    if (qEnvironmentVariableIsEmpty(\"QT_AUTO_SCREEN_SCALE_FACTOR\"))\n         qputenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\", \"1\");\n }\n #endif  // Q_OS_UNIX\n", "fix_pattern": "<pattern>: if a call is made to qgetenv followed by an isEmpty check, replace it with a direct call to qEnvironmentVariableIsEmpty for better performance, as it avoids the overhead of creating a QString object."}
{"number": 702, "change": "@@ -28,6 +28,8 @@\n \n #include \"apicontroller.h\"\n \n+#include <algorithm>\n+\n #include <QJsonDocument>\n #include <QMetaObject>\n \n@@ -69,9 +71,13 @@ const DataMap &APIController::data() const\n \n void APIController::checkParams(const QSet<QString> &requiredParams) const\n {\n-    const QSet<QString> params {this->params().keys().toSet()};\n+    const bool hasAllRequiredParams = std::all_of(requiredParams.cbegin(), requiredParams.cend()\n+        , [this](const QString &requiredParam)\n+    {\n+        return params().contains(requiredParam);\n+    });\n \n-    if (!params.contains(requiredParams))\n+    if (!hasAllRequiredParams)\n         throw APIError(APIErrorType::BadParams);\n }\n \n", "fix_pattern": "<pattern>: if an operation involves checking for the presence of multiple required parameters in a set, replace the set construction and lookup with a more efficient method using std::all_of to directly check each required parameter's existence, minimizing temporary object creation and improving readability."}
{"number": 706, "change": "@@ -29,8 +29,8 @@ void MPI_Sys::sample(Sys &in)\n \n         for (int i = 0; i < in.num(); i++)\n         {\n-            MPI_Allreduce(MPI_IN_PLACE, in.precMu.at(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n-            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.at(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precMu.col(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.col(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n         }\n         bcast_sum_cov_norm();\n     }\n", "fix_pattern": "<pattern>: if an API method retrieves a row or column of data using a potentially less efficient method (like at(index)), replace it with a direct method call that accesses the data column directly (like col(index)) for improved performance, specifically in the context of matrix or array data structures."}
{"number": 707, "change": "@@ -189,7 +189,7 @@ TcpSocketImplTest::Test1_HandleRecv (Ptr<Socket> sock)\n   {\n     rxBytes1 += sz;\n     rxPayload = new uint8_t[sz];\n-    memcpy (rxPayload, p->PeekData(), sz);\n+    p->CopyData (rxPayload, sz);\n   }\n   else\n   {\n", "fix_pattern": "<pattern>: if memcpy is used to transfer data from a packet buffer, replace it with the packet's optimized CopyData method to leverage potential internal optimizations and reduce overhead."}
{"number": 709, "change": "@@ -1718,7 +1718,7 @@ static void lCompose(\n #if 1 // def __COMPOSITE_PROFILE\n     double nsendrecvloc = (senddispl[nrank] + recvdispl[nrank])*sizeof(uint16_t);\n     double nsendrecv;\n-    MPI_Allreduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, comm);\n+    MPI_Reduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, master, comm);\n     const double t1 = MPI_Wtime();\n     if (rank == master)\n     {\n", "fix_pattern": "<pattern>: if the communication pattern allows for reduction to a specific root instead of broadcasting to all processes, replace MPI_Allreduce with MPI_Reduce to optimize performance by reducing the amount of data communicated across the network."}
{"number": 711, "change": "@@ -1533,7 +1533,7 @@ void NJClient::mixInChannel(bool muted, float vol, float pan, DecodeState *chan,\n     // advance the queue\n     chan->decode_samplesout += needed/chan->decode_codec->GetNumChannels();\n     chan->decode_codec->m_samples_used -= needed+chan->dump_samples;\n-    memcpy(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n+    memmove(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n     chan->dump_samples=0;\n   }\n   else\n", "fix_pattern": "<pattern>: if overlapping memory regions are detected, replace memcpy with memmove to ensure correct behavior since memmove handles such cases properly."}
{"number": 714, "change": "@@ -62,7 +62,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             std::vector<bool> vMatch(nTx, false);\n             std::vector<uint256> vMatchTxid1;\n             for (unsigned int j=0; j<nTx; j++) {\n-                bool fInclude = (rand() & ((1 << (att/2)) - 1)) == 0;\n+                bool fInclude = insecure_randbits(att / 2) == 0;\n                 vMatch[j] = fInclude;\n                 if (fInclude)\n                     vMatchTxid1.push_back(vTxid[j]);\n", "fix_pattern": "<pattern>: if a call to the standard `rand()` function is replaced with a custom API that is optimized for generating random bits, use `insecure_randbits(...)` for potentially better performance and more control over the randomness generation."}
{"number": 715, "change": "@@ -14,7 +14,7 @@ int _tflitetensor_name(ErlNifEnv *env, TfLiteTensor * tensor, ERL_NIF_TERM &out)\n     unsigned char * ptr;\n     size_t len = strlen(tensor_name_str);\n     if ((ptr = enif_make_new_binary(env, len, &tensor_name)) != nullptr) {\n-        strncpy((char *)ptr, tensor_name_str, len);\n+        memcpy((char *)ptr, tensor_name_str, len);\n         out = tensor_name;\n         return true;\n     } else {\n", "fix_pattern": "<pattern>: if strncpy is used to copy a fixed length of bytes, replace it with memcpy for better performance since strncpy performs null-termination checks and padding that are unnecessary in this context."}
{"number": 716, "change": "@@ -201,7 +201,7 @@ namespace erlang {\n             unsigned char *ptr;\n             size_t len = strlen(c_string);\n             if ((ptr = enif_make_new_binary(env, len, &binary_str)) != nullptr) {\n-                strcpy((char *) ptr, c_string);\n+                memcpy((char *)ptr, c_string, len);\n                 return binary_str;\n             } else {\n                 fprintf(stderr, \"internal error: cannot allocate memory for binary string\\r\\n\");\n", "fix_pattern": "<pattern>: if a function is copying a string and the length of the source is known, replace strcpy with memcpy for potentially better performance and to handle non-null-terminated data safely."}
{"number": 720, "change": "@@ -64,10 +64,10 @@ bool FormFieldRestrictedValues::safeForIntegerCoercion(FormRestrictions restrict\n     foreach(SelectRestriction sr, restrictions.first) {\n         if(sr.variable == name) {\n             foreach(QString value, sr.values) {\n-                // TODO: Would prefer to use a more general regex (e.g. allowing zero-padded values or leading/trailing\n-                // spaces) but these values cannot currently be injected back correctly (even though we could coerce\n+                // TODO: Would prefer to use a more general regex (e.g. allowing leading/trailing spaces)\n+                // but these values cannot currently be injected back correctly (even though we could coerce\n                 // and solve them), so we are quite conservative for now.\n-                if(!value.contains(QRegExp(\"^(0|([1-9][0-9]*))$\"))) {\n+                if(!value.contains(QRegExp(\"^([0-9]*)$\"))) {\n                     return false;\n                 }\n             }\n", "fix_pattern": "<pattern>: if a more specific regex pattern that constrains valid input is replaced with a more general pattern that allows additional cases (like leading/trailing spaces), ensure that it doesn't introduce significant performance overhead when the regex engine has to handle a broader set of matches; specific patterns can lead to faster evaluations and less backtracking compared to general patterns."}
{"number": 722, "change": "@@ -130,7 +130,7 @@ static Node *convertToCLinkFormat( xmlDocPtr doc, xmlNodePtr cur, int depth ) {\n \n Node *Parser::parse(const std::string &data, size_t len) {\n   // First, parse the XML memory buffer ito a DOM object\n-  xmlDocPtr doc = xmlParseMemory( data.c_str(), (int)len );\n+  xmlDocPtr doc = xmlReadMemory(data.c_str(), (int)len, NULL, NULL, XML_PARSE_NOERROR);\n   if ( doc == NULL ) {\n     LogWarn(\"XML file parsing failed:\");\n     LogWarn(\"%s\", data.c_str());\n", "fix_pattern": "<pattern>: if an API method for parsing XML is replaced with a different, more configurable method that allows for options (like error handling), then switch from a basic parsing function to a more flexible one (xmlReadMemory) that can handle additional parameters for better error control and customization."}
{"number": 725, "change": "@@ -270,8 +270,9 @@ extern \"C\" void report_segfault(int signo)\n \n extern \"C\" void report_abort(int signo)\n {\n-    log(CRITICAL, \"Aborted\");\n-    log(NOTICE, \"Please report this bug to \" PACKAGE_BUGREPORT);\n+    //Don't print to the log in signal handler, as that involves memory allocation.\n+    fprintf(stderr, \"Aborted\");\n+    fprintf(stderr, \"Please report this bug to \" PACKAGE_BUGREPORT);\n \n #if !defined(HAVE_SIGACTION)\n     signal(signo, SIG_DFL);\n", "fix_pattern": "<pattern>: if logging functions are called within a signal handler, switch to using fprintf to stderr to avoid memory allocation issues associated with the logging API"}
{"number": 737, "change": "@@ -431,7 +431,12 @@ void xyUpdate(){\n \n \tgvFPS = 1000 / fLength;\n \t//Wait for FPS limit\n-\tif(gvMaxFPS != 0) SDL_Delay((1000 / gvMaxFPS) - (fLength / gvMaxFPS));\n+\t//\t\tdelay\t4294967290\tunsigned int\n+\tUint32 current_time = (static_cast<Uint32>(fLength) / gvMaxFPS);\n+\tUint32 max_delay = (1000 / gvMaxFPS);\n+\tif (current_time < max_delay) {\n+\t\tif (gvMaxFPS != 0) SDL_Delay(max_delay - current_time);\n+\t}\n \t/*while(fLength < 1000 / gvMaxFPS){\n \t\tgvTicks = SDL_GetTicks();\n \t\tfLength = gvTicks - gvTickLast;\n", "fix_pattern": "<pattern>: if a delay is calculated and potentially called multiple times based on frame length and maximum FPS, first compute `current_time` and `max_delay` once, then perform the delay only if needed, thus avoiding redundant calculations and improving performance."}
{"number": 742, "change": "@@ -5,7 +5,7 @@\n         Quesa interactive renderer TriMesh implementation.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2004, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1443,11 +1443,12 @@ IRGeometry_Submit_TriMesh(TQ3ViewObject\t\t\t\ttheView,\n \tTQ3Status\t\t\tqd3dStatus;\n \tCQ3ObjectRef\t\tcachedGeom;\n \tCLockTriMeshData\tlocker;\n+\tbool\t\t\t\twasValid;\n \n \t\n \t// Look for a cached optimized geometry.\n-\tcachedGeom = GetCachedOptimizedTriMesh( theGeom );\n-\tif ( ! cachedGeom.isvalid() )\n+\tcachedGeom = GetCachedOptimizedTriMesh( theGeom, wasValid );\n+\tif ( ! wasValid )\n \t{\n \t\t// no cached data or stale cache\n \t\tcachedGeom = CQ3ObjectRef( Q3TriMesh_Optimize( theGeom ) );\n", "fix_pattern": "<pattern>: if an API method is upgraded to provide additional information about the validity of the cached geometry directly via an output parameter (instead of checking validity through a separate method call), leverage the new API method to potentially reduce the overhead of multiple validations and improve performance."}
{"number": 743, "change": "@@ -5,7 +5,7 @@\n         Implementation of Quesa API calls.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2008, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1277,14 +1277,14 @@ OpaqueTQ3Object::GetElement ( TQ3ElementType theType, void *theData )\n \n \t// If we've actually been passed a set, use it directly\n \tif ( Q3_OBJECT_IS_CLASS ( this, E3Set ) )\n-\t\treturn Q3Set_Get ( (TQ3SetObject) this, theType, theData ) ;\n+\t\treturn ( (E3Set*) this )->Get ( theType, theData ) ;\n \t\n \t// otherwise use the set within the instance data\n \t\n \tif ( theSet == NULL )\n \t\treturn kQ3Failure ;\n \t\n-\treturn Q3Set_Get ( theSet, theType, (void*)theData ) ;\n+\treturn ( (E3Set*) theSet )->Get ( theType, theData ) ;\n \t}\n \n \n", "fix_pattern": "<pattern>: if the original Q3Set_Get function is being replaced with the more efficient E3Set::Get member function call, then refactor the API usage to utilize the class method for potentially better performance and cleaner code."}
{"number": 748, "change": "@@ -73,11 +73,11 @@ QgsMapCanvasContextMenu::QgsMapCanvasContextMenu( QgsMapCanvas* canvas, const QP\n   }\n   else if ( mPickResult.feature.isValid() && mPickResult.layer )\n   {\n-    QgsCoordinateTransform ct( mPickResult.layer->crs(), mCanvas->mapSettings().destinationCrs() );\n+    const QgsCoordinateTransform* ct = QgsCoordinateTransformCache::instance()->transform( mPickResult.layer->crs().authid(), mCanvas->mapSettings().destinationCrs().authid() );\n     mRubberBand = new QgsGeometryRubberBand( mCanvas, mPickResult.feature.geometry()->type() );\n     mRubberBand->setIconType( QgsGeometryRubberBand::ICON_NONE );\n     mRubberBand->setOutlineWidth( 2 );\n-    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( ct ) );\n+    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( *ct ) );\n     if ( mPickResult.layer->type() == QgsMapLayer::RedliningLayer )\n     {\n       addAction( QIcon( \":/images/themes/default/mActionToggleEditing.svg\" ), tr( \"Edit\" ), this, SLOT( editFeature() ) );\n", "fix_pattern": "<pattern>: if a new instance of QgsCoordinateTransform is created every time a transformation is needed, utilize a caching mechanism (QgsCoordinateTransformCache) to retrieve pre-constructed coordinate transforms based on CRS identifiers to improve performance."}
{"number": 757, "change": "@@ -692,9 +692,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    continue;\n \t}\n \n-\t// This should be safe here.\n-\tchar* theData = NULL;\n-\ttheData = (char*) alloca(blobsize+4);\n+\tchar* theData = (char*) malloc(blobsize+4);\n \n \tif (theData == 0) {\n \t    std::cerr << \"Could Not allocate memory for data!\" << std::endl;\n@@ -709,6 +707,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    // bad writes to the offline-data files.\n \t    std::cerr << \"Bad read of data for \" << rawfilename\n \t\t<< \" expected: \" << blobsize << \" got:\" << bytesRead << std::endl;\n+\t    if (theData) free(theData);\n \t    continue;\n \t}\n \n@@ -717,6 +716,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t// This is the first index into the DataQueue.\n \tBlob datablob(blobsize, theData);\n \tDataQueues::enqueuePerformanceData(datablob);\n+\tif (theData) free(theData);\n \n     } // while\n \n", "fix_pattern": "<pattern>: if the code is using alloca to allocate memory on the stack, replace it with malloc for heap allocation, ensuring proper memory management, including freeing the allocated memory later in the code."}
{"number": 763, "change": "@@ -10,7 +10,6 @@\n #include \"archive.hh\"\n #include \"callback.hh\"\n #include \"remote-store.hh\"\n-#include \"sync.hh\"\n \n #include <nlohmann/json.hpp>\n #include <regex>\n@@ -1103,7 +1102,7 @@ std::map<StorePath, StorePath> copyPaths(\n     };\n \n     // total is accessed by each copy, which are each handled in separate threads\n-    Sync<uint64_t> _total = 0;\n+    std::atomic<uint64_t> total = 0;\n \n     for (auto & missingPath : sortedMissing) {\n         auto info = srcStore.queryPathInfo(missingPath);\n@@ -1126,9 +1125,8 @@ std::map<StorePath, StorePath> copyPaths(\n             PushActivity pact(act.id);\n \n             LambdaSink progressSink([&](std::string_view data) {\n-                auto total(_total.lock());\n-                *total += data.size();\n-                act.progress(*total, info->narSize);\n+                total += data.size();\n+                act.progress(total, info->narSize);\n             });\n             TeeSink tee { sink, progressSink };\n \n", "fix_pattern": "<pattern>: if a synchronization mechanism like a lock is used on an integer to ensure thread safety, replace it with an atomic variable to improve performance by avoiding the overhead of locking while still ensuring thread safety with atomic operations."}
{"number": 765, "change": "@@ -1040,7 +1040,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n         loadLibrary(id_lib);\n \n     uint nPage = 0;\n-    if(!QFileInfo(url).exists())\n+    if(!QFileInfo::exists(url))\n     {\n         if(strings.count()>0)\n         {\n@@ -1099,7 +1099,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n             ts.device()->write(file.readAll());\n         }\n     }\n-    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo(url).exists())\n+    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo::exists(url))\n     {\n         QString id=strings[2];\n         fb2mobi fb;\n", "fix_pattern": "<pattern>: if QFileInfo is used to check the existence of a file multiple times in conditions, replace the object creation with a static call to QFileInfo::exists to optimize performance by avoiding unnecessary instantiation."}
{"number": 767, "change": "@@ -295,7 +295,7 @@ static bool CreateMainSurface(int w, int h)\n \n \tDEBUG(misc, 0) (\"sdl: using mode %dx%d\", w, h);\n \n-\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_HWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n+\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_SWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n \tif(newscreen == NULL)\n \t\treturn false;\n \n", "fix_pattern": "<pattern>: if the SDL_SetVideoMode function is called with SDL_HWSURFACE, replace it with SDL_SWSURFACE for potentially better performance in environments that may not fully support hardware surfaces, thus avoiding unnecessary overhead associated with hardware surface rendering."}
{"number": 768, "change": "@@ -240,7 +240,7 @@ void DeleteWindow(Window *w)\n \n \tv = --_last_window;\n \tcount = (byte*)v - (byte*)w;\n-\tmemcpy(w, w + 1, count);\n+\tmemmove(w, w + 1, count);\n }\n \n Window *FindWindowById(WindowClass cls, WindowNumber number)\n", "fix_pattern": "<pattern>: if a source and destination overlap in a memory copy operation, replace memcpy with memmove to prevent undefined behavior and ensure correctness. memmove handles overlapping regions correctly, which can lead to performance improvements in cases where safety is a concern."}
{"number": 772, "change": "@@ -571,16 +571,11 @@ struct Converter_std_map\n         PyObject* value;\n         Py_ssize_t pos = 0;\n \n-        Py_INCREF(pyobj);\n-\n         while (PyDict_Next(pyobj, &pos, &key, &value)) {\n             result.insert(typename StdMap::value_type(\n                     Converter<typename StdMap::key_type>::toCpp(key),\n                     Converter<typename StdMap::mapped_type>::toCpp(value)));\n         }\n-\n-        Py_DECREF(pyobj);\n-\n         return result;\n     }\n };\n", "fix_pattern": "<pattern>: if Py_INCREF and Py_DECREF are called consecutively on the same PyObject, remove the redundant calls to improve performance as they balance each other out without any net change."}
{"number": 778, "change": "@@ -119,16 +119,12 @@ QList<QCameraDevice> QGstreamerVideoDevices::videoDevices() const\n \n void QGstreamerVideoDevices::addDevice(GstDevice *device)\n {\n-    gchar *type = gst_device_get_device_class(device);\n-    gst_object_ref(device);\n-    if (!strcmp(type, \"Video/Source\") || !strcmp(type, \"Source/Video\")) {\n+    if (gst_device_has_classes(device, \"Video/Source\")) {\n+        gst_object_ref(device);\n         m_videoSources.push_back({device, QByteArray::number(m_idGenerator)});\n         videoInputsChanged();\n         m_idGenerator++;\n-    } else {\n-        gst_object_unref(device);\n     }\n-    g_free(type);\n }\n \n void QGstreamerVideoDevices::removeDevice(GstDevice *device)\n", "fix_pattern": "<pattern>: if a comparison of device classes is performed using strcmp, replace it with the more efficient function gst_device_has_classes to avoid the overhead of string comparison and potentially streamline the logic flow for checking device classes."}
{"number": 780, "change": "@@ -55,7 +55,7 @@ std::string raw_text(const GumboNode * node)\n     else if( child_node->type == GUMBO_NODE_ELEMENT )\n     {\n       inner_text.push_back(' ');\n-      inner_text.append(text(child_node));\n+      inner_text.append(raw_text(child_node));\n     }\n   }\n \n", "fix_pattern": "<pattern>: if an API method used for text extraction (text) is replaced by a more efficient method (raw_text), it indicates that the new method offers better performance or fewer overheads in the context of extracting text from nodes in the HTML parsing process."}
{"number": 790, "change": "@@ -8,8 +8,11 @@ namespace pink {\n \n PinkEpoll::PinkEpoll()\n {\n-  epfd_ = epoll_create(1024); \n-  fcntl(epfd_, F_SETFD, fcntl(epfd_, F_GETFD) | FD_CLOEXEC);\n+  epfd_ = epoll_create1(EPOLL_CLOEXEC);\n+  if (epfd_ < 0) {\n+    log_err(\"epoll create fail\")\n+    exit(1)\n+  }\n   events_ = (struct epoll_event *)malloc(sizeof(struct epoll_event) * PINK_MAX_CLIENTS);\n   if (!events_) {\n     log_err(\"init epoll_event error\");\n", "fix_pattern": "<pattern>: if epoll_create is used without the additional flags for better security and atomicity, replace it with epoll_create1 with appropriate flags, which provides a more robust and safer method for creating epoll instances."}
{"number": 795, "change": "@@ -2585,8 +2585,12 @@ QString QWebPage::userAgentForUrl(const QUrl& url) const\n \n     QChar securityStrength(QLatin1Char('N'));\n #if !defined(QT_NO_OPENSSL)\n-    if (QSslSocket::supportsSsl())\n-        securityStrength = QLatin1Char('U');\n+    // we could check QSslSocket::supportsSsl() here, but this makes\n+    // OpenSSL, certificates etc being loaded in all cases were QWebPage\n+    // is used. This loading is not needed for non-https.\n+    securityStrength = QLatin1Char('U');\n+    // this may lead to a false positive: We indicate SSL since it is\n+    // compiled in even though supportsSsl() might return false\n #endif\n     ua = ua.arg(securityStrength);\n \n", "fix_pattern": "<pattern>: if a method call (like QSslSocket::supportsSsl()) introduces unnecessary overhead for performance-sensitive paths, remove that call and set a derived security property (like securityStrength) directly, while noting the implications of potential false positives."}
{"number": 799, "change": "@@ -846,8 +846,7 @@ QScriptEnginePrivate::~QScriptEnginePrivate()\n \n QScriptValue QScriptEnginePrivate::scriptValueFromVariant(const QVariant &v)\n {\n-    Q_Q(QScriptEngine);\n-    QScriptValue result = q->create(v.userType(), v.data());\n+    QScriptValue result = create(v.userType(), v.data());\n     Q_ASSERT(result.isValid());\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is called on a pointer context (Q_Q), and the method being called is already a member function of the same context (i.e., `create`), remove the pointer context and call the method directly to improve code readability and possibly reduce overhead."}
{"number": 803, "change": "@@ -54,15 +54,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made sequentially with the same file descriptor, cache the result of F_GETFD and only call F_SETFD if the flags need to be changed, thus avoiding unnecessary system calls for improved performance."}
{"number": 806, "change": "@@ -797,10 +797,10 @@ bool RageDisplay_OGL::BeginFrame()\n \n void RageDisplay_OGL::EndFrame()\n {\n-\t// Give up the CPU to the OpenGL host if it wants it; in any case, make\n-\t// sure the frame is done. This helps graphics smoothness a lot by\n-\t// making sure we get the most out of each frame.\n-\tglFinish();\n+\t// glFlush(), not glFinish(); NVIDIA_GLX's glFinish()'s behavior is\n+\t// nowhere near performance-friendly and uses unholy amounts of CPU for\n+\t// Gog-knows-what.\n+\tglFlush();\n \n \twind->SwapBuffers();\n \tProcessStatsOnFlip();\n", "fix_pattern": "<pattern>: if glFinish() is used as a means to sync with the GPU, replace it with glFlush() to improve performance, as glFinish() can introduce significant CPU overhead that affects rendering efficiency."}
{"number": 807, "change": "@@ -236,8 +236,6 @@ void GLC_Texture::glcBindTexture(void)\n \t\tglLoadTexture();\n \t}\n \tglBindTexture(GL_TEXTURE_2D, m_GlTextureID);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n \n QImage GLC_Texture::loadFromFile(const QString& fileName)\n", "fix_pattern": "<pattern>: if multiple OpenGL texture parameter settings with the same target are called consecutively, consolidate them into a single function call to improve performance and reduce state changes."}
{"number": 810, "change": "@@ -101,16 +101,14 @@ Painter& Painter::draw(const std::string& str, bool difference)\n     if (str.empty())\n         return *this;\n \n+    if (!cairo_has_current_point(m_cr.get()))\n+        return *this;\n+\n     double x, y;\n-    cairo_font_extents_t fe;\n     cairo_text_extents_t textext;\n \n-    cairo_font_extents(m_cr.get(), &fe);\n     cairo_text_extents(m_cr.get(), str.c_str(), &textext);\n \n-    if (!cairo_has_current_point(m_cr.get()))\n-        return *this;\n-\n     AutoSaveRestore sr(*this);\n \n     cairo_get_current_point(m_cr.get(), &x, &y);\n", "fix_pattern": "<pattern>: if a function call to cairo_font_extents is unnecessary and does not affect the outcome of subsequent logic (like checking cairo_has_current_point), remove it to improve performance by avoiding redundant API calls."}
{"number": 812, "change": "@@ -112,7 +112,7 @@ namespace\n         DBusActivateTimeout()\n         {\n             bool ok;\n-            mTimeoutMs = qgetenv(\"QTXDG_DBUSACTIVATE_TIMEOUT\").toInt(&ok);\n+            mTimeoutMs = qEnvironmentVariableIntValue(\"QTXDG_DBUSACTIVATE_TIMEOUT\", &ok);\n             if (!ok)\n                 mTimeoutMs = 1500;\n         }\n", "fix_pattern": "<pattern>: if using qgetenv() followed by toInt() to retrieve an environment variable as an integer, replace it with qEnvironmentVariableIntValue() to reduce overhead and improve performance by directly reading and converting in one call."}
{"number": 835, "change": "@@ -77,7 +77,7 @@ bool BasicIndexingJob::index()\n     }\n \n     if (fileInfo.isDir()) {\n-        doc.addBoolTerm(QLatin1String(\"folder\"), QLatin1String(\"T\"));\n+        doc.addBoolTerm(QStringLiteral(\"Tfolder\"));\n \n         // This is an optimization for folders. They do not need to go through\n         // file indexing, so there are no indexers for folders\n", "fix_pattern": "<pattern>: if a QLatin1String is constructed using a string literal for values that will not change, replace it with QStringLiteral for potentially better performance and memory usage."}
{"number": 840, "change": "@@ -527,8 +527,7 @@ vdraw_send_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)\n \t\treturn TCL_ERROR;\n \t}\n \n-\tsprintf(solid_name, RT_VDRW_PREFIX);\n-\tstrncat(solid_name, dgop->dgo_currVHead->vdc_name, RT_VDRW_MAXNAME);\n+\tsnprintf(solid_name, RT_VDRW_MAXNAME+RT_VDRW_PREFIX_LEN+1, \"%s%s\", RT_VDRW_PREFIX, dgop->dgo_currVHead->vdc_name);\n \tif ((dp = db_lookup(dgop->dgo_wdbp->dbip, solid_name, LOOKUP_QUIET)) == DIR_NULL) {\n \t\treal_flag = 0;\n \t} else {\n", "fix_pattern": "<pattern>: if a string is being constructed using sprintf followed by strncat, replace it with snprintf to streamline the operation and enhance performance by eliminating the need for multiple function calls and potential buffer overflow risks."}
{"number": 844, "change": "@@ -1,4 +1,4 @@\n-/* $Id: clearspd.c,v 1.2 2000/04/10 16:25:15 brianp Exp $ */\n+/* $Id: clearspd.c,v 1.3 2000/12/07 21:50:39 brianp Exp $ */\n \n /*\n  * Simple GLUT program to measure glClear() and glutSwapBuffers() speed.\n@@ -7,6 +7,9 @@\n \n /*\n  * $Log: clearspd.c,v $\n+ * Revision 1.3  2000/12/07 21:50:39  brianp\n+ * call glFinish() before getting t1 time\n+ *\n  * Revision 1.2  2000/04/10 16:25:15  brianp\n  * fixed visual selection and reporting results\n  *\n@@ -71,14 +74,15 @@ static void Display( void )\n          glClear( BufferMask );\n          glutSwapBuffers();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n    }\n    else {\n       t0 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       for (i=0;i<Loops;i++) {\n          glClear( BufferMask );\n-         glFlush();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       glutSwapBuffers();\n    }\n", "fix_pattern": "<pattern>: if performance-critical sections involve OpenGL rendering APIs, replace glFlush() with glFinish() when synchronization is needed to ensure all previous rendering commands are complete before proceeding, as glFinish() blocks until all commands are executed, leading to more predictable timing in performance measurements."}
{"number": 853, "change": "@@ -504,11 +504,6 @@ Future<std::shared_ptr<parquet::arrow::FileReader>> ParquetFileFormat::GetReader\n                                                          default_fragment_scan_options));\n   auto properties = MakeReaderProperties(*this, parquet_scan_options.get(), source.path(),\n                                          source.filesystem(), options->pool);\n-  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n-  // TODO(ARROW-12259): workaround since we have Future<(move-only type)>\n-  auto reader_fut = parquet::ParquetFileReader::OpenAsync(\n-      std::move(input), std::move(properties), metadata);\n-  auto path = source.path();\n   auto self = checked_pointer_cast<const ParquetFileFormat>(shared_from_this());\n \n   return source.OpenAsync().Then(\n", "fix_pattern": "<pattern>: NA"}
{"number": 864, "change": "@@ -254,8 +254,14 @@ namespace pos{\n       static void get(T* &data, std::string path, PixelConfigKey key){\n \n       unsigned int theKey=key.key();\n-    \n-      assert(theKey<=getConfig().size());\n+      \n+      static PixelConfigList configList=getConfig();\n+\n+      if (theKey>configList.size()){\n+\tconfigList=getConfig();\n+      }\n+\n+      assert(theKey<=configList.size());\n     \n       unsigned int last=path.find_last_of(\"/\");\n       assert(last!=std::string::npos);\n@@ -278,7 +284,7 @@ namespace pos{\n //      std::cout << \"[pos::PixelConfigFile::get()]\\t\\t\\tExtracted ext :\"<<ext <<std::endl;\n     \n       unsigned int version;\n-      int err=getConfig()[theKey].find(dir,version);   \n+      int err=configList[theKey].find(dir,version);   \n       // assert(err==0);\n       if(0!=err) \n \t{\n", "fix_pattern": "<pattern>: if a configuration list is retrieved multiple times within a function call, store it in a static variable to avoid redundant calls to getConfig() and improve performance, ensuring to check for size validity."}
{"number": 865, "change": "@@ -729,11 +729,8 @@ int QString16::localeAwareCompare(QStringView16 str1, QStringView16 str2)\n    }\n \n #if defined(Q_OS_WIN32)\n-   QString16 tmp1(str1.begin(), str1.end());\n-   QString16 tmp2(str2.begin(), str2.end());\n-\n-   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)tmp1.constData(), tmp1.size_storage(),\n-        (wchar_t *)tmp2.constData(), tmp2.size_storage());\n+   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)str1.charData(), str1.size_storage(),\n+        (wchar_t *)str2.charData(), str2.size_storage());\n \n    switch (retval) {\n       case CSTR_LESS_THAN:\n", "fix_pattern": "<pattern>: if temporary QString16 objects are created to convert QString data before passing it to an API, replace them with direct access to the char data and size functions of QString to eliminate unnecessary object creation and improve performance."}
{"number": 885, "change": "@@ -41,7 +41,18 @@ void GLIndexBuf::bind()\n \n void GLIndexBuf::bind_as_ssbo(uint binding)\n {\n-  bind();\n+  if (ibo_id_ == 0 || data_ != nullptr) {\n+    /* Calling `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo_id_)` changes the index buffer\n+     * of the currently bound VAO.\n+     *\n+     * In the OpenGL backend, the VAO state persists even after `GLVertArray::update_bindings`\n+     * is called.\n+     *\n+     * NOTE: For safety, we could call `glBindVertexArray(0)` right after drawing a `GPUBatch`.\n+     * However, for performance reasons, we have chosen not to do so. */\n+    glBindVertexArray(0);\n+    bind();\n+  }\n   BLI_assert(ibo_id_ != 0);\n   glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, ibo_id_);\n }\n", "fix_pattern": "<pattern>: if a binding operation is performed via glBindVertexArray before a specific condition (like checking if ibo_id_ is 0 or data_ is not null), it is refactored to avoid unnecessary binding calls, which can lead to performance improvements by preventing redundant state changes in the OpenGL pipeline."}
{"number": 886, "change": "@@ -1583,7 +1583,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\tglClear(GL_COLOR_BUFFER_BIT);\n \t\tif (sdl.opengl.pixel_buffer_object) {\n \t\t\tglUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, sdl.draw.width,\n \t\t\t                sdl.draw.height, GL_BGRA_EXT,\n \t\t\t                GL_UNSIGNED_INT_8_8_8_8_REV, 0);\n@@ -1591,7 +1590,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\t} else if (changedLines) {\n \t\t\tint y = 0;\n \t\t\tsize_t index = 0;\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\twhile (y < sdl.draw.height) {\n \t\t\t\tif (!(index & 1)) {\n \t\t\t\t\ty += changedLines[index];\n", "fix_pattern": "<pattern>: if glBindTexture is called multiple times with the same parameters consecutively, remove redundant calls to improve performance."}
{"number": 898, "change": "@@ -905,17 +905,18 @@ void CVideoPlayer::OpenDefaultStreams(bool reset)\n     CloseStream(m_CurrentVideo, true);\n \n   // open audio stream\n-  if(m_PlayerOptions.video_only)\n-    streams.clear();\n-  else\n-    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n   valid   = false;\n-\n-  for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+  if(!m_PlayerOptions.video_only)\n   {\n-    if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n-      valid = true;\n+    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n+\n+    for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+    {\n+      if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n+        valid = true;\n+    }\n   }\n+\n   if(!valid)\n     CloseStream(m_CurrentAudio, true);\n \n", "fix_pattern": "<pattern>: if a conditionally clearing a collection (streams.clear()) is followed by a reassignment based on the same condition, restructure the code to eliminate the unnecessary clearing operation and directly assign when conditions allow, improving performance by reducing redundant operations."}
{"number": 904, "change": "@@ -180,7 +180,16 @@ void DrawCallPerfBenchmark::destroyBenchmark()\n \n void DrawCallPerfBenchmark::drawBenchmark()\n {\n-    glClear(GL_COLOR_BUFFER_BIT);\n+    // This workaround fixes a huge queue of graphics commands accumulating on the GL\n+    // back-end. The GL back-end doesn't have a proper NULL device at the moment.\n+    // TODO(jmadill): Remove this when/if we ever get a proper OpenGL NULL device.\n+    const auto &eglParams = GetParam().eglParameters;\n+    if (eglParams.deviceType != EGL_PLATFORM_ANGLE_DEVICE_TYPE_NULL_ANGLE ||\n+        (eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE &&\n+         eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE))\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT);\n+    }\n \n     const auto &params = GetParam();\n \n", "fix_pattern": "<pattern>: if calling glClear is causing performance issues due to excessive accumulation of graphics commands in the GL back-end, conditionally execute glClear based on the type of EGL device to mitigate the performance impact."}
{"number": 905, "change": "@@ -938,7 +938,10 @@ egl::ConfigSet Renderer11::generateConfigs()\n         // Additional high bit depth formats added in D3D 10.0\n         // https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064.aspx\n         colorBufferFormats.push_back(GL_RGBA16F);\n-        colorBufferFormats.push_back(GL_RGB10_A2);\n+\n+        // TODO(geofflang): Re-enable once client code has been updated to filter configs better and\n+        // not use RGB10A2 accidentally when requesting RGBA8\n+        // colorBufferFormats.push_back(GL_RGB10_A2);\n     }\n \n     if (!mPresentPathFastEnabled)\n", "fix_pattern": "<pattern>: if a call to push back an invalid or unoptimized color format is detected, comment it out until client code can be updated to filter configurations properly, thus avoiding unnecessary overhead or potential misconfigurations."}
{"number": 907, "change": "@@ -75,7 +75,12 @@ std::vector<uint32_t> preprocessSpirv(\n \t}\n \n \tstd::vector<uint32_t> optimized;\n-\topt.Run(code.data(), code.size(), &optimized);\n+\tspvtools::OptimizerOptions options;\n+#if defined(NDEBUG)\n+\toptions.set_run_validator(false);\n+#endif\n+\n+\topt.Run(code.data(), code.size(), &optimized, options);\n \n \tif(false)\n \t{\n", "fix_pattern": "<pattern>: if an API method call is made without options that may control performance-sensitive features, enhance the call by utilizing options like disabling unnecessary validation in release builds to improve performance."}
{"number": 912, "change": "@@ -94,7 +94,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\t    node_type != abnode_type::equipment)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_server_dn(pnode, dn, sizeof(dn));\n-\t\tstrcat(dn, \"/cn=Microsoft Private MDB\");\n+\t\tHX_strlcat(dn, \"/cn=Microsoft Private MDB\", arsizeof(dn));\n \t\tif (NULL == pbuff) {\n \t\t\tpprop->value.pv = ndr_stack_alloc(\n \t\t\t\tNDR_STACK_OUT, strlen(dn) + 1);\n@@ -471,7 +471,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\tif (node_type != abnode_type::person)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_user_info(pnode, USER_STORE_PATH, dn, GX_ARRAY_SIZE(dn));\n-\t\tstrcat(dn, \"/config/portrait.jpg\");\n+\t\tHX_strlcat(dn, \"/config/portrait.jpg\", arsizeof(dn));\n \t\tif (!common_util_load_file(dn, &pprop->value.bin))\n \t\t\treturn ecNotFound;\n \t\treturn ecSuccess;\n", "fix_pattern": "<pattern>: if using strcat to concatenate strings where buffer size is a concern, replace it with a safer alternative such as HX_strlcat which takes the size of the destination buffer to prevent buffer overflows."}
{"number": 922, "change": "@@ -460,7 +460,7 @@ float DeserializeFloat(const char *str, const char **outEndStr)\n \t\treturn FLOAT_NAN;\n \tif (MATH_NEXT_WORD_IS(str, \"NaN(\"))\n \t{\n-\t\tMATH_SKIP_WORD(str, \"NaN(\");\n+\t\tstr += strlen(\"NaN(\"); //MATH_SKIP_WORD(str, \"NaN(\");\n \t\tu32 x;\n \t\tint n = sscanf(str, \"%X\", (unsigned int *)&x);\n \t\tif (n != 1)\n", "fix_pattern": "<pattern>: if a specific word is skipped using a function that likely incurs function call overhead, replace the function call with a direct manipulation of the pointer to improve performance by reducing function call overhead."}
{"number": 927, "change": "@@ -28,9 +28,10 @@ void QKlamptDisplay::initializeGL(){\n }\n \n void QKlamptDisplay::paintGL(){\n-  glClear(0);\n   if(gui != NULL)\n     gui->SendGLRender();\n+  else\n+    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n }\n \n \n", "fix_pattern": "<pattern>: if glClear is called without any bitmask during a certain condition (like a clear operation being redundant), then ensure it explicitly clears the color and depth buffers only when necessary by combining the relevant bitmasks in one call."}
{"number": 931, "change": "@@ -1096,7 +1096,7 @@ grLfbWriteRegion( GrBuffer_t dst_buffer,\n       }\n \n       glBindTexture(GL_TEXTURE_2D, default_texture);\n-      glTexImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n+      glTexSubImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n \n       set_copy_shader();\n \n", "fix_pattern": "<pattern>: if a texture is already created and needs to be updated, replace glTexImage2D with glTexSubImage2D to improve performance by avoiding the overhead of reallocating texture memory."}
{"number": 939, "change": "@@ -240,8 +240,8 @@ ConVar filesystem_unbuffered_io( \"filesystem_unbuffered_io\", \"1\", 0, \"\" );\n #define UseUnbufferedIO() true\n #endif\n \n-ConVar filesystem_native( \"filesystem_native\", \"1\", 0, \"Use native FS or STDIO\" );\n-ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", IsX360() ? \"64\" : \"16\", 0, \"\" );\n+ConVar filesystem_native( \"filesystem_native\", \"0\", 0, \"Use native FS or STDIO\" );\n+ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", \"64\", 0, \"\" );\n ConVar filesystem_report_buffered_io( \"filesystem_report_buffered_io\", \"0\" );\n \n //-----------------------------------------------------------------------------\n@@ -417,7 +417,7 @@ FILE *CFileSystem_Stdio::FS_fopen( const char *filenameT, const char *options, u\n \n \tCBaseFileSystem::FixUpPath ( filenameT, filename, sizeof( filename ) );\n \n-#ifdef _WIN32\n+#if defined(_WIN32) && 0\n \tif ( CWin32ReadOnlyFile::CanOpen( filename, options ) )\n \t{\n \t\tpFile = CWin32ReadOnlyFile::FS_fopen( filename, options, size );\n", "fix_pattern": "<pattern>: if there are changes to configuration variables (ConVar) that affect performance, ensure the values are optimized for the specific platform or environment, such as setting \"filesystem_native\" to \"0\" to potentially favor the STDIO approach over native file system access for performance reasons."}
{"number": 942, "change": "@@ -136,19 +136,14 @@ void OpenGL::setupContext()\n \tstate.boundTextures.clear();\n \tstate.boundTextures.resize(maxTextureUnits, 0);\n \n-\tGLenum curgltextureunit;\n-\tglGetIntegerv(GL_ACTIVE_TEXTURE, (GLint *) &curgltextureunit);\n-\n-\tstate.curTextureUnit = (int) curgltextureunit - GL_TEXTURE0;\n-\n-\t// Retrieve currently bound textures for each texture unit.\n \tfor (int i = 0; i < (int) state.boundTextures.size(); i++)\n \t{\n \t\tglActiveTexture(GL_TEXTURE0 + i);\n-\t\tglGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint *) &state.boundTextures[i]);\n+\t\tglBindTexture(GL_TEXTURE_2D, 0);\n \t}\n \n-\tglActiveTexture(curgltextureunit);\n+\tglActiveTexture(GL_TEXTURE0);\n+\tstate.curTextureUnit = 0;\n \n \tcreateDefaultTexture();\n \n", "fix_pattern": "<pattern>: if OpenGL calls are used to query the current active texture unit and bound textures, replace the querying logic with direct calls to set the texture state, minimizing API calls and redundant state retrievals."}
{"number": 945, "change": "@@ -66,7 +66,7 @@ namespace mapnik\n         if (!png_ptr) return;\n \n         // switch on optimization only if supported\n-#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)\n+#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_MMX_CODE_SUPPORTED)\n         png_uint_32 mask, flags;\n \n         flags = png_get_asm_flags(png_ptr);\n", "fix_pattern": "<pattern>: if an API directive checks for specific library versions or features, ensure that the check is using the correct defined macros for the intended assembly optimizations (i.e., update from PNG_ASSEMBLER_CODE_SUPPORTED to PNG_MMX_CODE_SUPPORTED)."}
{"number": 949, "change": "@@ -155,10 +155,13 @@ inline BOOL Win32uiHostGlue::DynamicApplicationInit(const TCHAR *cmd, const TCHA\n     TCHAR err_buf[256];\n     // It's critical Python is loaded *and initialized* before we load win32ui\n     // as just loading win32ui will cause it to call into Python.\n-    const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n-    for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n-        wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n-        hModCore = LoadLibrary(fname);\n+    hModCore = GetModuleHandle(py_dll);  // Check if Python is already loaded\n+    if (hModCore == NULL) {\n+        const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n+        for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n+            wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n+            hModCore = LoadLibrary(fname);\n+        }\n     }\n     if (hModCore == NULL) {\n         wsprintf(err_buf, _T(\"The application can not locate %s (%d)\\n\"), py_dll, GetLastError());\n", "fix_pattern": "<pattern>: if loading a library using LoadLibrary, first check if the library is already loaded using GetModuleHandle to avoid unnecessary calls to LoadLibrary, which can improve performance by reducing the overhead of multiple library load attempts."}
{"number": 965, "change": "@@ -349,9 +349,16 @@ void SDLRenderTarget::blitRenderTarget(RenderTarget *s, int x, int y, int w, int\n \tSDLRenderTarget *src = dynamic_cast<SDLRenderTarget *>(s);\n \tassert(src);\n \n-\t// TODO: evil use of internal SDL api\n+\tSDL_Renderer *renderer = SDL_CreateSoftwareRenderer(surface);\n+\tassert(renderer);\n+\tSDL_Texture *tex = SDL_CreateTextureFromSurface(renderer, src->surface);\n+\tassert(tex);\n+\n \tSDL_Rect r; r.x = x; r.y = y; r.w = w; r.h = h;\n-\tSDL_SoftStretch(src->surface, 0, surface, &r);\n+\tSDL_RenderCopy(renderer, tex, nullptr, &r);\n+\n+\tSDL_DestroyTexture(tex);\n+\tSDL_DestroyRenderer(renderer);\n }\n \n RenderTarget *SDLBackend::newRenderTarget(unsigned int w, unsigned int h) {\n", "fix_pattern": "<pattern>: if the SDL_SoftStretch function is used for scaling surfaces, refactor the code to create a software renderer, create a texture from the source surface, and use SDL_RenderCopy to perform the copy operation, as it can provide better performance through hardware acceleration or more optimized rendering."}
{"number": 971, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if string join operations are performed with regular char or QString, replace them with QLatin1Char for improved performance when dealing with Latin-1 encoded strings, as it avoids unnecessary conversions."}
{"number": 973, "change": "@@ -1,5 +1,6 @@\n #include \"TextureGL.h\"\n #include <cassert>\n+#include \"utils.h\"\n \n namespace Graphics {\n \n@@ -109,16 +110,18 @@ TextureGL::~TextureGL()\n void TextureGL::Update(const void *data, const vector2f &dataSize, ImageFormat format, ImageType type)\n {\n \tglEnable(m_target);\n+\tglBindTexture(m_target, m_texture);\n \n \tswitch (m_target) {\n \t\tcase GL_TEXTURE_2D:\n-\t\t\tglTexImage2D(m_target, 0, GLTextureFormat(GetDescriptor().format), dataSize.x, dataSize.y, 0, GLImageFormat(format), GLImageType(type), data);\n+\t\t\tglTexSubImage2D(m_target, 0, 0, 0, dataSize.x, dataSize.y, GLImageFormat(format), GLImageType(type), data);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tassert(0);\n \t}\n \n+\tglBindTexture(m_target, 0);\n \tglDisable(m_target);\n }\n \n", "fix_pattern": "<pattern>: if a texture is being created or updated with glTexImage2D, replace it with glBindTexture and glTexSubImage2D to optimize the texture upload process, as the latter can update an existing texture without recreating it, reducing overhead and potentially improving performance."}
{"number": 974, "change": "@@ -32,14 +32,16 @@ bool header_match( const string & env_var_name,\n                    const string & header_name,\n                    const HTTPRequest & saved_response )\n {\n+    const char * const env_value = getenv( env_var_name.c_str() );\n+\n     /* case 1: neither header exists (OK) */\n-    if ( (not getenv( env_var_name.c_str() )) and (not saved_response.has_header( header_name )) ) {\n+    if ( (not env_value) and (not saved_response.has_header( header_name )) ) {\n         return true;\n     }\n \n     /* case 2: headers both exist (OK if values match) */\n-    if ( getenv( env_var_name.c_str() ) and saved_response.has_header( header_name ) ) {\n-        return saved_response.get_header_value( header_name ) == string( getenv( env_var_name.c_str() ) );\n+    if ( env_value and saved_response.has_header( header_name ) ) {\n+        return saved_response.get_header_value( header_name ) == string( env_value );\n     }\n \n     /* case 3: one exists but the other doesn't (failure) */\n", "fix_pattern": "<pattern>: if getenv() is called multiple times with the same variable, store the result in a local variable to avoid redundant calls and improve performance."}
{"number": 977, "change": "@@ -760,10 +760,8 @@ static QRegion scaleRegion(const QRegion &region, qreal factor)\n {\n     if (region.isEmpty() || qFuzzyCompare(factor, qreal(1)))\n         return region;\n-    if (region.rectCount() == 1)\n-        return QRegion(scaleRect(QRectF(region.boundingRect()), factor).toRect());\n     QRegion result;\n-    foreach (const QRect &rect, region.rects())\n+    for (const QRect &rect : region)\n         result += QRectF(QPointF(rect.topLeft()) * factor, QSizeF(rect.size() * factor)).toRect();\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is checking the count of rectangles in a QRegion and then iterating through them, replace the check and foreach with a range-based for loop directly on the QRegion to enhance readability and potentially improve performance by avoiding an extra function call."}
{"number": 979, "change": "@@ -1078,11 +1078,12 @@ void QIcon::addFile(const QString &fileName, const QSize &size, Mode mode, State\n     if (!d) {\n \n         QFileInfo info(fileName);\n-        QIconEngine *engine = iconEngineFromSuffix(fileName, info.suffix());\n+        QString suffix = info.suffix();\n #ifndef QT_NO_MIMETYPE\n-        if (!engine)\n-            engine = iconEngineFromSuffix(fileName, QMimeDatabase().mimeTypeForFile(info).preferredSuffix());\n+        if (suffix.isEmpty())\n+            suffix = QMimeDatabase().mimeTypeForFile(info).preferredSuffix(); // determination from contents\n #endif // !QT_NO_MIMETYPE\n+        QIconEngine *engine = iconEngineFromSuffix(fileName, suffix);\n         d = new QIconPrivate(engine ? engine : new QPixmapIconEngine);\n     }\n \n", "fix_pattern": "<pattern>: if an icon engine is retrieved using a suffix derived from the filename that depends on file info, first check if the suffix is empty and retrieve it conditionally only once, storing it in a variable to avoid redundant calls for the same operation."}
{"number": 984, "change": "@@ -859,9 +859,9 @@ void GLPaintContour::finalize_geometry()\n \n     if (!this->contour_indices.empty()) {\n         glsafe(::glGenBuffers(1, &this->m_contour_EBO_id));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, this->m_contour_EBO_id));\n-        glsafe(::glBufferData(GL_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, 0));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this->m_contour_EBO_id));\n+        glsafe(::glBufferData(GL_ELEMENT_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));\n         this->contour_indices.clear();\n     }\n }\n", "fix_pattern": "<pattern>: if the OpenGL API is being used to bind and buffer a data array, ensure to use the appropriate buffer type that matches the intended usage; replace `GL_ARRAY_BUFFER` with `GL_ELEMENT_ARRAY_BUFFER` when dealing with element indices to enhance performance and correctness."}
{"number": 985, "change": "@@ -172,7 +172,7 @@ QEvdevTouchScreenHandler::QEvdevTouchScreenHandler(const QString &specification,\n {\n     setObjectName(QLatin1String(\"Evdev Touch Handler\"));\n \n-    bool printDeviceInfo = qgetenv(\"QT_QPA_EVDEV_DEBUG\").toInt();\n+    bool printDeviceInfo = qEnvironmentVariableIntValue(\"QT_QPA_EVDEV_DEBUG\");\n \n     // only the first device argument is used for now\n     QString spec = QString::fromLocal8Bit(qgetenv(\"QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS\"));\n", "fix_pattern": "<pattern>: replace the combination of qgetenv and QString::toInt to read an environment variable as an integer directly using qEnvironmentVariableIntValue for improved performance."}
{"number": 986, "change": "@@ -461,7 +461,7 @@ void QPainterPrivate::draw_helper(const QPainterPath &originalPath, DrawOperatio\n     p.drawPath(originalPath);\n \n #ifndef QT_NO_DEBUG\n-    static bool do_fallback_overlay = qgetenv(\"QT_PAINT_FALLBACK_OVERLAY\").size() > 0;\n+    static bool do_fallback_overlay = !qEnvironmentVariableIsEmpty(\"QT_PAINT_FALLBACK_OVERLAY\");\n     if (do_fallback_overlay) {\n         QImage block(8, 8, QImage::Format_ARGB32_Premultiplied);\n         QPainter pt(&block);\n", "fix_pattern": "<pattern>: if checking for the existence of an environment variable using qgetenv and then calling size() on its return is done, replace it with directly using qEnvironmentVariableIsEmpty for better performance and clarity."}
{"number": 988, "change": "@@ -562,9 +562,9 @@ void DapEngine::updateItem(const QString &iname)\n void DapEngine::reexpandItems(const QSet<QString> &inames)\n {\n     QSet<QString> expandedInames = inames;\n-    const QList<QString> &watcherNames = watchHandler()->watcherNames().keys();\n-    for (const QString &inames : watcherNames)\n-        expandedInames.insert(watchHandler()->watcherName(inames));\n+    const auto &watcherNames = watchHandler()->watcherNames();\n+    for (auto it = watcherNames.begin(); it != watcherNames.end(); ++it)\n+        expandedInames.insert(watchHandler()->watcherName(it.key()));\n \n     QList<QString> inamesVector = expandedInames.values();\n     inamesVector.sort();\n", "fix_pattern": "<pattern>: if a QList's keys() method is used to retrieve keys, then refactor the code to operate directly on the QList to reduce unnecessary intermediate copies and improve iterator access for performance."}
{"number": 992, "change": "@@ -184,7 +184,7 @@ void QXcbConnection::xi2Select(xcb_window_t window)\n     mask.mask_len = sizeof(bitMask);\n     mask.mask = xiBitMask;\n     // Enable each touchscreen\n-    foreach (XInput2DeviceData *dev, m_touchDevices.values()) {\n+    foreach (XInput2DeviceData *dev, m_touchDevices) {\n         mask.deviceid = dev->xiDeviceInfo->deviceid;\n         Status result = XISelectEvents(xDisplay, window, &mask, 1);\n         // If we have XInput >= 2.2 and successfully enable a touchscreen, then\n", "fix_pattern": "<pattern>: if accessing elements of a QList via the values() method results in performance overhead, replace it by directly iterating over the QList to avoid unnecessary copying of the underlying data."}
{"number": 995, "change": "@@ -2289,21 +2289,12 @@ TClass *TClass::GetBaseClass(const char *classname)\n \n    if (!fClassInfo) return 0;\n \n-   TObjLink *lnk = GetListOfBases() ? fBase->FirstLink() : 0;\n+   // Make sure we deal with possible aliases, we could also have normalized\n+   // the name.\n+   TClass *search = TClass::GetClass(classname);\n \n-   // otherwise look at inheritance tree\n-   while (lnk) {\n-      TClass     *c, *c1;\n-      TBaseClass *base = (TBaseClass*) lnk->GetObject();\n-      c = base->GetClassPointer();\n-      if (c) {\n-         if (strcmp(c->GetName(), classname) == 0) return c;\n-         c1 = c->GetBaseClass(classname);\n-         if (c1) return c1;\n-      }\n-      lnk = lnk->Next();\n-   }\n-   return 0;\n+   if (search) return GetBaseClass(search);\n+   else return 0;\n }\n \n //______________________________________________________________________________\n", "fix_pattern": "<pattern>: instead of iterating through a linked list to find class information, use a direct lookup via TClass::GetClass for better performance and efficiency in accessing the desired base class."}
{"number": 998, "change": "@@ -116,11 +116,7 @@ void Mesh::render() const {\n void Mesh::render(uint32_t mode, int count, int offset) const {\n     glBindVertexArray(_vao);\n     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _ibo);\n-\n     glDrawElements(mode, count, GL_UNSIGNED_SHORT, reinterpret_cast<void *>(offset));\n-\n-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n-    glBindVertexArray(0);\n }\n \n void Mesh::computeAABB() {\n", "fix_pattern": "<pattern>: if glBindBuffer and glBindVertexArray are being called with the argument 0, it may indicate an intention to unbind or reset state. This can be simplified or optimized by considering whether these calls are necessary, or if their logic can be handled more effectively within the rendering pipeline. If performance is a priority, it may be beneficial to review and restrict unnecessary state changes."}
{"number": 1002, "change": "@@ -32,14 +32,7 @@ GlobeGPS::GlobeGPS(QWidget* parent) : MarbleWidget(parent), loadedDives(0), edit\n \tQStringList list = mtm.mapThemeIds();\n \tQString  subsurfaceDataPath;\n \tQDir marble;\n-\tbool foundGoogleMap = false;\n-\tQ_FOREACH(const QString& theme, list){\n-\t\tif (theme == \"earth/googlesat/googlesat.dgml\"){\n-\t\t\tfoundGoogleMap = true;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tif (!foundGoogleMap) {\n+\tif (!list.contains(\"earth/googlesat/googlesat.dgml\")) {\n \t\tsubsurfaceDataPath = getSubsurfaceDataPath(\"marbledata\");\n \t\tif (subsurfaceDataPath != \"\") {\n \t\t\tMarbleDirs::setMarbleDataPath(subsurfaceDataPath);\n", "fix_pattern": "<pattern>: if a loop is used to check for the existence of an item in a QStringList, replace it with the QStringList::contains() method for better performance and readability."}
{"number": 1007, "change": "@@ -178,12 +178,12 @@ DatabaseCommand_Resolve::fullTextResolve( DatabaseImpl* lib )\n     QList< QPair<int, float> > trackPairs = lib->search( m_query );\n     QList< QPair<int, float> > albumPairs = lib->searchAlbum( m_query, 20 );\n \n+    TomahawkSqlQuery query = lib->newquery();\n+    query.prepare( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = ?\" );\n+\n     foreach ( const scorepair_t& albumPair, albumPairs )\n     {\n-        TomahawkSqlQuery query = lib->newquery();\n-\n-        QString sql = QString( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = %1\" ).arg( albumPair.first );\n-        query.prepare( sql );\n+        query.bindValue( 0, albumPair.first );\n         query.exec();\n \n         QList<Tomahawk::album_ptr> albumList;\n", "fix_pattern": "<pattern>: if constructing a SQL query with QString::arg is used for value substitution, replace it with parameterized queries using bindValue to improve performance and security (prevent SQL injection)."}
{"number": 1010, "change": "@@ -89,9 +89,6 @@ void vw_Start2DMode(GLdouble zNear, GLdouble zFar)\n  */\n void vw_End2DMode()\n {\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglPopMatrix();\n-\n \t// we don't switch to 0 unit, in 2D mode only 0 unit should be used\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n@@ -100,6 +97,7 @@ void vw_End2DMode()\n \tglPopMatrix();\n \n \tglMatrixMode(GL_MODELVIEW);\n+\tglPopMatrix();\n \n \tglPopAttrib();\n }\n", "fix_pattern": "<pattern>: if glMatrixMode(GL_MODELVIEW) is called immediately before glPopMatrix(), it can be removed to avoid unnecessary state changes, as glPopMatrix() resets the matrix without needing to set the mode first."}
{"number": 1018, "change": "@@ -602,12 +602,20 @@ void Database::PurgeExpiredInstances()\n \t\treturn;\n \t}\n \n+\tstd::vector<std::string> instance_ids;\n \tfor (auto row = results.begin(); row != results.end(); ++row) {\n-\t\tquery = StringFormat(\"DELETE FROM instance_list WHERE id=%u\", atoi(row[0]));\n-\t\tQueryDatabase(query);\n-\n-\t\tDeleteInstance(atoi(row[0]));\n+\t\tinstance_ids.emplace_back(row[0]);\n \t}\n+\n+\tstd::string imploded_instance_ids = implode(\",\", instance_ids);\n+\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list_player WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM respawn_times WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM spawn_condition_values WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"UPDATE character_corpses SET is_buried = 1, instance_id = 0 WHERE instance_id IN ({})\", imploded_instance_ids));\n+\n+\t\n }\n \n void Database::SetInstanceDuration(uint16 instance_id, uint32 new_duration)\n", "fix_pattern": "<pattern>: if multiple deletes and an update are performed on the same instance_id, consolidate them into a single query for better performance by using a formatted string that incorporates instance_ids as a comma-separated list. This reduces the number of separate database calls and can improve overall efficiency."}
{"number": 1020, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified before being passed to the JS_DefinePropertyById function, and to simplify the call, set the configurable attribute directly on the descriptor and pass it without individually specifying getter, setter, and attributes. This reduces the overhead of constructing the property descriptor with multiple parameters and improves readability."}
{"number": 1021, "change": "@@ -23,6 +23,7 @@\n #include <map>\n #include <tuple>\n #include <chrono>\n+#include <cassert>\n \n #include \"async_handler.h\"\n #include \"cache.h\"\n@@ -274,13 +275,13 @@ namespace {\n \t\t\treturn LoadDummyBitmap<T>(s.directory, f);\n \t\t}\n \n+#ifndef NDEBUG\n \t\t// Test if the file was requested asynchronously before.\n \t\t// If not the file can't be expected to exist -> bug.\n-\t\tFileRequestAsync* request = AsyncHandler::RequestFile(s.directory, f);\n-\t\tif (!request->IsReady()) {\n-\t\t\tOutput::Debug(\"BUG: File Not Requested: %s/%s\", s.directory, f.c_str());\n-\t\t\treturn BitmapRef();\n-\t\t}\n+\t\t// This test is expensive and turned off in release builds.\n+\t\tauto* req = AsyncHandler::RequestFile(s.directory, f);\n+\t\tassert(req != nullptr && req->IsReady());\n+#endif\n \n \t\tBitmapRef ret = LoadBitmap(s.directory, f, transparent, Bitmap::Flag_ReadOnly | (\n \t\t\t\t\t\t\t\t\t\t T == Material::Chipset? Bitmap::Flag_Chipset:\n", "fix_pattern": "<pattern>: if a check for readiness is performed during debugging, replace the runtime check with an assert to avoid performance overhead in release builds while still ensuring the condition is verified during development."}
{"number": 1028, "change": "@@ -118,7 +118,8 @@ KFileItemModelRolesUpdater::KFileItemModelRolesUpdater(KFileItemModel *model, QO\n     m_directoryContentsCounter = new KDirectoryContentsCounter(m_model, this);\n     connect(m_directoryContentsCounter, &KDirectoryContentsCounter::result, this, &KFileItemModelRolesUpdater::slotDirectoryContentsCountReceived);\n \n-    const auto plugins = KPluginMetaData::findPlugins(QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\"));\n+    const QString pluginNamespace = QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\");\n+    const auto plugins = KPluginMetaData::findPlugins(pluginNamespace, {}, KPluginMetaData::AllowEmptyMetaData);\n     for (const KPluginMetaData &data : plugins) {\n         auto instance = QPluginLoader(data.fileName()).instance();\n         auto plugin = qobject_cast<KOverlayIconPlugin *>(instance);\n", "fix_pattern": "<pattern>: if constructing a namespace string for KPluginMetaData::findPlugins involves repeated string manipulations, refactor the creation of the string into a separate variable to enhance readability and performance, while ensuring consistent use of the API."}
{"number": 1040, "change": "@@ -30,7 +30,7 @@\n #include \"vtkIdTypeArray.h\"\n #include \"vtkObjectFactory.h\"\n \n-vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18\");\n+vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18.6.1\");\n vtkStandardNewMacro(vtkDataSetAttributes);\n \n //--------------------------------------------------------------------------\n@@ -1470,16 +1470,16 @@ void vtkDataSetAttributes::CopyData(vtkDataSetAttributes::FieldList& list,\n                                     vtkDataSetAttributes* fromDSA,\n                                     int idx, vtkIdType fromId, vtkIdType toId)\n {\n-  vtkDataArray *fromDA;\n-  vtkDataArray *toDA;\n+  vtkAbstractArray *fromDA;\n+  vtkAbstractArray *toDA;\n   \n   int i;\n   for (i=0; i < list.NumberOfFields; i++)\n     {\n     if ( list.FieldIndices[i] >= 0 )\n       {\n-      toDA = this->GetArray(list.FieldIndices[i]);\n-      fromDA = fromDSA->GetArray(list.DSAIndices[idx][i]);\n+      toDA = this->GetAbstractArray(list.FieldIndices[i]);\n+      fromDA = fromDSA->GetAbstractArray(list.DSAIndices[idx][i]);\n       this->CopyTuple(fromDA, toDA, fromId, toId);\n       }\n     }\n", "fix_pattern": "<pattern>: if a specific API (vtkDataArray*) is replaced by a more generalized one (vtkAbstractArray*), it may indicate a move to more versatile or polymorphic data handling, which can improve performance through more efficient memory management and reduced type-checking overhead when handling datasets."}
{"number": 1041, "change": "@@ -57,7 +57,7 @@ extern \"C\" vtkglX::__GLXextFuncPtr glXGetProcAddressARB(const GLubyte *);\n // GLU is currently not linked in VTK.  We do not support it here.\n #define GLU_SUPPORTED   0\n \n-vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.29\");\n+vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.30\");\n vtkStandardNewMacro(vtkOpenGLExtensionManager);\n \n namespace vtkgl\n@@ -180,7 +180,7 @@ int vtkOpenGLExtensionManager::ExtensionSupported(const char *name)\n   // Workaround for a bug on renderer string=\"Quadro4 900 XGL/AGP/SSE2\"\n   // version string=\"1.5.8 NVIDIA 96.43.01\" or \"1.5.6 NVIDIA 87.56\"\n   // The driver reports it supports 1.5 but the 1.4 core promoted extension\n-  // GL_EXT_blend_func_separate is implemented in software.\n+  // GL_EXT_blend_func_separate is implemented in software (poor performance).\n   // All the NV2x chipsets are probably affected. NV2x chipsets are used\n   // in GeForce4 and Quadro4.\n   // It will make this method return false with \"GL_VERSION_1_4\" and true\n", "fix_pattern": "<pattern>: If a revision macro is updated to reflect a change in performance characteristics (from version 1.29 to 1.30) and includes a comment indicating poor performance related to a feature, then document the revision change alongside a performance note to provide context for why the change is notable."}
{"number": 1043, "change": "@@ -90,7 +90,7 @@ namespace rwe\n \n         glGenerateMipmap(GL_TEXTURE_2D);\n \n-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if the texture magnification filter could impact performance, and a performance improvement can be achieved by changing the filter from GL_LINEAR to GL_NEAREST, then update the parameter to use GL_NEAREST for better performance in scenarios where linear filtering is not necessary."}
{"number": 1052, "change": "@@ -64,7 +64,7 @@\n #define VTK_PV_ANIMATION_GROUP \"animateable\"\n \n vtkStandardNewMacro(vtkPVAnimationManager);\n-vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.47\");\n+vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.48\");\n vtkCxxSetObjectMacro(vtkPVAnimationManager, HorizantalParent, vtkKWWidget);\n vtkCxxSetObjectMacro(vtkPVAnimationManager, VerticalParent, vtkKWWidget);\n //*****************************************************************************\n@@ -205,7 +205,6 @@ void vtkPVAnimationManager::Create(vtkKWApplication* app, const char* )\n \n   this->ActiveTrackSelector->SetParent(\n     this->VAnimationInterface->GetSelectorFrame());\n-  this->ActiveTrackSelector->SetAnimationManager(this);\n   this->ActiveTrackSelector->Create(app, \"-relief flat\");\n   this->Script(\"pack %s -anchor n -side top -expand t -fill both\",\n     this->ActiveTrackSelector->GetWidgetName());\n", "fix_pattern": "<pattern>: if the vtkCxxRevisionMacro is updated to a new version number without changing any other logic or behavior in the code, correctly increment the versioning to reflect updates, indicating a potential change in functionality or fixes within the class."}
{"number": 1056, "change": "@@ -50,22 +50,15 @@ void dirvec_sort(struct dirvec *dv)\n \n struct directory *dirvec_find(const struct dirvec *dv, const char *path)\n {\n-\tchar *base;\n \tint i;\n-\tstruct directory *ret = NULL;\n-\n-\tbase = g_path_get_basename(path);\n \n \tdb_lock();\n \tfor (i = dv->nr; --i >= 0; )\n-\t\tif (!strcmp(directory_get_name(dv->base[i]), base)) {\n-\t\t\tret = dv->base[i];\n-\t\t\tbreak;\n-\t\t}\n+\t\tif (!strcmp(directory_get_name(dv->base[i]), path))\n+\t\t\treturn dv->base[i];\n \tdb_unlock();\n \n-\tg_free(base);\n-\treturn ret;\n+\treturn NULL;\n }\n \n int dirvec_delete(struct dirvec *dv, struct directory *del)\n", "fix_pattern": "<pattern>: if a temporary variable is used to hold the result of g_path_get_basename(path) only for comparison purposes, remove the unnecessary allocation of the temporary variable and directly compare the directory name with the original path instead."}
{"number": 1064, "change": "@@ -58,15 +58,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made to get and set file descriptor flags, combine them to reduce the number of system calls and avoid unnecessary operations when the new flags are equal to the old flags."}
{"number": 1078, "change": "@@ -45,11 +45,18 @@ ErrorOr<int> serenity_main(Main::Arguments arguments)\n \n     TRY(Core::System::pledge(\"stdio rpath exec\"));\n \n-    Vector<String> exec_environment_strings;\n     Vector<StringView> exec_environment;\n-    if (auto* term = getenv(\"TERM\")) {\n-        exec_environment_strings.append(String::formatted(\"TERM={}\", term));\n-        exec_environment.append(exec_environment_strings.last());\n+    for (size_t i = 0; environ[i]; ++i) {\n+        StringView env_view { environ[i] };\n+        auto maybe_needle = env_view.find('=');\n+\n+        if (!maybe_needle.has_value())\n+            continue;\n+\n+        if (env_view.substring_view(0, maybe_needle.value()) != \"TERM\"sv)\n+            continue;\n+\n+        exec_environment.append(env_view);\n     }\n \n     Vector<String> exec_arguments;\n", "fix_pattern": "<pattern>: if the code checks for a specific environment variable using getenv, refactor it to iterate through the `environ` array for potentially better performance and to handle cases where the environment variable may not exist or might be defined differently. This avoids the overhead of a string formatting operation unless necessary."}
{"number": 1082, "change": "@@ -76,7 +76,7 @@ static int newPage(const char *name, int level, int width, int height, int count\n \tglTexImage2D(GL_TEXTURE_2D, level, wz_texture_compression, width, height, 0,\n \t             GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n \tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n+\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if a texture filtering parameter is set using glTexParameteri(), consider switching from GL_LINEAR_MIPMAP_LINEAR to GL_NEAREST_MIPMAP_LINEAR to potentially improve performance due to the reduced computational cost of nearest filtering compared to linear filtering."}
{"number": 1085, "change": "@@ -600,11 +600,8 @@ int iV_DrawFormattedText(const char* String, UDWORD x, UDWORD y, UDWORD Width, U\n \n void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotation)\n {\n-\tGLint matrix_mode = 0;\n-\n \tpie_SetTexturePage(TEXPAGE_FONT);\n \n-\tglGetIntegerv(GL_MATRIX_MODE, &matrix_mode);\n \tglMatrixMode(GL_TEXTURE);\n \tglPushMatrix();\n \tglLoadIdentity();\n@@ -630,7 +627,7 @@ void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotati\n \tglPopMatrix();\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n-\tglMatrixMode(matrix_mode);\n+\tglMatrixMode(GL_MODELVIEW);\n \n \t// Reset the current model view matrix\n \tglLoadIdentity();\n", "fix_pattern": "<pattern>: if retrieving the current matrix mode using glGetIntegerv(GL_MATRIX_MODE, ...) is unnecessary and a specific mode (e.g., GL_MODELVIEW) can be assumed or set directly, replace the call with a direct glMatrixMode(...) invocation to improve performance."}
{"number": 1086, "change": "@@ -76,15 +76,14 @@ void GlLine::draw(float,Camera *) {\n \t\tglLineStipple(factor,pattern);\n \t\tglEnable(GL_LINE_STIPPLE);\n \t}\n-\tglBegin(GL_LINE_STRIP);\n \n-\tfor(unsigned int i=0; i < _points.size(); ++i) {\n-\t\tif (i < _colors.size()) {\n-\t\t\tsetColor(_colors[i]);\n-\t\t}\n-\t\tglVertex3fv((float *)&_points[i]);\n-\t}\n-\tglEnd();\n+\tglEnableClientState(GL_VERTEX_ARRAY);\n+\tglEnableClientState(GL_COLOR_ARRAY);\n+\tglVertexPointer(3, GL_FLOAT, 3 * sizeof(float), &_points[0]);\n+\tglColorPointer(4, GL_UNSIGNED_BYTE, 4 * sizeof(unsigned char), &_colors[0]);\n+\tglDrawArrays(GL_LINE_STRIP, 0, _points.size());\n+\tglDisableClientState(GL_VERTEX_ARRAY);\n+\tglDisableClientState(GL_COLOR_ARRAY);\n \n \tOpenGlConfigManager::getInst().desactivateLineAndPointAntiAliasing();\n \n", "fix_pattern": "<pattern>: if OpenGL drawing commands use `glBegin` and `glEnd` for drawing multiple vertices and colors, refactor the code to use vertex array capabilities, enabling the appropriate client states and using `glDrawArrays` for improved performance and reduced overhead."}
{"number": 1089, "change": "@@ -563,7 +563,6 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n     int return_code;\n     LSTATUS status;\n     unsigned int i;\n-    char str[256];\n     VkResult res;\n \n     WINE_TRACE(\"Starting VR info initialization.\\n\");\n@@ -587,14 +586,8 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n         WINE_ERR(\"Could not get IVRClientCore, error %d.\\n\", return_code);\n     }\n \n-    if ((env_str = getenv(\"SteamGameId\")))\n-        app_id = atoi(env_str);\n-    else\n-        app_id = 1245040; /* Proton 5.0 */\n-\n     /* Without overriding the app_key vrclient waits 2 seconds for a valid appkey before returning. */\n-    sprintf(str, \"{ \\\"app_key\\\" : \\\"steam.app.%u\\\" }\", app_id);\n-    error = client_core->Init(vr::VRApplication_Background, str);\n+    error = client_core->Init(vr::VRApplication_Background, NULL);\n     if (error != vr::VRInitError_None)\n     {\n         if (error == vr::VRInitError_Init_NoServerForBackgroundApp)\n", "fix_pattern": "<pattern>: if the initialization of a string with `sprintf` for API calls is unnecessary (as seen in the removal of dynamic app_id generation), directly pass `NULL` to avoid unnecessary string manipulation and potential performance overhead."}
{"number": 1093, "change": "@@ -213,7 +213,12 @@ void EffectChain::render_to_screen(unsigned char *src)\n \t\tassert(false);\n \t}\n \n-\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\tstatic bool first = true;\n+\tif (first) {\n+\t\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\t} else {\n+\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, format, GL_UNSIGNED_BYTE, src);\n+\t}\n \tcheck_error();\n \tglUniform1i(glGetUniformLocation(glsl_program_num, \"input_tex\"), 0);\n \n", "fix_pattern": "<pattern>: if the initial texture data is uploaded once using glTexImage2D, subsequent updates should be performed using glTexSubImage2D to improve performance by avoiding full texture reallocation. Use a flag to track whether it is the first call or not."}
{"number": 1103, "change": "@@ -383,8 +383,6 @@ void Renderer::render(uint32_t delta) {\n       const auto& batch = graphics_batches[i];\n       const auto program = batch.depth_shader.gl_program;\n       glUseProgram(program);\n-      glBindVertexArray(batch.gl_depth_vao);\n-\n       glUniformMatrix4fv(glGetUniformLocation(program, \"camera_view\"), 1, GL_FALSE, glm::value_ptr(camera_transform));\n       \n       // FIXME: These copies should happen outside of the render loop\n", "fix_pattern": "<pattern>: if glBindVertexArray is called redundantly, ensure that it's only called when necessary, potentially by checking if the current VAO is different from the one being bound to avoid unnecessary state changes."}
{"number": 1107, "change": "@@ -19,7 +19,7 @@\n  \n      For further information visit http://plib.sourceforge.net\n \n-     $Id: fnt.cc,v 1.1.2.5 2003-12-04 02:12:47 olly Exp $\n+     $Id: fnt.cc,v 1.1.2.6 2004-03-02 12:28:58 olly Exp $\n */\n \n #include \"fnt.h\"\n@@ -177,9 +177,6 @@ fntTexFont::load(const char *fname)\n \t\t (GLvoid *)teximage);\n     delete [] teximage;\n \n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n-\n     glAlphaFunc(GL_GREATER, 0.5f);\n \n     fseek(fd, fpos, SEEK_SET);\n", "fix_pattern": "<pattern>: NA"}
{"number": 1115, "change": "@@ -1573,7 +1573,7 @@ void KStartupInfoData::setApplicationId(const QString &desktop)\n     // the spec requires this is always a full path, in order for everyone to be able to find it\n     QString desk = QStandardPaths::locate(QStandardPaths::ApplicationsLocation, desktop);\n     if (desk.isEmpty()) {\n-        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, \"kservices5/\" + desktop);\n+        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, QLatin1String(\"kservices5/\") + desktop);\n     }\n     if (desk.isEmpty()) {\n         return;\n", "fix_pattern": "<pattern>: if a QString created from a literal is concatenated with another QString, use QLatin1String to avoid unnecessary conversion overhead for better performance."}
{"number": 1116, "change": "@@ -517,11 +517,14 @@ void Core::emitRichNotification(const QString &evid, const QString &title, const\n \n bool Core::emitBatteryChargePercentNotification(int currentPercent, int previousPercent, const QString &udi, Core::ChargeNotificationFlags flags)\n {\n-    using namespace Solid;\n-    Device device(udi);\n-    Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+    if (m_peripheralBatteriesPercent.contains(udi)) {\n+        using namespace Solid;\n+        Device device(udi);\n+        Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+        if (!b) {\n+            return false;\n+        }\n \n-    if (b && !b->isPowerSupply()) {\n         // if you leave the device out of reach or it has not been initialized yet\n         // it won't be \"there\" and report 0%, don't show anything in this case\n         if (!b->isPresent() || b->chargePercent() == 0) {\n", "fix_pattern": "<pattern>: if there is a need to check for a specific device's power supply status through an API call that is potentially costly, add a quick lookup check in a map or set to determine if further API usage is necessary, thus avoiding unnecessary calls when the information can be derived from a pre-checked structure."}
{"number": 1118, "change": "@@ -95,9 +95,9 @@ KAboutPerson KAboutPerson::fromJSON(const QJsonObject &obj)\n {\n     const QString name = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Name\"));\n     const QString task = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Task\"));\n-    const QString email = obj[QStringLiteral(\"Email\")].toString();\n-    const QString website = obj[QStringLiteral(\"Website\")].toString();\n-    const QUrl avatarUrl = obj[QStringLiteral(\"AvatarUrl\")].toVariant().toUrl();\n+    const QString email = obj.value(QLatin1String(\"Email\")).toString();\n+    const QString website = obj.value(QLatin1String(\"Website\")).toString();\n+    const QUrl avatarUrl = obj.value(QLatin1String(\"AvatarUrl\")).toVariant().toUrl();\n     return KAboutPerson(name, task, email, website, avatarUrl);\n }\n \n", "fix_pattern": "<pattern>: if accessing keys in a QJsonObject using QStringLiteral results in potential repeated conversions from QString to QByteArray, use QLatin1String instead for improved performance."}
{"number": 1119, "change": "@@ -99,9 +99,7 @@ KNotesApp::KNotesApp()\n {\n     Akonadi::ControlGui::widgetNeedsAkonadi(this);\n \n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n \n     if (KNotesGlobalConfig::self()->autoCreateResourceOnStart()) {\n         NoteShared::LocalResourceCreator *creator = new NoteShared::LocalResourceCreator(this);\n", "fix_pattern": "<pattern>: if checking for an environment variable and its value's emptiness, replace qgetenv and isEmpty with the more direct qEnvironmentVariableIsEmpty for improved performance."}
