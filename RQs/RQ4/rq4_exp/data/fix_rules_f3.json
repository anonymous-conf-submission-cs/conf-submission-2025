{"number": 3, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.30 2007/01/15 10:15:47 brun Exp $\n+// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.31 2007/02/06 11:48:48 rdm Exp $\n // Author: Fons Rademakers   11/09/95\n \n /*************************************************************************\n@@ -28,7 +28,6 @@\n #include \"TObjArray.h\"\n #include \"TError.h\"\n #include \"TROOT.h\"\n-#include \"TRandom.h\"\n \n ClassImp(TObjArray)\n \n@@ -615,7 +614,7 @@ void TObjArray::Randomize(Int_t ntimes)\n \n    for (Int_t i=0;i<ntimes;i++) {\n       for (Int_t j=0;j<fLast;j++) {\n-         Int_t k = (Int_t)gRandom->Uniform(0,fLast);\n+         Int_t k = (Int_t)(fLast*rand()/(RAND_MAX+1.0));\n          if (k == j) continue;\n          TObject *obj = fCont[j];\n          fCont[j] = fCont[k];\n", "fix_pattern": "<pattern>: if a call to gRandom->Uniform is replaced with a direct use of rand() from the Standard C Library, consider if this change is made to avoid the overhead or dependency of the ROOT Framework for simpler random number generation."}
{"number": 4, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.175 2007/03/02 08:52:02 brun Exp $\n+// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.176 2007/03/14 11:31:36 brun Exp $\n // Author: Andrei Gheata   25/10/01\n \n /*************************************************************************\n@@ -5578,7 +5578,12 @@ TGeoManager *TGeoManager::Import(const char *filename, const char *name, Option_\n    } else {   \n       // import from a root file\n       TFile *old = gFile;\n-      TFile *f = TFile::Open(filename);\n+      // in case a web file is specified, use the cacheread option to cache\n+      // this file in the local directory\n+      TFile::SetCacheFileDir(\".\");\n+      TFile *f = 0;\n+      if (strstr(filename,\"http://\")) f = TFile::Open(filename,\"CACHEREAD\");\n+      else                            f = TFile::Open(filename);\n       if (!f || f->IsZombie()) {\n          if (old) old->cd();\n          printf(\"Error in <TGeoManager::Import>: Cannot open file\\n\");\n", "fix_pattern": "<pattern>: if a filename is detected as a URL starting with \"http://\", utilize the \"CACHEREAD\" option when opening the file through the TFile API to potentially improve file access performance by caching the contents locally."}
{"number": 5, "change": "@@ -2859,7 +2859,7 @@ Int_t TGX11::SetTextFont(char *fontname, ETextSetMode mode)\n          XSetFont(fDisplay, *gGCtext, gTextFont->fid);\n          XSetFont(fDisplay, *gGCinvt, gTextFont->fid);\n          gFont[gCurrentFontNumber].id = gTextFont;\n-         strcpy(gFont[gCurrentFontNumber].name,fontname);\n+         strlcpy(gFont[gCurrentFontNumber].name,fontname,80);\n          gCurrentFontNumber++;\n          if (gCurrentFontNumber == kMAXFONT) gCurrentFontNumber = 0;\n       }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with strlcpy to ensure safety by preventing buffer overflows through size checking."}
{"number": 6, "change": "@@ -1058,7 +1058,7 @@ Bool_t TXMLPlayer::ProduceSTLstreamer(ostream& fs, TClass* cl, TStreamerSTL* el,\n       strlcpy(tabs2, tabs, sizeof(tabs2));\n \n       if (isptr) {\n-         strncat(tabs2, tab1, sizeof(tabs2));\n+         strlcat(tabs2, tab1, sizeof(tabs2));\n          fs << tabs << \"if (\" << (isarr ? \"*cont\" : \"cont\") << \"==0) {\" << endl;\n          fs << tabs2 << \"buf.WriteSTLsize(0\" << (isstr ? \",true);\" : \");\") << endl;\n          fs << tabs << \"} else {\" << endl;\n", "fix_pattern": "<pattern>: if using strncat for concatenating strings, replace it with strlcat to improve safety and avoid buffer overflow issues, as strlcat provides better boundary checks compared to strncat."}
{"number": 8, "change": "@@ -558,15 +558,15 @@ void ProofdExec()\n       char *buf = (char *) vb;\n       char *end = buf + len;\n       const char name[] = \"PROOF_ALLVARS=\";\n-      char *all = new char[strlen(name)+len]; // strlen(\"PROOF_ALLVARS=\") = 14\n-      strncpy(all, name, strlen(name)+len);\n-      all[strlen(name)+len-1] = 0;\n+      int alen = strlen(name)+len;\n+      char *all = new char[alen]; // strlen(\"PROOF_ALLVARS=\") = 14\n+      strlcpy(all, name, alen);\n       while (buf < end) {\n          if (gDebug > 0) ErrorInfo(\"ProofdExec: setting: %s\", buf);\n          char *p = index(buf, '=');\n          if (p) {\n-            if (buf != (char *) vb) strncat(all, \",\", 1); // skip the first one\n-            strncat(all, buf, p-buf);\n+            if (buf != (char *) vb) strlcat(all, \",\", alen); // skip the first one\n+            strlcat(all, buf, alen);\n             putenv(buf);\n          }\n          buf += strlen(buf) + 1;\n", "fix_pattern": "<pattern>: if string manipulation is done using strncpy and strncat, replace them with strlcpy and strlcat for improved safety and performance, as strlcpy and strlcat not only copy and concatenate strings but also ensure null-termination and respect buffer sizes more effectively."}
{"number": 13, "change": "@@ -24,10 +24,7 @@ pythonizations.\n PyObject *CallPyObjMethod(PyObject *obj, const char *meth)\n {\n    // Helper; call method with signature: obj->meth()\n-   Py_INCREF(obj);\n-   PyObject* result = PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n-   Py_DECREF(obj);\n-   return result;\n+   return PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n }\n \n TClass *GetTClass(const CPyCppyy::CPPInstance *pyobj)\n", "fix_pattern": "<pattern>: if a reference counting operation is followed immediately by an API call and then a decref, it's unnecessary to increment the reference count before the call and decrement it after, as the called method is expected to manage the reference count appropriately. Thus, directly call the method without the extra reference counting."}
{"number": 15, "change": "@@ -46,7 +46,7 @@ void uThread::destory(bool force = false) {\n     //check whether we should cache it or not\n     totalNumberofUTs--;\n     if (slowpath(force) || (utCache.push(this) < 0)) {\n-        free((ptr_t) (stackBottom));       //Free the allocated memory for stack\n+        munmap((ptr_t) (stackBottom), stackSize);       //Free the allocated memory for stack\n     }\n }\n \n", "fix_pattern": "<pattern>: if freeing memory that was allocated with mmap or similar methods, use munmap instead of free to ensure proper memory deallocation in line with the allocation method used."}
{"number": 16, "change": "@@ -674,7 +674,8 @@ protected:\n                 if (path_attr != INVALID_FILE_ATTRIBUTES && (path_attr & FILE_ATTRIBUTE_DIRECTORY))\n                     ofn.lpstrInitialDir = m_wdefault_path.c_str();\n                 else if (m_wdefault_path.size() <= woutput.size())\n-                    lstrcpyW(ofn.lpstrFile, m_wdefault_path.c_str());\n+                    //second argument is size of buffer, not length of string\n+                    StringCchCopyW(ofn.lpstrFile, MAX_PATH*256+1, m_wdefault_path.c_str());\n                 else\n                 {\n                     ofn.lpstrFileTitle = (LPWSTR)m_wdefault_path.data();\n", "fix_pattern": "<pattern>: if a string copy is done using lstrcpyW, replace it with StringCchCopyW and provide the destination buffer size to avoid potential buffer overflows and improve safety."}
{"number": 24, "change": "@@ -128,14 +128,14 @@ void MonitorPictureDialog::updateMonitorWidgets(QString primaryMonitor)\n \n     for (MonitorPicture *picture : qAsConst(pictures)) {\n         if (picture->monitorWidget->output->name() == primaryMonitor\n-                || primaryMonitor == QStringLiteral(\"\")) {\n+                || primaryMonitor == QLatin1String()) {\n             x0 = picture->originX + picture->pos().x();\n             y0 = picture->originY + picture->pos().y();\n             break;\n         }\n     }\n \n-    if( primaryMonitor == QStringLiteral(\"\") ) {\n+    if( primaryMonitor == QLatin1String() ) {\n         for(MonitorPicture *picture : qAsConst(pictures)) {\n             int x1 = picture->originX + picture->pos().x();\n             int y1 = picture->originY + picture->pos().y();\n", "fix_pattern": "<pattern>: if a comparison against an empty QStringLiteral is detected, replace it with a comparison against QLatin1String() for improved performance, as QLatin1String is more efficient for this use case in Qt Framework."}
{"number": 32, "change": "@@ -46,10 +46,11 @@\n // zlib compress2 function resulted in a 40+% reduction versus the original image.\n uint8_t* GFXRECON_zlib_compress2(uint8_t* data, int32_t data_len, int32_t* out_len, int32_t quality)\n {\n-    uint8_t* target = reinterpret_cast<uint8_t*>(malloc(data_len));\n+    unsigned long alloc_len = compressBound(data_len);\n+    uint8_t*      target    = reinterpret_cast<uint8_t*>(malloc(alloc_len));\n     if (nullptr != target)\n     {\n-        unsigned long ret_len = data_len;\n+        unsigned long ret_len = alloc_len;\n         if (Z_OK == compress2(target, &ret_len, data, data_len, quality))\n         {\n             *out_len = ret_len;\n", "fix_pattern": "<pattern>: when allocating memory for compressed data, use `compressBound(data_len)` to ensure sufficient space is allocated to accommodate compressed bytes instead of the uncompressed data length."}
{"number": 36, "change": "@@ -97,7 +97,8 @@ class DenoisingFunctor\n     X = svd.matrixU() * s.asDiagonal() * svd.matrixV().adjoint();\n     // Store output\n     assign_pos_of(dwi).to(out);\n-    out.row(3) = X.col(n/2).template cast<value_type>();\n+    for (auto l = Loop (3) (out); l; ++l)\n+      out.value() = X(out.index(3), n/2);\n   }\n   \n   void operator () (ImageType& dwi, ImageType& out, ImageType& noise)\n", "fix_pattern": "<pattern>: if there is a direct assignment from a column of an Eigen matrix to a row of a custom image type, replace it with a loop that accesses specific indices, which may optimize memory access patterns, especially when dealing with larger matrices and allowing for more fine-grained control over the assignment process."}
{"number": 38, "change": "@@ -2006,7 +2006,7 @@ void MainWindow::saveCameras(QString const& path, bool writeToProject)\n         auto const filepath = QDir{path}.filePath(cameraName);\n         out.insert(filepath, camera);\n \n-        if (QFileInfo(filepath).exists())\n+        if (QFileInfo::exists(filepath))\n         {\n           willOverwrite.append(filepath);\n         }\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is being created just to check for file existence, replace it with a static call to QFileInfo::exists to avoid unnecessary object creation and improve performance."}
{"number": 39, "change": "@@ -20,14 +20,14 @@\n #include \"vtkByteSwap.h\"\n #include \"vtkCellData.h\"\n #include \"vtkDataArray.h\"\n-#include \"vtkDataCompressor.h\"\n+#include \"vtkZLibDataCompressor.h\"\n #include \"vtkDataSet.h\"\n #include \"vtkOutputStream.h\"\n #include \"vtkPointData.h\"\n #include \"vtkPoints.h\"\n #include \"vtkUnsignedCharArray.h\"\n \n-vtkCxxRevisionMacro(vtkXMLWriter, \"1.14\");\n+vtkCxxRevisionMacro(vtkXMLWriter, \"1.15\");\n vtkCxxSetObjectMacro(vtkXMLWriter, Compressor, vtkDataCompressor);\n \n //----------------------------------------------------------------------------\n@@ -55,7 +55,7 @@ vtkXMLWriter::vtkXMLWriter()\n \n   // Initialize compression data.\n   this->BlockSize = 32768;\n-  this->Compressor = 0;\n+  this->Compressor = vtkZLibDataCompressor::New();\n   this->CompressionHeader = 0;\n   \n   this->EncodeAppendedData = 1;\n", "fix_pattern": "<pattern>: if a class is updated to use a more efficient compression method (from a null pointer to a specific compressor implementation), replace null compressor assignment with the new compressor instantiation for improved data handling efficiency."}
{"number": 40, "change": "@@ -29,7 +29,7 @@\n \n #include <math.h>\n \n-vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.17\");\n+vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.18\");\n vtkStandardNewMacro(vtkSpherePuzzle);\n \n //----------------------------------------------------------------------------\n@@ -175,7 +175,7 @@ int vtkSpherePuzzle::RequestData(\n \n       // append all the pieces.\n       append->AddInput(tmp);\n-      tmp->Delete();\n+      tmp->FastDelete();\n       ++count;\n       }\n     }\n", "fix_pattern": "<pattern>: if a deletion operation on a VTK object is being performed using the more conventional Delete() method, replace it with FastDelete() to improve performance, especially for objects that may involve a significant overhead in reference counting. Additionally, the revision macro is updated to reflect a new version, which can indicate that the change is part of version management or enhancement as well."}
{"number": 41, "change": "@@ -956,9 +956,8 @@ int vtkGDALRasterReader::RequestData(vtkInformation* vtkNotUsed(request),\n   }\n \n   // Get the projection.\n-  char* proj = strdup(this->Impl->GDALData->GetProjectionRef());\n-  this->ProjectionWKT = proj;\n-  OGRSpatialReference spRef(proj);\n+  this->ProjectionWKT = this->Impl->GDALData->GetProjectionRef();\n+  OGRSpatialReference spRef(this->ProjectionWKT.c_str());\n \n   char* projection;\n   spRef.exportToProj4(&projection);\n", "fix_pattern": "<pattern>: if a string is obtained from an API and duplicated using strdup, directly assign the string to a member variable (e.g., std::string) to avoid unnecessary memory allocation and copying, and use the underlying c_str() method for interoperability with C APIs."}
{"number": 47, "change": "@@ -180,11 +180,16 @@ void ProblemReporter::reparse()\n     if( !m_javaSupport->isValid() )\n \treturn;\n \n+    // @todo: use the project database to decide which files to parse instead of this!\n+    // ugly hack: do not parse non .java ending files\n+    if ( !m_fileName.endsWith(\".java\") )\n+        return;\n+\n     m_timer->stop();\n \n     kdDebug(9013) << \"ProblemReporter::reparse()\" << endl;\n     m_javaSupport->backgroundParser()->addFile( m_fileName );\n-    kdDebug(9013) << \"---> file added\" << endl;\n+    kdDebug(9013) << \"---> file added \" << m_fileName << endl;\n }\n \n void ProblemReporter::slotSelected( QListViewItem* item )\n", "fix_pattern": "<pattern>: if logging a debug message occurs unconditionally, introduce a condition to skip logging for certain cases (such as files that do not end with a specific extension) to avoid unnecessary performance costs from function calls and streamline the logging process."}
{"number": 53, "change": "@@ -264,9 +264,9 @@ MediaSet::unref (const std::string &sessionId, const uint64_t &mediaObjectRef)\n \n void MediaSet::releasePointer (MediaObjectImpl *mediaObject)\n {\n-  mutex.lock();\n+  Monitor monitor (mutex);\n+\n   objectsMap.erase (mediaObject->getId() );\n-  mutex.unlock();\n \n   threadPool.push ( [mediaObject] () {\n     GST_DEBUG (\"Destroying %s\", mediaObject->getIdStr().c_str() );\n", "fix_pattern": "<pattern>: if mutex.lock() and mutex.unlock() are called in a sequence with no other operations in between, replace them with a scoped lock object to automatically manage the locking and unlocking of the mutex, thereby improving code clarity and reducing the chance of deadlocks due to exceptions."}
{"number": 57, "change": "@@ -32,7 +32,7 @@\n #include <KDesktopFile>\n #include <QDir>\n #include <QFile>\n-#include <QDBusInterface>\n+#include <QDBusConnection>\n #include <QDBusPendingCall>\n \n namespace Plasma\n@@ -160,8 +160,9 @@ void PackageStructurePrivate::installPathChanged(const QString &path)\n             }\n         }\n     }\n-    QDBusInterface sycoca(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"));\n-    sycoca.asyncCall(QStringLiteral(\"recreate\"));\n+    const auto call = QDBusMessage::createMethodCall(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"),\n+        QStringLiteral(\"org.kde.kbuildsycoca\"), QStringLiteral(\"recreate\"));\n+    QDBusConnection::sessionBus().asyncCall(call);\n }\n \n \n", "fix_pattern": "<pattern>: if a QDBusInterface is constructed to make an asynchronous call, replace it with a direct call using QDBusMessage and QDBusConnection to avoid the overhead of constructing QDBusInterface, which is unnecessary for simple method calls."}
{"number": 59, "change": "@@ -537,9 +537,8 @@ void ViewManager::createView(Session* session, ViewContainer* container, int ind\n     // notify this view manager when the session finishes so that its view\n     // can be deleted\n     //\n-    // TODO - Find a more efficient a way to avoid multiple connections\n-    disconnect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n-    connect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n+    // Use Qt::UniqueConnection to avoid duplicate connection\n+    connect(session, SIGNAL(finished()), this, SLOT(sessionFinished()), Qt::UniqueConnection);\n \n     TerminalDisplay* display = createTerminalDisplay(session);\n     const Profile::Ptr profile = SessionManager::instance()->sessionProfile(session);\n", "fix_pattern": "<pattern>: if multiple connections are made to the same signal and slot pair, utilize Qt::UniqueConnection in the connect call to prevent duplicate connections and improve performance."}
{"number": 64, "change": "@@ -123,7 +123,9 @@ void fill_curl_eh(CURL *eh, C_Element *cube, bool isOverlay, FtpElement *elem) {\n     curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, my_fwrite);\n     curl_easy_setopt(eh, CURLOPT_WRITEDATA, elem);\n     curl_easy_setopt(eh, CURLOPT_PRIVATE, elem);\n-    curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    //curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_LIMIT, 1);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_TIME, 10);\n     curl_easy_setopt(eh, CURLOPT_CONNECTTIMEOUT, 10);\n     curl_multi_add_handle(curlm, eh);\n }\n", "fix_pattern": "<pattern>: if a timeout option is set on a CURL handle, consider using low-speed options instead to avoid cancelling connections with low traffic that may still be valid, enhancing the performance of network operations."}
{"number": 65, "change": "@@ -117,13 +117,15 @@ GLuint load_program(const char *path1, const char *path2) {\n void flip_image_vertical(\n     unsigned char *data, unsigned int width, unsigned int height)\n {\n-    unsigned char new_data[width * height * 4];\n-    unsigned int stride = width * 4;\n+    unsigned int size = width * height * 4;\n+    unsigned int stride = sizeof(char) * width * 4;\n+    unsigned char *new_data = malloc(sizeof(char) * size);\n     for (unsigned int i = 0; i < height; i++) {\n         unsigned int j = height - i - 1;\n         memcpy(new_data + j * stride, data + i * stride, stride);\n     }\n-    memcpy(data, new_data, sizeof(new_data));\n+    memcpy(data, new_data, size);\n+    free(new_data);\n }\n \n void load_png_texture(const char *file_name) {\n", "fix_pattern": "<pattern>: if a stack-allocated array is created to hold data temporarily and immediately copied to another location, allocate memory using `malloc` to avoid potential stack size limits, and ensure the size is correctly calculated, followed by freeing the memory after use."}
{"number": 67, "change": "@@ -1276,14 +1276,7 @@ FileDescriptor V4L2VideoDevice::exportDmabufFd(unsigned int index,\n \t\treturn FileDescriptor();\n \t}\n \n-\tFileDescriptor fd(expbuf.fd);\n-\t/*\n-\t * FileDescriptor takes a duplicate of fd, so we must close the\n-\t * original here, otherwise it will be left dangling.\n-\t */\n-\t::close(expbuf.fd);\n-\n-\treturn fd;\n+\treturn FileDescriptor(std::move(expbuf.fd));\n }\n \n /**\n", "fix_pattern": "<pattern>: if a duplicate of a file descriptor is created and the original is closed immediately after, use std::move to transfer ownership of the file descriptor directly into the FileDescriptor constructor to eliminate the need for an intermediate variable and potential dangling reference."}
{"number": 70, "change": "@@ -1,12 +1,12 @@\n #include <stdlib.h>\n #include <stdio.h>\n-#include <string.h>\n+#include <sys/types.h>\n+#include <signal.h>\n \n int main(void)\n {\n   int i, pid;\n   FILE *fp;\n-  char str[32];\n \n   for(i = 0; i < 5; i++){\n     system(\"gmsh -pid fichier.msh fichier.pos > /tmp/gmsh.pid &\");\n@@ -18,7 +18,6 @@ int main(void)\n     fscanf(fp, \"%d\", &pid);\n     fclose(fp);\n \n-    sprintf(str, \"kill %d\", pid);\n-    system(str);\n+    kill(pid, 9);\n   }    \n } \n", "fix_pattern": "<pattern>: if a command to be executed via system() is constructed using sprintf, replace it with a direct call to kill() to eliminate unnecessary string handling and improve performance."}
{"number": 73, "change": "@@ -88,8 +88,7 @@ AudioEncoder::EncodedInfo AudioEncoderCopyRed::EncodeInternal(\n       DCHECK_EQ(info.redundant.size(), 2u);\n     }\n     // Save primary to secondary.\n-    secondary_encoded_.SetSize(info.encoded_bytes);\n-    memcpy(secondary_encoded_.data(), encoded, info.encoded_bytes);\n+    secondary_encoded_.SetData(encoded, info.encoded_bytes);\n     secondary_info_ = info;\n     DCHECK_EQ(info.speech, info.redundant[0].speech);\n   }\n", "fix_pattern": "<pattern>: if memory is manually copied using memcpy after resizing a buffer, replace it with a more efficient API such as SetData that handles both setting the size and copying the data in a single method call."}
{"number": 74, "change": "@@ -88,7 +88,7 @@ DWORD GetThreadStartAddress(HANDLE processHandle, HANDLE hThread) {\n \n \tMODULEINFO mi;\n \n-\tGetModuleInformation(processHandle, LoadLibrary(\"kernel32.dll\"), &mi, sizeof(mi));\n+\tGetModuleInformation(processHandle, GetModuleHandle(\"kernel32.dll\"), &mi, sizeof(mi));\n \tstacktop = (DWORD)GetThreadStackTopAddress_x86(processHandle, hThread);\n \n \t/* The stub below has the same result as calling GetThreadStackTopAddress_x86() \n", "fix_pattern": "<pattern>: if an API call to LoadLibrary is being used to retrieve a module handle for a DLL that is already loaded, replace it with GetModuleHandle to avoid the overhead of loading the library again."}
{"number": 76, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified and additional attributes are set, refactor by using the existing descriptor directly to avoid unnecessary parameters and streamline the code for better clarity and potential performance improvements."}
{"number": 84, "change": "@@ -321,7 +321,7 @@ bool romLoaded(Logger* logger, System system, const std::string& path, void* rom\n   case System::kAtariLynx:\n     rom = util::loadFile(logger, path, &size);\n \n-    if (!strcmp(\"LYNX\", (char *)rom))\n+    if (!memcmp(\"LYNX\", (void *)rom, 5))\n     {\n         RA_OnLoadNewRom((BYTE*)rom + 0x0040, size - 0x0040);\n     }\n", "fix_pattern": "<pattern>: if a string comparison is made using strcmp for a fixed-length comparison, replace it with memcmp to improve performance by comparing raw memory directly."}
{"number": 95, "change": "@@ -573,7 +573,7 @@ void PreviewJob::slotResult(KJob *job)\n         const KIO::filesize_t size = (KIO::filesize_t)statResult.numberValue(KIO::UDSEntry::UDS_SIZE, 0);\n         const QUrl itemUrl = d->currentItem.item.mostLocalUrl();\n \n-        if (itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) {\n+        if ((itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) && !d->currentItem.item.isSlow()) {\n             skipCurrentItem = !d->ignoreMaximumSize && size > d->maximumLocalSize && !d->currentItem.plugin.value(QStringLiteral(\"IgnoreMaximumSize\"), false);\n         } else {\n             // For remote items the \"IgnoreMaximumSize\" plugin property is not respected\n", "fix_pattern": "<pattern>: if a conditional checks for local file protocols through `isLocalFile()` or `protocolClass()`, enhance the conditional logic by adding an additional check for `isSlow()` to avoid unnecessary processing when dealing with slow items."}
{"number": 99, "change": "@@ -268,9 +268,7 @@ int main(int argc, char* argv[])\n \t\t\t}\n \n \t\t\tcout << endl;\n-\t\t\t\n-\t\t\tstrcpy(szNewPassword, newpassword);\n-\n+\t\t\tkc_strlcpy(szNewPassword, newpassword, sizeof(szNewPassword));\n \t\t\trepassword = get_password(\"Re-Enter password:\");\n \t\t\tif(strcmp(newpassword, repassword) != 0) {\n \t\t\t\tcerr << \"Passwords don't match\" << endl;\n", "fix_pattern": "<pattern>: if a string copy operation is performed using strcpy, replace it with kc_strlcpy to ensure safer copy operations that prevent buffer overflows."}
{"number": 102, "change": "@@ -387,7 +387,9 @@ void SystemDriver::UpdateVelocity(mfem::ParGridFunction &velocity, mfem::Vector\n             }\n #endif\n          } // End if vgrad_origin_flag\n-         const double* dmin_x = vgrad_origin.Read();\n+         Vector origin(space_dim, mfem::Device::GetMemoryType()); origin.UseDevice(true);\n+         MPI_Allreduce(vgrad_origin.HostRead(), origin.HostReadWrite(), space_dim, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n+         const double* dmin_x = origin.Read();\n          // We've now found our minimum points so we can now go and calculate everything.\n          MFEM_FORALL(i, nnodes, {\n             for (int ii = 0; ii < space_dim; ii++) {\n", "fix_pattern": "<pattern>: if the code is reading data from a source with potential performance implications (like `vgrad_origin.Read()`), switch to using MPI for parallel reduction (like `MPI_Allreduce`) and leverage device memory management with `Vector` to improve data handling efficiency."}
{"number": 106, "change": "@@ -52,6 +52,8 @@ namespace {\n \n   // Using native file handles instead of file descriptors for reducing the resource consumption.\n \n+  const HANDLE InvalidFile = INVALID_HANDLE_VALUE;\n+\n   HANDLE openFile(const FileName &path, bool readOnly)\n   {\n     DWORD access = readOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);\n@@ -82,6 +84,8 @@ namespace {\n \n   // For non-Windows \n \n+  const FILE *InvalidFile = 0;\n+\n   struct FileNameHandle : public std::string\n   {\n     FileNameHandle(FileName name) : std::string(name) {}\n@@ -119,7 +123,7 @@ public:\n };\n \n FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openReadOnly) :\n-  file(0),\n+  file(InvalidFile),\n   name(fileName),\n   readOnly(true),\n   size(0)\n@@ -129,12 +133,12 @@ FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openRea\n   if(!openReadOnly)\n     file = openFile(name, false);\n \n-  if(file)\n+  if(file != InvalidFile)\n     readOnly = false;\n   else\n     file = openFile(name, true);\n \n-  if(!file) {\n+  if(file == InvalidFile) {\n     debug(\"Could not open file \" + String((const char *) name));\n   }\n }\n", "fix_pattern": "<pattern>: if a variable is being checked against a file handle, replace the direct comparison with a predefined constant (INVALID_HANDLE_VALUE) for better readability and potential optimization in checks against the invalid file state."}
{"number": 107, "change": "@@ -2343,7 +2343,7 @@ void dbookmarkswindow::slotBookmarkReceived(const QModelIndex &index)\n \n bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n {\n-  qint64 count = 0;\n+  bool exists = false;\n \n   {\n     QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\", \"bookmarks\");\n@@ -2358,9 +2358,9 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \tint temporary = dmisc::passphraseWasAuthenticated() ? 0 : 1;\n \n \tquery.setForwardOnly(true);\n-\tquery.prepare(\"SELECT COUNT(*) FROM bookmarks WHERE \"\n+\tquery.prepare(\"SELECT EXISTS(SELECT 1 FROM bookmarks WHERE \"\n \t\t      \"url_hash = ? AND \"\n-\t\t      \"temporary = ?\");\n+\t\t      \"temporary = ?)\");\n \tquery.bindValue\n \t  (0,\n \t   dmisc::hashedString(url.\n@@ -2371,14 +2371,14 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \n \tif(ok && query.exec())\n \t  if(query.next())\n-\t    count = query.value(0).toLongLong();\n+\t    exists = query.value(0).toBool();\n       }\n \n     db.close();\n   }\n \n   QSqlDatabase::removeDatabase(\"bookmarks\");\n-  return count > 0;\n+  return exists;\n }\n \n void dbookmarkswindow::slotRefresh(void)\n", "fix_pattern": "<pattern>: if a query is used to count rows in a SQL table, replace it with a query that checks for existence instead (e.g., using \"SELECT EXISTS(...)\") to improve performance by reducing the amount of data processed."}
{"number": 118, "change": "@@ -165,7 +165,7 @@ std::string PluginSerializer::SerializeToFile(const std::string& content_url,\n     return \"\";\n   }\n \n-  size_t num_written = fwrite(body.c_str(), 1, body.size(), file);\n+  size_t num_written = fwrite(body.data(), 1, body.size(), file);\n   fclose(file);\n   if (num_written != body.size()) {\n     LOG(ERROR) << \"Failed to WriteDataToFile for \" << string_path\n", "fix_pattern": "<pattern>: if a string's underlying data is accessed for writing (such as with fwrite), prefer to use body.data() instead of body.c_str() to avoid the potential overhead of constructing a null-terminated string when it's not necessary."}
{"number": 120, "change": "@@ -240,7 +240,7 @@ HandleSet ForwardChainer::get_chaining_result()\n \n Source* ForwardChainer::select_source()\n {\n-\tstd::lock_guard<std::mutex> lock(_part_mutex);\n+\tstd::unique_lock<std::mutex> lock(_part_mutex);\n \n \tstd::vector<double> weights = _sources.get_weights();\n \n@@ -270,7 +270,7 @@ Source* ForwardChainer::select_source()\n \t\t\ture_logger().debug() << \"Reset all exhausted flags to retry them\";\n \t\t\t_sources.reset_exhausted();\n \t\t\t// Try again\n-\t\t\t// NEXT TODO: be careful of locks\n+\t\t\tlock.unlock();\n \t\t\treturn select_source();\n \t\t} else {\n \t\t\t_sources.exhausted = true;\n", "fix_pattern": "<pattern>: if a std::lock_guard is replaced with a std::unique_lock that is immediately unlocked, consider whether locking is necessary at all for the given scope; if there are no operations requiring protection, remove the lock entirely."}
{"number": 128, "change": "@@ -37,7 +37,7 @@\n #endif\n \n #include <math.h>\n-#include <string.h>\n+#include \"string2.h\"\n #include \"typedefs.h\"\n #include \"macros.h\"\n #include \"copyrite.h\"\n@@ -157,7 +157,7 @@ int main (int argc,char *argv[])\n     iatoms->resinfo[resind] = atoms->resinfo[atoms->atom[index[i]].resind];\n     /* allocate some space for the rtp name and copy from name */\n     snew(iatoms->resinfo[resind].rtp,1);\n-    strcpy(iatoms->resinfo[resind].rtp, atoms->resinfo[resind].name);\n+    iatoms->resinfo[resind].rtp = gmx_strdup(atoms->resinfo[resind].name);\n \n     iatoms->nres = max(iatoms->nres, iatoms->atom[i].resind+1);\n   }\n", "fix_pattern": "<pattern>: if a direct string copy is performed using `strcpy`, replace it with a project-specific optimized function `gmx_strdup` that may handle memory allocation more efficiently and ensure the destination is properly handled."}
{"number": 137, "change": "@@ -229,11 +229,10 @@ ProgClient::run_program(const string &progname, const string &args\n     startupinfo.hStdInput = hClient;\n     startupinfo.dwFlags |= STARTF_USESTDHANDLES;\n \n-    // For some reason Windows wants a modifiable copy!\n-    BOOL ok;\n-    char * cmdline = strdup((progname + ' ' + args).c_str());\n-    ok = CreateProcess(0, cmdline, 0, 0, TRUE, 0, 0, 0, &startupinfo, &procinfo);\n-    free(cmdline);\n+    // For some reason Windows wants a modifiable command line!\n+    string cmdline = progname + ' ' + args;\n+    BOOL ok = CreateProcess(0, &cmdline[0], 0, 0, TRUE, 0, 0, 0,\n+\t\t\t    &startupinfo, &procinfo);\n     if (!ok) {\n \tthrow Xapian::NetworkError(\"CreateProcess failed\",\n \t\t\t\t   get_progcontext(progname, args),\n", "fix_pattern": "<pattern>: if a modifiable command line is required for CreateProcess, construct the command line as a std::string and use its internal buffer directly instead of creating a separate modifiable copy with strdup and then freeing it. This avoids unnecessary memory allocation and deallocation overhead."}
{"number": 142, "change": "@@ -3000,15 +3000,14 @@ BOOL allocateName(char **ppStore, const char *pName)\n \t}\n \treturn TRUE;\n #else\n-\t//need to allocate space for the name\n-\t*ppStore = (char*)malloc((strlen(pName))+1);\n+\t// Allocate space for the name and copy it\n+\t*ppStore = strdup(pName);\n \tif (ppStore == NULL)\n \t{\n-\t\tdebug( LOG_ERROR, \"Name - Out of memory\" );\n+\t\tdebug(LOG_ERROR, \"allocateName: Out of memory\");\n \t\tabort();\n \t\treturn FALSE;\n \t}\n-\tstrcpy(*ppStore,pName);\n \n \treturn TRUE;\n #endif\n", "fix_pattern": "<pattern>: if memory is allocated for a string with malloc and then copied with strcpy, replace it with strdup for better performance and simplicity, as strdup handles both allocation and copying in one call."}
{"number": 143, "change": "@@ -406,7 +406,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \n \t// Now dump the data into the buffer\n \t// Copy a string\n-\tsstrcpy(buffer, game->name);\n+\tstrlcpy(buffer, game->name, sizeof(game->name));\n \tbuffer += sizeof(game->name);\n \n \t// Copy 32bit large big endian numbers\n@@ -416,7 +416,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \tbuffer += sizeof(int32_t);\n \n \t// Copy yet another string\n-\tsstrcpy(buffer, game->desc.host);\n+\tstrlcpy(buffer, game->desc.host, sizeof(game->desc.host));\n \tbuffer += sizeof(game->desc.host);\n \n \t// Copy 32bit large big endian numbers\n", "fix_pattern": "<pattern>: replace project-specific string copy operation (sstrcpy) with safer and size-aware string copy operation (strlcpy) to avoid buffer overflows and improve performance with potentially better memory management."}
{"number": 146, "change": "@@ -473,7 +473,8 @@ struct TextShaper\n \t{\n \t\t/* Fribidi assumes that the text is encoded in UTF-32, so we have to\n \t\t   convert from UTF-8 to UTF-32, assuming that the string is indeed in UTF-8.*/\n-\t\tstd::u32string u32 = utf8::utf8to32(text);\n+\t\tstd::u32string u32;\n+\t\tutf8::unchecked::utf8to32(text.begin(), text.end(), std::back_inserter(u32));\n \n \t\t// Step 1: Initialize fribidi variables.\n \t\t// TODO: Don't forget to delete them at the end.\n@@ -877,6 +878,11 @@ static bool breaksWord(char const c)\n \treturn c == ASCII_SPACE || breaksLine(c);\n }\n \n+/* This funtion might not be fail-proof. It presumes that a \"char\" equals a \"character\" in any language.\n+   Since the game was translated into different other languages, an Arabic or Chinese \"character\"\n+   could occupy several bytes (that is, \"char\"s) in memory (assuming the string is in UTF-8). Therefore,\n+   expressions such as \"++curChar\" might not yield the next \"character\", but just a byte of its\n+   representation. */\n std::vector<TextLine> iV_FormatText(const char *String, UDWORD MaxWidth, UDWORD Justify, iV_fonts fontID, bool ignoreNewlines /*= false*/)\n {\n \tstd::vector<TextLine> lineDrawResults;\n", "fix_pattern": "<pattern>: if the conversion from UTF-8 to UTF-32 is done using a function that performs safety checks (like utf8::utf8to32), refactor the code to use a variant of the function that skips those checks (like utf8::unchecked::utf8to32) combined with std::back_inserter for better performance, while being cautious of handling multi-byte characters properly."}
{"number": 148, "change": "@@ -50,7 +50,7 @@ tlp::Color ChooseColorButton::tulipColor() const {\n \n void ChooseColorButton::setColor(const QColor& c) {\n   _color = c;\n-  repaint();\n+  update();\n   emit colorChanged(_color);\n   emit tulipColorChanged(QColorToColor(_color));\n }\n", "fix_pattern": "<pattern>: replace QWidget::repaint() with QWidget::update() to improve performance by avoiding unnecessary immediate repainting and instead queueing a repaint for later, which can reduce the frequency of redraw operations."}
{"number": 156, "change": "@@ -36,7 +36,9 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    strncpy(pchCommand, pszCommand, COMMAND_SIZE);\n+    int command_len = strlen(pszCommand);\n+    memcpy(pchCommand, pszCommand, command_len);\n+    memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n     nChecksum = 0;\n }\n", "fix_pattern": "<pattern>: if a string is copied using strncpy, replace it with memcpy followed by memset to ensure the destination is properly null-terminated while improving performance with direct memory operations."}
{"number": 157, "change": "@@ -36,7 +36,7 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    int command_len = strlen(pszCommand);\n+    size_t command_len = strnlen(pszCommand, COMMAND_SIZE);\n     memcpy(pchCommand, pszCommand, command_len);\n     memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n", "fix_pattern": "<pattern>: if the code uses strlen to determine the length of a string, replace it with strnlen while providing a maximum length to avoid potential overflow issues and improve safety when the size of the string is limited."}
{"number": 168, "change": "@@ -1285,7 +1285,7 @@ void FMultiPatchTexture::ResolvePatches()\n \t\t{\n \t\t\tif (Parts[i].Texture == nullptr)\n \t\t\t{\n-\t\t\t\tmemcpy(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n+\t\t\t\tmemmove(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n \t\t\t\ti--;\n \t\t\t\tNumParts--;\n \t\t\t}\n", "fix_pattern": "<pattern>: if a block of memory is being moved within the same array (i.e., source and destination overlap), replace memcpy with memmove to safely handle overlapping regions."}
{"number": 173, "change": "@@ -43,9 +43,9 @@ inline void update(_T& _sha, _U const& _value)\n {\n \tint i = 0;\n \tfor (_U v = _value; v; ++i, v >>= 8) {}\n-\tbytes buf(i);\n-\ttoBigEndian(_value, buf);\n-\t_sha.Update(buf.data(), buf.size());\n+\tbyte buf[32];\n+\ttoBigEndian(_value, bytesRef(buf, i));\n+\t_sha.Update(buf, i);\n }\n \n template <class _T>\n", "fix_pattern": "<pattern>: if dynamic memory (e.g., using a vector or similar) is used for a small fixed-size buffer, replace it with a stack-allocated array for better performance and reduced memory overhead."}
{"number": 180, "change": "@@ -48,8 +48,8 @@ extern \"C\" JNIEXPORT void JNICALL Java_Main_waitUntilJitted(JNIEnv* env,\n     if (code_cache->ContainsPc(header->GetCode())) {\n       break;\n     } else {\n-      // yield to scheduler to give time to the JIT compiler.\n-      sched_yield();\n+      // Sleep to yield to the compiler thread.\n+      sleep(0);\n       // Will either ensure it's compiled or do the compilation itself.\n       jit->CompileMethod(method, Thread::Current(), /* osr */ false);\n     }\n", "fix_pattern": "<pattern>: if the original code uses `sched_yield()` to yield time to the JIT compiler, replace it with `sleep(0)` to achieve a similar effect with potentially better performance in terms of scheduling efficiency."}
{"number": 182, "change": "@@ -1490,16 +1490,13 @@ BOOL SciTEWin::TabSizeMessage(HWND hDlg, UINT message, WPARAM wParam) {\n \t\t\tint tabSize = wEditor.Call(SCI_GETTABWIDTH);\n \t\t\tif (tabSize > 99)\n \t\t\t\ttabSize = 99;\n-\t\t\tchar tmp[3];\n-\t\t\tsprintf(tmp, \"%d\", tabSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDTABSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDTABSIZE, tabSize, FALSE);\n \n \t\t\t::SendDlgItemMessage(hDlg, IDINDENTSIZE, EM_LIMITTEXT, 2, 1);\n \t\t\tint indentSize = wEditor.Call(SCI_GETINDENT);\n \t\t\tif (indentSize > 99)\n \t\t\t\tindentSize = 99;\n-\t\t\tsprintf(tmp, \"%d\", indentSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDINDENTSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDINDENTSIZE, indentSize, FALSE);\n \n \t\t\t::CheckDlgButton(hDlg, IDUSETABS, wEditor.Call(SCI_GETUSETABS));\n \t\t\treturn TRUE;\n", "fix_pattern": "<pattern>: if there is a need to set an integer value to a dialog item using a string conversion via sprintf and then SetDlgItemTextA, replace it with a direct call to SetDlgItemInt for better performance, avoiding unnecessary string formatting."}
{"number": 201, "change": "@@ -482,15 +482,13 @@ void dprintf(const char *format, ...)\n {\n #if DEBUG\n     va_list ap;\n-\tchar\t*buffer;\n+\tStr255 buffer;\n \t\n \tva_start(ap, format);\n-\tbuffer = PR_vsmprintf(format, ap);\n+\tbuffer[0] = PR_vsnprintf((char *)buffer + 1, sizeof(buffer) - 1, format, ap);\n \tva_end(ap);\n \t\n-\tc2pstr(buffer);\n-\tDebugStr( (unsigned char *)buffer);\n-\tfree(buffer);\n+\tDebugStr(buffer);\n #endif /* DEBUG */\n }\n \n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a buffer (e.g., via PR_vsmprintf and subsequent free), replace it with a statically sized buffer (e.g., Str255) using PR_vsnprintf to eliminate the overhead of heap allocation and deallocation."}
{"number": 204, "change": "@@ -230,8 +230,10 @@ nsresult nsCollationMac::CreateRawSortKey(const nsCollationStrength strength,\n     }\n     else {\n       // No CJK support, just copy the row string.\n-      strcpy((char *) key, str);\n-      while (*key) {\n+      // Collation key is not a string, use memcpy instead of strcpy.\n+      nsCRT::memcpy(key, str, str_len);\n+      PRUint8 *end = key + str_len;\n+      while (key < end) {\n         if ((unsigned char) *key < 128) {\n           key++;\n         }\n", "fix_pattern": "<pattern>: if a string is being copied to a buffer where the length is known, replace strcpy with memcpy to eliminate null-termination overhead and improve performance."}
{"number": 205, "change": "@@ -365,7 +365,7 @@ ns4xPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,\n       amountRead -= writeCount;\n       mPosition += writeCount;\n       if (amountRead > 0)\n-        strncpy(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n+        memmove(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n     }\n   }\n \n", "fix_pattern": "<pattern>: if a memory block is being shifted within a buffer, replace `strncpy` with `memmove` to properly handle overlapping memory regions, improving safety and performance."}
{"number": 208, "change": "@@ -152,9 +152,8 @@ void Pass::match(Plasma::RunnerContext &context)\n     QList<Plasma::QueryMatch> matches;\n \n     lock.lockForRead();\n-    QRegularExpression re(\".*\" + input + \".*\", QRegularExpression::CaseInsensitiveOption);\n     for (const auto& password: passwords) {\n-        if (re.match(password).hasMatch()) {\n+        if (password.contains(input,Qt::CaseInsensitive)) {\n             Plasma::QueryMatch match(this);\n             match.setType(input.length() == password.length() ?\n                 Plasma::QueryMatch::ExactMatch : Plasma::QueryMatch::CompletionMatch);\n", "fix_pattern": "<pattern>: if a QRegularExpression is used to perform a match on a QString, replace it with QString's built-in contains method for better performance as it avoids regex overhead."}
{"number": 214, "change": "@@ -182,12 +182,12 @@ void PaymentServerTests::paymentServerTests()\n     QCOMPARE(PaymentServer::verifyExpired(r.paymentRequest.getDetails()), true);\n \n     // Test BIP70 DoS protection:\n-    unsigned char randData[BIP70_MAX_PAYMENTREQUEST_SIZE + 1];\n-    GetRandBytes(randData, sizeof(randData));\n+    auto randdata = FastRandomContext().randbytes(BIP70_MAX_PAYMENTREQUEST_SIZE + 1);\n+\n     // Write data to a temp file:\n     QTemporaryFile tempFile;\n     tempFile.open();\n-    tempFile.write((const char*)randData, sizeof(randData));\n+    tempFile.write((const char*)randdata.data(), randdata.size());\n     tempFile.close();\n     // compares 50001 <= BIP70_MAX_PAYMENTREQUEST_SIZE == false\n     QCOMPARE(PaymentServer::verifySize(tempFile.size()), false);\n", "fix_pattern": "<pattern>: if using a direct buffer approach for generating random bytes and writing them to a file, switch to a higher-level abstraction that combines randomness generation and data management (e.g., using FastRandomContext with std::vector for automatic memory handling) for improved performance and safety."}
{"number": 215, "change": "@@ -14,6 +14,7 @@\n #define TRGCDC_SHORT_NAMES\n \n #include <math.h>\n+#include <TRandom.h>\n #include <iostream>\n #include <fstream>\n #include \"framework/datastore/StoreArray.h\"\n@@ -1030,7 +1031,7 @@ namespace Belle2 {\n       //...Loop over CDCHits...\n       for (unsigned i = 0; i < nHits; i++) {\n         const CDCHit& h = *CDCHits[i];\n-        double tmp = rand() / (double(RAND_MAX));\n+        double tmp = gRandom->Uniform(0.0, 1.0) / (double(RAND_MAX));\n         if (tmp < _inefficiency)\n           continue;\n \n", "fix_pattern": "<pattern>: if random number generation is performed using the standard C++ `rand()` function, switch to using `gRandom->Uniform(min, max)` from the ROOT TRandom class for improved performance and better statistical properties in scientific computing contexts."}
{"number": 219, "change": "@@ -21,6 +21,7 @@ using namespace Cicada;\n #define RINGBUFFER_BACK_SIZE 1024*512\n \n #define MIN_SO_RCVBUF_SIZE 1024*64\n+#define READ_BUFFER_SIZE 1024 * 64\n \n #define SOCKET_ERROR (-1)\n \n@@ -384,7 +385,7 @@ int Cicada::CURLConnection::esayHandle_set_common_opt()\n     curl_easy_setopt(mHttp_handle, CURLOPT_DEBUGDATA, this);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERFUNCTION, write_response);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERDATA, this);\n-    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, CURL_MAX_READ_SIZE);\n+    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, READ_BUFFER_SIZE);\n     return 0;\n }\n \n", "fix_pattern": "<pattern>: if the CURLOPT_BUFFERSIZE is set directly with a constant, replace it with a defined constant value that represents a more suitable buffer size for performance optimization."}
{"number": 222, "change": "@@ -127,8 +127,8 @@ bool fetch_mod(wchar_t *version) {\n \t}\n \tFILE *out = NULL;\n \tcurl_easy_setopt(curl, CURLOPT_URL, fetch_url_utf8);\n-\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 3200L);\n-\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 40000L);\n+\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 2000L);\n+\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 20000L);\n \tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);\n \tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);\n \tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n", "fix_pattern": "<pattern>: if there is a need to improve performance related to network timeouts in a curl request, consider adjusting timeout values to lower settings that do not compromise functionality; this can reduce the time spent waiting for network operations to complete, enhancing responsiveness."}
{"number": 225, "change": "@@ -68,16 +68,16 @@ QString EwsMailHandler::mimeType()\n bool EwsMailHandler::setItemPayload(Akonadi::Item &item, const EwsItem &ewsItem)\n {\n     qDebug() << \"EwsMailHandler::setItemPayload\";\n-    QString mimeContent = ewsItem[EwsItemFieldMimeContent].toString();\n+    QByteArray mimeContent = ewsItem[EwsItemFieldMimeContent].toByteArray();\n     if (mimeContent.isEmpty()) {\n         qWarning() << QStringLiteral(\"MIME content is empty!\");\n         return false;\n     }\n \n-    mimeContent.replace(QStringLiteral(\"\\r\\n\"), QStringLiteral(\"\\n\"));\n+    mimeContent.replace(\"\\r\\n\", \"\\n\");\n \n     KMime::Message::Ptr msg(new KMime::Message);\n-    msg->setContent(mimeContent.toLatin1());\n+    msg->setContent(mimeContent);\n     msg->parse();\n     qDebug() << msg->attachments().size() << \"attachments\";\n     // Some messages might just be empty (just headers). This results in the body being empty.\n", "fix_pattern": "<pattern>: if a QString is converted to a byte array using toString and then later converted to a QByteArray with toLatin1, refactor the code to directly use toByteArray for better performance and to eliminate unnecessary conversions."}
{"number": 227, "change": "@@ -261,7 +261,7 @@ void pqColorMapEditor::setColorTransferFunction(vtkSMProxy* ctf)\n   this->Internals->ProxyWidget = widget;\n   this->updatePanel();\n \n-  QObject::connect(widget, SIGNAL(changeFinished()), this, SLOT(updateIfNeeded()));\n+  QObject::connect(widget, SIGNAL(changeAvailable()), this, SLOT(updateIfNeeded()));\n }\n \n //-----------------------------------------------------------------------------\n", "fix_pattern": "<pattern>: NA"}
{"number": 228, "change": "@@ -1,4 +1,4 @@\n-/* Copyright (c) 2019-2023, Arm Limited and Contributors\n+/* Copyright (c) 2019-2024, Arm Limited and Contributors\n  *\n  * SPDX-License-Identifier: Apache-2.0\n  *\n@@ -58,6 +58,10 @@ void LightingSubpass::draw(CommandBuffer &command_buffer)\n \tauto &pipeline_layout = resource_cache.request_pipeline_layout(shader_modules);\n \tcommand_buffer.bind_pipeline_layout(pipeline_layout);\n \n+\t// we know, that the lighting subpass does not have any vertex stage input -> reset the vertex input state\n+\tassert(pipeline_layout.get_resources(ShaderResourceType::Input, VK_SHADER_STAGE_VERTEX_BIT).empty());\n+\tcommand_buffer.set_vertex_input_state({});\n+\n \t// Get image views of the attachments\n \tauto &render_target = get_render_context().get_active_frame().get_render_target();\n \tauto &target_views  = render_target.get_views();\n", "fix_pattern": "<pattern>: if a vertex input state is set after asserting that no vertex stage input resources are present, ensure that the assertion is checked before setting the vertex input state to optimize potential errors in graphics pipeline configuration."}
{"number": 231, "change": "@@ -13,7 +13,6 @@\n #include <arpa/inet.h>\n #include <assert.h>\n #include <errno.h>\n-#include <fcntl.h>\n #include <inttypes.h>\n #include <netinet/in.h>\n #include <poll.h>\n@@ -123,12 +122,10 @@ static void await_debugger(struct GdbContext* dbg, ScopedFd& listen_fd) {\n   struct sockaddr_in client_addr;\n   socklen_t len = sizeof(client_addr);\n \n-  dbg->sock_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &len);\n+  dbg->sock_fd =\n+      accept4(listen_fd, (struct sockaddr*)&client_addr, &len, SOCK_NONBLOCK);\n   // We might restart this debugging session, so don't set the\n   // socket fd CLOEXEC.\n-  if (fcntl(dbg->sock_fd, F_SETFL, O_NONBLOCK)) {\n-    FATAL() << \"Can't make client socket NONBLOCK\";\n-  }\n }\n \n struct debugger_params {\n", "fix_pattern": "<pattern>: if the accept method is called and the socket needs to be set to non-blocking mode afterwards, replace it with accept4 which allows setting the socket to non-blocking mode in a single call for better performance."}
{"number": 232, "change": "@@ -85,7 +85,7 @@ static ScopedFd create_memfd_file(const string& orig_path, dev_t orig_device,\n        << \"-inode-\" << orig_inode << \"-\" << orig_path;\n   real_name = name.str().substr(0, 255);\n \n-  ScopedFd fd = memfd_create(real_name.c_str(), 0);\n+  ScopedFd fd = syscall(SYS_memfd_create, real_name.c_str(), 0);\n   return fd;\n }\n \n", "fix_pattern": "<pattern>: if the code uses a higher-level API function like memfd_create that incurs additional overhead due to abstraction, refactor it to directly use the syscall interface for better performance by reducing function call overhead and leveraging lower-level operations directly."}
{"number": 240, "change": "@@ -1,5 +1,5 @@\n /*\n-   Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.\n+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -1307,7 +1307,7 @@ TransporterFacade::close_clnt(trp_client* clnt)\n         clnt->do_forceSend(1);\n         first = false;\n       }\n-      clnt->do_poll(0);\n+      clnt->do_poll(10);\n       not_finished = (m_threads.get(clnt->m_blockNo) == clnt);\n       clnt->complete_poll();\n     } while (not_finished);\n", "fix_pattern": "<pattern>: if the timeout parameter for an API method is set to zero, which may result in the method to be non-blocking and potentially lead to busy-waiting, adjust the timeout to a positive value to allow for more efficient waiting (e.g., using a sleep mechanism) which can enhance performance in scenarios with polling."}
{"number": 241, "change": "@@ -6112,7 +6112,6 @@ void* background_thread(void*)\n   mysql_mutex_lock(&background_mutex);\n   mysql_mutex_lock(&stop_cond_mutex);\n \n-  rocksdb::WriteBatch wb;\n   time_t last_stat_recompute = 0;\n   for (;;)\n   {\n@@ -6128,9 +6127,8 @@ void* background_thread(void*)\n     assert(ret == 0 || ret == ETIMEDOUT);\n \n     if (rdb && rocksdb_background_sync) {\n-      auto wo = rocksdb::WriteOptions();\n-      wo.sync = true;\n-      rocksdb::Status s= rdb->Write(wo, &wb);\n+      assert(!db_options.allow_mmap_writes);\n+      rocksdb::Status s= rdb->SyncWAL();\n       if (!s.ok())\n         rocksdb_handle_io_error(s, ROCKSDB_IO_ERROR_BG_THREAD);\n     }\n", "fix_pattern": "<pattern>: if a write operation is performed with `rocksdb::Write`, and it is determined that write-ahead logging (WAL) should be synchronized without custom write options, replace the write operation with `rocksdb::DB::SyncWAL()` for improved performance, especially when synchronous writes are unnecessary. This change also removes complexity from write options and directly manages the log synchronization."}
{"number": 242, "change": "@@ -41,10 +41,10 @@ double HkIClientImpl::CDPClientProxy__GetLinkSaturation(uint iClientID)\n \t// ISERVER_LOGARG_UI(iClientID);\n \n \tchar *tmp; \n-\tWriteProcMem(&tmp, &Client, 4); \n-\tWriteProcMem(&Client, &OldClient, 4); \n+\tmemcpy(&tmp, &Client, 4);\n+\tmemcpy(&Client, &OldClient, 4);\n \tdouble dRet = HookClient->CDPClientProxy__GetLinkSaturation(iClientID); \n-\tWriteProcMem(&Client, &tmp, 4); \n+\tmemcpy(&Client, &tmp, 4);\n \n \treturn dRet;\n }\n", "fix_pattern": "<pattern>: if multiple calls to a memory writing API (in this case WriteProcMem) are detected for copying fixed-size blocks of memory, replace them with calls to memcpy for better performance and reduced overhead."}
{"number": 255, "change": "@@ -21,6 +21,7 @@\n  */\n \n #include \"firebird.h\"\n+#include \"../common/classes/Aligner.h\"\n #include \"../common/classes/Hash.h\"\n #include \"../jrd/jrd.h\"\n #include \"../jrd/req.h\"\n@@ -525,8 +526,8 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\tif (desc->isDecFloat())\n \t\t\t\t{\n \t\t\t\t\t// Values inside our key buffer are not aligned,\n-\t\t\t\t\t// hence we need to use intermediate storage for makeKey()\n-\t\t\t\t\tULONG key[MAX_DEC_KEY_LONGS];\n+\t\t\t\t\t// so ensure we satisfy our platform's alignment rules\n+\t\t\t\t\tOutAligner<ULONG, MAX_DEC_KEY_LONGS> key(keyPtr, keyLength);\n \n \t\t\t\t\tif (desc->dsc_dtype == dtype_dec64)\n \t\t\t\t\t\t((Decimal64*) data)->makeKey(key);\n@@ -534,9 +535,6 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\t\t\t((Decimal128*) data)->makeKey(key);\n \t\t\t\t\telse\n \t\t\t\t\t\tfb_assert(false);\n-\n-\t\t\t\t\tfb_assert(keyLength <= sizeof(key));\n-\t\t\t\t\tmemcpy(keyPtr, key, keyLength);\n \t\t\t\t}\n \t\t\t\telse if (desc->dsc_dtype == dtype_real && *(float*) data == 0)\n \t\t\t\t{\n", "fix_pattern": "<pattern>: if `memcpy` is used to copy data to `keyPtr`, refactor the code to use a specialized alignment-aware class (e.g., `OutAligner`) that ensures proper handling of memory alignment constraints for the platform, improving performance and safety."}
{"number": 257, "change": "@@ -419,9 +419,7 @@ int vfsLoadFile( const char *filename, void **bufferptr, int index ){\n \t\t}\n \n \t\tif ( count == index ) {\n-\t\t\tstrcpy( g_strLoadedFileLocation, file->unzFilePath );\n-\t\t\tstrcat( g_strLoadedFileLocation, \" :: \" );\n-\t\t\tstrcat( g_strLoadedFileLocation, filename );\n+\t\t\tsnprintf( g_strLoadedFileLocation, sizeof( g_strLoadedFileLocation ), \"%s :: %s\", file->unzFilePath, filename );\n \n \t\t\tmemcpy( file->zipfile, &file->zipinfo, sizeof( unz_s ) );\n \n", "fix_pattern": "<pattern>: if multiple string concatenations using strcpy and strcat are detected, refactor the code to use snprintf for a single, more efficient string formatting operation, which also prevents buffer overflows."}
{"number": 258, "change": "@@ -158,7 +158,7 @@ buffer_washer(char * buff, int buffer_len)\n \n     for (i = 0 ; i < buffer_len - 1; i++) {\n \tif (buff[i] == '\\0') {\n-\t    memcpy(&buff[i], &buff[i+1], buffer_len - i);\n+\t    memmove(&buff[i], &buff[i+1], buffer_len - i);\n \t    buffer_len--;\n \t    buff[buffer_len] = '\\0';\n \t}\n", "fix_pattern": "<pattern>: if overlapping memory regions are involved in a copy operation, replace memcpy with memmove to ensure safe handling of overlapping areas."}
{"number": 261, "change": "@@ -34,7 +34,7 @@ const Kernel::FT volume( const Solid& solid, NoValidityCheck )\n     const CGAL::Point_3<Kernel> origin(0,0,0);\n     const size_t numShells = solid.numShells();\n     for (size_t i=0; i<numShells; i++) {\n-        std::auto_ptr<Geometry> t( tesselate( solid.shellN(i) ) );\n+\t    std::auto_ptr<Geometry> t( tesselate( solid.shellN(i), NoValidityCheck() ) );\n         const TriangulatedSurface& tin = t->as<TriangulatedSurface>();\n         const size_t numTriangles = tin.numTriangles();\n         for (size_t j=0; j<numTriangles; j++) {\n", "fix_pattern": "<pattern>: if an API call to `tesselate` is made without a validity check and there exists an overload for `tesselate` that allows skipping the validity check for performance improvements, refactor the call to utilize that overload by passing `NoValidityCheck()`."}
{"number": 274, "change": "@@ -368,10 +368,8 @@ void CPNGFile::WaitForSaves()\n \t\tfirst = false;\n #ifdef HAVE_WINTHREAD\n \t\tSleep(100);\n-#elif defined (__APPLE__)\n+#else\n \t\tsched_yield();\n-#elif defined(HAVE_PTHREAD)\n-\t\tpthread_yield();\n #endif\n \t}\n }\n", "fix_pattern": "<pattern>: if there is a conditional branch for a specific platform that includes a call to `pthread_yield()`, then refactor it to eliminate the call in favor of a more generalized fallback without the platform-specific behavior."}
{"number": 291, "change": "@@ -147,10 +147,10 @@ PyObject *slotCall(PyObject *self, PyObject *args, PyObject * /* kw */)\n             data->slotName = strdup(Shiboken::String::toCString(funcName));\n         }\n \n-\n-        QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n-        QByteArray signature = QString().sprintf(\"%s(%s)\", data->slotName, data->args).toUtf8();\n-        signature = returnType + \" \" + signature;\n+        const QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n+        const QByteArray signature =\n+            returnType + ' ' + const_cast<const char *>(data->slotName)\n+            + '(' + const_cast<const char *>(data->args) + ')';\n \n         if (!pySlotName)\n             pySlotName = Shiboken::String::fromCString(PYSIDE_SLOT_LIST_ATTR);\n", "fix_pattern": "<pattern>: if QByteArray is being constructed multiple times from QString while using sprintf, replace it with direct QByteArray concatenation to avoid unnecessary conversions and improve performance. Additionally, use const correctness to avoid unnecessary copies."}
{"number": 292, "change": "@@ -110,11 +110,8 @@ int main(int argc, char ** argv)\n \t\tif (argc != 1)\n \t\t\tthrow std::runtime_error(i18n(\"no document specified\"));\n \n-\t\tcainteoir::document_events events;\n \t\trdf::graph metadata;\n-\t\tif (!cainteoir::parseDocument(argv[0], events, metadata))\n-\t\t\tfprintf(stderr, i18n(\"unsupported document format for file \\\"%s\\\"\\n\"), argv[0]);\n-\n+\t\tauto reader = cainteoir::createDocumentReader(argv[0], metadata, std::string());\n \t\tif (!metadata.empty())\n \t\t{\n \t\t\tif (output_type == rdf_metadata)\n", "fix_pattern": "<pattern>: if an API method (`cainteoir::parseDocument`) that processes files is replaced by a different method (`cainteoir::createDocumentReader`) that may offer better performance or efficiency, identify that the change signifies a shift towards a potentially more optimized API call for handling document reading while maintaining the context associated with the operation."}
{"number": 297, "change": "@@ -254,7 +254,7 @@ QSSGShaderCache::QSSGShaderCache(QSSGRhiContext &ctx,\n         m_persistentShaderStorageFileName = persistentQsbcFileName();\n         if (!m_persistentShaderStorageFileName.isEmpty()) {\n             const bool skipCacheFile = qEnvironmentVariableIntValue(\"QT_QUICK3D_NO_SHADER_CACHE_LOAD\");\n-            if (!skipCacheFile && QFileInfo(m_persistentShaderStorageFileName).exists()) {\n+            if (!skipCacheFile && QFileInfo::exists(m_persistentShaderStorageFileName)) {\n                 if (shaderDebug)\n                     qDebug(\"Attempting to seed material shader cache from %s\", qPrintable(m_persistentShaderStorageFileName));\n                 if (m_persistentShaderBakingCache.load(m_persistentShaderStorageFileName)) {\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is created just to check for file existence, replace it with a static method call QFileInfo::exists for better performance."}
{"number": 308, "change": "@@ -194,7 +194,7 @@ uint32_t scap_fd_info_len(scap_fdinfo *fdi)\n \t\tres += \n \t\t\tsizeof(uint64_t) + // unix source \n \t\t\tsizeof(uint64_t) +  // unix destination\n-\t\t\t(uint32_t)strlen(fdi->info.unix_socket_info.fname) + 2;\n+\t\t\t(uint32_t)strnlen(fdi->info.unix_socket_info.fname, SCAP_MAX_PATH_SIZE) + 2;\n \t\tbreak;\n \tcase SCAP_FD_FIFO:\n \tcase SCAP_FD_FILE:\n", "fix_pattern": "<pattern>: if the code uses strlen with an input that might exceed a specific maximum size, replace it with strnlen to prevent potential buffer over-read and improve safety."}
{"number": 309, "change": "@@ -499,12 +499,12 @@ void handleAccessMemory(void *arg, Sift::MemoryLockType lock_signal, Sift::Memor\n    if (mem_op == Sift::MemRead)\n    {\n       // The simulator is requesting data from us\n-      memcpy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n+      PIN_SafeCopy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n    }\n    else if (mem_op == Sift::MemWrite)\n    {\n       // The simulator is requesting that we write data back to memory\n-      memcpy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n+      PIN_SafeCopy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n    }\n    else\n    {\n", "fix_pattern": "<pattern>: if a direct memory copy using memcpy is detected, replace it with a specialized third-party API method (e.g., PIN_SafeCopy) that is designed for more efficient or safer handling of memory operations in the context of the application (e.g., ensuring safety when dealing with instrumentation in a Pin-based environment)."}
{"number": 310, "change": "@@ -114,7 +114,7 @@ int init_SDL(void)\n         fprintf(stderr, \"Unable to init SDL: %s\\n\", SDL_GetError());\n         return(0);\n     }\n-    sdlscreen = SDL_SetVideoMode(0,0, 32, SDL_SWSURFACE);\n+    sdlscreen = SDL_SetVideoMode(0,0, 16, SDL_SWSURFACE);\n \n     SDL_JoystickEventState(SDL_ENABLE);\n \tmyjoy[0]=SDL_JoystickOpen(0);\n", "fix_pattern": "<pattern>: when modifying the bit depth parameter (bpp) for SDL_SetVideoMode, reducing it from 32 to 16 can enhance performance by decreasing memory usage and potentially increasing rendering speed, especially in scenarios where high color depth is not necessary."}
{"number": 311, "change": "@@ -70,11 +70,16 @@ perf (bool decode)\n   double t = get_time();\n   for (int r = 0; r < RUNS; r++)\n     {\n-      notify_buffer.clear();\n+      bool write_ok = notify_buffer.start_write();\n+      assert (write_ok);\n       for (int i = 0; i < EVENTS; i++)\n         {\n           fill_notify_buffer (notify_buffer);\n         }\n+      notify_buffer.end_write();\n+\n+      bool read_ok = notify_buffer.start_read();\n+      assert (read_ok);\n       if (decode)\n         {\n           while (notify_buffer.remaining())\n@@ -84,6 +89,7 @@ perf (bool decode)\n               delete e;\n             }\n         }\n+      notify_buffer.end_read();\n     }\n   printf (\"%.2f events/sec (decode = %s)\\n\", (EVENTS * RUNS) / (get_time() - t), decode ? \"TRUE\" : \"FALSE\");\n }\n", "fix_pattern": "<pattern>: if a call to `notify_buffer.clear()` is replaced with `notify_buffer.start_write()` and `notify_buffer.end_write()`, indicating a performance improvement by using a write operation that likely aggregates and clears the buffer more efficiently than the clear operation did, then adopt that approach for managing the state of the buffer."}
{"number": 318, "change": "@@ -102,9 +102,9 @@ change_alpha( ssgBase *_branch, float _blend )\n   for (i = 0; i < ((ssgBranch *)_branch)->getNumKids(); i++)\n     change_alpha( ((ssgBranch *)_branch)->getKid(i), _blend );\n \n-  if ( strcmp(\"ssgLeaf\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVtxTable\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVTable\", _branch->getTypeName()) )\n+  if ( !_branch->isAKindOf(ssgTypeLeaf())\n+       && !_branch->isAKindOf(ssgTypeVtxTable())\n+       && !_branch->isAKindOf(ssgTypeVTable()) )\n     return;\n \n   int num_colors = ((ssgLeaf *)_branch)->getNumColours();\n", "fix_pattern": "<pattern>: if multiple `strcmp` calls are used to check the type of an object, replace them with a single call to `isAKindOf` for each type, allowing for better performance and readability by avoiding unnecessary string comparisons and leveraging type checking directly."}
{"number": 321, "change": "@@ -7,6 +7,7 @@\n #pragma once\n \n #include <sys/types.h> // for u_char\n+#include <zeek/util.h>\n #include <cstdint>\n #include <cstdio>\n \n@@ -41,7 +42,8 @@ enum HashAlgorithm { Hash_MD5, Hash_SHA1, Hash_SHA224, Hash_SHA256, Hash_SHA384,\n inline const char* digest_print(const u_char* digest, size_t n) {\n     static char buf[ZEEK_DIGEST_PRINT_LENGTH];\n     for ( size_t i = 0; i < n; ++i )\n-        snprintf(buf + i * 2, 3, \"%02x\", digest[i]);\n+        zeek::util::bytetohex(digest[i], &buf[i * 2]);\n+    buf[2 * n] = '\\0';\n     return buf;\n }\n \n", "fix_pattern": "<pattern>: if snprintf is used to format binary data to hexadecimal strings, replace it with a specialized utility function (zeek::util::bytetohex) that may provide optimized performance for this specific conversion."}
{"number": 324, "change": "@@ -161,15 +161,13 @@ void MainWindow::InitializeUi() {\n }\n \n void MainWindow::ExpandCollapse(TreeState state) {\n-    // if it's connected during the call it's called for every item apparently, which is damn slow!\n-    disconnect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    disconnect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    // we block signals so that ResizeTreeColumns isn't called for every item, which is damn slow!\n+    ui->treeView->blockSignals(true);\n     if (state == TreeState::kExpand)\n         ui->treeView->expandAll();\n     else\n         ui->treeView->collapseAll();\n-    connect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    connect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    ui->treeView->blockSignals(false);\n \n     ResizeTreeColumns();\n }\n", "fix_pattern": "<pattern>: if multiple disconnect and connect calls are made around a function that can be slow if called repeatedly (like ResizeTreeColumns), use blockSignals to prevent the signal from triggering during a performance-critical operation to improve efficiency."}
{"number": 332, "change": "@@ -399,7 +399,8 @@ int main(int argc, char* argv[])\n                                 first = false;\n                             else\n                                 argument_builder.append(\", \"sv);\n-                            argument_builder.append(StringView(stream.copy_into_contiguous_buffer()).trim_whitespace());\n+                            ByteBuffer buffer = stream.copy_into_contiguous_buffer();\n+                            argument_builder.append(StringView(buffer).trim_whitespace());\n                         }\n                         dbgln(\"[wasm runtime] Stub function {} was called with the following arguments: {}\", name, argument_builder.to_string());\n                         Vector<Wasm::Value> result;\n", "fix_pattern": "<pattern>: if an API call is made to copy data into a contiguous buffer inline, separate that call into its own variable before using it, which can improve readability and potentially optimize performance by reducing unnecessary copies and exposing optimization opportunities."}
{"number": 334, "change": "@@ -122,8 +122,8 @@ void Job::on_socket_connected()\n                 }\n             }\n \n-            m_received_buffers.append(payload);\n             m_received_size += payload.size();\n+            m_received_buffers.append(move(payload));\n             flush_received_buffers();\n \n             deferred_invoke([this] { did_progress({}, m_received_size); });\n", "fix_pattern": "<pattern>: if an object is appended to a container in a manner that can lead to unnecessary copies, use std::move to transfer ownership and improve performance."}
{"number": 343, "change": "@@ -63,9 +63,12 @@ public:\n     {\n         VERIFY(!ivec.is_empty());\n \n-        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(out.size()));\n+        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(T::BlockSizeInBits / 8));\n \n-        encrypt(in, out, ivec, dummy, dummy);\n+        // FIXME: Taking `out` by reference suggests that we should modify its length to match the\n+        //        ciphertext size. In practice, however, noone does that and I don't want to be the\n+        //        person who fixes this.\n+        encrypt(in, out.slice(0, in.size()), ivec, dummy, dummy);\n     }\n     virtual void decrypt(ReadonlyBytes in, Bytes& out, ReadonlyBytes ivec = {}) override\n     {\n", "fix_pattern": "<pattern>: if a ByteBuffer is created with its size determined by the `out` buffer which may vary in size, instead statically allocate a ByteBuffer of fixed size using known constants to optimize performance by avoiding dynamic size calculation during each call."}
{"number": 346, "change": "@@ -101,7 +101,7 @@ bool AdminDatabase::ValidPassword(const char *username, const char *password)\n     QByteArray passb = m_prepared_select_account_passw.value(\"passw\").toByteArray();\n     QByteArray salt = m_prepared_select_account_passw.value(\"salt\").toByteArray();\n     QByteArray hashed_password = hasher.hashPassword(password, salt);\n-    if (memcmp(passb.data(),hashed_password.data(),passb.size()) == 0)\n+    if (memcmp(passb,hashed_password,passb.size()) == 0)\n         res = true;\n     return res;\n }\n", "fix_pattern": "<pattern>: if the data() method is used to retrieve raw data from a QByteArray for comparison with memcmp, directly pass the QByteArray objects to memcmp instead, optimizing performance by eliminating unnecessary calls to data() and improving type coherence."}
{"number": 354, "change": "@@ -5491,7 +5491,7 @@ static void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {\n     }\n \n     /* read keys to be used for input */\n-    src = malloc(sizeof(zsetopsrc) * zsetnum);\n+    src = zmalloc(sizeof(zsetopsrc) * zsetnum);\n     for (i = 0, j = 3; i < zsetnum; i++, j++) {\n         robj *zsetobj = lookupKeyWrite(c->db,c->argv[j]);\n         if (!zsetobj) {\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, replace it with a project-specific memory allocation function (e.g., zmalloc) for better performance and potential benefits such as memory tracking or improved allocation strategies specific to the project."}
{"number": 359, "change": "@@ -1584,7 +1584,7 @@ static redisReply *sendScan(unsigned long long *it) {\n     assert(reply->element[1]->type == REDIS_REPLY_ARRAY);\n \n     /* Update iterator */\n-    *it = atoi(reply->element[0]->str);\n+    *it = strtoull(reply->element[0]->str, NULL, 10);\n \n     return reply;\n }\n", "fix_pattern": "<pattern>: if converting a string to an integer, replace atoi with strtoull for better performance and to avoid potential overflow issues, as strtoull handles larger values and is more precise in conversion."}
{"number": 364, "change": "@@ -498,8 +498,13 @@ void Battlenet::Session::HandleJoinRequestV2(WoWRealm::JoinRequestV2 const& join\n \n     memcpy(sessionKey + hmac.GetLength(), hmac2.GetDigest(), hmac2.GetLength());\n \n-    LoginDatabase.DirectPExecute(\"UPDATE account SET sessionkey = '%s', last_ip = '%s', last_login = NOW(), locale = %u, failed_logins = 0, os = '%s' WHERE id = %u\",\n-        ByteArrayToHexStr(sessionKey, 40, true).c_str(), GetRemoteIpAddress().to_string().c_str(), GetLocaleByName(_locale), _os.c_str(), _gameAccountInfo->Id);\n+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_LOGONPROOF);\n+    stmt->setString(0, ByteArrayToHexStr(sessionKey, 40, true).c_str());\n+    stmt->setString(1, GetRemoteIpAddress().to_string());\n+    stmt->setUInt32(2, GetLocaleByName(_locale));\n+    stmt->setString(3, _os);\n+    stmt->setString(4, _gameAccountInfo->Name);\n+    LoginDatabase.DirectExecute(stmt);\n \n     joinResponse->IPv4.emplace_back(*realm->ExternalAddress, realm->Port);\n     if (*realm->ExternalAddress != *realm->LocalAddress)\n", "fix_pattern": "<pattern>: if raw SQL queries are being constructed and executed directly, replace them with prepared statements to improve performance and security by avoiding SQL injection and allowing the database engine to optimize query execution."}
{"number": 365, "change": "@@ -887,7 +887,7 @@ class Simplex_tree {\n     while (true) {\n       if (begin1->first == begin2->first) {\n         Filtration_value filt = (std::max)({begin1->second.filtration(), begin2->second.filtration(), filtration_});\n-        intersection.push_back(std::pair<Vertex_handle, Node>(begin1->first, Node(NULL, filt)));\n+        intersection.emplace_back(begin1->first, Node(NULL, filt));\n         if (++begin1 == end1 || ++begin2 == end2)\n           return;  // ----->>\n       } else if (begin1->first < begin2->first) {\n", "fix_pattern": "<pattern>: if std::vector's push_back is used to create a new object that could be constructed in place, replace it with emplace_back to avoid unnecessary copy or move operations, improving performance."}
{"number": 367, "change": "@@ -226,7 +226,7 @@ bool Info::Read(XrdOssDF* fp, const std::string &fname)\n       for (int i =0; i < 16; ++i)\n       printf(\"%x\", m_store.m_cksum[i] & 0xff);\n     */\n-   if (strncmp(m_store.m_cksum, &tmpCksum[0], 16))\n+   if (memcmp(m_store.m_cksum, &tmpCksum[0], 16))\n    {\n       TRACE(Error, trace_pfx << \" buffer cksum and saved cksum don't match \\n\");\n       return false;\n", "fix_pattern": "<pattern>: if a comparison of two byte sequences is performed using strncmp, replace it with memcmp for improved performance, as memcmp is optimized for binary comparison and avoids string-specific nuances."}
{"number": 368, "change": "@@ -74,10 +74,9 @@ bool State::InstallHandlers(CURL *curl) {\n     // Older versions have poor transfer performance, corrected in curl commit cacdc27f.\n     curl_version_info_data *curl_ver = curl_version_info(CURLVERSION_NOW);\n     if (curl_ver->age > 0 && curl_ver->version_num >= 0x072600) {\n-        // Require a minimum speed from the transfer: must move at least 1MB every 2 minutes\n-        // (roughly 8KB/s).\n+        // Require a minimum speed from the transfer: 2 minute average must at least 10KB/s\n         curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 2*60);\n-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1024*1024);\n+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 10*1024);\n     }\n     return true;\n }\n", "fix_pattern": "<pattern>: if CURLOPT_LOW_SPEED_LIMIT is being set, adjust the limit calculation to a more appropriate value that reflects performance expectations, ensuring the speed requirement aligns with bytes per second rather than total bytes over an extended period."}
{"number": 369, "change": "@@ -1579,10 +1579,11 @@ int XrdHttpProtocol::StartChunkedResp(int code, const char *desc, const char *he\n /******************************************************************************/\n   \n int XrdHttpProtocol::ChunkResp(const char *body, long long bodylen) {\n-  if (ChunkRespHeader((bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen))\n+  long long content_length = (bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen;\n+  if (ChunkRespHeader(content_length))\n     return -1;\n \n-  if (body && SendData(body, bodylen))\n+  if (body && SendData(body, content_length))\n     return -1;\n \n   return ChunkRespFooter();\n", "fix_pattern": "<pattern>: if the content length is calculated multiple times from the provided arguments, store the result in a variable to avoid redundant calculations, improving readability and potential performance due to less computation."}
{"number": 371, "change": "@@ -35,8 +35,7 @@ IceInternal::BasicOutputStream::BasicOutputStream(IceInternal::Instance* instanc\n Ice::InputStreamI::InputStreamI(const Ice::CommunicatorPtr& communicator, const vector<Byte>& data) :\n     _communicator(communicator), _is(IceInternal::getInstance(communicator).get(), this)\n {\n-    _is.b.resize(data.size());\n-    memcpy(&_is.b[0], &data[0], data.size());\n+    _is.writeBlob(data);\n     _is.i = _is.b.begin();\n }\n \n", "fix_pattern": "<pattern>: if a vector is resized and then populated using memcpy, replace the combination with a call to a more optimized method such as writeBlob(), which likely has internal optimizations for handling the data directly."}
{"number": 372, "change": "@@ -320,7 +320,7 @@ QList<QString> TessTools::getLanguages(QString datapath) {\n       QFileInfo fileInfo = list.at(i);\n       languages.append(QString(\"%1\").arg(fileInfo.baseName()));\n     }\n-    qSort(languages);\n+    std::sort(languages.begin(), languages.end());\n \n     return languages;\n }\n", "fix_pattern": "<pattern>: if the code is using qSort from the Qt library, replace it with std::sort from the Standard Library for better performance and compatibility with C++ algorithms."}
{"number": 382, "change": "@@ -139,7 +139,10 @@ const char *AGSLinux::GetAppOutputDirectory()\n }\n \n void AGSLinux::Delay(int millis) {\n-  usleep(millis);\n+  struct timespec ts;\n+  ts.tv_sec = 0;\n+  ts.tv_nsec = millis * 1000000;\n+  nanosleep(&ts, NULL);\n }\n \n unsigned long AGSLinux::GetDiskFreeSpaceMB() {\n", "fix_pattern": "<pattern>: if the usleep function is used for sleeping in microseconds, replace it with nanosleep for better precision and to provide a more flexible structure for specifying sleep time in nanoseconds."}
{"number": 383, "change": "@@ -191,7 +191,7 @@ struct buffer : public buffer_base {\n         int rem = (pos <= lim ? lim - pos : 0);\n \n         //rem << 2? wtf?\n-        memcpy(bf.get(), bf.get() + position(), rem << 2);\n+        memmove(bf.get(), bf.get() + position(), rem << 2);\n \n         position(rem);\n         limit(capacity());\n", "fix_pattern": "<pattern>: if a memory operation involves overlapping source and destination regions, replace memcpy with memmove to ensure correct behavior without undefined behavior, as memmove handles overlapping regions safely."}
{"number": 385, "change": "@@ -98,10 +98,13 @@ int test_rw_image_access_qualifier(cl_device_id device_id, cl_context context, c\n     return -1;\n     }\n \n+    MTdata mtData = init_genrand(gRandomSeed);\n     /* Fill input array with random values */\n     for (i = 0; i < size; i++) {\n-        input[i] = (unsigned int)(rand()/((double)RAND_MAX + 1)*255);\n+        input[i] = genrand_int32(mtData);\n     }\n+    free_mtdata(mtData);\n+    mtData = NULL;\n \n     /* Zero out output array */\n     for (i = 0; i < size; i++) {\n", "fix_pattern": "<pattern>: if a random number is generated using the standard `rand()` function, which has poor randomness quality and possible performance issues in a multi-threaded context, replace it with Mersenne Twister RNG functions (`init_genrand`, `genrand_int32`, and `free_mtdata`) for improved performance and better randomness quality."}
{"number": 386, "change": "@@ -33,7 +33,7 @@\n #include <wx/debug.h>\n #include <wx/fileconf.h>\n #include <wx/filename.h>\n-#include <wx/ffile.h>\n+#include <wx/wfstream.h>\n \n \n const wxChar* const traceSettings = wxT( \"KICAD_SETTINGS\" );\n@@ -392,9 +392,10 @@ bool JSON_SETTINGS::SaveToFile( const wxString& aDirectory, bool aForce )\n         std::stringstream buffer;\n         buffer << std::setw( 2 ) << *this << std::endl;\n \n-        wxFFile   file( path.GetFullPath(), \"wb\" );\n+        wxFFileOutputStream fileStream( path.GetFullPath(), \"wb\" );\n \n-        if( !file.IsOpened() || !file.Write( buffer.str().c_str(), buffer.str().size() ) )\n+        if( !fileStream.IsOk()\n+                || !fileStream.WriteAll( buffer.str().c_str(), buffer.str().size() ) )\n         {\n             wxLogTrace( traceSettings, \"Warning: could not save %s\", GetFullFilename() );\n             success = false;\n", "fix_pattern": "<pattern>: if wxFFile is used for file output, replace it with wxFFileOutputStream to leverage the optimized WriteAll method for performance improvements in file writing operations."}
{"number": 389, "change": "@@ -53,7 +53,8 @@ bool mitk::MovieGeneratorOpenCV::InitGenerator()\n \n bool mitk::MovieGeneratorOpenCV::AddFrame( void *data )\n {\n-  cvSetImageData(m_currentFrame,data,m_width*3);\n+  //cvSetImageData(m_currentFrame,data,m_width*3);\n+  memcpy(data,m_currentFrame->imageData,m_width*m_height*3);\n   cvWriteFrame(m_aviWriter,m_currentFrame);\n   return true;\n }\n", "fix_pattern": "<pattern>: if an API call is used to set image data, replace it with a direct memory copy using memcpy for improved performance, as this avoids the overhead associated with the API function and can lead to faster execution."}
{"number": 391, "change": "@@ -39,7 +39,7 @@\n #include \"vtkUnsignedLongArray.h\"\n #include \"vtkUnsignedShortArray.h\"\n \n-vtkCxxRevisionMacro(vtkCompleteArrays, \"1.8\");\n+vtkCxxRevisionMacro(vtkCompleteArrays, \"1.9\");\n vtkStandardNewMacro(vtkCompleteArrays);\n \n vtkCxxSetObjectMacro(vtkCompleteArrays,Controller,vtkMultiProcessController);\n@@ -101,10 +101,7 @@ int vtkCompleteArrays::RequestData(\n       {\n       noNeed = 1;\n       }\n-    for (idx = 1; idx < numProcs; ++idx)\n-      {\n-      this->Controller->Send(&noNeed, 1, idx, 3389001);\n-      }\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n@@ -151,7 +148,7 @@ int vtkCompleteArrays::RequestData(\n     }\n   else\n     { // remote processes\n-    this->Controller->Receive(&noNeed, 1, 0, 3389001);\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n", "fix_pattern": "<pattern>: if a loop is used to send messages individually to multiple destinations using the Send method, replace it with a Broadcast call to streamline communication, reducing overhead."}
{"number": 392, "change": "@@ -28,7 +28,7 @@\n #include <QRegExp>\n \n vtkStandardNewMacro(vtkSMXYChartViewProxy);\n-vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.7\");\n+vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.8\");\n //----------------------------------------------------------------------------\n vtkSMXYChartViewProxy::vtkSMXYChartViewProxy()\n {\n@@ -53,6 +53,8 @@ vtkContextView* vtkSMXYChartViewProxy::NewChartView()\n   // Construct a new chart view and return the view of it\n   this->Chart = vtkChartXY::New();\n   this->ChartView->GetScene()->AddItem(this->Chart);\n+  // Do not use the buffer id for now - performance issues.\n+  this->ChartView->GetScene()->SetUseBufferId(false);\n \n   return this->ChartView;\n }\n", "fix_pattern": "<pattern>: if a performance issue is identified with the usage of buffer IDs in VTK's rendering context, disable the use of buffer IDs by calling `SetUseBufferId(false)` to potentially improve rendering performance while transitioning between versions."}
{"number": 394, "change": "@@ -901,7 +901,8 @@ static size_t VSICurlHandleWriteFunc( void *buffer, size_t count,\n static bool VSICurlIsS3SignedURL( const char* pszURL )\n {\n     return\n-        strstr(pszURL, \".s3.amazonaws.com/\") != NULL &&\n+        (strstr(pszURL, \".s3.amazonaws.com/\") != NULL ||\n+         strstr(pszURL, \".storage.googleapis.com/\") != NULL) &&\n         (strstr(pszURL, \"&Signature=\") != NULL ||\n          strstr(pszURL, \"?Signature=\") != NULL);\n }\n", "fix_pattern": "<pattern>: if multiple calls are made to strstr with the same haystack, combine checks for efficiency by using logical OR to minimize the number of function calls."}
{"number": 398, "change": "@@ -3260,8 +3260,15 @@ void TV::ChangeChannel(int direction)\n \n QString TV::GetQueuedChanNum(void) const\n {\n+    static QRegExp regexp = QRegExp(\"([1-9]|\\\\w)\");\n+\n+    // avoid regular expression if queue is empty.\n+    if (queuedChanNum.isEmpty())\n+        return queuedChanNum;\n+\n     // strip initial zeros.\n-    int nzi = queuedChanNum.find(QRegExp(\"([1-9]|\\\\w)\"));\n+    regexp.setMinimal(true); // we don't need greedy matching\n+    int nzi = queuedChanNum.find(regexp);\n     if (nzi > 0)\n         queuedChanNum = queuedChanNum.right(queuedChanNum.length() - nzi);\n \n", "fix_pattern": "<pattern>: if a regular expression is created in every call, move the QRegExp object to a static variable to avoid repeated allocation and initialization overhead; also, set minimal matching to improve performance when searching."}
{"number": 400, "change": "@@ -150,7 +150,7 @@ WebSocketParser::addStreamData(const char* data, unsigned int len) {\n WebSocketFrame*\n WebSocketParser::getNextFrame() {\n   if (!mHeaderHandled) {\n-    char* pos = strstr(mData, \"\\r\\n\\r\\n\");\n+    char* pos = (char*) memmem(mData, mLength, \"\\r\\n\\r\\n\", 4);\n \n     if (pos) {\n       char* data = (char*) malloc(pos - mData);\n", "fix_pattern": "<pattern>: if the API method strstr is used for finding a substring in a large data buffer, replace it with the more efficient memmem function, which allows for specification of the length of the haystack, resulting in better performance."}
{"number": 402, "change": "@@ -89,7 +89,8 @@ public:\n             if (   ((flags() & kMethcla_BusMappingExternal) == kMethcla_BusMappingExternal)\n                 || ((flags() & kMethcla_BusMappingFeedback) == kMethcla_BusMappingFeedback)\n                 || (bus()->epoch() == env.epoch())) {\n-                memcpy(dst, bus()->data() + offset, numFrames * sizeof(sample_t));\n+                const sample_t* buffer = bus()->data();\n+                std::copy(buffer + offset, buffer + offset + numFrames, dst);\n             } else {\n                 memset(dst, 0, numFrames * sizeof(sample_t));\n             }\n", "fix_pattern": "<pattern>: if a memcpy operation copies a range of data from one location to another, consider using std::copy as a more expressive and potentially optimized alternative, which provides better type safety and integration with STL containers."}
{"number": 407, "change": "@@ -45,6 +45,7 @@\n \n /* Includes */\n #include <precomp.hpp>\n+#include <opencv2/core.hpp>\n #include <stdlib.h>\n #include <stdio.h>\n #include <stdint.h>\n@@ -476,11 +477,7 @@ inline int    RHO_HEST_REFC::initialize(void){\n     lm.tmp1     = NULL;\n     lm.Jte      = NULL;\n \n-#ifdef _WIN32\n-    fastSeed(rand());\n-#else\n-    fastSeed(random());\n-#endif\n+    fastSeed((unsigned)cv::theRNG());\n \n \n     int areAllAllocsSuccessful = ctrl.smpl   &&\n", "fix_pattern": "<pattern>: if the code uses platform-specific random number generation (like rand() for Windows or random() for other platforms), refactor it to use a central random number generator from a library (such as OpenCV's cv::theRNG) for better consistency and potentially improved performance."}
{"number": 408, "change": "@@ -30,14 +30,7 @@ namespace log4cpp {\n                                const std::string& fileName) : \n             LayoutAppender(name),\n             _fileName(fileName) {\n-#if defined(__OPENVMS__)\n-        // shr=get, File Sharing Options, Allow users to read\n-        // ctx=rec, Force record mode access\n-        // rop=rea, Record-processing options, Locks record for a read operation for this process, while allowing other accessors to read the record. \n-        _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644, \"shr=get\",\"ctx=rec\",\"rop=rea\");\n-#else\n         _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644);\n-#endif\n     }\n     \n     FileAppender::FileAppender(const std::string& name, int fd) :\n", "fix_pattern": "<pattern>: NA"}
{"number": 409, "change": "@@ -802,10 +802,10 @@ void flex_rewrite::quantized_graph_rewrite(deserialized_graph &dgraph) {\n         const dnnl_dims_t scales_dims {scales_zp_dim};\n         const auto scales_md\n                 = dnn_mem_t::init_md(1, scales_dims, dnnl_f32, tag::abx);\n-        dnn_mem_t scales_mem(\n-                scales_md, get_cpu_engine(), {false, scales.data()});\n-        dnn_mem_t dummy;\n-        fill_scales(e, dummy, scales_mem);\n+        dnn_mem_t scales_dt(\n+                scales_md, get_test_engine().get(), {false, scales.data()});\n+        dnn_mem_t scales_fp(scales_md, get_test_engine().get());\n+        fill_scales(e, scales_dt, scales_fp);\n \n         std::vector<int64_t> zps;\n         for (int64_t i = 0; i < scales_zp_dim; i++) {\n", "fix_pattern": "<pattern>: When using the DNNL library, if obtaining memory for a computation is done using a CPU engine, switch to using a test engine for memory allocation to potentially improve performance in testing scenarios, and ensure that both the destination and source memories are prepared for the operation being performed."}
{"number": 411, "change": "@@ -20,7 +20,7 @@ XMLException::XMLException(const string& msg)\n auto_ptr<XMLElement> XMLLoader::loadXML(const string& filename,\n                                         const string& systemID)\n {\n-\txmlDocPtr doc = xmlParseFile(filename.c_str());\n+\txmlDocPtr doc = xmlReadFile(filename.c_str(), NULL, 0);\n \tif (!doc) {\n \t\tthrow XMLException(filename + \": Document parsing failed\");\n \t}\n", "fix_pattern": "<pattern>: if the code is using xmlParseFile to parse an XML file, replace it with xmlReadFile, which allows for additional options and generally offers better performance and flexibility in handling XML parsing with more control over the input parameters."}
{"number": 416, "change": "@@ -691,7 +691,7 @@ QString QSystemLocalePrivate::winToQtFormat(const QString &sys_fmt)\n             if (text == QLatin1String(\"'\"))\n                 result += QLatin1String(\"''\");\n             else\n-                result += QString(QLatin1Char('\\'') + text + QLatin1Char('\\''));\n+                result += QLatin1Char('\\'') + text + QLatin1Char('\\'');\n             continue;\n         }\n \n", "fix_pattern": "<pattern>: if a QString is appended with multiple concatenations involving QLatin1Char, refactor the code to eliminate the redundant use of QString's operator by combining the operations into a single expression, resulting in improved performance by reducing overhead."}
{"number": 417, "change": "@@ -110,7 +110,7 @@ int QCollator::compare(const QChar *s1, int len1, const QChar *s2, int len2) con\n     if (d->collator)\n         return ucol_strcoll(d->collator, (const UChar *)s1, len1, (const UChar *)s2, len2);\n \n-    return QString::compare(QString(s1, len1), QString(s2, len2), d->caseSensitivity);\n+    return QString::compare_helper(s1, len1, s2, len2, d->caseSensitivity);\n }\n \n int QCollator::compare(const QString &s1, const QString &s2) const\n", "fix_pattern": "<pattern>: if an API method (QString::compare) is potentially less efficient than a specialized helper (QString::compare_helper), replace calls to the less efficient method with the specialized helper to improve performance."}
{"number": 419, "change": "@@ -704,10 +704,9 @@ void QSslSocketBackendPrivate::transmit()\n                 // Write encrypted data from the buffer into the read BIO.\n                 int writtenToBio = q_BIO_write(readBio, data.constData(), encryptedBytesRead);\n \n-                // do the actual read() here and throw away the results.\n+                // Throw away the results.\n                 if (writtenToBio > 0) {\n-                    // ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek\n-                    plainSocket->read(data.data(), writtenToBio);\n+                    plainSocket->skip(writtenToBio);\n                 } else {\n                     // ### Better error handling.\n                     setErrorAndEmit(QAbstractSocket::SslInternalError,\n", "fix_pattern": "<pattern>: if data read from a socket is not needed, replace the read operation with skip() to avoid unnecessary memory copying and improve performance."}
{"number": 426, "change": "@@ -2585,7 +2585,7 @@ static int qMetaTypeCustomType_unlocked(const char *typeName, int length)\n #if QT_CONFIG(thread)\n         Q_ASSERT(!reg->lock.tryLockForWrite());\n #endif\n-        if (auto ti = reg->aliases.value(QByteArray(typeName, length), nullptr)) {\n+        if (auto ti = reg->aliases.value(QByteArray::fromRawData(typeName, length), nullptr)) {\n             return ti->typeId;\n         }\n     }\n", "fix_pattern": "<pattern>: if a QByteArray is created using the constructor with QByteArray(typeName, length), then refactor the code to use QByteArray::fromRawData(typeName, length) for a more efficient creation without unnecessary overhead."}
{"number": 427, "change": "@@ -72,7 +72,7 @@ QString QTlsBackendOpenSSL::getErrorsFromOpenSsl()\n         if (!errorString.isEmpty())\n             errorString.append(\", \"_L1);\n         q_ERR_error_string_n(errNum, buf, sizeof buf);\n-        errorString.append(QString::fromLatin1(buf)); // error is ascii according to man ERR_error_string\n+        errorString.append(QLatin1StringView(buf)); // error is ascii according to man ERR_error_string\n     }\n     return errorString;\n }\n", "fix_pattern": "<pattern>: if QString::fromLatin1 is used to convert a Latin1 encoded string, replace it with QLatin1StringView to avoid unnecessary QString creation and improve performance, as QLatin1StringView provides a lightweight non-owning view of the string."}
{"number": 430, "change": "@@ -606,9 +606,8 @@ QByteArray qCompress(const uchar* data, qsizetype nbytes, int compressionLevel)\n             qToBigEndian(CompressSizeHint_t(nbytes), bazip.data());\n             break;\n         case Z_MEM_ERROR:\n-            qWarning(\"qCompress: Z_MEM_ERROR: Not enough memory\");\n-            bazip.resize(0);\n-            break;\n+            return tooMuchData(ZLibOp::Compression);\n+\n         case Z_BUF_ERROR:\n             len *= 2;\n             break;\n", "fix_pattern": "<pattern>: if there is a scenario where qWarning is called due to insufficient memory and the subsequent action is to resize a QByteArray to 0, replace it with an early return that indicates the error condition, thus avoiding unnecessary operations related to resizing the QByteArray and improving performance by reducing function overhead."}
{"number": 438, "change": "@@ -74,15 +74,13 @@ void MatrixFreePDE<dim,degree>::getIntegralMF(const MatrixFree<dim,double> &data\n \n         unsigned int num_q_points = var.n_q_points;\n \n-\t\tdealii::AlignedVector<dealii::VectorizedArray<double> > JxW(num_q_points);\n-\t\tvar.fill_JxW_values(JxW);\n-\n         //loop over quadrature points\n         for (unsigned int q=0; q<num_q_points; ++q){\n \t\t\tdealii::VectorizedArray<double> val = var.get_value(q);\n+\t\t\tdealii::VectorizedArray<double> jxw = var.JxW(q);\n \t\t\tassembler_lock.lock ();\n-\t\t\tfor (unsigned i=0; i<val.n_array_elements;i++){\n-\t\t\t\tintegrated_var += val[i]*JxW[q][i];\n+\t\t\tfor (unsigned i=0; i<val.size();i++){\n+\t\t\t\tintegrated_var += val[i]*jxw[i];\n \t\t\t}\n \t\t\tassembler_lock.unlock ();\n         }\n", "fix_pattern": "<pattern>: if the code directly fills a buffer for JxW values and then accesses it in a loop, replace the buffer fill with a direct access from the method returning the value for the specific quadrature point, thus avoiding unnecessary memory allocation and copying."}
{"number": 439, "change": "@@ -84,10 +84,15 @@ void tst_QPacketProtocol::init()\n     QVERIFY(m_server->listen(QHostAddress(\"127.0.0.1\")));\n \n     m_client = new QTcpSocket(this);\n+\n+    QSignalSpy serverSpy(m_server, SIGNAL(newConnection()));\n+    QSignalSpy clientSpy(m_client, SIGNAL(connected()));\n+\n     m_client->connectToHost(m_server->serverAddress(), m_server->serverPort());\n \n-    QVERIFY(m_client->waitForConnected());\n-    QVERIFY(m_server->waitForNewConnection(10000));\n+    QVERIFY(clientSpy.count() > 0 || clientSpy.wait());\n+    QVERIFY(serverSpy.count() > 0 || serverSpy.wait());\n+\n     m_serverConn = m_server->nextPendingConnection();\n }\n \n", "fix_pattern": "<pattern>: if the code uses synchronous blocking methods (like waitForConnected and waitForNewConnection) that can potentially stall execution, refactor it to utilize signals and slots with QSignalSpy, allowing for a non-blocking check of connection status while still waiting for events effectively."}
{"number": 440, "change": "@@ -3521,7 +3521,7 @@ void QQuickWindow::setColor(const QColor &color)\n     }\n     d->clearColor = color;\n     emit colorChanged(color);\n-    d->dirtyItem(contentItem());\n+    update();\n }\n \n QColor QQuickWindow::color() const\n", "fix_pattern": "<pattern>: if a call to `dirtyItem(contentItem())` is replaced with a call to `update()`, use `update()` directly to refresh the entire window instead of marking a specific item as dirty, potentially avoiding unnecessary updates and improving overall performance."}
{"number": 441, "change": "@@ -435,15 +435,14 @@ void QQuickWindow::physicalDpiChanged()\n void QQuickWindow::handleScreenChanged(QScreen *screen)\n {\n     Q_D(QQuickWindow);\n+    disconnect(d->physicalDpiChangedConnection);\n     if (screen) {\n         physicalDpiChanged();\n         // When physical DPI changes on the same screen, either the resolution or the device pixel\n         // ratio changed. We must check what it is. Device pixel ratio does not have its own\n         // ...Changed() signal.\n-        d->physicalDpiChangedConnection = connect(screen, SIGNAL(physicalDotsPerInchChanged(qreal)),\n-                                                  this, SLOT(physicalDpiChanged()));\n-    } else {\n-        disconnect(d->physicalDpiChangedConnection);\n+        d->physicalDpiChangedConnection = connect(screen, &QScreen::physicalDotsPerInchChanged,\n+                                                  this, &QQuickWindow::physicalDpiChanged);\n     }\n \n     d->forcePolish();\n", "fix_pattern": "<pattern>: if using the old SIGNAL/SLOT macros for connecting signals and slots, replace them with the new method syntax for better performance and type safety; also ensure proper disconnecting of existing connections before re-connecting."}
{"number": 443, "change": "@@ -571,7 +571,7 @@ Status TensorToNdarray(const Tensor& t, PyObject** ret) {\n   if (!status.ok()) {\n     return status;\n   }\n-  return TF_TensorToPyArray(std::move(tf_tensor), ret);\n+  return TF_TensorToMaybeAliasedPyArray(std::move(tf_tensor), ret);\n }\n \n }  // namespace tensorflow\n", "fix_pattern": "<pattern>: if an API function that directly converts a TensorFlow tensor to a Python array is replaced with a potentially more optimized function that allows for aliasing, then consider using TF_TensorToMaybeAliasedPyArray for better performance or reduced memory overhead."}
{"number": 449, "change": "@@ -159,8 +159,8 @@ const QString get_dc_nickname(const char *model, uint32_t deviceid)\n {\n \tconst DiveComputerNode *existNode = dcList.getExact(model, deviceid);\n \tif (!existNode)\n-\t\treturn QString(\"\");\n-\tif (existNode->nickName != \"\")\n+\t\treturn QString();\n+\telse if (!existNode->nickName.isEmpty())\n \t\treturn existNode->nickName;\n \telse\n \t\treturn model;\n", "fix_pattern": "<pattern>: if returning an empty QString, use the default constructor QString() instead of QString(\"\") for better clarity and consistency; if checking for empty strings, utilize isEmpty() method instead of comparing to an empty string literal."}
{"number": 452, "change": "@@ -1,6 +1,6 @@\n \n /*\n- * $Id: HttpReply.cc,v 1.93 2007/05/18 06:41:22 amosjeffries Exp $\n+ * $Id: HttpReply.cc,v 1.94 2007/05/22 16:37:26 rousskov Exp $\n  *\n  * DEBUG: section 58    HTTP Reply (Response)\n  * AUTHOR: Alex Rousskov\n@@ -433,7 +433,7 @@ HttpReply::bodySize(method_t method) const\n \n bool HttpReply::sanityCheckStartLine(MemBuf *buf, http_status *error)\n {\n-    if (buf->contentSize() >= protoPrefix.size() && strncmp(protoPrefix, buf->content(), protoPrefix.size()) != 0) {\n+    if (buf->contentSize() >= protoPrefix.size() && protoPrefix.compare(buf->content(), protoPrefix.size()) != 0) {\n         debugs(58, 3, \"HttpReply::sanityCheckStartLine: missing protocol prefix (\" << protoPrefix << \") in '\" << buf->content() << \"'\");\n         *error = HTTP_INVALID_HEADER;\n         return false;\n", "fix_pattern": "<pattern>: if a comparison is performed between a C-style string using `strncmp`, replace it with the corresponding `std::string::compare` method for improved safety and potential performance, as it utilizes STL optimizations."}
{"number": 454, "change": "@@ -89,9 +89,9 @@ ACLMethodData::parse()\n \n     for (Tail = &values; *Tail; Tail = &((*Tail)->next));\n     while ((t = strtokFile())) {\n-        if (strcmp(t, \"PURGE\") == 0)\n-            ++ThePurgeCount; // configuration code wants to know\n         CbDataList<HttpRequestMethod> *q = new CbDataList<HttpRequestMethod> (HttpRequestMethod(t, NULL));\n+        if (q->element == Http::METHOD_PURGE)\n+            ++ThePurgeCount; // configuration code wants to know\n         *(Tail) = q;\n         Tail = &q->next;\n     }\n", "fix_pattern": "<pattern>: if comparing strings with `strcmp` for specific known constants, replace it with a direct comparison against enum values or constants for better readability and potential performance improvement."}
{"number": 456, "change": "@@ -36,8 +36,6 @@ inline uint32_t bitmask32(size_t bottom_bits) {\n class address_encryptor {\n public:\n   explicit address_encryptor(const std::array<address::byte_type, 32>& key) {\n-    EVP_CIPHER_CTX_init(ctx_.get());\n-    OpenSSL_add_all_ciphers();\n     cipher_ = EVP_get_cipherbyname(\"aes-128-ecb\");\n     block_size_ = EVP_CIPHER_block_size(cipher_);\n     pad_ = std::vector<address::byte_type>(block_size_);\n", "fix_pattern": "<pattern>: if EVP_CIPHER_CTX_init is called for initialization and OpenSSL_add_all_ciphers is called to register ciphers, consider that these initialization functions may be called multiple times in a program. Instead, initialize ctx_ once during application startup or before first use, and ensure OpenSSL_add_all_ciphers is invoked only once to reduce overhead."}
{"number": 459, "change": "@@ -8,11 +8,13 @@\n \n #include <vector>\n \n+#include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n-#include <boost/thread.hpp>\n \n #include \"ITMImagePtrTypes.h\"\n \n+#include \"tvgutil/misc/ThreadPool.h\"\n+\n namespace spaint {\n \n /**\n@@ -93,8 +95,7 @@ public:\n   static void save_image_on_thread(const boost::shared_ptr<const ORUtils::Image<T> >& image, const std::string& path, ImageFileType fileType = IFT_UNKNOWN)\n   {\n     void (*p)(const boost::shared_ptr<const ORUtils::Image<T> >&, const std::string&, ImageFileType) = &save_image;\n-    boost::thread t(p, image, path, fileType);\n-    t.detach();\n+    tvgutil::ThreadPool::instance().start_asynch(boost::bind(p, image, path, fileType));\n   }\n \n   /**\n", "fix_pattern": "<pattern>: if a thread is created and detached using boost::thread, replace it with a ThreadPool implementation to manage threads more efficiently and reduce overhead from thread creation."}
{"number": 469, "change": "@@ -249,7 +249,7 @@ ColorCorrectionPrivate::ColorCorrectionPrivate(ColorCorrection *parent)\n \n     // Establish a D-Bus communication interface with KolorServer\n     m_csi = new ColorServerInterface(\n-        QStringLiteral(\"org.kde.kded\"),\n+        QStringLiteral(\"org.kde.kded5\"),\n         QStringLiteral(\"/modules/kolorserver\"),\n         QDBusConnection::sessionBus(),\n         this);\n", "fix_pattern": "<pattern>: if a QStringLiteral is being adjusted to use a specific versioning scheme in the context of an API (like 'kded5' instead of 'kded'), ensure the version is updated to maintain compatibility or performance benefits without direct performance implications."}
{"number": 474, "change": "@@ -220,7 +220,7 @@ void PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)\n                 // Rotate to highest position, so it can be lopped\n                 // by decrementing e_phnum.\n                 memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));\n-                memcpy(phdr, 1+phdr, j * sizeof(*phdr));\n+                memmove(phdr, 1+phdr, j * sizeof(*phdr));  // overlapping\n                 memcpy(&phdr[j], (unsigned char *)ibuf, sizeof(*phdr));\n                 --phdr;\n                 set_te16(&ehdri.e_phnum, --e_phnum);\n", "fix_pattern": "<pattern>: if a memory copy operation involves overlapping regions, replace memcpy with memmove to ensure correct behavior and avoid potential data corruption."}
{"number": 475, "change": "@@ -379,7 +379,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n     model->materials[i].specular[2] = 0.0f;\n     model->materials[i].specular[3] = 1.0f;\n   }\n-  model->materials[0].name = strdup(\"default\");\n+  model->materials[0].name = std::string(\"default\");\n \n   /* now, read in the data */\n   nummaterials = 0;\n@@ -397,7 +397,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n       }\n       sscanf(buf, \"%s %s\", buf, buf);\n       nummaterials++;\n-      model->materials[nummaterials].name = strdup(buf);\n+      model->materials[nummaterials].name = std::string(buf);\n       break;\n     case 'N':\n       fscanf(file, \"%f\", &model->materials[nummaterials].shininess);\n", "fix_pattern": "<pattern>: if the API is using strdup to allocate strings, replace it with std::string to manage memory automatically and improve performance by eliminating unnecessary memory allocation and deallocation."}
{"number": 476, "change": "@@ -52,7 +52,6 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   int rowSize = ((3*imageW + 3) >> 2) << 2;      // how many bytes in the row (used to create padding)\n   //unsigned long fileSize = 2ul * imageH * imageW + 54; // pix data + 54 byte hdr\n   int fileSize = 54 + imageH*rowSize;        // headers (54 bytes) + pixel data\n-  memset(&rgbBuffer[rowSize - 4], 0, 4);\n \n   bmFlHdr[ 2] = (unsigned char)(fileSize      ); // all ints stored little-endian\n   bmFlHdr[ 3] = (unsigned char)(fileSize >>  8); // i.e., LSB first\n@@ -80,6 +79,9 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   outFile.write(bmInHdr, sizeof(bmInHdr));\n \n   uint8_t* buf = (uint8_t*)rgbBuffer;\n+\n+  // set zero to padding area\n+  memset(&buf[rowSize - 4], 0, 4);\n   for ( int i = imageH - 1; i >= 0; i-- ) {\n     _tft->readRectRGB( 0, i, imageW, 1, rgbBuffer ); // capture a whole line\n     int j = 0;\n", "fix_pattern": "<pattern>: the code removes unnecessary comments and maintains the use of `memset` to set a padding area to zero, which is already an efficient operation. There's no significant performance enhancement or refactoring taking place; thus, the pattern simply reflects the operation of zeroing out a memory region using `memset`."}
{"number": 481, "change": "@@ -496,6 +496,7 @@ void\n GlassTable::compact(byte * p)\n {\n     LOGCALL_VOID(DB, \"GlassTable::compact\", (void*)p);\n+    Assert(p != buffer);\n     Assert(writable);\n     int e = block_size;\n     byte * b = buffer;\n@@ -504,10 +505,10 @@ GlassTable::compact(byte * p)\n \tItem item(p, c);\n \tint l = item.size();\n \te -= l;\n-\tmemmove(b + e, item.get_address(), l);\n+\tmemcpy(b + e, item.get_address(), l);\n \tsetD(p, c, e);  /* reform in b */\n     }\n-    memmove(p + e, b + e, block_size - e);  /* copy back */\n+    memcpy(p + e, b + e, block_size - e);  /* copy back */\n     e -= dir_end;\n     SET_TOTAL_FREE(p, e);\n     SET_MAX_FREE(p, e);\n", "fix_pattern": "<pattern>: if using memmove for non-overlapping memory regions, replace it with memcpy for better performance, ensuring to assert that the pointers do not point to the same buffer before copying."}
{"number": 482, "change": "@@ -189,8 +189,8 @@ void map_horizon::upload()\n \n void map_horizon::upload_minimap()\n {\n-  uint32_t texture[1024][1024];\n-  memset(texture, 0, 1024 * 1024 * sizeof(uint32_t));\n+  std::vector<uint32_t> texture(1024 * 1024);\n+  memset(texture.data(), 0, 1024 * 1024 * sizeof(uint32_t));\n \n   for (size_t y (0); y < 64; ++y)\n   {\n@@ -209,14 +209,14 @@ void map_horizon::upload_minimap()\n       {\n         for (size_t i (0); i < 16; ++i)\n         {\n-          texture[y * 16 + j][x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n+          texture[(y * 16 + j) * 1024 + x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n         }\n       }\n     }\n   }\n \n   minimap.bind();\n-  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture);\n+  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.data());\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n", "fix_pattern": "<pattern>: if a fixed-size array is allocated on the stack for a texture, replace it with a std::vector to take advantage of dynamic memory management and ensure better flexibility; also adjust indexing for one-dimensional access using a calculated index based on width."}
{"number": 494, "change": "@@ -32,12 +32,14 @@\n #include <mutex>\n #include <thread>\n \n+#include <android-base/chrono_utils.h>\n #include <android-base/file.h>\n #include <android-base/logging.h>\n #include <android-base/properties.h>\n #include <android-base/stringprintf.h>\n \n using android::base::StringPrintf;\n+using android::base::boot_clock;\n using namespace std::chrono_literals;\n \n namespace android {\n@@ -50,9 +52,9 @@ static std::condition_variable g_bootcharting_finished_cv;\n static bool g_bootcharting_finished;\n \n static long long get_uptime_jiffies() {\n-  std::string uptime;\n-  if (!android::base::ReadFileToString(\"/proc/uptime\", &uptime)) return 0;\n-  return 100LL * strtod(uptime.c_str(), NULL);\n+    constexpr int64_t kNanosecondsPerJiffy = 10000000;\n+    boot_clock::time_point uptime = boot_clock::now();\n+    return uptime.time_since_epoch().count() / kNanosecondsPerJiffy;\n }\n \n static std::unique_ptr<FILE, decltype(&fclose)> fopen_unique(const char* filename,\n", "fix_pattern": "<pattern>: if reading from a file using ReadFileToString incurs file I/O overhead, replace it with a high-resolution clock implementation (like boot_clock) to retrieve uptime directly without file access, significantly improving performance."}
{"number": 506, "change": "@@ -212,7 +212,7 @@ void Video_Dumb::flip() {\n   }\n \n #ifdef UGS_LINUX\n-  sleep(0);\n+  usleep(1);\n #endif\n \n   framecount++;\n", "fix_pattern": "<pattern>: if the code is using the sleep function with a duration of 0 seconds to yield control, replace it with usleep(1) to yield control more effectively while allowing for a minimal sleep time and potentially reducing CPU usage."}
{"number": 508, "change": "@@ -19,6 +19,7 @@\n #include <sys/un.h>\n #include <event.h>\n #include <stdlib.h>\n+#include <sys/socket.h>\n \n struct delegate_info {\n     const char *helper;\n@@ -58,7 +59,7 @@ delegate_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle delegate process: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a blocking read operation is replaced with a non-blocking receive operation using `recv` with the `MSG_DONTWAIT` flag to improve responsiveness and potentially avoid blocking on socket reads."}
{"number": 509, "change": "@@ -19,6 +19,7 @@\n #include <string.h>\n #include <unistd.h>\n #include <sys/un.h>\n+#include <sys/socket.h>\n #include <event.h>\n \n struct tcp_stock_connection {\n@@ -84,7 +85,7 @@ tcp_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle TCP connection: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a direct read operation is used to read data from a socket, replace it with the recv function and make use of flags like MSG_DONTWAIT to improve responsiveness by handling non-blocking I/O."}
{"number": 524, "change": "@@ -59,9 +59,9 @@ EclipseDebugger::on_connect()\n       __debugger_if->read();\n       char* host = __debugger_if->host();\n       unsigned int port = __debugger_if->port();\n-      std::stringstream command;\n-      command << \"tktools -h \" << host << \" -p \" << port;      \n-      system(command.str().c_str());\n+      std::stringstream portstr;\n+      portstr << port;\n+      execlp(\"tktools\", \"tktools\", \"-h\", host, \"-p\", portstr.str().c_str(), (char *) 0);\n     }\n \n   } catch (Exception &e) {\n", "fix_pattern": "<pattern>: if a system call is utilized to perform shell command execution, replace it with execlp to avoid the overhead of shell interpretation and improve performance."}
{"number": 526, "change": "@@ -35,7 +35,8 @@ struct repo_t *repo_new(const char *reponame) {\n \n   CALLOC(repo, 1, sizeof(struct repo_t), return NULL);\n \n-  if (asprintf(&repo->name, \"%s\", reponame) == -1) {\n+  repo->name = strdup(reponame);\n+  if (repo->name == NULL) {\n     fprintf(stderr, \"error: failed to allocate memory\\n\");\n     free(repo);\n     return NULL;\n", "fix_pattern": "<pattern>: if asprintf is used to allocate and format a string with a single argument and there is no formatting required (just a copy), replace it with strdup for better performance and simpler code."}
{"number": 538, "change": "@@ -242,5 +242,5 @@ QString MakeJob::environmentProfile() const\n \n bool MakeJob::isNMake(const QString& makeBin)\n {\n-    return QFileInfo(makeBin).baseName().toLower() == \"nmake\";\n+    return QFileInfo(makeBin).baseName().compare(QStringLiteral(\"nmake\"), Qt::CaseInsensitive);\n }\n", "fix_pattern": "<pattern>: if the comparison of QStrings involves converting one string to lowercase using toLower(), replace it with QString::compare using Qt::CaseInsensitive for better performance and to avoid unnecessary string manipulation."}
{"number": 540, "change": "@@ -93,10 +93,10 @@ void set_storage_service(http_context& ctx, routes& r) {\n         return ctx.db.local().commitlog()->active_config().commit_log_location;\n     });\n \n-    ss::get_token_endpoint.set(r, [] (const_req req) {\n+    ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n         auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n         std::vector<storage_service_json::mapper> res;\n-        return map_to_key_value(token_to_ep, res);\n+        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if an API method is using a non-movable type (like const_req) as a parameter, change it to a movable type (like std::unique_ptr<request>) to facilitate ownership transfer and improve performance. Additionally, utilize make_ready_future to streamline returns and avoid intermediate copies."}
{"number": 544, "change": "@@ -3402,11 +3402,11 @@ bool BaseGame::getVersion(byte *verMajor, byte *verMinor, byte *extMajor, byte *\n void BaseGame::setWindowTitle() {\n \tif (_renderer) {\n \t\tchar title[512];\n-\t\tstrcpy(title, _caption[0]);\n+\t\tCommon::strlcpy(title, _caption[0], 512);\n \t\tif (title[0] != '\\0') {\n-\t\t\tstrcat(title, \" - \");\n+\t\t\tCommon::strlcat(title, \" - \", 512);\n \t\t}\n-\t\tstrcat(title, \"WME Lite\");\n+\t\tCommon::strlcat(title, \"WME Lite\", 512);\n \n \n \t\tUtf8String utf8Title;\n", "fix_pattern": "<pattern>: if using strcpy and strcat to manipulate strings, replace them with strlcpy and strlcat for improved safety and to prevent buffer overflows."}
{"number": 545, "change": "@@ -270,7 +270,7 @@ bool SXString::scCallMethod(ScScript *script, ScStack *stack, ScStack *thisStack\n \t\tScValue *val = stack->pop();\n \t\tchar separators[MAX_PATH_LENGTH] = \",\";\n \t\tif (!val->isNULL()) {\n-\t\t\tstrcpy(separators, val->getString());\n+\t\t\tCommon::strlcpy(separators, val->getString(), MAX_PATH_LENGTH);\n \t\t}\n \n \t\tSXArray *array = new SXArray(_gameRef);\n", "fix_pattern": "<pattern>: if a string is copied using strcpy, replace it with a safer alternative like Common::strlcpy that prevents buffer overflows by limiting the number of copied characters."}
{"number": 546, "change": "@@ -677,10 +677,8 @@ void GraphicManager::drawChar(byte ander, int x, int y, Color color) {\n void GraphicManager::refreshScreen() {\n \t// These cycles are for doubling the screen height.\n \tfor (uint16 y = 0; y < _screen.h / 2; y++) {\n-\t\tfor (uint16 x = 0; x < _screen.w; x++) {\n-\t\t\tfor (int j = 0; j < 2; j++)\n-\t\t\t\t*(byte *)_screen.getBasePtr(x, y * 2 + j) = *(byte *)_surface.getBasePtr(x, y);\n-\t\t}\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2), _surface.getBasePtr(0, y), _screen.w);\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2 + 1), _surface.getBasePtr(0, y), _screen.w);\n \t}\n \t// Now we copy the stretched picture to the screen.\n \tg_system->copyRectToScreen(_screen.getPixels(), _screen.pitch, 0, 0, kScreenWidth, kScreenHeight * 2);\n", "fix_pattern": "<pattern>: if a nested loop is used to copy pixel data from one buffer to another, replace it with memcpy(...) calls to perform the operation in a single API call for better performance."}
{"number": 547, "change": "@@ -239,10 +239,10 @@ int ScummEngine_v72he::setupStringArrayFromString(char *cStr) {\n \n \twriteVar(0, 0);\n \n-\tint len = strlen(cStr);\n+\tint len = strlen(cStr) + 1;\n \tbyte *ptr = defineArray(0, kStringArray, 0, 0, 0, len);\n \tif (ptr != nullptr)\n-\t\tstrcpy((char*)ptr, cStr);\n+\t\tCommon::strlcpy((char*)ptr, cStr, len);\n \n \treturn readVar(0);\n }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with a safer string copy function like Common::strlcpy that also prevents buffer overflows by specifying the size of the destination buffer."}
{"number": 550, "change": "@@ -268,7 +268,7 @@ void Dialogs::scrollModeDialogue() {\n }\n \n void Dialogs::store(byte what, TuneType &played) {\n-\tmemcpy(played, played + 1, sizeof(played) - 1);\n+\tmemmove(played, played + 1, sizeof(played) - 1);\n \tplayed[30] = what;\n }\n \n", "fix_pattern": "<pattern>: if a memory operation is performed that may overlap the source and destination buffers, replace memcpy with memmove to ensure correct behavior and potentially better performance in cases of overlapping memory regions."}
{"number": 551, "change": "@@ -817,7 +817,6 @@ bool TTFFont::cacheGlyph(Glyph &glyph, uint32 chr) const {\n \t}\n \n \tuint8 *dst = (uint8 *)glyph.image.getPixels();\n-\tmemset(dst, 0, glyph.image.h * glyph.image.pitch);\n \n \tswitch (bitmap->pixel_mode) {\n \tcase FT_PIXEL_MODE_MONO:\n", "fix_pattern": "code removed:\n```\n    memset(dst, 0, glyph.image.h * glyph.image.pitch);\n```\ncode added:\n```\n    bzero(dst, glyph.image.h * glyph.image.pitch);\n```\n<pattern>: if a call to memset is used to zero out a block of memory, consider using bzero (or an equivalent) when clearing memory for better performance and potential clarity in intent, assuming that the environment supports it."}
{"number": 554, "change": "@@ -185,10 +185,8 @@ void xbt_ex_setup_backtrace(xbt_ex_t * e)\n       maps_name = bprintf(\"/proc/%d/maps\", (int) getpid());\n       maps = fopen(maps_name, \"r\");\n \n-      sscanf(addrs[i], \"%lx\", &addr);\n-      sprintf(maps_buff, \"%#lx\", addr);\n-\n-      if (strcmp(addrs[i], maps_buff)) {\n+      addr = strtol(addrs[i], &p, 16);\n+      if (*p != '\\0') {\n         XBT_CRITICAL(\"Cannot parse backtrace address '%s' (addr=%#lx)\",\n                   addrs[i], addr);\n       }\n", "fix_pattern": "<pattern>: if a combination of sscanf and sprintf is used for parsing and formatting a hexadecimal value, replace it with a direct conversion using strtol to improve performance and eliminate unnecessary string formatting operations."}
{"number": 562, "change": "@@ -619,7 +619,7 @@ class WatchDog {\n                            timeout_in_milliseconds_/1000));\n       } else if (rc != 0) {\n         std::string message(StringPrintf(\"pthread_cond_timedwait failed: %s\", strerror(rc)));\n-        Fatal(message.c_str());\n+        Fatal(message);\n       }\n     }\n     CHECK_WATCH_DOG_PTHREAD_CALL(pthread_mutex_unlock, (&mutex_), reason);\n", "fix_pattern": "<pattern>: if a function is accepting a std::string but being called with its c_str() method, modify the call to use the std::string directly to avoid the overhead of creating a temporary C-style string."}
{"number": 564, "change": "@@ -31,7 +31,7 @@ class SQLiteConnection {\n          }\n       }\n \n-      if (sqlite3_open(path.c_str(), &_conn) != SQLITE_OK) {\n+      if (sqlite3_open_v2(path.c_str(), &_conn, SQLITE_OPEN_READONLY | SQLITE_OPEN_NOMUTEX, 0) != SQLITE_OK) {\n          BOOST_THROW_EXCEPTION(ConnectionFailedException() << ConnectionError(sqlite3_errmsg(_conn)));\n       }\n \n", "fix_pattern": "<pattern>: if the sqlite3_open function is used for read-only access, replace it with sqlite3_open_v2 using SQLITE_OPEN_READONLY and SQLITE_OPEN_NOMUTEX flags to improve performance by avoiding unnecessary locking mechanisms and ensuring no write operations can occur."}
{"number": 566, "change": "@@ -554,7 +554,7 @@ void rlc_um::reassemble_rx_sdus()\n \n       log->debug(\"Concatenating %d bytes in to current length %d. rx_window remaining bytes=%d, vr_ur_in_rx_sdu=%d, vr_ur=%d, rx_mod=%d, last_mod=%d\\n\",\n         len, rx_sdu->N_bytes, rx_window[vr_ur].buf->N_bytes, vr_ur_in_rx_sdu, vr_ur, cfg.rx_mod, (vr_ur_in_rx_sdu+1)%cfg.rx_mod);\n-      memcpy(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n+      memmove(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n       rx_sdu->N_bytes += len;\n       rx_window[vr_ur].buf->msg += len;\n       rx_window[vr_ur].buf->N_bytes -= len;\n", "fix_pattern": "<pattern>: if the source and destination memory areas may overlap during a memory copy operation, replace memcpy with memmove to ensure the operation is safe and avoid undefined behavior, which can lead to performance issues."}
{"number": 572, "change": "@@ -32,7 +32,7 @@\n \n #define VTK_MYSQL_DEFAULT_PORT 3306\n  \n-vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.22\");\n+vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.23\");\n vtkStandardNewMacro(vtkMySQLDatabase);\n \n // ----------------------------------------------------------------------\n@@ -461,12 +461,14 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n {\n   skipped = false;\n   vtkStdString queryStr = \", \";\n+  bool mustUseName = true;\n \n   int idxType = schema->GetIndexTypeFromHandle( tblHandle, idxHandle );\n   switch ( idxType )\n     {\n     case vtkSQLDatabaseSchema::PRIMARY_KEY:\n       queryStr += \"PRIMARY KEY \";\n+      mustUseName = false;\n       break;\n     case vtkSQLDatabaseSchema::UNIQUE:\n       queryStr += \"UNIQUE \";\n@@ -478,7 +480,11 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n       return vtkStdString();\n     }\n   \n-  queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+  // No index_name for PRIMARY KEYs\n+  if ( mustUseName )\n+    {\n+    queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+    }\n   queryStr += \" (\";\n         \n   // Loop over all column names of the index\n", "fix_pattern": "<pattern>: if the API call for retrieving index names may be unnecessary (specifically for PRIMARY KEYs), refactor the logic to conditionally execute the call only when required, thus potentially reducing redundant computations and avoiding unnecessary string concatenation in the query."}
{"number": 573, "change": "@@ -48,7 +48,7 @@\n #include <vtkstd/set>\n #include <vtkstd/algorithm>\n \n-vtkCxxRevisionMacro(vtkKdTree, \"1.22\");\n+vtkCxxRevisionMacro(vtkKdTree, \"1.23\");\n \n // Timing data ---------------------------------------------\n \n@@ -2280,7 +2280,8 @@ int vtkKdTree::_FindClosestPointInRegion(int regionId,\n \n   float *candidate = this->LocatorPoints + (idx * 3);\n \n-  for (int i=0; i < this->RegionList[regionId]->GetNumberOfPoints(); i++)\n+  int numPoints = this->RegionList[regionId]->GetNumberOfPoints();\n+  for (int i=0; i < numPoints; i++)\n     {\n     double dx = (x - candidate[0]) * (x - candidate[0]);\n \n", "fix_pattern": "<pattern>: if a loop iterates over the result of a method call that can be computed once, store the result in a variable before the loop to avoid repeated calls and improve performance."}
{"number": 575, "change": "@@ -3769,9 +3769,9 @@ BOOL CSoundFile::ReadABC(const uint8_t *lpStream, DWORD dwMemLength)\n \t\t\t\t\t\t\tp[t]='\\0';\n \t\t\t\t\t\tfor( t=2; isspace(p[t]); t++ ) ;\n \t\t\t\t\t\tstrcpy(buf,m_szNames[0]);\n-\t\t\t\t\t\tif( strlen(buf) + strlen(p+t) > 199 ) p[t+199-strlen(buf)] = '\\0'; // chop it of\n \t\t\t\t\t\tif( strlen(buf) ) strcat(buf,\" \"); // add a space\n-\t\t\t\t\t\tstrcat(buf, p+t);\n+\t\t\t\t\t\t// don't go past 200 bytes.\n+\t\t\t\t\t\tstrncat(buf, p+t, 200-strlen(buf)-1);\n \t\t\t\t\t\tif( strlen(buf) > 31 ) buf[31] = '\\0'; // chop it of\n \t\t\t\t\t\tstrcpy(m_szNames[0], buf);\n \t\t\t\t\t\tbreak;\n", "fix_pattern": "<pattern>: if code manually checks buffer length and concatenates two strings using strcat, replace with strncat to ensure that the buffer does not overflow, thus improving safety and potentially performance."}
{"number": 579, "change": "@@ -35,6 +35,8 @@\n #include <QLineEdit>\n #include <QContextMenuEvent>\n \n+#include <algorithm>\n+\n #include \"qg_blockwidget.h\"\n #include \"rs_blocklist.h\"\n #include \"qg_actionhandler.h\"\n@@ -78,7 +80,7 @@ void QG_BlockModel::setBlockList(RS_BlockList* bl) {\n             listBlock.append(bl->at(i));\n     }\n     setActiveBlock(bl->getActive());\n-    qSort ( listBlock.begin(), listBlock.end(), blockLessThan );\n+    std::sort( listBlock.begin(), listBlock.end(), blockLessThan);\n \n     //called to force redraw\n     endResetModel();\n", "fix_pattern": "<pattern>: if using qSort from the Qt library, replace it with std::sort from the C++ Standard Library for potentially better performance and enhanced optimizations since std::sort is generally more efficient and widely used in modern C++."}
{"number": 581, "change": "@@ -209,7 +209,15 @@ QVector<BuildingGeoPolygonGraphicsItem::NamedEntry> BuildingGeoPolygonGraphicsIt\n \n void BuildingGeoPolygonGraphicsItem::paint(GeoPainter* painter, const ViewportParams* viewport, const QString &layer, int tileZoomLevel)\n {\n-    Q_UNUSED(tileZoomLevel);\n+    // Just display flat buildings for tile level 17\n+    if (tileZoomLevel == 17) {\n+        if (layer.endsWith(QLatin1String(\"/frame\"))) {\n+            AbstractGeoPolygonGraphicsItem::paint(painter, viewport, layer, tileZoomLevel );\n+        }\n+        return;\n+    }\n+\n+    // For level 18, 19 .. render 3D buildings in perspective\n     if (layer.endsWith(QLatin1String(\"/frame\"))) {\n         Q_ASSERT(m_cachedOuterPolygons.isEmpty());\n         Q_ASSERT(m_cachedInnerPolygons.isEmpty());\n", "fix_pattern": "<pattern>: if there is a check for specific conditions based on the input parameters that can potentially skip unnecessary processing or rendering, restructure the code to handle those conditions explicitly before calling potentially expensive API methods like AbstractGeoPolygonGraphicsItem::paint."}
{"number": 584, "change": "@@ -428,9 +428,10 @@ namespace net_utils\n \t\t\t\n \t\t\t\thandler_obj hndlr(ec, bytes_transfered);\n \n-\t\t\t\tchar local_buff[10000] = {0};\n+\t\t\t\tstatic const size_t max_size = 16384;\n+\t\t\t\tbuff.resize(max_size);\n \t\t\t\t\n-\t\t\t\tasync_read(local_buff, sizeof(local_buff), boost::asio::transfer_at_least(1), hndlr);\n+\t\t\t\tasync_read(&buff[0], max_size, boost::asio::transfer_at_least(1), hndlr);\n \n \t\t\t\t// Block until the asynchronous operation has completed.\n \t\t\t\twhile (ec == boost::asio::error::would_block && !boost::interprocess::ipcdetail::atomic_read32(&m_shutdowned))\n@@ -463,7 +464,7 @@ namespace net_utils\n \t\t\t\t\treturn false;*/\n \n \t\t\t\tm_bytes_received += bytes_transfered;\n-\t\t\t\tbuff.assign(local_buff, bytes_transfered);\n+\t\t\t\tbuff.resize(bytes_transfered);\n \t\t\t\treturn true;\n \t\t\t}\n \n", "fix_pattern": "<pattern>: if a local buffer is used to read data and then assigned to a std::string, replace the local buffer with a resize of the std::string to reduce memory copying and potential reallocations; also ensure the async_read function utilizes the string's internal buffer directly for efficiency."}
{"number": 585, "change": "@@ -594,7 +594,7 @@ BOOL SetEndOfFile(HANDLE hFile) {\n }\n \n DWORD SleepEx( DWORD dwMilliseconds,  BOOL bAlertable) {\n-  SDL_Delay(dwMilliseconds);\n+  usleep(dwMilliseconds * 1000);\n   return 0;\n }\n \n", "fix_pattern": "<pattern>: if using SDL_Delay for sleeping, replace it with usleep for potentially finer control over the sleep duration since usleep provides microsecond resolution compared to SDL_Delay's millisecond resolution."}
{"number": 587, "change": "@@ -155,7 +155,7 @@ void *CAudioDecoder::GetData(unsigned int size)\n   if (m_gaplessBufferSize > size)\n   {\n     memcpy(m_outputBuffer, m_gaplessBuffer, size*sizeof(float));\n-    memcpy(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n+    memmove(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n     m_gaplessBufferSize -= size;\n     return m_outputBuffer;\n   }\n", "fix_pattern": "<pattern>: if a buffer may overlap when copying data, replace memcpy(...) with memmove(...) to ensure correct behavior and maintain performance."}
{"number": 589, "change": "@@ -489,10 +489,11 @@ writeable_pgsql_selection::factory::factory(const po::variables_map &opts)\n   // select ways which use nodes already in the working set\n   m_connection.prepare(\"ways_from_nodes\",\n     \"INSERT INTO tmp_ways \"\n-      \"SELECT DISTINCT wn.way_id \"\n+      \"SELECT DISTINCT wn.way_id AS id \"\n         \"FROM current_way_nodes wn \"\n           \"JOIN tmp_nodes tn ON wn.node_id = tn.id \"\n-            \"AND wn.way_id NOT IN (SELECT id FROM tmp_ways)\");\n+          \"LEFT JOIN tmp_ways tw ON wn.way_id = tw.id \"\n+        \"WHERE tw.id IS NULL\");\n   // select nodes used by ways already in the working set\n   m_connection.prepare(\"nodes_from_way_nodes\",\n     \"INSERT INTO tmp_nodes \"\n", "fix_pattern": "<pattern>: if a query uses a subquery with NOT IN which can be inefficient, refactor the query to use a LEFT JOIN with a WHERE clause for better performance in filtering data from related tables."}
{"number": 590, "change": "@@ -496,9 +496,8 @@ NAN_METHOD(Driver::open) {\n #endif\n \n   GDALDriver *raw = driver->getGDALDriver();\n-  GDALOpenInfo *open_info = new GDALOpenInfo(path.c_str(), access);\n-  GDALDataset *ds = raw->pfnOpen(open_info);\n-  delete open_info;\n+  const char *driver_list[2] = {raw->GetDescription(), nullptr};\n+  GDALDataset *ds = (GDALDataset *)GDALOpenEx(path.c_str(), access, driver_list, NULL, NULL);\n   if (!ds) {\n     Nan::ThrowError(\"Error opening dataset\");\n     return;\n", "fix_pattern": "<pattern>: if a GDAL dataset is opened using the older GDALOpenInfo method that involves manual memory management, refactor the code to use GDALOpenEx which simplifies the process and potentially improves performance by avoiding the need to create and delete a GDALOpenInfo object."}
{"number": 591, "change": "@@ -591,7 +591,7 @@ void CmdRaytracingRender::activated(int iMsg)\n         doCommand(Doc,\"f = open(TempFile,'wb')\");\n         doCommand(Doc,\"f.write(PageFile.read())\");\n         doCommand(Doc,\"f.close()\");\n-        doCommand(Doc,\"subprocess.call('\\\"%s\\\" '+TempFile,shell=True)\",renderer.c_str());\n+        doCommand(Doc,\"subprocess.Popen([\\\"%s\\\",TempFile])\",renderer.c_str());\n         doCommand(Doc,\"del TempFile,PageFile\");            \n         commitCommand();\n     }\n", "fix_pattern": "<pattern>: if the command being executed involves a shell call with subprocess.call, replace it with subprocess.Popen and pass the command as a list to avoid the overhead of shell parsing and improve performance."}
{"number": 593, "change": "@@ -51,8 +51,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tif (!string)\n \t\treturn;\n \t\n-\tchar *workstr = new char[strlen(string) + 1];\n-\tstrcpy(workstr, string);\n+\tchar *workstr = strdup(string);\n \tstrtok(workstr, \"\\n\");\n \t\n \tchar *token = strtok(NULL,\"\\n\");\n@@ -60,7 +59,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \t\n \tif (!token)\n \t{\n-\t\tdelete [] workstr;\n+\t\tfree(workstr);\n \t\tstringList.AddItem(new BString(string));\n \t\treturn;\n \t}\n@@ -84,7 +83,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tlasttoken = token;\n \tstringList.AddItem(newword);\n \t\t\n-\tdelete [] workstr;\n+\tfree(workstr);\n }\n \n \n", "fix_pattern": "<pattern>: when dynamically allocating a string and then copying its contents, replace the manual allocation and copy with strdup, which performs both operations in one call and simplifies the code; also, ensure to call free only once on the allocated memory."}
{"number": 595, "change": "@@ -244,7 +244,7 @@ void* VideoScaler::Run(void* pArgs)\n     int tOutputBufferSize = avpicture_get_size(mTargetPixelFormat, mTargetResX, mTargetResY) + FF_INPUT_BUFFER_PADDING_SIZE;\n \n     // allocate chunk buffer\n-    tOutputBuffer = (uint8_t*)malloc(tOutputBufferSize);\n+    tOutputBuffer = (uint8_t*)av_malloc(tOutputBufferSize);\n \n     // Allocate video frame\n     LOG(LOG_VERBOSE, \"..allocating memory for output frame\");\n", "fix_pattern": "<pattern>: if memory allocation is done using malloc, switch to av_malloc from the FFmpeg library for optimized memory handling within FFmpeg's context."}
{"number": 606, "change": "@@ -434,9 +434,7 @@ void Renderer::executeCommands(const QVector<RenderCommand *> commands)\n \n     Q_FOREACH (RenderCommand *command, commands) {\n \n-        QMutexLocker locker(&m_mutex);\n         MeshData *meshData = m_meshDataManager->data(command->m_meshData);\n-        locker.unlock();\n         if (meshData == Q_NULLPTR || meshData->attributeNames().empty()) {\n             qCWarning(Rendering) << \"RenderCommand should have a mesh\";\n             continue ;\n", "fix_pattern": "<pattern>: if a mutex locker is constructed and immediately unlocked without being used to guard a critical section, remove the unnecessary QMutexLocker instantiation to improve performance."}
{"number": 610, "change": "@@ -68,7 +68,7 @@ Node& CDirAdditionalPropertiesDlg::MakeNode(Node& parentNode, const std::vector<\n \t++it;\n \tif (it != path.end())\n \t{\n-\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name.c_str())).c_str(), parentNode.hItem);\n+\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name)).c_str(), parentNode.hItem);\n \t\treturn MakeNode(node, path, it);\n \t}\n \tnode.canonicalName = strutils::join(path.begin(), path.end(), _T(\".\"));\n", "fix_pattern": "<pattern>: if a function is called on a string (like c_str()) that's unnecessary for the operation, replace it with direct usage of the string object to reduce overhead and improve clarity."}
{"number": 612, "change": "@@ -442,13 +442,13 @@ Ref<const readable_block_store_t> read_sections(const MPI_Comm comm, const strin\n   Array<char> raw;\n   {\n     Log::Scope scope(\"read data\");\n-    const auto our_size = CHECK_CAST_INT(partition_loop(total_size,ranks,rank).size());\n-    raw.resize(our_size,false);\n+    const auto chunk = partition_loop(total_size,ranks,rank);\n+    raw.resize(CHECK_CAST_INT(chunk.size()),false);\n     MPI_File file;\n     const int r = MPI_File_open(comm,(char*)filename.c_str(),MPI_MODE_RDONLY,MPI_INFO_NULL,&file);\n     if (r != MPI_SUCCESS)\n       die(\"failed to open '%s' for reading: %s\",filename,error_string(r));\n-    CHECK(MPI_File_read_ordered(file,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+    CHECK(MPI_File_read_at_all(file,chunk.lo,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n     CHECK(MPI_File_close(&file));\n   }\n \n", "fix_pattern": "<pattern>: if the code is reading ordered data with MPI_File_read_ordered, switch to MPI_File_read_at_all for better performance when handling large chunks of data by specifying the offset directly, thus avoiding potential bottlenecks in ordered reads."}
{"number": 613, "change": "@@ -679,10 +679,18 @@ void write_sparse_samples(const MPI_Comm comm, const string& filename, accumulat\n     index += sizeof(s.wins);\n   }\n \n+  // Compute offsets.  MPI_File_write_ordered would do this for us, but MPI_File_write_ordered\n+  // is completely broken performance-wise.\n+  uint64_t offset = 0;\n+  {\n+    uint64_t buffer_size = buffer.size();\n+    CHECK(MPI_Exscan(&buffer_size,&offset,1,datatype<uint64_t>(),MPI_SUM,comm));\n+  }\n+\n   // Write the file\n   MPI_File file;\n   file_open(comm,filename,&file);\n-  CHECK(MPI_File_write_ordered(file,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+  CHECK(MPI_File_write_at_all(file,offset,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n   CHECK(MPI_File_close(&file));\n }\n \n", "fix_pattern": "<pattern>: if the code is using MPI_File_write_ordered, which is known to have performance issues, replace it with an MPI_File_write_at_all call that computes offsets manually using an MPI_Exscan to optimize performance for collective writes."}
{"number": 616, "change": "@@ -223,9 +223,8 @@ JNIEXPORT jbyteArray JNICALL Java_org_tensorflow_Session_run(\n   jbyteArray ret = nullptr;\n   if (run_metadata != nullptr) {\n     ret = env->NewByteArray(run_metadata->length);\n-    jbyte* elems = env->GetByteArrayElements(ret, nullptr);\n-    memcpy(elems, run_metadata->data, run_metadata->length);\n-    env->ReleaseByteArrayElements(ret, elems, JNI_COMMIT);\n+    env->SetByteArrayRegion(ret, 0, run_metadata->length,\n+                            reinterpret_cast<const jbyte*>(run_metadata->data));\n   }\n   TF_DeleteStatus(status);\n   return ret;\n", "fix_pattern": "<pattern>: if GetByteArrayElements is used to obtain a pointer for memcpy followed by ReleaseByteArrayElements, replace the sequence with SetByteArrayRegion to directly copy data into the Java byte array, improving performance by avoiding unnecessary memory management overhead."}
{"number": 619, "change": "@@ -92,7 +92,11 @@ void StringReader(png_structp png_ptr, png_bytep data, png_size_t length) {\n   DecodeContext* const ctx =\n       absl::bit_cast<DecodeContext*>(png_get_io_ptr(png_ptr));\n   if (static_cast<png_size_t>(ctx->data_left) < length) {\n-    memset(data, 0, length);\n+    // Don't zero out the data buffer as it has been lazily allocated (copy on\n+    // write) and zeroing it out here can produce an OOM. Since the buffer is\n+    // only used for reading data from the image, this doesn't result in any\n+    // data leak, so it is safe to just leave the buffer be as it is and just\n+    // exit with error.\n     png_error(png_ptr, \"More bytes requested to read than available\");\n   } else {\n     memcpy(data, ctx->data, length);\n", "fix_pattern": "<pattern>: if a buffer has been lazily allocated with copy-on-write semantics and is only used for reading, avoid unnecessary zeroing out of the buffer to prevent potential out-of-memory errors (OOM) and improve performance by bypassing the memset call."}
{"number": 624, "change": "@@ -31,6 +31,7 @@\n #include <boost/intrusive_ptr.hpp>\n \n #include \"mongo/platform/atomic_word.h\"\n+#include \"mongo/util/allocator.h\"\n \n namespace mongo {\n \n@@ -56,7 +57,7 @@ public:\n     }\n \n     static SharedBuffer allocate(size_t bytes) {\n-        return takeOwnership(static_cast<char*>(malloc(sizeof(Holder) + bytes)));\n+        return takeOwnership(static_cast<char*>(mongoMalloc(sizeof(Holder) + bytes)));\n     }\n \n     /**\n", "fix_pattern": "<pattern>: if a memory allocation is performed using malloc from Standard C, replace it with mongoMalloc from the MongoDB Project to potentially benefit from custom memory management optimizations specific to that library."}
{"number": 629, "change": "@@ -948,8 +948,7 @@ static const char * DoParseBindingFunc(key_binding_t& bind, const char * func_st\n \t// line tokeniser.\n \n \tstatic char buffer[600];\n-\tstrncpy(buffer, func_str, sizeof(buffer));\n-\tbuffer[sizeof(buffer) - 1] = 0;\n+\tStringCopy(buffer, sizeof(buffer), func_str);\n \n \tfor (unsigned int k = 0 ; buffer[k] ; k++)\n \t\tif (buffer[k] == ',' || buffer[k] == ':')\n", "fix_pattern": "<pattern>: if using strncpy for string copying, replace it with a project-specific optimized StringCopy function for better performance and potential additional safety features."}
{"number": 631, "change": "@@ -265,7 +265,7 @@ int RageSound_Linux::MixerThread_start(void *p) {\n void RageSound_Linux::MixerThread() {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \twhile(!shutdown) { while (GetData()); }\n }\n \t\n", "fix_pattern": "<pattern>: if using a sleep function in a busy-wait loop, replace it with a library-specific delay function (like SDL_Delay) to improve performance and avoid unnecessary CPU usage."}
{"number": 632, "change": "@@ -73,7 +73,7 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n \n   /* I don't like this but I can't think of another place to put it. */\n   while (!SOUNDMAN)\n-    sleep(10);\n+    SDL_Delay(10);\n   \n   for (unsigned i = 0; i < P->sounds.size(); ++i) {\n     if (P->sounds[i]->stopping)\n@@ -88,6 +88,8 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n     }\n   }\n \n+  mix.read(buf); \n+\n   memcpy(stream, buf, len);\n   P->last_cursor_pos += buffersize_frames;\n }\n", "fix_pattern": "<pattern>: if a call to sleep is made using a standard C++ sleep function, replace it with a platform-specific equivalent like SDL_Delay for improved performance in scenarios involving multimedia applications or game development where frame timing is critical."}
{"number": 639, "change": "@@ -34,8 +34,8 @@ screen_status_printf(const char *format, ...)\n {\n \tva_list ap;\n \tva_start(ap,format);\n-\tchar *msg = g_strdup_vprintf(format,ap);\n+\tchar msg[256];\n+\tvsnprintf(msg, sizeof(msg), format, ap);\n \tva_end(ap);\n \tscreen_status_message(msg);\n-\tg_free(msg);\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation is being used to create a formatted string with g_strdup_vprintf followed by g_free, refactor the code to use a stack-allocated buffer with vsnprintf to avoid the overhead of heap allocation and deallocation."}
{"number": 641, "change": "@@ -101,7 +101,9 @@ tag_pool_get_item(enum tag_type type, const char *value, size_t length)\n \tslot_p = &slots[calc_hash_n(type, value, length) % NUM_SLOTS];\n \tfor (slot = *slot_p; slot != NULL; slot = slot->next) {\n \t\tif (slot->item.type == type &&\n-\t\t    strcmp(value, slot->item.value) == 0 && slot->ref < 0xff) {\n+\t\t    length == strlen(slot->item.value) &&\n+\t\t    memcmp(value, slot->item.value, length) == 0 &&\n+\t\t    slot->ref < 0xff) {\n \t\t\tassert(slot->ref > 0);\n \t\t\t++slot->ref;\n \t\t\treturn &slot->item;\n", "fix_pattern": "<pattern>: if a strcmp comparison is used, replace it with a combination of strlen to check lengths and memcmp to compare the strings for potentially better performance by avoiding null termination checks and leveraging raw memory comparison."}
{"number": 644, "change": "@@ -1860,7 +1860,7 @@ void CSoundFile::LoadMixPlugins(FileReader &file)\n \t\t\t\t\tif(m_MixPlugins[plug].pPluginData)\n \t\t\t\t\t{\n \t\t\t\t\t\tm_MixPlugins[plug].nPluginDataSize = pluginDataChunkSize;\n-\t\t\t\t\t\tmemcpy(m_MixPlugins[plug].pPluginData, pluginDataChunk.GetRawData(), pluginDataChunkSize);\n+\t\t\t\t\t\tpluginDataChunk.ReadRaw(m_MixPlugins[plug].pPluginData, pluginDataChunkSize);\n \t\t\t\t\t}\n \t\t\t\t}\n \n", "fix_pattern": "<pattern>: if an API method using `memcpy` to copy data from one memory location to another is detected, replace it with a more specialized method (in this case, `ReadRaw()`) that likely includes optimizations specific to the data source being read from."}
{"number": 647, "change": "@@ -45,10 +45,10 @@ public:\n         : m_vector(vector)\n     {}\n \n-    void emplace_back(T && value)\n+    void emplace_back(T &&value)\n     {\n         QMutexLocker lock(&m_mutex);\n-        m_vector.emplace_back(value);\n+        m_vector.push_back(std::move(value));\n     }\n \n     void emplace_back(const T &value)\n", "fix_pattern": "<pattern>: when transferring ownership of an object to a vector, use std::move to avoid unnecessary copies, replacing emplace_back with push_back to insert the element into the vector directly."}
{"number": 650, "change": "@@ -1712,20 +1712,18 @@ float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {\n static void CreateClusterTree(CLUSTERER *Clusterer) {\n   ClusteringContext context;\n   ClusterPair HeapEntry;\n-  TEMPCLUSTER *PotentialCluster;\n \n   // each sample and its nearest neighbor form a \"potential\" cluster\n   // save these in a heap with the \"best\" potential clusters on top\n   context.tree = Clusterer->KDTree;\n-  context.candidates =\n-      static_cast<TEMPCLUSTER *>(malloc(Clusterer->NumberOfSamples * sizeof(TEMPCLUSTER)));\n+  context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];\n   context.next = 0;\n   context.heap = new ClusterHeap(Clusterer->NumberOfSamples);\n   KDWalk(context.tree, reinterpret_cast<void_proc>(MakePotentialClusters), &context);\n \n   // form potential clusters into actual clusters - always do \"best\" first\n   while (context.heap->Pop(&HeapEntry)) {\n-    PotentialCluster = HeapEntry.data();\n+    TEMPCLUSTER *PotentialCluster = HeapEntry.data();\n \n     // if main cluster of potential cluster is already in another cluster\n     // then we don't need to worry about it\n@@ -1761,7 +1759,7 @@ static void CreateClusterTree(CLUSTERER *Clusterer) {\n   FreeKDTree(context.tree);\n   Clusterer->KDTree = nullptr;\n   delete context.heap;\n-  free(context.candidates);\n+  delete[] context.candidates;\n } // CreateClusterTree\n \n /**\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, switch to using new to allocate memory and delete[] to deallocate it, improving performance and type-safety in C++."}
{"number": 669, "change": "@@ -197,8 +197,7 @@ ImageDescriptor::ImageDescriptor(int _Width, int _Height, uint32 *_Pixels)\n \tVScale = 1.0;\n \tUScale = 1.0;\n \tSize = _Width * _Height * 4;\n-\tPixels = new uint32[_Width * _Height];\n-\tmemcpy(Pixels, _Pixels, Size);\n+\tPixels = _Pixels;\n \tFormat = RGBA8;\n \tMipMapCount = 0;\n }\n", "fix_pattern": "<pattern>: if pixels are being copied from a source array to a newly allocated array using memcpy, and it is safe to assign the source directly to the target, replace the memcpy with direct assignment, which avoids unnecessary memory operations."}
{"number": 677, "change": "@@ -57,7 +57,7 @@ AccountOpResult AccountMgr::CreateAccount(std::string username, std::string pass\n \n     if(!loginDatabase.PExecute(\"INSERT INTO account(username,sha_pass_hash,joindate) VALUES('%s',SHA1(CONCAT('%s',':','%s')),NOW())\", username.c_str(), username.c_str(), password.c_str()))\n         return AOR_DB_INTERNAL_ERROR;                       // unexpected error\n-    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM account, realmlist WHERE account.id NOT IN (SELECT acctid FROM realmcharacters)\");\n+    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist,account LEFT JOIN realmcharacters ON acctid=account.id WHERE acctid IS NULL\");\n \n     return AOR_OK;                                          // everything's fine\n }\n", "fix_pattern": "<pattern>: when performing an insert operation that selects from multiple tables, refactor the query to use a LEFT JOIN to prevent inserting duplicate records, optimizing the execution by filtering on NULL values instead of using a subquery."}
{"number": 679, "change": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n \n+#include \"cstring.h\"\n #include \"uni2name.h\"\n #include \"unicode/unifilt.h\"\n #include \"unicode/uchar.h\"\n@@ -93,7 +94,7 @@ void UnicodeNameTransliterator::handleTransliterate(Replaceable& text, UTransPos\n         UChar32 c = text.char32At(cursor);\n         if ((len=u_charName(c, U_UNICODE_CHAR_NAME, buf, sizeof(buf), &status)) <= 0 || U_FAILURE(status)) {\n             sprintf(buf, \"U+%04lX\", c);\n-            len = strlen(buf);\n+            len = uprv_strlen(buf);\n         }\n \n         str.truncate(1);\n", "fix_pattern": "<pattern>: if the standard strlen function is used for measuring string length, replace it with uprv_strlen from the ICU library to leverage potential performance optimizations specific to Unicode string handling."}
{"number": 684, "change": "@@ -120,7 +120,8 @@ void KLoadFileMetaDataThread::run()\n             if (variants.isEmpty()) {\n                 // the file has not been indexed, query the meta data\n                 // directly from the file\n-                KFileMetaInfo metaInfo(urls.first());\n+                const QString path = urls.first().toLocalFile();\n+                KFileMetaInfo metaInfo(path, QString(), KFileMetaInfo::Fastest);\n                 const QHash<QString, KFileMetaInfoItem> metaInfoItems = metaInfo.items();\n                 foreach (const KFileMetaInfoItem& metaInfoItem, metaInfoItems) {\n                     const QString uriString = metaInfoItem.name();\n", "fix_pattern": "<pattern>: if the KFileMetaInfo constructor is called with a QString that can be directly converted to a local file path, replace it with a direct call to toLocalFile() to improve performance by avoiding unnecessary conversions and using the Fastest option for efficiency."}
{"number": 685, "change": "@@ -56,7 +56,8 @@ static QString lookupIconNameFor(const KUrl &url, KUriFilterData::UriTypes type)\n             if (service && service->icon() != QLatin1String( \"unknown\" ))\n                 iconName = service->icon();\n             // Try to find an icon with the same name as the binary (useful for non-kde apps)\n-            else if ( !KIconLoader::global()->loadIcon( exeName, KIconLoader::NoGroup, 16, KIconLoader::DefaultState, QStringList(), 0, true ).isNull() )\n+            // Use iconPath rather than loadIcon() as the latter uses QPixmap (not threadsafe)\n+            else if ( !KIconLoader::global()->iconPath( exeName, KIconLoader::NoGroup, true ).isNull() )\n                 iconName = exeName;\n             else\n                 // not found, use default\n", "fix_pattern": "<pattern>: if an API method loads heavy graphical resources (QPixmap) that may not be thread-safe, replace it with a method that retrieves a path to the resource (iconPath) instead to improve performance and ensure thread safety."}
{"number": 686, "change": "@@ -1442,8 +1442,8 @@ void Applet::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QW\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, \"Wallpaper\");\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, w->pluginName());\n                     w->restore(wallpaperConfig);\n-                    disconnect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n-                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n+                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)),\n+                            Qt::UniqueConnection);\n                 }\n \n                 painter->save();\n", "fix_pattern": "<pattern>: if a disconnect and then immediate reconnect is detected for a Qt signal, use Qt::UniqueConnection in the connect call to avoid redundant signals and improve performance by ensuring the connection is only made if it doesn't already exist."}
{"number": 689, "change": "@@ -37,10 +37,10 @@\n StyledCalendarDelegate::StyledCalendarDelegate(QObject *parent)\n     : QStyledItemDelegate(parent)\n {\n-    mPixmap.insert(Enable, KIconLoader().loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n-    mPixmap.insert(RemoveFromList, KIconLoader().loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n-    mPixmap.insert(AddToList, KIconLoader().loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n-    mPixmap.insert(Quickview, KIconLoader().loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n+    mPixmap.insert(Enable, KIconLoader::global()->loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n+    mPixmap.insert(RemoveFromList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n+    mPixmap.insert(AddToList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n+    mPixmap.insert(Quickview, KIconLoader::global()->loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n }\n \n StyledCalendarDelegate::~StyledCalendarDelegate()\n", "fix_pattern": "<pattern>: if multiple calls are made to `KIconLoader().loadIcon`, replace them with calls to `KIconLoader::global()->loadIcon` to utilize a singleton instance of `KIconLoader`, which reduces overhead from repeated constructions of the `KIconLoader` object."}
{"number": 693, "change": "@@ -433,8 +433,9 @@ void ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n         }\n     }\n     if (useModSeq > 0) {\n-        // FIXME: issue the corresponding command\n-        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n+        QMap<QByteArray, quint64> fetchModifier;\n+        fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n+        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n     } else {\n         flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n     }\n", "fix_pattern": "<pattern>: if a command fetch is being issued without optional modifiers that could improve behavior or performance, refactor the fetch call to include and pass additional parameters like `fetchModifier` for enhanced functionality."}
{"number": 694, "change": "@@ -278,12 +278,12 @@ zmsg_t *cmb_msg_encode (char *tag, json_object *o)\n \n     if (!(zmsg = zmsg_new ()))\n         err_exit (\"zmsg_new\");\n-    if (zmsg_addstr (zmsg, \"%s\", tag) < 0)\n-        err_exit (\"zmsg_addstr\");\n+    if (zmsg_addmem (zmsg, tag, strlen (tag)) < 0)\n+        err_exit (\"zmsg_addmem\");\n     if (o) {\n         const char *s = json_object_to_json_string (o);\n-        if (zmsg_addstr (zmsg, \"%s\", s) < 0)\n-            err_exit (\"zmsg_addstr\");\n+        if (zmsg_addmem (zmsg, s, strlen (s)) < 0)\n+            err_exit (\"zmsg_addmem\");\n     }\n     return zmsg;\n }\n", "fix_pattern": "<pattern>: if the code is using zmsg_addstr to add strings to the zmsg, replace it with zmsg_addmem to directly add the memory representation of the strings along with their length, improving efficiency by eliminating the need for the function to determine the string length internally."}
{"number": 701, "change": "@@ -338,7 +338,7 @@ void showSplashScreen()\n #if defined(Q_OS_UNIX)\n void setupDpi()\n {\n-    if (qgetenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\").isEmpty())\n+    if (qEnvironmentVariableIsEmpty(\"QT_AUTO_SCREEN_SCALE_FACTOR\"))\n         qputenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\", \"1\");\n }\n #endif  // Q_OS_UNIX\n", "fix_pattern": "<pattern>: if a call is made to qgetenv followed by an isEmpty check, replace it with a direct call to qEnvironmentVariableIsEmpty for better performance, as it avoids the overhead of creating a QString object."}
{"number": 702, "change": "@@ -28,6 +28,8 @@\n \n #include \"apicontroller.h\"\n \n+#include <algorithm>\n+\n #include <QJsonDocument>\n #include <QMetaObject>\n \n@@ -69,9 +71,13 @@ const DataMap &APIController::data() const\n \n void APIController::checkParams(const QSet<QString> &requiredParams) const\n {\n-    const QSet<QString> params {this->params().keys().toSet()};\n+    const bool hasAllRequiredParams = std::all_of(requiredParams.cbegin(), requiredParams.cend()\n+        , [this](const QString &requiredParam)\n+    {\n+        return params().contains(requiredParam);\n+    });\n \n-    if (!params.contains(requiredParams))\n+    if (!hasAllRequiredParams)\n         throw APIError(APIErrorType::BadParams);\n }\n \n", "fix_pattern": "<pattern>: if an operation involves checking for the presence of multiple required parameters in a set, replace the set construction and lookup with a more efficient method using std::all_of to directly check each required parameter's existence, minimizing temporary object creation and improving readability."}
{"number": 706, "change": "@@ -29,8 +29,8 @@ void MPI_Sys::sample(Sys &in)\n \n         for (int i = 0; i < in.num(); i++)\n         {\n-            MPI_Allreduce(MPI_IN_PLACE, in.precMu.at(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n-            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.at(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precMu.col(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.col(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n         }\n         bcast_sum_cov_norm();\n     }\n", "fix_pattern": "<pattern>: if an API method retrieves a row or column of data using a potentially less efficient method (like at(index)), replace it with a direct method call that accesses the data column directly (like col(index)) for improved performance, specifically in the context of matrix or array data structures."}
{"number": 707, "change": "@@ -189,7 +189,7 @@ TcpSocketImplTest::Test1_HandleRecv (Ptr<Socket> sock)\n   {\n     rxBytes1 += sz;\n     rxPayload = new uint8_t[sz];\n-    memcpy (rxPayload, p->PeekData(), sz);\n+    p->CopyData (rxPayload, sz);\n   }\n   else\n   {\n", "fix_pattern": "<pattern>: if memcpy is used to transfer data from a packet buffer, replace it with the packet's optimized CopyData method to leverage potential internal optimizations and reduce overhead."}
{"number": 709, "change": "@@ -1718,7 +1718,7 @@ static void lCompose(\n #if 1 // def __COMPOSITE_PROFILE\n     double nsendrecvloc = (senddispl[nrank] + recvdispl[nrank])*sizeof(uint16_t);\n     double nsendrecv;\n-    MPI_Allreduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, comm);\n+    MPI_Reduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, master, comm);\n     const double t1 = MPI_Wtime();\n     if (rank == master)\n     {\n", "fix_pattern": "<pattern>: if the communication pattern allows for reduction to a specific root instead of broadcasting to all processes, replace MPI_Allreduce with MPI_Reduce to optimize performance by reducing the amount of data communicated across the network."}
{"number": 711, "change": "@@ -1533,7 +1533,7 @@ void NJClient::mixInChannel(bool muted, float vol, float pan, DecodeState *chan,\n     // advance the queue\n     chan->decode_samplesout += needed/chan->decode_codec->GetNumChannels();\n     chan->decode_codec->m_samples_used -= needed+chan->dump_samples;\n-    memcpy(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n+    memmove(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n     chan->dump_samples=0;\n   }\n   else\n", "fix_pattern": "<pattern>: if overlapping memory regions are detected, replace memcpy with memmove to ensure correct behavior since memmove handles such cases properly."}
{"number": 712, "change": "@@ -143,8 +143,8 @@ void convert_inplace_test_do_it( dl_ctx_t       dl_ctx,        dl_typeid_t type,\n \t\t*out_buffer = (unsigned char*)malloc(*out_size + 1);\n \t\tmemset(*out_buffer, 0xFE, *out_size + 1);\n \n-\t\tmemcpy( *out_buffer, convert_buffer, convert_size );\n-\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, *out_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, convert_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tmemcpy(*out_buffer, convert_buffer, *out_size);\n \t}\n \n \tfree(convert_buffer);\n", "fix_pattern": "<pattern>: if a memcpy operation is performed after an API call that alters the buffer's content, refactor the code to first call the API and then perform the memcpy only if necessary, using the proper output size calculated from the API call, which avoids potentially copying unnecessary data or incorrect sizes."}
{"number": 714, "change": "@@ -62,7 +62,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             std::vector<bool> vMatch(nTx, false);\n             std::vector<uint256> vMatchTxid1;\n             for (unsigned int j=0; j<nTx; j++) {\n-                bool fInclude = (rand() & ((1 << (att/2)) - 1)) == 0;\n+                bool fInclude = insecure_randbits(att / 2) == 0;\n                 vMatch[j] = fInclude;\n                 if (fInclude)\n                     vMatchTxid1.push_back(vTxid[j]);\n", "fix_pattern": "<pattern>: if a call to the standard `rand()` function is replaced with a custom API that is optimized for generating random bits, use `insecure_randbits(...)` for potentially better performance and more control over the randomness generation."}
{"number": 715, "change": "@@ -14,7 +14,7 @@ int _tflitetensor_name(ErlNifEnv *env, TfLiteTensor * tensor, ERL_NIF_TERM &out)\n     unsigned char * ptr;\n     size_t len = strlen(tensor_name_str);\n     if ((ptr = enif_make_new_binary(env, len, &tensor_name)) != nullptr) {\n-        strncpy((char *)ptr, tensor_name_str, len);\n+        memcpy((char *)ptr, tensor_name_str, len);\n         out = tensor_name;\n         return true;\n     } else {\n", "fix_pattern": "<pattern>: if strncpy is used to copy a fixed length of bytes, replace it with memcpy for better performance since strncpy performs null-termination checks and padding that are unnecessary in this context."}
{"number": 720, "change": "@@ -64,10 +64,10 @@ bool FormFieldRestrictedValues::safeForIntegerCoercion(FormRestrictions restrict\n     foreach(SelectRestriction sr, restrictions.first) {\n         if(sr.variable == name) {\n             foreach(QString value, sr.values) {\n-                // TODO: Would prefer to use a more general regex (e.g. allowing zero-padded values or leading/trailing\n-                // spaces) but these values cannot currently be injected back correctly (even though we could coerce\n+                // TODO: Would prefer to use a more general regex (e.g. allowing leading/trailing spaces)\n+                // but these values cannot currently be injected back correctly (even though we could coerce\n                 // and solve them), so we are quite conservative for now.\n-                if(!value.contains(QRegExp(\"^(0|([1-9][0-9]*))$\"))) {\n+                if(!value.contains(QRegExp(\"^([0-9]*)$\"))) {\n                     return false;\n                 }\n             }\n", "fix_pattern": "<pattern>: if a more specific regex pattern that constrains valid input is replaced with a more general pattern that allows additional cases (like leading/trailing spaces), ensure that it doesn't introduce significant performance overhead when the regex engine has to handle a broader set of matches; specific patterns can lead to faster evaluations and less backtracking compared to general patterns."}
{"number": 722, "change": "@@ -130,7 +130,7 @@ static Node *convertToCLinkFormat( xmlDocPtr doc, xmlNodePtr cur, int depth ) {\n \n Node *Parser::parse(const std::string &data, size_t len) {\n   // First, parse the XML memory buffer ito a DOM object\n-  xmlDocPtr doc = xmlParseMemory( data.c_str(), (int)len );\n+  xmlDocPtr doc = xmlReadMemory(data.c_str(), (int)len, NULL, NULL, XML_PARSE_NOERROR);\n   if ( doc == NULL ) {\n     LogWarn(\"XML file parsing failed:\");\n     LogWarn(\"%s\", data.c_str());\n", "fix_pattern": "<pattern>: if an API method for parsing XML is replaced with a different, more configurable method that allows for options (like error handling), then switch from a basic parsing function to a more flexible one (xmlReadMemory) that can handle additional parameters for better error control and customization."}
{"number": 725, "change": "@@ -270,8 +270,9 @@ extern \"C\" void report_segfault(int signo)\n \n extern \"C\" void report_abort(int signo)\n {\n-    log(CRITICAL, \"Aborted\");\n-    log(NOTICE, \"Please report this bug to \" PACKAGE_BUGREPORT);\n+    //Don't print to the log in signal handler, as that involves memory allocation.\n+    fprintf(stderr, \"Aborted\");\n+    fprintf(stderr, \"Please report this bug to \" PACKAGE_BUGREPORT);\n \n #if !defined(HAVE_SIGACTION)\n     signal(signo, SIG_DFL);\n", "fix_pattern": "<pattern>: if logging functions are called within a signal handler, switch to using fprintf to stderr to avoid memory allocation issues associated with the logging API"}
{"number": 737, "change": "@@ -431,7 +431,12 @@ void xyUpdate(){\n \n \tgvFPS = 1000 / fLength;\n \t//Wait for FPS limit\n-\tif(gvMaxFPS != 0) SDL_Delay((1000 / gvMaxFPS) - (fLength / gvMaxFPS));\n+\t//\t\tdelay\t4294967290\tunsigned int\n+\tUint32 current_time = (static_cast<Uint32>(fLength) / gvMaxFPS);\n+\tUint32 max_delay = (1000 / gvMaxFPS);\n+\tif (current_time < max_delay) {\n+\t\tif (gvMaxFPS != 0) SDL_Delay(max_delay - current_time);\n+\t}\n \t/*while(fLength < 1000 / gvMaxFPS){\n \t\tgvTicks = SDL_GetTicks();\n \t\tfLength = gvTicks - gvTickLast;\n", "fix_pattern": "<pattern>: if a delay is calculated and potentially called multiple times based on frame length and maximum FPS, first compute `current_time` and `max_delay` once, then perform the delay only if needed, thus avoiding redundant calculations and improving performance."}
{"number": 743, "change": "@@ -5,7 +5,7 @@\n         Implementation of Quesa API calls.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2008, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1277,14 +1277,14 @@ OpaqueTQ3Object::GetElement ( TQ3ElementType theType, void *theData )\n \n \t// If we've actually been passed a set, use it directly\n \tif ( Q3_OBJECT_IS_CLASS ( this, E3Set ) )\n-\t\treturn Q3Set_Get ( (TQ3SetObject) this, theType, theData ) ;\n+\t\treturn ( (E3Set*) this )->Get ( theType, theData ) ;\n \t\n \t// otherwise use the set within the instance data\n \t\n \tif ( theSet == NULL )\n \t\treturn kQ3Failure ;\n \t\n-\treturn Q3Set_Get ( theSet, theType, (void*)theData ) ;\n+\treturn ( (E3Set*) theSet )->Get ( theType, theData ) ;\n \t}\n \n \n", "fix_pattern": "<pattern>: if the original Q3Set_Get function is being replaced with the more efficient E3Set::Get member function call, then refactor the API usage to utilize the class method for potentially better performance and cleaner code."}
{"number": 748, "change": "@@ -73,11 +73,11 @@ QgsMapCanvasContextMenu::QgsMapCanvasContextMenu( QgsMapCanvas* canvas, const QP\n   }\n   else if ( mPickResult.feature.isValid() && mPickResult.layer )\n   {\n-    QgsCoordinateTransform ct( mPickResult.layer->crs(), mCanvas->mapSettings().destinationCrs() );\n+    const QgsCoordinateTransform* ct = QgsCoordinateTransformCache::instance()->transform( mPickResult.layer->crs().authid(), mCanvas->mapSettings().destinationCrs().authid() );\n     mRubberBand = new QgsGeometryRubberBand( mCanvas, mPickResult.feature.geometry()->type() );\n     mRubberBand->setIconType( QgsGeometryRubberBand::ICON_NONE );\n     mRubberBand->setOutlineWidth( 2 );\n-    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( ct ) );\n+    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( *ct ) );\n     if ( mPickResult.layer->type() == QgsMapLayer::RedliningLayer )\n     {\n       addAction( QIcon( \":/images/themes/default/mActionToggleEditing.svg\" ), tr( \"Edit\" ), this, SLOT( editFeature() ) );\n", "fix_pattern": "<pattern>: if a new instance of QgsCoordinateTransform is created every time a transformation is needed, utilize a caching mechanism (QgsCoordinateTransformCache) to retrieve pre-constructed coordinate transforms based on CRS identifiers to improve performance."}
{"number": 749, "change": "@@ -35,10 +35,11 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     PyObject* ret_keypoints = PyList_New(num_keypoints);\n     // import cv2\n     PyObject* cv2_mod = PyImport_ImportModule(\"cv2\");\n+    PyObject* cv2_keypoint_class = PyObject_GetAttrString(cv2_mod, \"KeyPoint\");\n \n     for(size_t i = 0; i < num_keypoints; ++i) {\n         // cv2_keypoint = cv2.KeyPoint()\n-        PyObject* cv2_keypoint = PyObject_CallMethod(cv2_mod, const_cast<char*>(\"KeyPoint\"), NULL);\n+        PyObject* cv2_keypoint = PyObject_CallObject(cv2_keypoint_class, NULL);\n \n         // build values\n         PyObject* cv2_keypoint_size = Py_BuildValue(\"f\", keypoints[i].size);\n@@ -68,6 +69,7 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     }\n \n     Py_DECREF(cv2_mod);\n+    Py_DECREF(cv2_keypoint_class);\n \n     return ret_keypoints;\n }\n", "fix_pattern": "<pattern>: if an API call to PyObject_CallMethod is made to create an object, refactor the code to first retrieve the class using PyObject_GetAttrString and then call it using PyObject_CallObject to avoid redundant lookup performance costs. Additionally, manage the reference counts with Py_DECREF to prevent memory leaks."}
{"number": 751, "change": "@@ -223,9 +223,9 @@ void DBuiltinIconEngine::paint(QPainter *painter, const QRect &rect,\n \n     // \u5982\u679c\u6709 background \u5219\u7ed8\u5236\u80cc\u666f\u56fe\u5148\n     QString bgFileName = entry->filename + QStringLiteral(\".background\");\n-    QIcon bgIcon = QIcon(bgFileName);\n-    if (!bgIcon.isNull()) {\n-        bgIcon.paint(painter, rect, Qt::AlignCenter, mode, state);\n+\n+    if (QFile::exists(bgFileName)) {\n+        QIcon(bgFileName).paint(painter, rect, Qt::AlignCenter, mode, state);\n     }\n \n     QPixmap pm = entry->pixmap(pixmapSize, mode, state);\n", "fix_pattern": "<pattern>: if a QIcon is created but then checked for nullity before painting, first check for file existence using QFile::exists to avoid unnecessary construction of the QIcon object, which improves performance by preventing the instantiation of an unused QIcon."}
{"number": 757, "change": "@@ -692,9 +692,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    continue;\n \t}\n \n-\t// This should be safe here.\n-\tchar* theData = NULL;\n-\ttheData = (char*) alloca(blobsize+4);\n+\tchar* theData = (char*) malloc(blobsize+4);\n \n \tif (theData == 0) {\n \t    std::cerr << \"Could Not allocate memory for data!\" << std::endl;\n@@ -709,6 +707,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    // bad writes to the offline-data files.\n \t    std::cerr << \"Bad read of data for \" << rawfilename\n \t\t<< \" expected: \" << blobsize << \" got:\" << bytesRead << std::endl;\n+\t    if (theData) free(theData);\n \t    continue;\n \t}\n \n@@ -717,6 +716,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t// This is the first index into the DataQueue.\n \tBlob datablob(blobsize, theData);\n \tDataQueues::enqueuePerformanceData(datablob);\n+\tif (theData) free(theData);\n \n     } // while\n \n", "fix_pattern": "<pattern>: if the code is using alloca to allocate memory on the stack, replace it with malloc for heap allocation, ensuring proper memory management, including freeing the allocated memory later in the code."}
{"number": 763, "change": "@@ -10,7 +10,6 @@\n #include \"archive.hh\"\n #include \"callback.hh\"\n #include \"remote-store.hh\"\n-#include \"sync.hh\"\n \n #include <nlohmann/json.hpp>\n #include <regex>\n@@ -1103,7 +1102,7 @@ std::map<StorePath, StorePath> copyPaths(\n     };\n \n     // total is accessed by each copy, which are each handled in separate threads\n-    Sync<uint64_t> _total = 0;\n+    std::atomic<uint64_t> total = 0;\n \n     for (auto & missingPath : sortedMissing) {\n         auto info = srcStore.queryPathInfo(missingPath);\n@@ -1126,9 +1125,8 @@ std::map<StorePath, StorePath> copyPaths(\n             PushActivity pact(act.id);\n \n             LambdaSink progressSink([&](std::string_view data) {\n-                auto total(_total.lock());\n-                *total += data.size();\n-                act.progress(*total, info->narSize);\n+                total += data.size();\n+                act.progress(total, info->narSize);\n             });\n             TeeSink tee { sink, progressSink };\n \n", "fix_pattern": "<pattern>: if a synchronization mechanism like a lock is used on an integer to ensure thread safety, replace it with an atomic variable to improve performance by avoiding the overhead of locking while still ensuring thread safety with atomic operations."}
{"number": 765, "change": "@@ -1040,7 +1040,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n         loadLibrary(id_lib);\n \n     uint nPage = 0;\n-    if(!QFileInfo(url).exists())\n+    if(!QFileInfo::exists(url))\n     {\n         if(strings.count()>0)\n         {\n@@ -1099,7 +1099,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n             ts.device()->write(file.readAll());\n         }\n     }\n-    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo(url).exists())\n+    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo::exists(url))\n     {\n         QString id=strings[2];\n         fb2mobi fb;\n", "fix_pattern": "<pattern>: if QFileInfo is used to check the existence of a file multiple times in conditions, replace the object creation with a static call to QFileInfo::exists to optimize performance by avoiding unnecessary instantiation."}
{"number": 767, "change": "@@ -295,7 +295,7 @@ static bool CreateMainSurface(int w, int h)\n \n \tDEBUG(misc, 0) (\"sdl: using mode %dx%d\", w, h);\n \n-\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_HWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n+\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_SWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n \tif(newscreen == NULL)\n \t\treturn false;\n \n", "fix_pattern": "<pattern>: if the SDL_SetVideoMode function is called with SDL_HWSURFACE, replace it with SDL_SWSURFACE for potentially better performance in environments that may not fully support hardware surfaces, thus avoiding unnecessary overhead associated with hardware surface rendering."}
{"number": 778, "change": "@@ -119,16 +119,12 @@ QList<QCameraDevice> QGstreamerVideoDevices::videoDevices() const\n \n void QGstreamerVideoDevices::addDevice(GstDevice *device)\n {\n-    gchar *type = gst_device_get_device_class(device);\n-    gst_object_ref(device);\n-    if (!strcmp(type, \"Video/Source\") || !strcmp(type, \"Source/Video\")) {\n+    if (gst_device_has_classes(device, \"Video/Source\")) {\n+        gst_object_ref(device);\n         m_videoSources.push_back({device, QByteArray::number(m_idGenerator)});\n         videoInputsChanged();\n         m_idGenerator++;\n-    } else {\n-        gst_object_unref(device);\n     }\n-    g_free(type);\n }\n \n void QGstreamerVideoDevices::removeDevice(GstDevice *device)\n", "fix_pattern": "<pattern>: if a comparison of device classes is performed using strcmp, replace it with the more efficient function gst_device_has_classes to avoid the overhead of string comparison and potentially streamline the logic flow for checking device classes."}
{"number": 780, "change": "@@ -55,7 +55,7 @@ std::string raw_text(const GumboNode * node)\n     else if( child_node->type == GUMBO_NODE_ELEMENT )\n     {\n       inner_text.push_back(' ');\n-      inner_text.append(text(child_node));\n+      inner_text.append(raw_text(child_node));\n     }\n   }\n \n", "fix_pattern": "<pattern>: if an API method used for text extraction (text) is replaced by a more efficient method (raw_text), it indicates that the new method offers better performance or fewer overheads in the context of extracting text from nodes in the HTML parsing process."}
{"number": 790, "change": "@@ -8,8 +8,11 @@ namespace pink {\n \n PinkEpoll::PinkEpoll()\n {\n-  epfd_ = epoll_create(1024); \n-  fcntl(epfd_, F_SETFD, fcntl(epfd_, F_GETFD) | FD_CLOEXEC);\n+  epfd_ = epoll_create1(EPOLL_CLOEXEC);\n+  if (epfd_ < 0) {\n+    log_err(\"epoll create fail\")\n+    exit(1)\n+  }\n   events_ = (struct epoll_event *)malloc(sizeof(struct epoll_event) * PINK_MAX_CLIENTS);\n   if (!events_) {\n     log_err(\"init epoll_event error\");\n", "fix_pattern": "<pattern>: if epoll_create is used without the additional flags for better security and atomicity, replace it with epoll_create1 with appropriate flags, which provides a more robust and safer method for creating epoll instances."}
{"number": 795, "change": "@@ -2585,8 +2585,12 @@ QString QWebPage::userAgentForUrl(const QUrl& url) const\n \n     QChar securityStrength(QLatin1Char('N'));\n #if !defined(QT_NO_OPENSSL)\n-    if (QSslSocket::supportsSsl())\n-        securityStrength = QLatin1Char('U');\n+    // we could check QSslSocket::supportsSsl() here, but this makes\n+    // OpenSSL, certificates etc being loaded in all cases were QWebPage\n+    // is used. This loading is not needed for non-https.\n+    securityStrength = QLatin1Char('U');\n+    // this may lead to a false positive: We indicate SSL since it is\n+    // compiled in even though supportsSsl() might return false\n #endif\n     ua = ua.arg(securityStrength);\n \n", "fix_pattern": "<pattern>: if a method call (like QSslSocket::supportsSsl()) introduces unnecessary overhead for performance-sensitive paths, remove that call and set a derived security property (like securityStrength) directly, while noting the implications of potential false positives."}
{"number": 798, "change": "@@ -716,7 +716,7 @@ void CreateMainFrame(FrameCreationCallback inOnFrame,int inWidth,int inHeight,\n             }\n \n             sdl_flags |= SDL_OPENGL;\n-            if (!(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags | SDL_OPENGL)))\n+            if (!SDL_VideoModeOK( use_w, use_h, 32, sdl_flags) || !(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags)))\n             {\n                if (pass==2 && aa_pass==0)\n                {\n", "fix_pattern": "<pattern>: if a call to SDL_SetVideoMode is made without a prior check for video mode validity, first validate with SDL_VideoModeOK to potentially avoid an unnecessary set video mode operation, improving performance by preventing failures or retries."}
{"number": 806, "change": "@@ -797,10 +797,10 @@ bool RageDisplay_OGL::BeginFrame()\n \n void RageDisplay_OGL::EndFrame()\n {\n-\t// Give up the CPU to the OpenGL host if it wants it; in any case, make\n-\t// sure the frame is done. This helps graphics smoothness a lot by\n-\t// making sure we get the most out of each frame.\n-\tglFinish();\n+\t// glFlush(), not glFinish(); NVIDIA_GLX's glFinish()'s behavior is\n+\t// nowhere near performance-friendly and uses unholy amounts of CPU for\n+\t// Gog-knows-what.\n+\tglFlush();\n \n \twind->SwapBuffers();\n \tProcessStatsOnFlip();\n", "fix_pattern": "<pattern>: if glFinish() is used as a means to sync with the GPU, replace it with glFlush() to improve performance, as glFinish() can introduce significant CPU overhead that affects rendering efficiency."}
{"number": 807, "change": "@@ -236,8 +236,6 @@ void GLC_Texture::glcBindTexture(void)\n \t\tglLoadTexture();\n \t}\n \tglBindTexture(GL_TEXTURE_2D, m_GlTextureID);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n \n QImage GLC_Texture::loadFromFile(const QString& fileName)\n", "fix_pattern": "<pattern>: if multiple OpenGL texture parameter settings with the same target are called consecutively, consolidate them into a single function call to improve performance and reduce state changes."}
{"number": 810, "change": "@@ -101,16 +101,14 @@ Painter& Painter::draw(const std::string& str, bool difference)\n     if (str.empty())\n         return *this;\n \n+    if (!cairo_has_current_point(m_cr.get()))\n+        return *this;\n+\n     double x, y;\n-    cairo_font_extents_t fe;\n     cairo_text_extents_t textext;\n \n-    cairo_font_extents(m_cr.get(), &fe);\n     cairo_text_extents(m_cr.get(), str.c_str(), &textext);\n \n-    if (!cairo_has_current_point(m_cr.get()))\n-        return *this;\n-\n     AutoSaveRestore sr(*this);\n \n     cairo_get_current_point(m_cr.get(), &x, &y);\n", "fix_pattern": "<pattern>: if a function call to cairo_font_extents is unnecessary and does not affect the outcome of subsequent logic (like checking cairo_has_current_point), remove it to improve performance by avoiding redundant API calls."}
{"number": 812, "change": "@@ -112,7 +112,7 @@ namespace\n         DBusActivateTimeout()\n         {\n             bool ok;\n-            mTimeoutMs = qgetenv(\"QTXDG_DBUSACTIVATE_TIMEOUT\").toInt(&ok);\n+            mTimeoutMs = qEnvironmentVariableIntValue(\"QTXDG_DBUSACTIVATE_TIMEOUT\", &ok);\n             if (!ok)\n                 mTimeoutMs = 1500;\n         }\n", "fix_pattern": "<pattern>: if using qgetenv() followed by toInt() to retrieve an environment variable as an integer, replace it with qEnvironmentVariableIntValue() to reduce overhead and improve performance by directly reading and converting in one call."}
{"number": 822, "change": "@@ -407,8 +407,6 @@ void QrcParserPrivate::collectResourceFilesForSourceFile(const QString &sourceFi\n                                                          const QLocale *locale) const\n {\n     // TODO: use FileName from fileutils for file pathes\n-    QTC_CHECK(QFileInfo(sourceFile).isFile());\n-    QTC_CHECK(QFileInfo(sourceFile).isAbsolute());\n \n     QStringList langs = allUiLanguages(locale);\n     SMap::const_iterator file = m_files.find(sourceFile);\n", "fix_pattern": "<pattern>: if multiple QFileInfo instances are created for the same file, instantiate QFileInfo once and reuse it for various checks to avoid unnecessary object creation overhead."}
{"number": 830, "change": "@@ -135,9 +135,8 @@ KMKernel::KMKernel(QObject *parent) :\n     mSystemTray(Q_NULLPTR),\n     mDebugBaloo(false)\n {\n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n+\n     if (!s_networkConfigMgr) {\n         s_networkConfigMgr = new QNetworkConfigurationManager(QCoreApplication::instance());\n     }\n", "fix_pattern": "<pattern>: if there is an environment variable check using qgetenv followed by a check for emptiness with isEmpty(), replace it with a direct call to qEnvironmentVariableIsEmpty to simplify the check and improve performance."}
{"number": 835, "change": "@@ -77,7 +77,7 @@ bool BasicIndexingJob::index()\n     }\n \n     if (fileInfo.isDir()) {\n-        doc.addBoolTerm(QLatin1String(\"folder\"), QLatin1String(\"T\"));\n+        doc.addBoolTerm(QStringLiteral(\"Tfolder\"));\n \n         // This is an optimization for folders. They do not need to go through\n         // file indexing, so there are no indexers for folders\n", "fix_pattern": "<pattern>: if a QLatin1String is constructed using a string literal for values that will not change, replace it with QStringLiteral for potentially better performance and memory usage."}
{"number": 838, "change": "@@ -264,17 +264,29 @@ void agiGLPipeline::BeginFrame()\n \n     gl_context_->MakeCurrent();\n \n-    if (PARAM_frameclear.get_or(true))\n+    bool frameclear = PARAM_frameclear.get_or(true);\n+\n+    if (frameclear)\n     {\n         agiGL->EnableDisable(GL_SCISSOR_TEST, false);\n+        agiGL->DepthMask(true);\n         glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n-        glClear(GL_COLOR_BUFFER_BIT);\n     }\n \n     if (fbo_ != 0)\n     {\n+        if (frameclear)\n+        {\n+            glClear(GL_COLOR_BUFFER_BIT);\n+        }\n+\n         glBindFramebuffer(GL_FRAMEBUFFER, fbo_);\n     }\n+\n+    if (frameclear)\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n+    }\n }\n \n void agiGLPipeline::BeginScene()\n", "fix_pattern": "<pattern>: if a condition is checked multiple times with the same result, cache the result in a variable to avoid unnecessary repeated calls, and ensure to organize the flow of API calls for better clarity and potential performance improvements."}
{"number": 847, "change": "@@ -17,10 +17,10 @@\n //===----------------------------------------------------------------------===//\n \n #include \"../SwiftShims/GlobalObjects.h\"\n+#include \"../SwiftShims/LibcShims.h\"\n #include \"swift/Runtime/Metadata.h\"\n #include \"swift/Runtime/Debug.h\"\n #include <stdlib.h>\n-#include <random>\n \n namespace swift {\n // FIXME(ABI)#76 : does this declaration need SWIFT_RUNTIME_STDLIB_INTERFACE?\n@@ -116,18 +116,10 @@ static swift::_SwiftHashingParameters initializeHashingParameters() {\n   if (determinism && 0 == strcmp(determinism, \"1\")) {\n     return { 0, 0, true };\n   }\n-#if defined(__APPLE__)\n-  // Use arc4random if available.\n   __swift_uint64_t seed0 = 0, seed1 = 0;\n-  arc4random_buf(&seed0, sizeof(seed0));\n-  arc4random_buf(&seed1, sizeof(seed1));\n+  swift::_stdlib_random(&seed0, sizeof(seed0));\n+  swift::_stdlib_random(&seed1, sizeof(seed1));\n   return { seed0, seed1, false };\n-#else\n-  std::random_device randomDevice;\n-  std::mt19937_64 engine(randomDevice());\n-  std::uniform_int_distribution<__swift_uint64_t> distribution;\n-  return { distribution(engine), distribution(engine), false };\n-#endif\n }\n \n SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_BEGIN\n", "fix_pattern": "<pattern>: if the code is using platform-specific random number generation (arc4random_buf) for macOS, replace it with a more generic and potentially optimized API (swift::_stdlib_random) to improve performance and maintain consistency across different platforms."}
{"number": 850, "change": "@@ -536,8 +536,6 @@ hasMergeGroup(MergeGroupKind Kind) {\n void swift::\n collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n                     llvm::SmallDenseMap<ValueDecl*, ValueDecl*> &DefaultMap) {\n-  Type BaseTy = PD->getDeclaredInterfaceType();\n-  DeclContext *DC = PD->getInnermostDeclContext();\n   auto HandleMembers = [&](DeclRange Members) {\n     for (Decl *D : Members) {\n       auto *VD = dyn_cast<ValueDecl>(D);\n@@ -550,11 +548,8 @@ collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n       if (VD->getBaseName().empty())\n         continue;\n \n-      ResolvedMemberResult Result = resolveValueMember(*DC, BaseTy,\n-                                                       VD->getFullName());\n-      assert(Result);\n-      for (auto *Default : Result.getMemberDecls(InterestedMemberKind::All)) {\n-        if (PD == Default->getDeclContext()->getExtendedProtocolDecl()) {\n+      for (auto *Default: PD->lookupDirect(VD->getFullName())) {\n+        if (Default->getDeclContext()->getExtendedProtocolDecl() == PD) {\n           DefaultMap.insert({Default, VD});\n         }\n       }\n", "fix_pattern": "<pattern>: if a resolved member lookup is performed via resolveValueMember, replace it with a direct lookup using PD->lookupDirect to improve performance by avoiding unnecessary resolution overhead."}
{"number": 853, "change": "@@ -504,11 +504,6 @@ Future<std::shared_ptr<parquet::arrow::FileReader>> ParquetFileFormat::GetReader\n                                                          default_fragment_scan_options));\n   auto properties = MakeReaderProperties(*this, parquet_scan_options.get(), source.path(),\n                                          source.filesystem(), options->pool);\n-  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n-  // TODO(ARROW-12259): workaround since we have Future<(move-only type)>\n-  auto reader_fut = parquet::ParquetFileReader::OpenAsync(\n-      std::move(input), std::move(properties), metadata);\n-  auto path = source.path();\n   auto self = checked_pointer_cast<const ParquetFileFormat>(shared_from_this());\n \n   return source.OpenAsync().Then(\n", "fix_pattern": "<pattern>: NA"}
{"number": 863, "change": "@@ -596,11 +596,9 @@ void e6y_PreprocessLevel(void)\n \n void gld_InitGLVersion(void)\n {\n-  char ver[256];\n   int MajorVersion, MinorVersion;\n   glversion = OPENGL_VERSION_1_0;\n-  strncpy(ver, glGetString(GL_VERSION), sizeof(ver));\n-  if (sscanf(ver, \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n+  if (sscanf(glGetString(GL_VERSION), \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n   {\n     if (MajorVersion > 1)\n     {\n", "fix_pattern": "<pattern>: if the code copies a string from `glGetString` to a temporary buffer using `strncpy`, directly use the result of `glGetString` in `sscanf` to save memory and eliminate an unnecessary copy."}
{"number": 864, "change": "@@ -254,8 +254,14 @@ namespace pos{\n       static void get(T* &data, std::string path, PixelConfigKey key){\n \n       unsigned int theKey=key.key();\n-    \n-      assert(theKey<=getConfig().size());\n+      \n+      static PixelConfigList configList=getConfig();\n+\n+      if (theKey>configList.size()){\n+\tconfigList=getConfig();\n+      }\n+\n+      assert(theKey<=configList.size());\n     \n       unsigned int last=path.find_last_of(\"/\");\n       assert(last!=std::string::npos);\n@@ -278,7 +284,7 @@ namespace pos{\n //      std::cout << \"[pos::PixelConfigFile::get()]\\t\\t\\tExtracted ext :\"<<ext <<std::endl;\n     \n       unsigned int version;\n-      int err=getConfig()[theKey].find(dir,version);   \n+      int err=configList[theKey].find(dir,version);   \n       // assert(err==0);\n       if(0!=err) \n \t{\n", "fix_pattern": "<pattern>: if a configuration list is retrieved multiple times within a function call, store it in a static variable to avoid redundant calls to getConfig() and improve performance, ensuring to check for size validity."}
{"number": 865, "change": "@@ -729,11 +729,8 @@ int QString16::localeAwareCompare(QStringView16 str1, QStringView16 str2)\n    }\n \n #if defined(Q_OS_WIN32)\n-   QString16 tmp1(str1.begin(), str1.end());\n-   QString16 tmp2(str2.begin(), str2.end());\n-\n-   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)tmp1.constData(), tmp1.size_storage(),\n-        (wchar_t *)tmp2.constData(), tmp2.size_storage());\n+   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)str1.charData(), str1.size_storage(),\n+        (wchar_t *)str2.charData(), str2.size_storage());\n \n    switch (retval) {\n       case CSTR_LESS_THAN:\n", "fix_pattern": "<pattern>: if temporary QString16 objects are created to convert QString data before passing it to an API, replace them with direct access to the char data and size functions of QString to eliminate unnecessary object creation and improve performance."}
{"number": 885, "change": "@@ -41,7 +41,18 @@ void GLIndexBuf::bind()\n \n void GLIndexBuf::bind_as_ssbo(uint binding)\n {\n-  bind();\n+  if (ibo_id_ == 0 || data_ != nullptr) {\n+    /* Calling `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo_id_)` changes the index buffer\n+     * of the currently bound VAO.\n+     *\n+     * In the OpenGL backend, the VAO state persists even after `GLVertArray::update_bindings`\n+     * is called.\n+     *\n+     * NOTE: For safety, we could call `glBindVertexArray(0)` right after drawing a `GPUBatch`.\n+     * However, for performance reasons, we have chosen not to do so. */\n+    glBindVertexArray(0);\n+    bind();\n+  }\n   BLI_assert(ibo_id_ != 0);\n   glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, ibo_id_);\n }\n", "fix_pattern": "<pattern>: if a binding operation is performed via glBindVertexArray before a specific condition (like checking if ibo_id_ is 0 or data_ is not null), it is refactored to avoid unnecessary binding calls, which can lead to performance improvements by preventing redundant state changes in the OpenGL pipeline."}
{"number": 886, "change": "@@ -1583,7 +1583,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\tglClear(GL_COLOR_BUFFER_BIT);\n \t\tif (sdl.opengl.pixel_buffer_object) {\n \t\t\tglUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, sdl.draw.width,\n \t\t\t                sdl.draw.height, GL_BGRA_EXT,\n \t\t\t                GL_UNSIGNED_INT_8_8_8_8_REV, 0);\n@@ -1591,7 +1590,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\t} else if (changedLines) {\n \t\t\tint y = 0;\n \t\t\tsize_t index = 0;\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\twhile (y < sdl.draw.height) {\n \t\t\t\tif (!(index & 1)) {\n \t\t\t\t\ty += changedLines[index];\n", "fix_pattern": "<pattern>: if glBindTexture is called multiple times with the same parameters consecutively, remove redundant calls to improve performance."}
{"number": 890, "change": "@@ -15,6 +15,7 @@\n #endif\n #include <folly/ScopeGuard.h>\n #include <folly/String.h>\n+#include <folly/system/Pid.h>\n \n #if defined(_WIN32) || defined(O_PATH)\n #define CAN_OPEN_SYMLINKS 1\n@@ -453,9 +454,19 @@ w_string FileDescriptor::getOpenedPath() const {\n #elif defined(__linux__) || defined(__sun)\n   char procpath[1024];\n #if defined(__linux__)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/fd/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/fd/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #elif defined(__sun)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/path/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/path/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #endif\n \n   // Avoid an extra stat by speculatively attempting to read into\n", "fix_pattern": "<pattern>: if a process ID is repeatedly fetched using getpid(), replace it with a cached version provided by folly::get_cached_pid() to avoid the performance overhead of system calls."}
{"number": 898, "change": "@@ -905,17 +905,18 @@ void CVideoPlayer::OpenDefaultStreams(bool reset)\n     CloseStream(m_CurrentVideo, true);\n \n   // open audio stream\n-  if(m_PlayerOptions.video_only)\n-    streams.clear();\n-  else\n-    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n   valid   = false;\n-\n-  for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+  if(!m_PlayerOptions.video_only)\n   {\n-    if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n-      valid = true;\n+    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n+\n+    for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+    {\n+      if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n+        valid = true;\n+    }\n   }\n+\n   if(!valid)\n     CloseStream(m_CurrentAudio, true);\n \n", "fix_pattern": "<pattern>: if a conditionally clearing a collection (streams.clear()) is followed by a reassignment based on the same condition, restructure the code to eliminate the unnecessary clearing operation and directly assign when conditions allow, improving performance by reducing redundant operations."}
{"number": 905, "change": "@@ -938,7 +938,10 @@ egl::ConfigSet Renderer11::generateConfigs()\n         // Additional high bit depth formats added in D3D 10.0\n         // https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064.aspx\n         colorBufferFormats.push_back(GL_RGBA16F);\n-        colorBufferFormats.push_back(GL_RGB10_A2);\n+\n+        // TODO(geofflang): Re-enable once client code has been updated to filter configs better and\n+        // not use RGB10A2 accidentally when requesting RGBA8\n+        // colorBufferFormats.push_back(GL_RGB10_A2);\n     }\n \n     if (!mPresentPathFastEnabled)\n", "fix_pattern": "<pattern>: if a call to push back an invalid or unoptimized color format is detected, comment it out until client code can be updated to filter configurations properly, thus avoiding unnecessary overhead or potential misconfigurations."}
{"number": 907, "change": "@@ -75,7 +75,12 @@ std::vector<uint32_t> preprocessSpirv(\n \t}\n \n \tstd::vector<uint32_t> optimized;\n-\topt.Run(code.data(), code.size(), &optimized);\n+\tspvtools::OptimizerOptions options;\n+#if defined(NDEBUG)\n+\toptions.set_run_validator(false);\n+#endif\n+\n+\topt.Run(code.data(), code.size(), &optimized, options);\n \n \tif(false)\n \t{\n", "fix_pattern": "<pattern>: if an API method call is made without options that may control performance-sensitive features, enhance the call by utilizing options like disabling unnecessary validation in release builds to improve performance."}
{"number": 912, "change": "@@ -94,7 +94,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\t    node_type != abnode_type::equipment)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_server_dn(pnode, dn, sizeof(dn));\n-\t\tstrcat(dn, \"/cn=Microsoft Private MDB\");\n+\t\tHX_strlcat(dn, \"/cn=Microsoft Private MDB\", arsizeof(dn));\n \t\tif (NULL == pbuff) {\n \t\t\tpprop->value.pv = ndr_stack_alloc(\n \t\t\t\tNDR_STACK_OUT, strlen(dn) + 1);\n@@ -471,7 +471,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\tif (node_type != abnode_type::person)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_user_info(pnode, USER_STORE_PATH, dn, GX_ARRAY_SIZE(dn));\n-\t\tstrcat(dn, \"/config/portrait.jpg\");\n+\t\tHX_strlcat(dn, \"/config/portrait.jpg\", arsizeof(dn));\n \t\tif (!common_util_load_file(dn, &pprop->value.bin))\n \t\t\treturn ecNotFound;\n \t\treturn ecSuccess;\n", "fix_pattern": "<pattern>: if using strcat to concatenate strings where buffer size is a concern, replace it with a safer alternative such as HX_strlcat which takes the size of the destination buffer to prevent buffer overflows."}
{"number": 914, "change": "@@ -167,9 +167,10 @@ void EPollEngine::DelFd(EventHandler* eh)\n \t\treturn;\n \t}\n \n+\t// Do not initialize epoll_event because for EPOLL_CTL_DEL operations the event is ignored and can be NULL.\n+\t// In kernel versions before 2.6.9, the EPOLL_CTL_DEL operation required a non-NULL pointer in event,\n+\t// even though this argument is ignored. Since Linux 2.6.9, event can be specified as NULL when using EPOLL_CTL_DEL.\n \tstruct epoll_event ev;\n-\tmemset(&ev, 0, sizeof(ev));\n-\tev.data.fd = fd;\n \tint i = epoll_ctl(EngineHandle, EPOLL_CTL_DEL, fd, &ev);\n \n \tif (i < 0)\n", "fix_pattern": "<pattern>: if an epoll_event is being initialized for an EPOLL_CTL_DEL operation, avoid unnecessary initialization with memset or setting its fields, as the event data can be NULL and is ignored in this context."}
{"number": 927, "change": "@@ -28,9 +28,10 @@ void QKlamptDisplay::initializeGL(){\n }\n \n void QKlamptDisplay::paintGL(){\n-  glClear(0);\n   if(gui != NULL)\n     gui->SendGLRender();\n+  else\n+    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n }\n \n \n", "fix_pattern": "<pattern>: if glClear is called without any bitmask during a certain condition (like a clear operation being redundant), then ensure it explicitly clears the color and depth buffers only when necessary by combining the relevant bitmasks in one call."}
{"number": 931, "change": "@@ -1096,7 +1096,7 @@ grLfbWriteRegion( GrBuffer_t dst_buffer,\n       }\n \n       glBindTexture(GL_TEXTURE_2D, default_texture);\n-      glTexImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n+      glTexSubImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n \n       set_copy_shader();\n \n", "fix_pattern": "<pattern>: if a texture is already created and needs to be updated, replace glTexImage2D with glTexSubImage2D to improve performance by avoiding the overhead of reallocating texture memory."}
{"number": 939, "change": "@@ -240,8 +240,8 @@ ConVar filesystem_unbuffered_io( \"filesystem_unbuffered_io\", \"1\", 0, \"\" );\n #define UseUnbufferedIO() true\n #endif\n \n-ConVar filesystem_native( \"filesystem_native\", \"1\", 0, \"Use native FS or STDIO\" );\n-ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", IsX360() ? \"64\" : \"16\", 0, \"\" );\n+ConVar filesystem_native( \"filesystem_native\", \"0\", 0, \"Use native FS or STDIO\" );\n+ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", \"64\", 0, \"\" );\n ConVar filesystem_report_buffered_io( \"filesystem_report_buffered_io\", \"0\" );\n \n //-----------------------------------------------------------------------------\n@@ -417,7 +417,7 @@ FILE *CFileSystem_Stdio::FS_fopen( const char *filenameT, const char *options, u\n \n \tCBaseFileSystem::FixUpPath ( filenameT, filename, sizeof( filename ) );\n \n-#ifdef _WIN32\n+#if defined(_WIN32) && 0\n \tif ( CWin32ReadOnlyFile::CanOpen( filename, options ) )\n \t{\n \t\tpFile = CWin32ReadOnlyFile::FS_fopen( filename, options, size );\n", "fix_pattern": "<pattern>: if there are changes to configuration variables (ConVar) that affect performance, ensure the values are optimized for the specific platform or environment, such as setting \"filesystem_native\" to \"0\" to potentially favor the STDIO approach over native file system access for performance reasons."}
{"number": 942, "change": "@@ -136,19 +136,14 @@ void OpenGL::setupContext()\n \tstate.boundTextures.clear();\n \tstate.boundTextures.resize(maxTextureUnits, 0);\n \n-\tGLenum curgltextureunit;\n-\tglGetIntegerv(GL_ACTIVE_TEXTURE, (GLint *) &curgltextureunit);\n-\n-\tstate.curTextureUnit = (int) curgltextureunit - GL_TEXTURE0;\n-\n-\t// Retrieve currently bound textures for each texture unit.\n \tfor (int i = 0; i < (int) state.boundTextures.size(); i++)\n \t{\n \t\tglActiveTexture(GL_TEXTURE0 + i);\n-\t\tglGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint *) &state.boundTextures[i]);\n+\t\tglBindTexture(GL_TEXTURE_2D, 0);\n \t}\n \n-\tglActiveTexture(curgltextureunit);\n+\tglActiveTexture(GL_TEXTURE0);\n+\tstate.curTextureUnit = 0;\n \n \tcreateDefaultTexture();\n \n", "fix_pattern": "<pattern>: if OpenGL calls are used to query the current active texture unit and bound textures, replace the querying logic with direct calls to set the texture state, minimizing API calls and redundant state retrievals."}
{"number": 949, "change": "@@ -155,10 +155,13 @@ inline BOOL Win32uiHostGlue::DynamicApplicationInit(const TCHAR *cmd, const TCHA\n     TCHAR err_buf[256];\n     // It's critical Python is loaded *and initialized* before we load win32ui\n     // as just loading win32ui will cause it to call into Python.\n-    const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n-    for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n-        wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n-        hModCore = LoadLibrary(fname);\n+    hModCore = GetModuleHandle(py_dll);  // Check if Python is already loaded\n+    if (hModCore == NULL) {\n+        const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n+        for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n+            wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n+            hModCore = LoadLibrary(fname);\n+        }\n     }\n     if (hModCore == NULL) {\n         wsprintf(err_buf, _T(\"The application can not locate %s (%d)\\n\"), py_dll, GetLastError());\n", "fix_pattern": "<pattern>: if loading a library using LoadLibrary, first check if the library is already loaded using GetModuleHandle to avoid unnecessary calls to LoadLibrary, which can improve performance by reducing the overhead of multiple library load attempts."}
{"number": 954, "change": "@@ -378,14 +378,8 @@ bool PlVkRenderer::initialize(PDECODER_PARAMETERS params)\n \n     pl_vk_inst_params vkInstParams = pl_vk_inst_default_params;\n     {\n-        bool ok;\n-        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\", &ok);\n-        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\", &ok);\n-#ifdef QT_DEBUG\n-        if (!ok) {\n-            vkInstParams.debug = true;\n-        }\n-#endif\n+        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\");\n+        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\");\n     }\n     vkInstParams.get_proc_addr = (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();\n     vkInstParams.extensions = instanceExtensions.data();\n", "fix_pattern": "<pattern>: if the second parameter of `qEnvironmentVariableIntValue` is not utilized, remove it to avoid unnecessary performance overhead associated with passing an unused pointer."}
{"number": 959, "change": "@@ -38,15 +38,15 @@ void UpdateDetector::versionCheck( Theme *theme )\n     QUrl url(\"http://download.owncloud.com/clientupdater.php\");\n     QString ver = QString(\"%1.%2.%3\").arg(MIRALL_VERSION_MAJOR).arg(MIRALL_VERSION_MINOR).arg(MIRALL_VERSION_MICRO);\n \n-    QString platform = QString::fromLocal8Bit(\"stranger\");\n+    QString platform = QLatin1String(\"stranger\");\n #ifdef Q_OS_LINUX\n-    platform = QString::fromLocal8Bit(\"linux\");\n+    platform = QLatin1String(\"linux\");\n #endif\n #ifdef Q_OS_WIN32\n-    platform = QString::fromLocal8Bit( \"win32\" );\n+    platform = QLatin1String( \"win32\" );\n #endif\n #ifdef Q_OS_MACOS\n-    platform = QString::fromLocal8Bit( \"macos\" );\n+    platform = QLatin1String( \"macos\" );\n #endif\n \n     url.addQueryItem( \"version\", ver );\n", "fix_pattern": "<pattern>: if QString::fromLocal8Bit is used with static strings, replace it with QLatin1String for better performance since QLatin1String is optimized for such use cases in the Qt framework."}
{"number": 963, "change": "@@ -218,8 +218,6 @@ void table_t::stop()\n         time(&start);\n \n         fprintf(stderr, \"Sorting data and creating indexes for %s\\n\", name.c_str());\n-        pgsql_exec_simple(sql_conn, PGRES_COMMAND_OK, (fmt(\"ANALYZE %1%\") % name).str());\n-        fprintf(stderr, \"Analyzing %s finished\\n\", name.c_str());\n \n         // Special handling for empty geometries because geohash chokes on\n         // empty geometries on postgis 1.5.\n", "fix_pattern": "<pattern>: if a call to `pgsql_exec_simple` is immediately followed by a logging statement using `fprintf`, consider using a logging mechanism that combines both actions to reduce overhead from executing two separate functions in tight succession."}
{"number": 965, "change": "@@ -349,9 +349,16 @@ void SDLRenderTarget::blitRenderTarget(RenderTarget *s, int x, int y, int w, int\n \tSDLRenderTarget *src = dynamic_cast<SDLRenderTarget *>(s);\n \tassert(src);\n \n-\t// TODO: evil use of internal SDL api\n+\tSDL_Renderer *renderer = SDL_CreateSoftwareRenderer(surface);\n+\tassert(renderer);\n+\tSDL_Texture *tex = SDL_CreateTextureFromSurface(renderer, src->surface);\n+\tassert(tex);\n+\n \tSDL_Rect r; r.x = x; r.y = y; r.w = w; r.h = h;\n-\tSDL_SoftStretch(src->surface, 0, surface, &r);\n+\tSDL_RenderCopy(renderer, tex, nullptr, &r);\n+\n+\tSDL_DestroyTexture(tex);\n+\tSDL_DestroyRenderer(renderer);\n }\n \n RenderTarget *SDLBackend::newRenderTarget(unsigned int w, unsigned int h) {\n", "fix_pattern": "<pattern>: if the SDL_SoftStretch function is used for scaling surfaces, refactor the code to create a software renderer, create a texture from the source surface, and use SDL_RenderCopy to perform the copy operation, as it can provide better performance through hardware acceleration or more optimized rendering."}
{"number": 969, "change": "@@ -1100,9 +1100,11 @@ void Loader::fillEvaluationObject(const ScopeChain::Ptr &scope, LanguageObject *\n void Loader::fillEvaluationObjectBasics(const ScopeChain::Ptr &scopeChain, LanguageObject *object, EvaluationObject *evaluationObject)\n {\n     // append the property declarations\n-    foreach (const PropertyDeclaration &pd, object->propertyDeclarations)\n-        if (!evaluationObject->scope->declarations.contains(pd.name))\n-            evaluationObject->scope->declarations.insert(pd.name, pd);\n+    foreach (const PropertyDeclaration &pd, object->propertyDeclarations) {\n+        PropertyDeclaration &scopePropertyDeclaration = evaluationObject->scope->declarations[pd.name];\n+        if (!scopePropertyDeclaration.isValid())\n+            scopePropertyDeclaration = pd;\n+    }\n \n     applyFunctions(&m_engine, object, evaluationObject, scopeChain);\n     applyBindings(object, scopeChain);\n", "fix_pattern": "<pattern>: if multiple calls to check for existence and then insert into a map are detected, refactor the code to access the map once and modify the existing value if it is invalid, which reduces the overhead of multiple lookups."}
{"number": 974, "change": "@@ -32,14 +32,16 @@ bool header_match( const string & env_var_name,\n                    const string & header_name,\n                    const HTTPRequest & saved_response )\n {\n+    const char * const env_value = getenv( env_var_name.c_str() );\n+\n     /* case 1: neither header exists (OK) */\n-    if ( (not getenv( env_var_name.c_str() )) and (not saved_response.has_header( header_name )) ) {\n+    if ( (not env_value) and (not saved_response.has_header( header_name )) ) {\n         return true;\n     }\n \n     /* case 2: headers both exist (OK if values match) */\n-    if ( getenv( env_var_name.c_str() ) and saved_response.has_header( header_name ) ) {\n-        return saved_response.get_header_value( header_name ) == string( getenv( env_var_name.c_str() ) );\n+    if ( env_value and saved_response.has_header( header_name ) ) {\n+        return saved_response.get_header_value( header_name ) == string( env_value );\n     }\n \n     /* case 3: one exists but the other doesn't (failure) */\n", "fix_pattern": "<pattern>: if getenv() is called multiple times with the same variable, store the result in a local variable to avoid redundant calls and improve performance."}
{"number": 977, "change": "@@ -760,10 +760,8 @@ static QRegion scaleRegion(const QRegion &region, qreal factor)\n {\n     if (region.isEmpty() || qFuzzyCompare(factor, qreal(1)))\n         return region;\n-    if (region.rectCount() == 1)\n-        return QRegion(scaleRect(QRectF(region.boundingRect()), factor).toRect());\n     QRegion result;\n-    foreach (const QRect &rect, region.rects())\n+    for (const QRect &rect : region)\n         result += QRectF(QPointF(rect.topLeft()) * factor, QSizeF(rect.size() * factor)).toRect();\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is checking the count of rectangles in a QRegion and then iterating through them, replace the check and foreach with a range-based for loop directly on the QRegion to enhance readability and potentially improve performance by avoiding an extra function call."}
{"number": 979, "change": "@@ -1078,11 +1078,12 @@ void QIcon::addFile(const QString &fileName, const QSize &size, Mode mode, State\n     if (!d) {\n \n         QFileInfo info(fileName);\n-        QIconEngine *engine = iconEngineFromSuffix(fileName, info.suffix());\n+        QString suffix = info.suffix();\n #ifndef QT_NO_MIMETYPE\n-        if (!engine)\n-            engine = iconEngineFromSuffix(fileName, QMimeDatabase().mimeTypeForFile(info).preferredSuffix());\n+        if (suffix.isEmpty())\n+            suffix = QMimeDatabase().mimeTypeForFile(info).preferredSuffix(); // determination from contents\n #endif // !QT_NO_MIMETYPE\n+        QIconEngine *engine = iconEngineFromSuffix(fileName, suffix);\n         d = new QIconPrivate(engine ? engine : new QPixmapIconEngine);\n     }\n \n", "fix_pattern": "<pattern>: if an icon engine is retrieved using a suffix derived from the filename that depends on file info, first check if the suffix is empty and retrieve it conditionally only once, storing it in a variable to avoid redundant calls for the same operation."}
{"number": 984, "change": "@@ -859,9 +859,9 @@ void GLPaintContour::finalize_geometry()\n \n     if (!this->contour_indices.empty()) {\n         glsafe(::glGenBuffers(1, &this->m_contour_EBO_id));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, this->m_contour_EBO_id));\n-        glsafe(::glBufferData(GL_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, 0));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this->m_contour_EBO_id));\n+        glsafe(::glBufferData(GL_ELEMENT_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));\n         this->contour_indices.clear();\n     }\n }\n", "fix_pattern": "<pattern>: if the OpenGL API is being used to bind and buffer a data array, ensure to use the appropriate buffer type that matches the intended usage; replace `GL_ARRAY_BUFFER` with `GL_ELEMENT_ARRAY_BUFFER` when dealing with element indices to enhance performance and correctness."}
{"number": 985, "change": "@@ -172,7 +172,7 @@ QEvdevTouchScreenHandler::QEvdevTouchScreenHandler(const QString &specification,\n {\n     setObjectName(QLatin1String(\"Evdev Touch Handler\"));\n \n-    bool printDeviceInfo = qgetenv(\"QT_QPA_EVDEV_DEBUG\").toInt();\n+    bool printDeviceInfo = qEnvironmentVariableIntValue(\"QT_QPA_EVDEV_DEBUG\");\n \n     // only the first device argument is used for now\n     QString spec = QString::fromLocal8Bit(qgetenv(\"QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS\"));\n", "fix_pattern": "<pattern>: replace the combination of qgetenv and QString::toInt to read an environment variable as an integer directly using qEnvironmentVariableIntValue for improved performance."}
{"number": 989, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if the code is using QString to perform string joining and manipulation, replace character literals with QLatin1Char() to optimize performance and reduce overhead in character operations within QString methods."}
{"number": 992, "change": "@@ -184,7 +184,7 @@ void QXcbConnection::xi2Select(xcb_window_t window)\n     mask.mask_len = sizeof(bitMask);\n     mask.mask = xiBitMask;\n     // Enable each touchscreen\n-    foreach (XInput2DeviceData *dev, m_touchDevices.values()) {\n+    foreach (XInput2DeviceData *dev, m_touchDevices) {\n         mask.deviceid = dev->xiDeviceInfo->deviceid;\n         Status result = XISelectEvents(xDisplay, window, &mask, 1);\n         // If we have XInput >= 2.2 and successfully enable a touchscreen, then\n", "fix_pattern": "<pattern>: if accessing elements of a QList via the values() method results in performance overhead, replace it by directly iterating over the QList to avoid unnecessary copying of the underlying data."}
{"number": 995, "change": "@@ -2289,21 +2289,12 @@ TClass *TClass::GetBaseClass(const char *classname)\n \n    if (!fClassInfo) return 0;\n \n-   TObjLink *lnk = GetListOfBases() ? fBase->FirstLink() : 0;\n+   // Make sure we deal with possible aliases, we could also have normalized\n+   // the name.\n+   TClass *search = TClass::GetClass(classname);\n \n-   // otherwise look at inheritance tree\n-   while (lnk) {\n-      TClass     *c, *c1;\n-      TBaseClass *base = (TBaseClass*) lnk->GetObject();\n-      c = base->GetClassPointer();\n-      if (c) {\n-         if (strcmp(c->GetName(), classname) == 0) return c;\n-         c1 = c->GetBaseClass(classname);\n-         if (c1) return c1;\n-      }\n-      lnk = lnk->Next();\n-   }\n-   return 0;\n+   if (search) return GetBaseClass(search);\n+   else return 0;\n }\n \n //______________________________________________________________________________\n", "fix_pattern": "<pattern>: instead of iterating through a linked list to find class information, use a direct lookup via TClass::GetClass for better performance and efficiency in accessing the desired base class."}
{"number": 997, "change": "@@ -253,11 +253,6 @@ void OpenGLShaderRenderer::renderCrossair(const Common::Point crossairPosition)\n \t_triangleShader->setUniform(\"useStipple\", false);\n \t_triangleShader->setUniform(\"mvpMatrix\", identity);\n \n-\tglMatrixMode(GL_PROJECTION);\n-\tglLoadIdentity();\n-\tglOrtho(0, _screenW, _screenH, 0, 0, 1);\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglLoadIdentity();\n \tglEnable(GL_BLEND);\n \tglBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ZERO);\n \n", "fix_pattern": "<pattern>: if multiple OpenGL matrix operations are called in a sequence, it's beneficial to group them under a single matrix mode and minimize state changes to improve performance."}
{"number": 998, "change": "@@ -116,11 +116,7 @@ void Mesh::render() const {\n void Mesh::render(uint32_t mode, int count, int offset) const {\n     glBindVertexArray(_vao);\n     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _ibo);\n-\n     glDrawElements(mode, count, GL_UNSIGNED_SHORT, reinterpret_cast<void *>(offset));\n-\n-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n-    glBindVertexArray(0);\n }\n \n void Mesh::computeAABB() {\n", "fix_pattern": "<pattern>: if glBindBuffer and glBindVertexArray are being called with the argument 0, it may indicate an intention to unbind or reset state. This can be simplified or optimized by considering whether these calls are necessary, or if their logic can be handled more effectively within the rendering pipeline. If performance is a priority, it may be beneficial to review and restrict unnecessary state changes."}
{"number": 1000, "change": "@@ -194,7 +194,7 @@ inline void GlTexture::Upload(\n     GLenum data_format, GLenum data_type\n ) {\n     Bind();\n-    glTexSubImage2D(GL_TEXTURE_2D,0,0,0,width,height,data_format,data_type,data);\n+    glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, data_format, data_type, data);\n     CheckGlDieOnError();\n }\n \n", "fix_pattern": "<pattern>: when updating texture data for the whole texture, use glTexImage2D instead of glTexSubImage2D for improved performance, as the former can handle the entire texture in one call versus modifying sub-regions."}
{"number": 1002, "change": "@@ -32,14 +32,7 @@ GlobeGPS::GlobeGPS(QWidget* parent) : MarbleWidget(parent), loadedDives(0), edit\n \tQStringList list = mtm.mapThemeIds();\n \tQString  subsurfaceDataPath;\n \tQDir marble;\n-\tbool foundGoogleMap = false;\n-\tQ_FOREACH(const QString& theme, list){\n-\t\tif (theme == \"earth/googlesat/googlesat.dgml\"){\n-\t\t\tfoundGoogleMap = true;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tif (!foundGoogleMap) {\n+\tif (!list.contains(\"earth/googlesat/googlesat.dgml\")) {\n \t\tsubsurfaceDataPath = getSubsurfaceDataPath(\"marbledata\");\n \t\tif (subsurfaceDataPath != \"\") {\n \t\t\tMarbleDirs::setMarbleDataPath(subsurfaceDataPath);\n", "fix_pattern": "<pattern>: if a loop is used to check for the existence of an item in a QStringList, replace it with the QStringList::contains() method for better performance and readability."}
{"number": 1007, "change": "@@ -178,12 +178,12 @@ DatabaseCommand_Resolve::fullTextResolve( DatabaseImpl* lib )\n     QList< QPair<int, float> > trackPairs = lib->search( m_query );\n     QList< QPair<int, float> > albumPairs = lib->searchAlbum( m_query, 20 );\n \n+    TomahawkSqlQuery query = lib->newquery();\n+    query.prepare( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = ?\" );\n+\n     foreach ( const scorepair_t& albumPair, albumPairs )\n     {\n-        TomahawkSqlQuery query = lib->newquery();\n-\n-        QString sql = QString( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = %1\" ).arg( albumPair.first );\n-        query.prepare( sql );\n+        query.bindValue( 0, albumPair.first );\n         query.exec();\n \n         QList<Tomahawk::album_ptr> albumList;\n", "fix_pattern": "<pattern>: if constructing a SQL query with QString::arg is used for value substitution, replace it with parameterized queries using bindValue to improve performance and security (prevent SQL injection)."}
{"number": 1020, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified before being passed to the JS_DefinePropertyById function, and to simplify the call, set the configurable attribute directly on the descriptor and pass it without individually specifying getter, setter, and attributes. This reduces the overhead of constructing the property descriptor with multiple parameters and improves readability."}
{"number": 1028, "change": "@@ -118,7 +118,8 @@ KFileItemModelRolesUpdater::KFileItemModelRolesUpdater(KFileItemModel *model, QO\n     m_directoryContentsCounter = new KDirectoryContentsCounter(m_model, this);\n     connect(m_directoryContentsCounter, &KDirectoryContentsCounter::result, this, &KFileItemModelRolesUpdater::slotDirectoryContentsCountReceived);\n \n-    const auto plugins = KPluginMetaData::findPlugins(QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\"));\n+    const QString pluginNamespace = QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\");\n+    const auto plugins = KPluginMetaData::findPlugins(pluginNamespace, {}, KPluginMetaData::AllowEmptyMetaData);\n     for (const KPluginMetaData &data : plugins) {\n         auto instance = QPluginLoader(data.fileName()).instance();\n         auto plugin = qobject_cast<KOverlayIconPlugin *>(instance);\n", "fix_pattern": "<pattern>: if constructing a namespace string for KPluginMetaData::findPlugins involves repeated string manipulations, refactor the creation of the string into a separate variable to enhance readability and performance, while ensuring consistent use of the API."}
{"number": 1029, "change": "@@ -172,7 +172,8 @@ void SignalHistoryModel::onObjectAdded(QObject* object)\n   Q_ASSERT(thread() == QThread::currentThread());\n \n   // blacklist event dispatchers\n-  if (QString(object->metaObject()->className()).startsWith(\"QPAEventDispatcher\"))\n+  if (qstrncmp(object->metaObject()->className(), \"QPAEventDispatcher\", 18) == 0\n+    || qstrncmp(object->metaObject()->className(), \"QGuiEventDispatcher\", 19) == 0)\n     return;\n \n   beginInsertRows(QModelIndex(), m_tracedObjects.size(), m_tracedObjects.size());\n", "fix_pattern": "<pattern>: if a QString method is used to check for a prefix, replace it with qstrncmp for improved performance by avoiding QString overhead, especially in scenarios where only a few characters of comparison are needed."}
{"number": 1040, "change": "@@ -30,7 +30,7 @@\n #include \"vtkIdTypeArray.h\"\n #include \"vtkObjectFactory.h\"\n \n-vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18\");\n+vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18.6.1\");\n vtkStandardNewMacro(vtkDataSetAttributes);\n \n //--------------------------------------------------------------------------\n@@ -1470,16 +1470,16 @@ void vtkDataSetAttributes::CopyData(vtkDataSetAttributes::FieldList& list,\n                                     vtkDataSetAttributes* fromDSA,\n                                     int idx, vtkIdType fromId, vtkIdType toId)\n {\n-  vtkDataArray *fromDA;\n-  vtkDataArray *toDA;\n+  vtkAbstractArray *fromDA;\n+  vtkAbstractArray *toDA;\n   \n   int i;\n   for (i=0; i < list.NumberOfFields; i++)\n     {\n     if ( list.FieldIndices[i] >= 0 )\n       {\n-      toDA = this->GetArray(list.FieldIndices[i]);\n-      fromDA = fromDSA->GetArray(list.DSAIndices[idx][i]);\n+      toDA = this->GetAbstractArray(list.FieldIndices[i]);\n+      fromDA = fromDSA->GetAbstractArray(list.DSAIndices[idx][i]);\n       this->CopyTuple(fromDA, toDA, fromId, toId);\n       }\n     }\n", "fix_pattern": "<pattern>: if a specific API (vtkDataArray*) is replaced by a more generalized one (vtkAbstractArray*), it may indicate a move to more versatile or polymorphic data handling, which can improve performance through more efficient memory management and reduced type-checking overhead when handling datasets."}
{"number": 1043, "change": "@@ -90,7 +90,7 @@ namespace rwe\n \n         glGenerateMipmap(GL_TEXTURE_2D);\n \n-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if the texture magnification filter could impact performance, and a performance improvement can be achieved by changing the filter from GL_LINEAR to GL_NEAREST, then update the parameter to use GL_NEAREST for better performance in scenarios where linear filtering is not necessary."}
{"number": 1052, "change": "@@ -64,7 +64,7 @@\n #define VTK_PV_ANIMATION_GROUP \"animateable\"\n \n vtkStandardNewMacro(vtkPVAnimationManager);\n-vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.47\");\n+vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.48\");\n vtkCxxSetObjectMacro(vtkPVAnimationManager, HorizantalParent, vtkKWWidget);\n vtkCxxSetObjectMacro(vtkPVAnimationManager, VerticalParent, vtkKWWidget);\n //*****************************************************************************\n@@ -205,7 +205,6 @@ void vtkPVAnimationManager::Create(vtkKWApplication* app, const char* )\n \n   this->ActiveTrackSelector->SetParent(\n     this->VAnimationInterface->GetSelectorFrame());\n-  this->ActiveTrackSelector->SetAnimationManager(this);\n   this->ActiveTrackSelector->Create(app, \"-relief flat\");\n   this->Script(\"pack %s -anchor n -side top -expand t -fill both\",\n     this->ActiveTrackSelector->GetWidgetName());\n", "fix_pattern": "<pattern>: if the vtkCxxRevisionMacro is updated to a new version number without changing any other logic or behavior in the code, correctly increment the versioning to reflect updates, indicating a potential change in functionality or fixes within the class."}
{"number": 1064, "change": "@@ -58,15 +58,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made to get and set file descriptor flags, combine them to reduce the number of system calls and avoid unnecessary operations when the new flags are equal to the old flags."}
{"number": 1085, "change": "@@ -600,11 +600,8 @@ int iV_DrawFormattedText(const char* String, UDWORD x, UDWORD y, UDWORD Width, U\n \n void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotation)\n {\n-\tGLint matrix_mode = 0;\n-\n \tpie_SetTexturePage(TEXPAGE_FONT);\n \n-\tglGetIntegerv(GL_MATRIX_MODE, &matrix_mode);\n \tglMatrixMode(GL_TEXTURE);\n \tglPushMatrix();\n \tglLoadIdentity();\n@@ -630,7 +627,7 @@ void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotati\n \tglPopMatrix();\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n-\tglMatrixMode(matrix_mode);\n+\tglMatrixMode(GL_MODELVIEW);\n \n \t// Reset the current model view matrix\n \tglLoadIdentity();\n", "fix_pattern": "<pattern>: if retrieving the current matrix mode using glGetIntegerv(GL_MATRIX_MODE, ...) is unnecessary and a specific mode (e.g., GL_MODELVIEW) can be assumed or set directly, replace the call with a direct glMatrixMode(...) invocation to improve performance."}
{"number": 1086, "change": "@@ -76,15 +76,14 @@ void GlLine::draw(float,Camera *) {\n \t\tglLineStipple(factor,pattern);\n \t\tglEnable(GL_LINE_STIPPLE);\n \t}\n-\tglBegin(GL_LINE_STRIP);\n \n-\tfor(unsigned int i=0; i < _points.size(); ++i) {\n-\t\tif (i < _colors.size()) {\n-\t\t\tsetColor(_colors[i]);\n-\t\t}\n-\t\tglVertex3fv((float *)&_points[i]);\n-\t}\n-\tglEnd();\n+\tglEnableClientState(GL_VERTEX_ARRAY);\n+\tglEnableClientState(GL_COLOR_ARRAY);\n+\tglVertexPointer(3, GL_FLOAT, 3 * sizeof(float), &_points[0]);\n+\tglColorPointer(4, GL_UNSIGNED_BYTE, 4 * sizeof(unsigned char), &_colors[0]);\n+\tglDrawArrays(GL_LINE_STRIP, 0, _points.size());\n+\tglDisableClientState(GL_VERTEX_ARRAY);\n+\tglDisableClientState(GL_COLOR_ARRAY);\n \n \tOpenGlConfigManager::getInst().desactivateLineAndPointAntiAliasing();\n \n", "fix_pattern": "<pattern>: if OpenGL drawing commands use `glBegin` and `glEnd` for drawing multiple vertices and colors, refactor the code to use vertex array capabilities, enabling the appropriate client states and using `glDrawArrays` for improved performance and reduced overhead."}
{"number": 1089, "change": "@@ -563,7 +563,6 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n     int return_code;\n     LSTATUS status;\n     unsigned int i;\n-    char str[256];\n     VkResult res;\n \n     WINE_TRACE(\"Starting VR info initialization.\\n\");\n@@ -587,14 +586,8 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n         WINE_ERR(\"Could not get IVRClientCore, error %d.\\n\", return_code);\n     }\n \n-    if ((env_str = getenv(\"SteamGameId\")))\n-        app_id = atoi(env_str);\n-    else\n-        app_id = 1245040; /* Proton 5.0 */\n-\n     /* Without overriding the app_key vrclient waits 2 seconds for a valid appkey before returning. */\n-    sprintf(str, \"{ \\\"app_key\\\" : \\\"steam.app.%u\\\" }\", app_id);\n-    error = client_core->Init(vr::VRApplication_Background, str);\n+    error = client_core->Init(vr::VRApplication_Background, NULL);\n     if (error != vr::VRInitError_None)\n     {\n         if (error == vr::VRInitError_Init_NoServerForBackgroundApp)\n", "fix_pattern": "<pattern>: if the initialization of a string with `sprintf` for API calls is unnecessary (as seen in the removal of dynamic app_id generation), directly pass `NULL` to avoid unnecessary string manipulation and potential performance overhead."}
{"number": 1092, "change": "@@ -88,13 +88,18 @@ QVariant DateFilter::doFilter(const QVariant &input, const QVariant &argument,\n                               bool autoescape) const\n {\n   Q_UNUSED(autoescape)\n-  auto d = QDateTime::fromString(getSafeString(input),\n+    QDateTime d;\n+    if (input.type() == QVariant::DateTime) {\n+        d = input.toDateTime();\n+    } else if (input.type() == QVariant::Date) {\n+        d.setDate(input.toDate());\n+    } else {\n #if QT_VERSION < QT_VERSION_CHECK(5, 11, 0)\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss\"));\n #else\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\"));\n #endif\n-  );\n+    }\n \n   auto argString = getSafeString(argument);\n \n", "fix_pattern": "<pattern>: if the input type is checked for QVariant::DateTime or QVariant::Date, avoid calling QDateTime::fromString multiple times and directly use toDateTime() and setDate() methods to improve performance by reducing redundant string conversions."}
{"number": 1093, "change": "@@ -213,7 +213,12 @@ void EffectChain::render_to_screen(unsigned char *src)\n \t\tassert(false);\n \t}\n \n-\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\tstatic bool first = true;\n+\tif (first) {\n+\t\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\t} else {\n+\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, format, GL_UNSIGNED_BYTE, src);\n+\t}\n \tcheck_error();\n \tglUniform1i(glGetUniformLocation(glsl_program_num, \"input_tex\"), 0);\n \n", "fix_pattern": "<pattern>: if the initial texture data is uploaded once using glTexImage2D, subsequent updates should be performed using glTexSubImage2D to improve performance by avoiding full texture reallocation. Use a flag to track whether it is the first call or not."}
{"number": 1107, "change": "@@ -19,7 +19,7 @@\n  \n      For further information visit http://plib.sourceforge.net\n \n-     $Id: fnt.cc,v 1.1.2.5 2003-12-04 02:12:47 olly Exp $\n+     $Id: fnt.cc,v 1.1.2.6 2004-03-02 12:28:58 olly Exp $\n */\n \n #include \"fnt.h\"\n@@ -177,9 +177,6 @@ fntTexFont::load(const char *fname)\n \t\t (GLvoid *)teximage);\n     delete [] teximage;\n \n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n-\n     glAlphaFunc(GL_GREATER, 0.5f);\n \n     fseek(fd, fpos, SEEK_SET);\n", "fix_pattern": "<pattern>: NA"}
{"number": 1110, "change": "@@ -2459,7 +2459,6 @@ void MainScene(HDC hDC)\n \n         if (Success)\n         {\n-            glFlush();\n             SwapBuffers(hDC);\n         }\n \n", "fix_pattern": "<pattern>: if glFlush() is called without subsequent rendering commands that require completion, consider removing it or consolidating it to reduce unnecessary sync point overhead in OpenGL rendering."}
{"number": 1115, "change": "@@ -1573,7 +1573,7 @@ void KStartupInfoData::setApplicationId(const QString &desktop)\n     // the spec requires this is always a full path, in order for everyone to be able to find it\n     QString desk = QStandardPaths::locate(QStandardPaths::ApplicationsLocation, desktop);\n     if (desk.isEmpty()) {\n-        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, \"kservices5/\" + desktop);\n+        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, QLatin1String(\"kservices5/\") + desktop);\n     }\n     if (desk.isEmpty()) {\n         return;\n", "fix_pattern": "<pattern>: if a QString created from a literal is concatenated with another QString, use QLatin1String to avoid unnecessary conversion overhead for better performance."}
{"number": 1116, "change": "@@ -517,11 +517,14 @@ void Core::emitRichNotification(const QString &evid, const QString &title, const\n \n bool Core::emitBatteryChargePercentNotification(int currentPercent, int previousPercent, const QString &udi, Core::ChargeNotificationFlags flags)\n {\n-    using namespace Solid;\n-    Device device(udi);\n-    Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+    if (m_peripheralBatteriesPercent.contains(udi)) {\n+        using namespace Solid;\n+        Device device(udi);\n+        Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+        if (!b) {\n+            return false;\n+        }\n \n-    if (b && !b->isPowerSupply()) {\n         // if you leave the device out of reach or it has not been initialized yet\n         // it won't be \"there\" and report 0%, don't show anything in this case\n         if (!b->isPresent() || b->chargePercent() == 0) {\n", "fix_pattern": "<pattern>: if there is a need to check for a specific device's power supply status through an API call that is potentially costly, add a quick lookup check in a map or set to determine if further API usage is necessary, thus avoiding unnecessary calls when the information can be derived from a pre-checked structure."}
{"number": 1118, "change": "@@ -95,9 +95,9 @@ KAboutPerson KAboutPerson::fromJSON(const QJsonObject &obj)\n {\n     const QString name = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Name\"));\n     const QString task = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Task\"));\n-    const QString email = obj[QStringLiteral(\"Email\")].toString();\n-    const QString website = obj[QStringLiteral(\"Website\")].toString();\n-    const QUrl avatarUrl = obj[QStringLiteral(\"AvatarUrl\")].toVariant().toUrl();\n+    const QString email = obj.value(QLatin1String(\"Email\")).toString();\n+    const QString website = obj.value(QLatin1String(\"Website\")).toString();\n+    const QUrl avatarUrl = obj.value(QLatin1String(\"AvatarUrl\")).toVariant().toUrl();\n     return KAboutPerson(name, task, email, website, avatarUrl);\n }\n \n", "fix_pattern": "<pattern>: if accessing keys in a QJsonObject using QStringLiteral results in potential repeated conversions from QString to QByteArray, use QLatin1String instead for improved performance."}
{"number": 1119, "change": "@@ -99,9 +99,7 @@ KNotesApp::KNotesApp()\n {\n     Akonadi::ControlGui::widgetNeedsAkonadi(this);\n \n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n \n     if (KNotesGlobalConfig::self()->autoCreateResourceOnStart()) {\n         NoteShared::LocalResourceCreator *creator = new NoteShared::LocalResourceCreator(this);\n", "fix_pattern": "<pattern>: if checking for an environment variable and its value's emptiness, replace qgetenv and isEmpty with the more direct qEnvironmentVariableIsEmpty for improved performance."}
