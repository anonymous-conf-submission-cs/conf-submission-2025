{"number": 1, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.7 2005/06/12 17:21:53 brun Exp $\n+// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.8 2005/06/14 05:06:03 brun Exp $\n // Author: Wim Lavrijsen, Jan 2005\n \n // Bindings\n@@ -138,7 +138,7 @@ PyObject* PyROOT::RootObjectByValueExecutor::Execute( G__CallFunc* func, void* s\n    void* result2 = result1;\n    if ( fClass->GetClassInfo() && fClass->GetClassInfo()->Linkage() != -1 ) {\n       result2 = new char[ fClass->Size() ];\n-      mempcpy( result2, result1, fClass->Size() );\n+      memcpy( result2, result1, fClass->Size() );\n    }\n    G__pop_tempobject();            // doesn't call dtor\n \n", "fix_pattern": "<pattern>: if the code uses mempcpy unnecessarily when memcpy suffices, replace it with memcpy for improved performance since memcpy is typically optimized for this use case and avoids potential unnecessary complications."}
{"number": 3, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.30 2007/01/15 10:15:47 brun Exp $\n+// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.31 2007/02/06 11:48:48 rdm Exp $\n // Author: Fons Rademakers   11/09/95\n \n /*************************************************************************\n@@ -28,7 +28,6 @@\n #include \"TObjArray.h\"\n #include \"TError.h\"\n #include \"TROOT.h\"\n-#include \"TRandom.h\"\n \n ClassImp(TObjArray)\n \n@@ -615,7 +614,7 @@ void TObjArray::Randomize(Int_t ntimes)\n \n    for (Int_t i=0;i<ntimes;i++) {\n       for (Int_t j=0;j<fLast;j++) {\n-         Int_t k = (Int_t)gRandom->Uniform(0,fLast);\n+         Int_t k = (Int_t)(fLast*rand()/(RAND_MAX+1.0));\n          if (k == j) continue;\n          TObject *obj = fCont[j];\n          fCont[j] = fCont[k];\n", "fix_pattern": "<pattern>: if a call to gRandom->Uniform is replaced with a direct use of rand() from the Standard C Library, consider if this change is made to avoid the overhead or dependency of the ROOT Framework for simpler random number generation."}
{"number": 4, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.175 2007/03/02 08:52:02 brun Exp $\n+// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.176 2007/03/14 11:31:36 brun Exp $\n // Author: Andrei Gheata   25/10/01\n \n /*************************************************************************\n@@ -5578,7 +5578,12 @@ TGeoManager *TGeoManager::Import(const char *filename, const char *name, Option_\n    } else {   \n       // import from a root file\n       TFile *old = gFile;\n-      TFile *f = TFile::Open(filename);\n+      // in case a web file is specified, use the cacheread option to cache\n+      // this file in the local directory\n+      TFile::SetCacheFileDir(\".\");\n+      TFile *f = 0;\n+      if (strstr(filename,\"http://\")) f = TFile::Open(filename,\"CACHEREAD\");\n+      else                            f = TFile::Open(filename);\n       if (!f || f->IsZombie()) {\n          if (old) old->cd();\n          printf(\"Error in <TGeoManager::Import>: Cannot open file\\n\");\n", "fix_pattern": "<pattern>: if a filename is detected as a URL starting with \"http://\", utilize the \"CACHEREAD\" option when opening the file through the TFile API to potentially improve file access performance by caching the contents locally."}
{"number": 8, "change": "@@ -558,15 +558,15 @@ void ProofdExec()\n       char *buf = (char *) vb;\n       char *end = buf + len;\n       const char name[] = \"PROOF_ALLVARS=\";\n-      char *all = new char[strlen(name)+len]; // strlen(\"PROOF_ALLVARS=\") = 14\n-      strncpy(all, name, strlen(name)+len);\n-      all[strlen(name)+len-1] = 0;\n+      int alen = strlen(name)+len;\n+      char *all = new char[alen]; // strlen(\"PROOF_ALLVARS=\") = 14\n+      strlcpy(all, name, alen);\n       while (buf < end) {\n          if (gDebug > 0) ErrorInfo(\"ProofdExec: setting: %s\", buf);\n          char *p = index(buf, '=');\n          if (p) {\n-            if (buf != (char *) vb) strncat(all, \",\", 1); // skip the first one\n-            strncat(all, buf, p-buf);\n+            if (buf != (char *) vb) strlcat(all, \",\", alen); // skip the first one\n+            strlcat(all, buf, alen);\n             putenv(buf);\n          }\n          buf += strlen(buf) + 1;\n", "fix_pattern": "<pattern>: if string manipulation is done using strncpy and strncat, replace them with strlcpy and strlcat for improved safety and performance, as strlcpy and strlcat not only copy and concatenate strings but also ensure null-termination and respect buffer sizes more effectively."}
{"number": 13, "change": "@@ -24,10 +24,7 @@ pythonizations.\n PyObject *CallPyObjMethod(PyObject *obj, const char *meth)\n {\n    // Helper; call method with signature: obj->meth()\n-   Py_INCREF(obj);\n-   PyObject* result = PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n-   Py_DECREF(obj);\n-   return result;\n+   return PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n }\n \n TClass *GetTClass(const CPyCppyy::CPPInstance *pyobj)\n", "fix_pattern": "<pattern>: if a reference counting operation is followed immediately by an API call and then a decref, it's unnecessary to increment the reference count before the call and decrement it after, as the called method is expected to manage the reference count appropriately. Thus, directly call the method without the extra reference counting."}
{"number": 15, "change": "@@ -46,7 +46,7 @@ void uThread::destory(bool force = false) {\n     //check whether we should cache it or not\n     totalNumberofUTs--;\n     if (slowpath(force) || (utCache.push(this) < 0)) {\n-        free((ptr_t) (stackBottom));       //Free the allocated memory for stack\n+        munmap((ptr_t) (stackBottom), stackSize);       //Free the allocated memory for stack\n     }\n }\n \n", "fix_pattern": "<pattern>: if freeing memory that was allocated with mmap or similar methods, use munmap instead of free to ensure proper memory deallocation in line with the allocation method used."}
{"number": 16, "change": "@@ -674,7 +674,8 @@ protected:\n                 if (path_attr != INVALID_FILE_ATTRIBUTES && (path_attr & FILE_ATTRIBUTE_DIRECTORY))\n                     ofn.lpstrInitialDir = m_wdefault_path.c_str();\n                 else if (m_wdefault_path.size() <= woutput.size())\n-                    lstrcpyW(ofn.lpstrFile, m_wdefault_path.c_str());\n+                    //second argument is size of buffer, not length of string\n+                    StringCchCopyW(ofn.lpstrFile, MAX_PATH*256+1, m_wdefault_path.c_str());\n                 else\n                 {\n                     ofn.lpstrFileTitle = (LPWSTR)m_wdefault_path.data();\n", "fix_pattern": "<pattern>: if a string copy is done using lstrcpyW, replace it with StringCchCopyW and provide the destination buffer size to avoid potential buffer overflows and improve safety."}
{"number": 24, "change": "@@ -128,14 +128,14 @@ void MonitorPictureDialog::updateMonitorWidgets(QString primaryMonitor)\n \n     for (MonitorPicture *picture : qAsConst(pictures)) {\n         if (picture->monitorWidget->output->name() == primaryMonitor\n-                || primaryMonitor == QStringLiteral(\"\")) {\n+                || primaryMonitor == QLatin1String()) {\n             x0 = picture->originX + picture->pos().x();\n             y0 = picture->originY + picture->pos().y();\n             break;\n         }\n     }\n \n-    if( primaryMonitor == QStringLiteral(\"\") ) {\n+    if( primaryMonitor == QLatin1String() ) {\n         for(MonitorPicture *picture : qAsConst(pictures)) {\n             int x1 = picture->originX + picture->pos().x();\n             int y1 = picture->originY + picture->pos().y();\n", "fix_pattern": "<pattern>: if a comparison against an empty QStringLiteral is detected, replace it with a comparison against QLatin1String() for improved performance, as QLatin1String is more efficient for this use case in Qt Framework."}
{"number": 29, "change": "@@ -557,9 +557,7 @@ template<typename real_t, typename index_t>\n \n #ifdef HAVE_MPI\n     if(nprocs>1){\n-      double lpredicted;\n-      MPI_Allreduce(&predicted, &lpredicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n-      predicted = lpredicted;\n+      MPI_Allreduce(MPI_IN_PLACE, &predicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n     }\n #endif\n     \n", "fix_pattern": "<pattern>: if a variable is used to receive a result from MPI_Allreduce and then assigned back to an original variable, simplify the call by using MPI_IN_PLACE to avoid unnecessary data copying, allowing for in-place reduction."}
{"number": 36, "change": "@@ -97,7 +97,8 @@ class DenoisingFunctor\n     X = svd.matrixU() * s.asDiagonal() * svd.matrixV().adjoint();\n     // Store output\n     assign_pos_of(dwi).to(out);\n-    out.row(3) = X.col(n/2).template cast<value_type>();\n+    for (auto l = Loop (3) (out); l; ++l)\n+      out.value() = X(out.index(3), n/2);\n   }\n   \n   void operator () (ImageType& dwi, ImageType& out, ImageType& noise)\n", "fix_pattern": "<pattern>: if there is a direct assignment from a column of an Eigen matrix to a row of a custom image type, replace it with a loop that accesses specific indices, which may optimize memory access patterns, especially when dealing with larger matrices and allowing for more fine-grained control over the assignment process."}
{"number": 38, "change": "@@ -2006,7 +2006,7 @@ void MainWindow::saveCameras(QString const& path, bool writeToProject)\n         auto const filepath = QDir{path}.filePath(cameraName);\n         out.insert(filepath, camera);\n \n-        if (QFileInfo(filepath).exists())\n+        if (QFileInfo::exists(filepath))\n         {\n           willOverwrite.append(filepath);\n         }\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is being created just to check for file existence, replace it with a static call to QFileInfo::exists to avoid unnecessary object creation and improve performance."}
{"number": 39, "change": "@@ -20,14 +20,14 @@\n #include \"vtkByteSwap.h\"\n #include \"vtkCellData.h\"\n #include \"vtkDataArray.h\"\n-#include \"vtkDataCompressor.h\"\n+#include \"vtkZLibDataCompressor.h\"\n #include \"vtkDataSet.h\"\n #include \"vtkOutputStream.h\"\n #include \"vtkPointData.h\"\n #include \"vtkPoints.h\"\n #include \"vtkUnsignedCharArray.h\"\n \n-vtkCxxRevisionMacro(vtkXMLWriter, \"1.14\");\n+vtkCxxRevisionMacro(vtkXMLWriter, \"1.15\");\n vtkCxxSetObjectMacro(vtkXMLWriter, Compressor, vtkDataCompressor);\n \n //----------------------------------------------------------------------------\n@@ -55,7 +55,7 @@ vtkXMLWriter::vtkXMLWriter()\n \n   // Initialize compression data.\n   this->BlockSize = 32768;\n-  this->Compressor = 0;\n+  this->Compressor = vtkZLibDataCompressor::New();\n   this->CompressionHeader = 0;\n   \n   this->EncodeAppendedData = 1;\n", "fix_pattern": "<pattern>: if a class is updated to use a more efficient compression method (from a null pointer to a specific compressor implementation), replace null compressor assignment with the new compressor instantiation for improved data handling efficiency."}
{"number": 40, "change": "@@ -29,7 +29,7 @@\n \n #include <math.h>\n \n-vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.17\");\n+vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.18\");\n vtkStandardNewMacro(vtkSpherePuzzle);\n \n //----------------------------------------------------------------------------\n@@ -175,7 +175,7 @@ int vtkSpherePuzzle::RequestData(\n \n       // append all the pieces.\n       append->AddInput(tmp);\n-      tmp->Delete();\n+      tmp->FastDelete();\n       ++count;\n       }\n     }\n", "fix_pattern": "<pattern>: if a deletion operation on a VTK object is being performed using the more conventional Delete() method, replace it with FastDelete() to improve performance, especially for objects that may involve a significant overhead in reference counting. Additionally, the revision macro is updated to reflect a new version, which can indicate that the change is part of version management or enhancement as well."}
{"number": 41, "change": "@@ -956,9 +956,8 @@ int vtkGDALRasterReader::RequestData(vtkInformation* vtkNotUsed(request),\n   }\n \n   // Get the projection.\n-  char* proj = strdup(this->Impl->GDALData->GetProjectionRef());\n-  this->ProjectionWKT = proj;\n-  OGRSpatialReference spRef(proj);\n+  this->ProjectionWKT = this->Impl->GDALData->GetProjectionRef();\n+  OGRSpatialReference spRef(this->ProjectionWKT.c_str());\n \n   char* projection;\n   spRef.exportToProj4(&projection);\n", "fix_pattern": "<pattern>: if a string is obtained from an API and duplicated using strdup, directly assign the string to a member variable (e.g., std::string) to avoid unnecessary memory allocation and copying, and use the underlying c_str() method for interoperability with C APIs."}
{"number": 53, "change": "@@ -264,9 +264,9 @@ MediaSet::unref (const std::string &sessionId, const uint64_t &mediaObjectRef)\n \n void MediaSet::releasePointer (MediaObjectImpl *mediaObject)\n {\n-  mutex.lock();\n+  Monitor monitor (mutex);\n+\n   objectsMap.erase (mediaObject->getId() );\n-  mutex.unlock();\n \n   threadPool.push ( [mediaObject] () {\n     GST_DEBUG (\"Destroying %s\", mediaObject->getIdStr().c_str() );\n", "fix_pattern": "<pattern>: if mutex.lock() and mutex.unlock() are called in a sequence with no other operations in between, replace them with a scoped lock object to automatically manage the locking and unlocking of the mutex, thereby improving code clarity and reducing the chance of deadlocks due to exceptions."}
{"number": 54, "change": "@@ -16,7 +16,7 @@\n #include <QKeyEvent>\n #include <QKeySequence>\n #include <QList>\n-#include <QRegExp>\n+#include <QRegularExpression>\n #include <QStandardPaths>\n #include <QString>\n #include <QStringList>\n@@ -370,7 +370,7 @@ KeyboardMacrosPluginCommands::KeyboardMacrosPluginCommands(KeyboardMacrosPlugin\n \n bool KeyboardMacrosPluginCommands::exec(KTextEditor::View *view, const QString &cmd, QString &msg, const KTextEditor::Range &)\n {\n-    QStringList actionAndName = cmd.split(QRegExp(QStringLiteral(\"\\\\s+\")));\n+    QStringList actionAndName = cmd.split(QRegularExpression(QStringLiteral(\"\\\\s+\")));\n     if (actionAndName.length() != 2) {\n         msg = i18n(\"Usage: %1 <name>.\", actionAndName.at(0));\n         return false;\n", "fix_pattern": "<pattern>: if using QRegExp for regular expression operations, replace it with QRegularExpression for better performance and support for Unicode properties."}
{"number": 57, "change": "@@ -32,7 +32,7 @@\n #include <KDesktopFile>\n #include <QDir>\n #include <QFile>\n-#include <QDBusInterface>\n+#include <QDBusConnection>\n #include <QDBusPendingCall>\n \n namespace Plasma\n@@ -160,8 +160,9 @@ void PackageStructurePrivate::installPathChanged(const QString &path)\n             }\n         }\n     }\n-    QDBusInterface sycoca(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"));\n-    sycoca.asyncCall(QStringLiteral(\"recreate\"));\n+    const auto call = QDBusMessage::createMethodCall(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"),\n+        QStringLiteral(\"org.kde.kbuildsycoca\"), QStringLiteral(\"recreate\"));\n+    QDBusConnection::sessionBus().asyncCall(call);\n }\n \n \n", "fix_pattern": "<pattern>: if a QDBusInterface is constructed to make an asynchronous call, replace it with a direct call using QDBusMessage and QDBusConnection to avoid the overhead of constructing QDBusInterface, which is unnecessary for simple method calls."}
{"number": 59, "change": "@@ -537,9 +537,8 @@ void ViewManager::createView(Session* session, ViewContainer* container, int ind\n     // notify this view manager when the session finishes so that its view\n     // can be deleted\n     //\n-    // TODO - Find a more efficient a way to avoid multiple connections\n-    disconnect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n-    connect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n+    // Use Qt::UniqueConnection to avoid duplicate connection\n+    connect(session, SIGNAL(finished()), this, SLOT(sessionFinished()), Qt::UniqueConnection);\n \n     TerminalDisplay* display = createTerminalDisplay(session);\n     const Profile::Ptr profile = SessionManager::instance()->sessionProfile(session);\n", "fix_pattern": "<pattern>: if multiple connections are made to the same signal and slot pair, utilize Qt::UniqueConnection in the connect call to prevent duplicate connections and improve performance."}
{"number": 62, "change": "@@ -65,9 +65,8 @@ int main(int argc, char **argv)\n                     // that makes the operation much heavier than it needs to be\n                     isWallpaper = true;\n                 } else {\n-                    if (QFileInfo(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile)).exists()\n-                    || QFileInfo(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile)).exists()\n-                    ) {\n+                    if (QFileInfo::exists(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile))\n+                        || QFileInfo::exists(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile))) {\n                         isWallpaper = true;\n                         isKPackage = true;\n                         // Similarly to above, we could read all the information out of the kpackage, but\n", "fix_pattern": "<pattern>: if the QFileInfo constructor is used just to check for file existence, replace it with the QFileInfo::exists static method to improve performance by avoiding unnecessary object creation."}
{"number": 64, "change": "@@ -123,7 +123,9 @@ void fill_curl_eh(CURL *eh, C_Element *cube, bool isOverlay, FtpElement *elem) {\n     curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, my_fwrite);\n     curl_easy_setopt(eh, CURLOPT_WRITEDATA, elem);\n     curl_easy_setopt(eh, CURLOPT_PRIVATE, elem);\n-    curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    //curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_LIMIT, 1);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_TIME, 10);\n     curl_easy_setopt(eh, CURLOPT_CONNECTTIMEOUT, 10);\n     curl_multi_add_handle(curlm, eh);\n }\n", "fix_pattern": "<pattern>: if a timeout option is set on a CURL handle, consider using low-speed options instead to avoid cancelling connections with low traffic that may still be valid, enhancing the performance of network operations."}
{"number": 65, "change": "@@ -117,13 +117,15 @@ GLuint load_program(const char *path1, const char *path2) {\n void flip_image_vertical(\n     unsigned char *data, unsigned int width, unsigned int height)\n {\n-    unsigned char new_data[width * height * 4];\n-    unsigned int stride = width * 4;\n+    unsigned int size = width * height * 4;\n+    unsigned int stride = sizeof(char) * width * 4;\n+    unsigned char *new_data = malloc(sizeof(char) * size);\n     for (unsigned int i = 0; i < height; i++) {\n         unsigned int j = height - i - 1;\n         memcpy(new_data + j * stride, data + i * stride, stride);\n     }\n-    memcpy(data, new_data, sizeof(new_data));\n+    memcpy(data, new_data, size);\n+    free(new_data);\n }\n \n void load_png_texture(const char *file_name) {\n", "fix_pattern": "<pattern>: if a stack-allocated array is created to hold data temporarily and immediately copied to another location, allocate memory using `malloc` to avoid potential stack size limits, and ensure the size is correctly calculated, followed by freeing the memory after use."}
{"number": 67, "change": "@@ -1276,14 +1276,7 @@ FileDescriptor V4L2VideoDevice::exportDmabufFd(unsigned int index,\n \t\treturn FileDescriptor();\n \t}\n \n-\tFileDescriptor fd(expbuf.fd);\n-\t/*\n-\t * FileDescriptor takes a duplicate of fd, so we must close the\n-\t * original here, otherwise it will be left dangling.\n-\t */\n-\t::close(expbuf.fd);\n-\n-\treturn fd;\n+\treturn FileDescriptor(std::move(expbuf.fd));\n }\n \n /**\n", "fix_pattern": "<pattern>: if a duplicate of a file descriptor is created and the original is closed immediately after, use std::move to transfer ownership of the file descriptor directly into the FileDescriptor constructor to eliminate the need for an intermediate variable and potential dangling reference."}
{"number": 70, "change": "@@ -1,12 +1,12 @@\n #include <stdlib.h>\n #include <stdio.h>\n-#include <string.h>\n+#include <sys/types.h>\n+#include <signal.h>\n \n int main(void)\n {\n   int i, pid;\n   FILE *fp;\n-  char str[32];\n \n   for(i = 0; i < 5; i++){\n     system(\"gmsh -pid fichier.msh fichier.pos > /tmp/gmsh.pid &\");\n@@ -18,7 +18,6 @@ int main(void)\n     fscanf(fp, \"%d\", &pid);\n     fclose(fp);\n \n-    sprintf(str, \"kill %d\", pid);\n-    system(str);\n+    kill(pid, 9);\n   }    \n } \n", "fix_pattern": "<pattern>: if a command to be executed via system() is constructed using sprintf, replace it with a direct call to kill() to eliminate unnecessary string handling and improve performance."}
{"number": 72, "change": "@@ -483,7 +483,7 @@ void CreateOutputFile(const std::string &fileName, int format,\n           glLoadMatrixd(modelview);\n         }\n         else{\n-          buffer.fill(CTX::instance()->batch);\n+          drawContext::global()->drawCurrentOpenglWindow(true);\n         }\n         res = gl2psEndPage();\n       }\n@@ -513,10 +513,9 @@ void CreateOutputFile(const std::string &fileName, int format,\n         gl2psBeginPage(base.c_str(), \"Gmsh\", viewport,\n                        GL2PS_TEX, GL2PS_NO_SORT, GL2PS_NONE, GL_RGBA, 0, NULL,\n                        0, 0, 0, buffsize, fp, base.c_str());\n-        PixelBuffer buffer(width, height, GL_RGB, GL_UNSIGNED_BYTE);\n         int oldtext = CTX::instance()->print.text;\n         CTX::instance()->print.text = 1;\n-        buffer.fill(CTX::instance()->batch);\n+        drawContext::global()->drawCurrentOpenglWindow(true);\n         CTX::instance()->print.text = oldtext;\n         res = gl2psEndPage();\n       }\n", "fix_pattern": "<pattern>: if a buffer is filled but immediately after the drawing operation is executed, remove the unnecessary buffer fill and directly call the drawing method to enhance performance."}
{"number": 73, "change": "@@ -88,8 +88,7 @@ AudioEncoder::EncodedInfo AudioEncoderCopyRed::EncodeInternal(\n       DCHECK_EQ(info.redundant.size(), 2u);\n     }\n     // Save primary to secondary.\n-    secondary_encoded_.SetSize(info.encoded_bytes);\n-    memcpy(secondary_encoded_.data(), encoded, info.encoded_bytes);\n+    secondary_encoded_.SetData(encoded, info.encoded_bytes);\n     secondary_info_ = info;\n     DCHECK_EQ(info.speech, info.redundant[0].speech);\n   }\n", "fix_pattern": "<pattern>: if memory is manually copied using memcpy after resizing a buffer, replace it with a more efficient API such as SetData that handles both setting the size and copying the data in a single method call."}
{"number": 74, "change": "@@ -88,7 +88,7 @@ DWORD GetThreadStartAddress(HANDLE processHandle, HANDLE hThread) {\n \n \tMODULEINFO mi;\n \n-\tGetModuleInformation(processHandle, LoadLibrary(\"kernel32.dll\"), &mi, sizeof(mi));\n+\tGetModuleInformation(processHandle, GetModuleHandle(\"kernel32.dll\"), &mi, sizeof(mi));\n \tstacktop = (DWORD)GetThreadStackTopAddress_x86(processHandle, hThread);\n \n \t/* The stub below has the same result as calling GetThreadStackTopAddress_x86() \n", "fix_pattern": "<pattern>: if an API call to LoadLibrary is being used to retrieve a module handle for a DLL that is already loaded, replace it with GetModuleHandle to avoid the overhead of loading the library again."}
{"number": 78, "change": "@@ -484,8 +484,7 @@ IniFile::TildeExpansion(const char *file, char *path)\n \n     /* Buffer overflow has already been checked. */\n \n-    strcpy(path, home);\n-    strcat(path, file + 1);\n+    snprintf(path, LINELEN, \"%s%s\", home, file + 1);\n     return;\n }\n \n", "fix_pattern": "<pattern>: if multiple string manipulations are performed with strcpy and strcat, replace with snprintf for a single operation that combines both operations into one, improving performance and reducing buffer overflow risks."}
{"number": 84, "change": "@@ -321,7 +321,7 @@ bool romLoaded(Logger* logger, System system, const std::string& path, void* rom\n   case System::kAtariLynx:\n     rom = util::loadFile(logger, path, &size);\n \n-    if (!strcmp(\"LYNX\", (char *)rom))\n+    if (!memcmp(\"LYNX\", (void *)rom, 5))\n     {\n         RA_OnLoadNewRom((BYTE*)rom + 0x0040, size - 0x0040);\n     }\n", "fix_pattern": "<pattern>: if a string comparison is made using strcmp for a fixed-length comparison, replace it with memcmp to improve performance by comparing raw memory directly."}
{"number": 94, "change": "@@ -160,6 +160,7 @@ void PackageKitBackend::acquireFetching(bool f)\n \n void PackageKitBackend::reloadPackageList()\n {\n+    qDebug() << \"xxx\";\n     acquireFetching(true);\n     if (m_refresher) {\n         disconnect(m_refresher.data(), &PackageKit::Transaction::finished, this, &PackageKitBackend::reloadPackageList);\n@@ -185,9 +186,9 @@ void PackageKitBackend::reloadPackageList()\n \n         const auto pkgNames = component.packageNames();\n         if (pkgNames.isEmpty()) {\n-            auto launchable = component.launchable(AppStream::Launchable::KindDesktopId);\n-            if (component.kind() == AppStream::Component::KindDesktopApp && !launchable.entries().isEmpty()) {\n-                const QString file = locateService(launchable.entries().constFirst());\n+            const auto entries = component.launchable(AppStream::Launchable::KindDesktopId).entries();\n+            if (component.kind() == AppStream::Component::KindDesktopApp && !entries.isEmpty()) {\n+                const QString file = locateService(entries.first());\n                 if (!file.isEmpty()) {\n                     acquireFetching(true);\n                     auto trans = PackageKit::Daemon::searchFiles(file);\n", "fix_pattern": "<pattern>: if an API method is called multiple times on the same object within a conditional statement, store the result in a variable to avoid redundant calls, which improves performance by reducing unnecessary computations."}
{"number": 99, "change": "@@ -268,9 +268,7 @@ int main(int argc, char* argv[])\n \t\t\t}\n \n \t\t\tcout << endl;\n-\t\t\t\n-\t\t\tstrcpy(szNewPassword, newpassword);\n-\n+\t\t\tkc_strlcpy(szNewPassword, newpassword, sizeof(szNewPassword));\n \t\t\trepassword = get_password(\"Re-Enter password:\");\n \t\t\tif(strcmp(newpassword, repassword) != 0) {\n \t\t\t\tcerr << \"Passwords don't match\" << endl;\n", "fix_pattern": "<pattern>: if a string copy operation is performed using strcpy, replace it with kc_strlcpy to ensure safer copy operations that prevent buffer overflows."}
{"number": 102, "change": "@@ -387,7 +387,9 @@ void SystemDriver::UpdateVelocity(mfem::ParGridFunction &velocity, mfem::Vector\n             }\n #endif\n          } // End if vgrad_origin_flag\n-         const double* dmin_x = vgrad_origin.Read();\n+         Vector origin(space_dim, mfem::Device::GetMemoryType()); origin.UseDevice(true);\n+         MPI_Allreduce(vgrad_origin.HostRead(), origin.HostReadWrite(), space_dim, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n+         const double* dmin_x = origin.Read();\n          // We've now found our minimum points so we can now go and calculate everything.\n          MFEM_FORALL(i, nnodes, {\n             for (int ii = 0; ii < space_dim; ii++) {\n", "fix_pattern": "<pattern>: if the code is reading data from a source with potential performance implications (like `vgrad_origin.Read()`), switch to using MPI for parallel reduction (like `MPI_Allreduce`) and leverage device memory management with `Vector` to improve data handling efficiency."}
{"number": 106, "change": "@@ -52,6 +52,8 @@ namespace {\n \n   // Using native file handles instead of file descriptors for reducing the resource consumption.\n \n+  const HANDLE InvalidFile = INVALID_HANDLE_VALUE;\n+\n   HANDLE openFile(const FileName &path, bool readOnly)\n   {\n     DWORD access = readOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);\n@@ -82,6 +84,8 @@ namespace {\n \n   // For non-Windows \n \n+  const FILE *InvalidFile = 0;\n+\n   struct FileNameHandle : public std::string\n   {\n     FileNameHandle(FileName name) : std::string(name) {}\n@@ -119,7 +123,7 @@ public:\n };\n \n FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openReadOnly) :\n-  file(0),\n+  file(InvalidFile),\n   name(fileName),\n   readOnly(true),\n   size(0)\n@@ -129,12 +133,12 @@ FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openRea\n   if(!openReadOnly)\n     file = openFile(name, false);\n \n-  if(file)\n+  if(file != InvalidFile)\n     readOnly = false;\n   else\n     file = openFile(name, true);\n \n-  if(!file) {\n+  if(file == InvalidFile) {\n     debug(\"Could not open file \" + String((const char *) name));\n   }\n }\n", "fix_pattern": "<pattern>: if a variable is being checked against a file handle, replace the direct comparison with a predefined constant (INVALID_HANDLE_VALUE) for better readability and potential optimization in checks against the invalid file state."}
{"number": 107, "change": "@@ -2343,7 +2343,7 @@ void dbookmarkswindow::slotBookmarkReceived(const QModelIndex &index)\n \n bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n {\n-  qint64 count = 0;\n+  bool exists = false;\n \n   {\n     QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\", \"bookmarks\");\n@@ -2358,9 +2358,9 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \tint temporary = dmisc::passphraseWasAuthenticated() ? 0 : 1;\n \n \tquery.setForwardOnly(true);\n-\tquery.prepare(\"SELECT COUNT(*) FROM bookmarks WHERE \"\n+\tquery.prepare(\"SELECT EXISTS(SELECT 1 FROM bookmarks WHERE \"\n \t\t      \"url_hash = ? AND \"\n-\t\t      \"temporary = ?\");\n+\t\t      \"temporary = ?)\");\n \tquery.bindValue\n \t  (0,\n \t   dmisc::hashedString(url.\n@@ -2371,14 +2371,14 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \n \tif(ok && query.exec())\n \t  if(query.next())\n-\t    count = query.value(0).toLongLong();\n+\t    exists = query.value(0).toBool();\n       }\n \n     db.close();\n   }\n \n   QSqlDatabase::removeDatabase(\"bookmarks\");\n-  return count > 0;\n+  return exists;\n }\n \n void dbookmarkswindow::slotRefresh(void)\n", "fix_pattern": "<pattern>: if a query is used to count rows in a SQL table, replace it with a query that checks for existence instead (e.g., using \"SELECT EXISTS(...)\") to improve performance by reducing the amount of data processed."}
{"number": 108, "change": "@@ -98,13 +98,8 @@ void Pool::joinAll()\n \n Pool::WorkerCountType Pool::getWorkQueueCount() const\n {\n-\tPool::WorkerCountType size = 0;\n-\t\n-\tenqueuedWorkMutex.lock();\n-\tsize = enqueuedWork.size();\n-\tenqueuedWorkMutex.unlock();\n-\t\n-\treturn size;\n+\tstd::lock_guard<std::mutex> l(enqueuedWorkMutex);\t\n+\treturn enqueuedWork.size();\n }\n \n Pool::WorkerCountType Pool::getActiveWorkerCount() const\n", "fix_pattern": "<pattern>: if manual locking and unlocking of a mutex is performed, use a std::lock_guard to manage the mutex automatically and ensure proper unlocking after the scope ends, improving code clarity and safety."}
{"number": 118, "change": "@@ -165,7 +165,7 @@ std::string PluginSerializer::SerializeToFile(const std::string& content_url,\n     return \"\";\n   }\n \n-  size_t num_written = fwrite(body.c_str(), 1, body.size(), file);\n+  size_t num_written = fwrite(body.data(), 1, body.size(), file);\n   fclose(file);\n   if (num_written != body.size()) {\n     LOG(ERROR) << \"Failed to WriteDataToFile for \" << string_path\n", "fix_pattern": "<pattern>: if a string's underlying data is accessed for writing (such as with fwrite), prefer to use body.data() instead of body.c_str() to avoid the potential overhead of constructing a null-terminated string when it's not necessary."}
{"number": 120, "change": "@@ -240,7 +240,7 @@ HandleSet ForwardChainer::get_chaining_result()\n \n Source* ForwardChainer::select_source()\n {\n-\tstd::lock_guard<std::mutex> lock(_part_mutex);\n+\tstd::unique_lock<std::mutex> lock(_part_mutex);\n \n \tstd::vector<double> weights = _sources.get_weights();\n \n@@ -270,7 +270,7 @@ Source* ForwardChainer::select_source()\n \t\t\ture_logger().debug() << \"Reset all exhausted flags to retry them\";\n \t\t\t_sources.reset_exhausted();\n \t\t\t// Try again\n-\t\t\t// NEXT TODO: be careful of locks\n+\t\t\tlock.unlock();\n \t\t\treturn select_source();\n \t\t} else {\n \t\t\t_sources.exhausted = true;\n", "fix_pattern": "<pattern>: if a std::lock_guard is replaced with a std::unique_lock that is immediately unlocked, consider whether locking is necessary at all for the given scope; if there are no operations requiring protection, remove the lock entirely."}
{"number": 128, "change": "@@ -37,7 +37,7 @@\n #endif\n \n #include <math.h>\n-#include <string.h>\n+#include \"string2.h\"\n #include \"typedefs.h\"\n #include \"macros.h\"\n #include \"copyrite.h\"\n@@ -157,7 +157,7 @@ int main (int argc,char *argv[])\n     iatoms->resinfo[resind] = atoms->resinfo[atoms->atom[index[i]].resind];\n     /* allocate some space for the rtp name and copy from name */\n     snew(iatoms->resinfo[resind].rtp,1);\n-    strcpy(iatoms->resinfo[resind].rtp, atoms->resinfo[resind].name);\n+    iatoms->resinfo[resind].rtp = gmx_strdup(atoms->resinfo[resind].name);\n \n     iatoms->nres = max(iatoms->nres, iatoms->atom[i].resind+1);\n   }\n", "fix_pattern": "<pattern>: if a direct string copy is performed using `strcpy`, replace it with a project-specific optimized function `gmx_strdup` that may handle memory allocation more efficiently and ensure the destination is properly handled."}
{"number": 131, "change": "@@ -126,8 +126,7 @@ TiffIFD* TiffIFD::parseDngPrivateData(TiffEntry *t) {\n   */\n   uint32 size = t->count;\n   const uchar8 *data = t->getData();\n-  string id((const char*)data);\n-  if (0 != id.compare(\"Adobe\"))\n+  if (0 != memcmp(data, \"Adobe\", 6))\n     ThrowTPE(\"Not Adobe Private data\");\n \n   data+=6;\n", "fix_pattern": "<pattern>: if a string comparison is needed and the length of the string is known, replace std::string::compare with memcmp for lower-level performance improvements, as memcmp is generally faster for fixed-length comparisons."}
{"number": 136, "change": "@@ -48,7 +48,7 @@ namespace tp {\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlWriteCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &response.body);\n-\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); //10s timeout\n+\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L); //5s timeout\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, CurlHeadersCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEHEADER, &response.headers);\n", "fix_pattern": "<pattern>: if a timeout value is being configured for a CURL request, ensure to set a lower timeout value for better responsiveness and improved resource utilization; in this case, reducing from 10 seconds to 5 seconds."}
{"number": 138, "change": "@@ -1430,10 +1430,6 @@ GlassTable::readahead_key(const string &key) const\n     LOGCALL(DB, bool, \"GlassTable::readahead_key\", key);\n     Assert(!key.empty());\n \n-    // An overlong key cannot be found.\n-    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n-\tRETURN(false);\n-\n     // Three cases:\n     //\n     // handle == -1:  Lazy table in a multi-file database which isn't yet open.\n@@ -1450,6 +1446,10 @@ GlassTable::readahead_key(const string &key) const\n     if (level == 0)\n \tRETURN(false);\n \n+    // An overlong key cannot be found.\n+    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n+\tRETURN(true);\n+\n     form_key(key);\n \n     // We'll only readahead the first level, since descending the B-tree would\n", "fix_pattern": "<pattern>: if the return value is used to indicate the success or failure of a key search operation in a B-tree, change the logic to return true for the case of an overlong key, as it indicates an immediate failure to locate a valid key that should be found within the defined limits."}
{"number": 142, "change": "@@ -3000,15 +3000,14 @@ BOOL allocateName(char **ppStore, const char *pName)\n \t}\n \treturn TRUE;\n #else\n-\t//need to allocate space for the name\n-\t*ppStore = (char*)malloc((strlen(pName))+1);\n+\t// Allocate space for the name and copy it\n+\t*ppStore = strdup(pName);\n \tif (ppStore == NULL)\n \t{\n-\t\tdebug( LOG_ERROR, \"Name - Out of memory\" );\n+\t\tdebug(LOG_ERROR, \"allocateName: Out of memory\");\n \t\tabort();\n \t\treturn FALSE;\n \t}\n-\tstrcpy(*ppStore,pName);\n \n \treturn TRUE;\n #endif\n", "fix_pattern": "<pattern>: if memory is allocated for a string with malloc and then copied with strcpy, replace it with strdup for better performance and simplicity, as strdup handles both allocation and copying in one call."}
{"number": 143, "change": "@@ -406,7 +406,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \n \t// Now dump the data into the buffer\n \t// Copy a string\n-\tsstrcpy(buffer, game->name);\n+\tstrlcpy(buffer, game->name, sizeof(game->name));\n \tbuffer += sizeof(game->name);\n \n \t// Copy 32bit large big endian numbers\n@@ -416,7 +416,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \tbuffer += sizeof(int32_t);\n \n \t// Copy yet another string\n-\tsstrcpy(buffer, game->desc.host);\n+\tstrlcpy(buffer, game->desc.host, sizeof(game->desc.host));\n \tbuffer += sizeof(game->desc.host);\n \n \t// Copy 32bit large big endian numbers\n", "fix_pattern": "<pattern>: replace project-specific string copy operation (sstrcpy) with safer and size-aware string copy operation (strlcpy) to avoid buffer overflows and improve performance with potentially better memory management."}
{"number": 146, "change": "@@ -473,7 +473,8 @@ struct TextShaper\n \t{\n \t\t/* Fribidi assumes that the text is encoded in UTF-32, so we have to\n \t\t   convert from UTF-8 to UTF-32, assuming that the string is indeed in UTF-8.*/\n-\t\tstd::u32string u32 = utf8::utf8to32(text);\n+\t\tstd::u32string u32;\n+\t\tutf8::unchecked::utf8to32(text.begin(), text.end(), std::back_inserter(u32));\n \n \t\t// Step 1: Initialize fribidi variables.\n \t\t// TODO: Don't forget to delete them at the end.\n@@ -877,6 +878,11 @@ static bool breaksWord(char const c)\n \treturn c == ASCII_SPACE || breaksLine(c);\n }\n \n+/* This funtion might not be fail-proof. It presumes that a \"char\" equals a \"character\" in any language.\n+   Since the game was translated into different other languages, an Arabic or Chinese \"character\"\n+   could occupy several bytes (that is, \"char\"s) in memory (assuming the string is in UTF-8). Therefore,\n+   expressions such as \"++curChar\" might not yield the next \"character\", but just a byte of its\n+   representation. */\n std::vector<TextLine> iV_FormatText(const char *String, UDWORD MaxWidth, UDWORD Justify, iV_fonts fontID, bool ignoreNewlines /*= false*/)\n {\n \tstd::vector<TextLine> lineDrawResults;\n", "fix_pattern": "<pattern>: if the conversion from UTF-8 to UTF-32 is done using a function that performs safety checks (like utf8::utf8to32), refactor the code to use a variant of the function that skips those checks (like utf8::unchecked::utf8to32) combined with std::back_inserter for better performance, while being cautious of handling multi-byte characters properly."}
{"number": 148, "change": "@@ -50,7 +50,7 @@ tlp::Color ChooseColorButton::tulipColor() const {\n \n void ChooseColorButton::setColor(const QColor& c) {\n   _color = c;\n-  repaint();\n+  update();\n   emit colorChanged(_color);\n   emit tulipColorChanged(QColorToColor(_color));\n }\n", "fix_pattern": "<pattern>: replace QWidget::repaint() with QWidget::update() to improve performance by avoiding unnecessary immediate repainting and instead queueing a repaint for later, which can reduce the frequency of redraw operations."}
{"number": 156, "change": "@@ -36,7 +36,9 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    strncpy(pchCommand, pszCommand, COMMAND_SIZE);\n+    int command_len = strlen(pszCommand);\n+    memcpy(pchCommand, pszCommand, command_len);\n+    memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n     nChecksum = 0;\n }\n", "fix_pattern": "<pattern>: if a string is copied using strncpy, replace it with memcpy followed by memset to ensure the destination is properly null-terminated while improving performance with direct memory operations."}
{"number": 173, "change": "@@ -43,9 +43,9 @@ inline void update(_T& _sha, _U const& _value)\n {\n \tint i = 0;\n \tfor (_U v = _value; v; ++i, v >>= 8) {}\n-\tbytes buf(i);\n-\ttoBigEndian(_value, buf);\n-\t_sha.Update(buf.data(), buf.size());\n+\tbyte buf[32];\n+\ttoBigEndian(_value, bytesRef(buf, i));\n+\t_sha.Update(buf, i);\n }\n \n template <class _T>\n", "fix_pattern": "<pattern>: if dynamic memory (e.g., using a vector or similar) is used for a small fixed-size buffer, replace it with a stack-allocated array for better performance and reduced memory overhead."}
{"number": 174, "change": "@@ -46,6 +46,7 @@\n  * Stride Prefetcher template instantiations.\n  */\n \n+#include \"base/random.hh\"\n #include \"debug/HWPrefetch.hh\"\n #include \"mem/cache/prefetch/stride.hh\"\n \n@@ -176,7 +177,7 @@ StridePrefetcher::pcTableVictim(Addr pc, int master_id)\n {\n     // Rand replacement for now\n     int set = pcHash(pc);\n-    int way = rand() % pcTableAssoc;\n+    int way = random_mt.random<int>(0, pcTableAssoc - 1);\n \n     DPRINTF(HWPrefetch, \"Victimizing lookup table[%d][%d].\\n\", set, way);\n     return &pcTable[master_id][set][way];\n", "fix_pattern": "<pattern>: if the code uses the standard `rand()` function for generating random numbers, replace it with a project-specific random number generator method for improved performance and potentially better randomness properties."}
{"number": 180, "change": "@@ -48,8 +48,8 @@ extern \"C\" JNIEXPORT void JNICALL Java_Main_waitUntilJitted(JNIEnv* env,\n     if (code_cache->ContainsPc(header->GetCode())) {\n       break;\n     } else {\n-      // yield to scheduler to give time to the JIT compiler.\n-      sched_yield();\n+      // Sleep to yield to the compiler thread.\n+      sleep(0);\n       // Will either ensure it's compiled or do the compilation itself.\n       jit->CompileMethod(method, Thread::Current(), /* osr */ false);\n     }\n", "fix_pattern": "<pattern>: if the original code uses `sched_yield()` to yield time to the JIT compiler, replace it with `sleep(0)` to achieve a similar effect with potentially better performance in terms of scheduling efficiency."}
{"number": 181, "change": "@@ -108,11 +108,8 @@ static LRESULT HandleCopyData(LPARAM lParam) {\n \tCOPYDATASTRUCT *pcds = reinterpret_cast<COPYDATASTRUCT *>(lParam);\n \t// Copy into an temporary buffer to ensure \\0 terminated\n \tif (pcds->lpData) {\n-\t\tchar *dataCopy = new char[pcds->cbData + 1];\n-\t\tstrncpy(dataCopy, static_cast<char *>(pcds->lpData), pcds->cbData);\n-\t\tdataCopy[pcds->cbData] = '\\0';\n-\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy);\n-\t\tdelete []dataCopy;\n+\t\tstd::string dataCopy(static_cast<char *>(pcds->lpData), pcds->cbData);\n+\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy.c_str());\n \t}\n \treturn 0;\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation and manual string copy using strncpy is used, replace it with a std::string construction to avoid memory management overhead and ensure better safety and performance."}
{"number": 190, "change": "@@ -1,3 +1,5 @@\n+#define OPENSSL_SUPPRESS_DEPRECATED\n+\n #include <psibase/crypto.hpp>\n \n #include <openssl/sha.h>\n@@ -126,8 +128,11 @@ namespace psibase\n    Checksum256 sha256(const char* data, size_t length)\n    {\n       //std::array<unsigned char, 256 / 8> result;\n+      SHA256_CTX ctx;\n+      SHA256_Init(&ctx);\n+      SHA256_Update(&ctx, (const unsigned char*)data, length);\n       Checksum256 result;\n-      SHA256((const unsigned char*)data, length, (unsigned char*)result.data());\n+      SHA256_Final((unsigned char*)result.data(), &ctx);\n       return result;\n    }\n \n", "fix_pattern": "<pattern>: when using the SHA256 function from OpenSSL, instead of calling a single function that may lead to inefficiencies, refactor the code to use the initialization, update, and finalization steps with the SHA256_CTX context, which allows for better control of the hashing process and may improve performance by reducing memory allocations and managing state more explicitly."}
{"number": 198, "change": "@@ -54,7 +54,13 @@ int sock;\n #ifdef UNIX_ASYNC_DNS\n   static XP_Bool done = FALSE;\n \n-  LOG(\"XFE_InitDNS_Early\", (\"calling DNS_SpawnProcess.\\n\"));\n+  /*\n+   * The following used to be LOG() instead of fprintf(). But, LOG() uses\n+   * PR_smprintf() which fires up NSPR.\n+   */\n+#ifdef PROC1_DEBUG_PRINT\n+  fprintf(stderr, \"\\tproc1 (%d): %s\\n\", getpid(), \"XFE_InitDNS_Early: calling DNS_SpawnProcess.\");\n+#endif\n   sock = DNS_SpawnProcess(argc, argv);\n \n   XP_ASSERT(!done);\n", "fix_pattern": "<pattern>: if a logging function (LOG) introduces significant overhead due to additional processing (like memory allocation via PR_smprintf), replace it with a lower-overhead alternative (like fprintf) when debugging output is necessary to improve performance."}
{"number": 201, "change": "@@ -482,15 +482,13 @@ void dprintf(const char *format, ...)\n {\n #if DEBUG\n     va_list ap;\n-\tchar\t*buffer;\n+\tStr255 buffer;\n \t\n \tva_start(ap, format);\n-\tbuffer = PR_vsmprintf(format, ap);\n+\tbuffer[0] = PR_vsnprintf((char *)buffer + 1, sizeof(buffer) - 1, format, ap);\n \tva_end(ap);\n \t\n-\tc2pstr(buffer);\n-\tDebugStr( (unsigned char *)buffer);\n-\tfree(buffer);\n+\tDebugStr(buffer);\n #endif /* DEBUG */\n }\n \n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a buffer (e.g., via PR_vsmprintf and subsequent free), replace it with a statically sized buffer (e.g., Str255) using PR_vsnprintf to eliminate the overhead of heap allocation and deallocation."}
{"number": 204, "change": "@@ -230,8 +230,10 @@ nsresult nsCollationMac::CreateRawSortKey(const nsCollationStrength strength,\n     }\n     else {\n       // No CJK support, just copy the row string.\n-      strcpy((char *) key, str);\n-      while (*key) {\n+      // Collation key is not a string, use memcpy instead of strcpy.\n+      nsCRT::memcpy(key, str, str_len);\n+      PRUint8 *end = key + str_len;\n+      while (key < end) {\n         if ((unsigned char) *key < 128) {\n           key++;\n         }\n", "fix_pattern": "<pattern>: if a string is being copied to a buffer where the length is known, replace strcpy with memcpy to eliminate null-termination overhead and improve performance."}
{"number": 205, "change": "@@ -365,7 +365,7 @@ ns4xPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,\n       amountRead -= writeCount;\n       mPosition += writeCount;\n       if (amountRead > 0)\n-        strncpy(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n+        memmove(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n     }\n   }\n \n", "fix_pattern": "<pattern>: if a memory block is being shifted within a buffer, replace `strncpy` with `memmove` to properly handle overlapping memory regions, improving safety and performance."}
{"number": 208, "change": "@@ -152,9 +152,8 @@ void Pass::match(Plasma::RunnerContext &context)\n     QList<Plasma::QueryMatch> matches;\n \n     lock.lockForRead();\n-    QRegularExpression re(\".*\" + input + \".*\", QRegularExpression::CaseInsensitiveOption);\n     for (const auto& password: passwords) {\n-        if (re.match(password).hasMatch()) {\n+        if (password.contains(input,Qt::CaseInsensitive)) {\n             Plasma::QueryMatch match(this);\n             match.setType(input.length() == password.length() ?\n                 Plasma::QueryMatch::ExactMatch : Plasma::QueryMatch::CompletionMatch);\n", "fix_pattern": "<pattern>: if a QRegularExpression is used to perform a match on a QString, replace it with QString's built-in contains method for better performance as it avoids regex overhead."}
{"number": 214, "change": "@@ -182,12 +182,12 @@ void PaymentServerTests::paymentServerTests()\n     QCOMPARE(PaymentServer::verifyExpired(r.paymentRequest.getDetails()), true);\n \n     // Test BIP70 DoS protection:\n-    unsigned char randData[BIP70_MAX_PAYMENTREQUEST_SIZE + 1];\n-    GetRandBytes(randData, sizeof(randData));\n+    auto randdata = FastRandomContext().randbytes(BIP70_MAX_PAYMENTREQUEST_SIZE + 1);\n+\n     // Write data to a temp file:\n     QTemporaryFile tempFile;\n     tempFile.open();\n-    tempFile.write((const char*)randData, sizeof(randData));\n+    tempFile.write((const char*)randdata.data(), randdata.size());\n     tempFile.close();\n     // compares 50001 <= BIP70_MAX_PAYMENTREQUEST_SIZE == false\n     QCOMPARE(PaymentServer::verifySize(tempFile.size()), false);\n", "fix_pattern": "<pattern>: if using a direct buffer approach for generating random bytes and writing them to a file, switch to a higher-level abstraction that combines randomness generation and data management (e.g., using FastRandomContext with std::vector for automatic memory handling) for improved performance and safety."}
{"number": 215, "change": "@@ -14,6 +14,7 @@\n #define TRGCDC_SHORT_NAMES\n \n #include <math.h>\n+#include <TRandom.h>\n #include <iostream>\n #include <fstream>\n #include \"framework/datastore/StoreArray.h\"\n@@ -1030,7 +1031,7 @@ namespace Belle2 {\n       //...Loop over CDCHits...\n       for (unsigned i = 0; i < nHits; i++) {\n         const CDCHit& h = *CDCHits[i];\n-        double tmp = rand() / (double(RAND_MAX));\n+        double tmp = gRandom->Uniform(0.0, 1.0) / (double(RAND_MAX));\n         if (tmp < _inefficiency)\n           continue;\n \n", "fix_pattern": "<pattern>: if random number generation is performed using the standard C++ `rand()` function, switch to using `gRandom->Uniform(min, max)` from the ROOT TRandom class for improved performance and better statistical properties in scientific computing contexts."}
{"number": 218, "change": "@@ -27,7 +27,8 @@ void AMQPMessage::setMessage(const char * data,uint32_t length) {\n \tif (this->data)\n \t\tfree(this->data);\n \n-\tthis->data = strdup(data);\n+\tthis->data = (char*)malloc(length);\n+\tmemcpy(this->data,data,length);\n \tthis->len = length;\n }\n \n", "fix_pattern": "<pattern>: if strdup is used to allocate and copy a string, replace it with malloc followed by memcpy for potentially better performance and control over allocation size."}
{"number": 219, "change": "@@ -21,6 +21,7 @@ using namespace Cicada;\n #define RINGBUFFER_BACK_SIZE 1024*512\n \n #define MIN_SO_RCVBUF_SIZE 1024*64\n+#define READ_BUFFER_SIZE 1024 * 64\n \n #define SOCKET_ERROR (-1)\n \n@@ -384,7 +385,7 @@ int Cicada::CURLConnection::esayHandle_set_common_opt()\n     curl_easy_setopt(mHttp_handle, CURLOPT_DEBUGDATA, this);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERFUNCTION, write_response);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERDATA, this);\n-    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, CURL_MAX_READ_SIZE);\n+    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, READ_BUFFER_SIZE);\n     return 0;\n }\n \n", "fix_pattern": "<pattern>: if the CURLOPT_BUFFERSIZE is set directly with a constant, replace it with a defined constant value that represents a more suitable buffer size for performance optimization."}
{"number": 225, "change": "@@ -68,16 +68,16 @@ QString EwsMailHandler::mimeType()\n bool EwsMailHandler::setItemPayload(Akonadi::Item &item, const EwsItem &ewsItem)\n {\n     qDebug() << \"EwsMailHandler::setItemPayload\";\n-    QString mimeContent = ewsItem[EwsItemFieldMimeContent].toString();\n+    QByteArray mimeContent = ewsItem[EwsItemFieldMimeContent].toByteArray();\n     if (mimeContent.isEmpty()) {\n         qWarning() << QStringLiteral(\"MIME content is empty!\");\n         return false;\n     }\n \n-    mimeContent.replace(QStringLiteral(\"\\r\\n\"), QStringLiteral(\"\\n\"));\n+    mimeContent.replace(\"\\r\\n\", \"\\n\");\n \n     KMime::Message::Ptr msg(new KMime::Message);\n-    msg->setContent(mimeContent.toLatin1());\n+    msg->setContent(mimeContent);\n     msg->parse();\n     qDebug() << msg->attachments().size() << \"attachments\";\n     // Some messages might just be empty (just headers). This results in the body being empty.\n", "fix_pattern": "<pattern>: if a QString is converted to a byte array using toString and then later converted to a QByteArray with toLatin1, refactor the code to directly use toByteArray for better performance and to eliminate unnecessary conversions."}
{"number": 227, "change": "@@ -261,7 +261,7 @@ void pqColorMapEditor::setColorTransferFunction(vtkSMProxy* ctf)\n   this->Internals->ProxyWidget = widget;\n   this->updatePanel();\n \n-  QObject::connect(widget, SIGNAL(changeFinished()), this, SLOT(updateIfNeeded()));\n+  QObject::connect(widget, SIGNAL(changeAvailable()), this, SLOT(updateIfNeeded()));\n }\n \n //-----------------------------------------------------------------------------\n", "fix_pattern": "<pattern>: NA"}
{"number": 228, "change": "@@ -1,4 +1,4 @@\n-/* Copyright (c) 2019-2023, Arm Limited and Contributors\n+/* Copyright (c) 2019-2024, Arm Limited and Contributors\n  *\n  * SPDX-License-Identifier: Apache-2.0\n  *\n@@ -58,6 +58,10 @@ void LightingSubpass::draw(CommandBuffer &command_buffer)\n \tauto &pipeline_layout = resource_cache.request_pipeline_layout(shader_modules);\n \tcommand_buffer.bind_pipeline_layout(pipeline_layout);\n \n+\t// we know, that the lighting subpass does not have any vertex stage input -> reset the vertex input state\n+\tassert(pipeline_layout.get_resources(ShaderResourceType::Input, VK_SHADER_STAGE_VERTEX_BIT).empty());\n+\tcommand_buffer.set_vertex_input_state({});\n+\n \t// Get image views of the attachments\n \tauto &render_target = get_render_context().get_active_frame().get_render_target();\n \tauto &target_views  = render_target.get_views();\n", "fix_pattern": "<pattern>: if a vertex input state is set after asserting that no vertex stage input resources are present, ensure that the assertion is checked before setting the vertex input state to optimize potential errors in graphics pipeline configuration."}
{"number": 232, "change": "@@ -85,7 +85,7 @@ static ScopedFd create_memfd_file(const string& orig_path, dev_t orig_device,\n        << \"-inode-\" << orig_inode << \"-\" << orig_path;\n   real_name = name.str().substr(0, 255);\n \n-  ScopedFd fd = memfd_create(real_name.c_str(), 0);\n+  ScopedFd fd = syscall(SYS_memfd_create, real_name.c_str(), 0);\n   return fd;\n }\n \n", "fix_pattern": "<pattern>: if the code uses a higher-level API function like memfd_create that incurs additional overhead due to abstraction, refactor it to directly use the syscall interface for better performance by reducing function call overhead and leveraging lower-level operations directly."}
{"number": 241, "change": "@@ -6112,7 +6112,6 @@ void* background_thread(void*)\n   mysql_mutex_lock(&background_mutex);\n   mysql_mutex_lock(&stop_cond_mutex);\n \n-  rocksdb::WriteBatch wb;\n   time_t last_stat_recompute = 0;\n   for (;;)\n   {\n@@ -6128,9 +6127,8 @@ void* background_thread(void*)\n     assert(ret == 0 || ret == ETIMEDOUT);\n \n     if (rdb && rocksdb_background_sync) {\n-      auto wo = rocksdb::WriteOptions();\n-      wo.sync = true;\n-      rocksdb::Status s= rdb->Write(wo, &wb);\n+      assert(!db_options.allow_mmap_writes);\n+      rocksdb::Status s= rdb->SyncWAL();\n       if (!s.ok())\n         rocksdb_handle_io_error(s, ROCKSDB_IO_ERROR_BG_THREAD);\n     }\n", "fix_pattern": "<pattern>: if a write operation is performed with `rocksdb::Write`, and it is determined that write-ahead logging (WAL) should be synchronized without custom write options, replace the write operation with `rocksdb::DB::SyncWAL()` for improved performance, especially when synchronous writes are unnecessary. This change also removes complexity from write options and directly manages the log synchronization."}
{"number": 242, "change": "@@ -41,10 +41,10 @@ double HkIClientImpl::CDPClientProxy__GetLinkSaturation(uint iClientID)\n \t// ISERVER_LOGARG_UI(iClientID);\n \n \tchar *tmp; \n-\tWriteProcMem(&tmp, &Client, 4); \n-\tWriteProcMem(&Client, &OldClient, 4); \n+\tmemcpy(&tmp, &Client, 4);\n+\tmemcpy(&Client, &OldClient, 4);\n \tdouble dRet = HookClient->CDPClientProxy__GetLinkSaturation(iClientID); \n-\tWriteProcMem(&Client, &tmp, 4); \n+\tmemcpy(&Client, &tmp, 4);\n \n \treturn dRet;\n }\n", "fix_pattern": "<pattern>: if multiple calls to a memory writing API (in this case WriteProcMem) are detected for copying fixed-size blocks of memory, replace them with calls to memcpy for better performance and reduced overhead."}
{"number": 251, "change": "@@ -67,14 +67,8 @@ void OGGLoader::into(Loadable& resource, const LoaderOptions& options) {\n     Sound* sound = dynamic_cast<Sound*>(res_ptr);\n     assert(sound && \"You passed a Resource that is not a Sound to the OGG loader\");\n \n-    std::ifstream t(filename_.encode().c_str(), std::ios::binary);\n-    std::vector<uint8_t> data;\n-\n-    t.seekg(0, std::ios::end);\n-    data.reserve(t.tellg());\n-    t.seekg(0, std::ios::beg);\n-\n-    data.assign((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());\n+    std::string buf = data_->str();\n+    std::vector<uint8_t> data(buf.begin(), buf.end());\n \n     StreamWrapper stream(stb_vorbis_open_memory(&data[0], data.size(),nullptr, nullptr));\n \n", "fix_pattern": "<pattern>: if reading data from a file using std::ifstream involves seeking the file size and using std::istreambuf_iterator, replace it with reading data into a string buffer first and then constructing the vector from the string to reduce overhead from seeking and iterating."}
{"number": 253, "change": "@@ -63,9 +63,11 @@ BOOL WINAPI DllMain(HINSTANCE h, DWORD reason, LPVOID reserved)\n \t\tstrcpy(++p, FBDLLNAME);\n \t\tp += strlen(FBDLLNAME);\n \t\t*p = 0;\n-\t\thFBDLLInstance = LoadLibrary(buffer);\n-\t\tif (!hFBDLLInstance) {\n-\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\tif (!GetModuleHandle(buffer) && !GetModuleHandle(FBDLLNAME)) {\n+\t\t\thFBDLLInstance = LoadLibrary(buffer);\n+\t\t\tif (!hFBDLLInstance) {\n+\t\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase DLL_PROCESS_DETACH:\n", "fix_pattern": "<pattern>: if the code checks for the loaded module using LoadLibrary, replace it with GetModuleHandle to avoid loading the library again if it's already been loaded; then only fall back to LoadLibrary if the module is not currently loaded."}
{"number": 255, "change": "@@ -21,6 +21,7 @@\n  */\n \n #include \"firebird.h\"\n+#include \"../common/classes/Aligner.h\"\n #include \"../common/classes/Hash.h\"\n #include \"../jrd/jrd.h\"\n #include \"../jrd/req.h\"\n@@ -525,8 +526,8 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\tif (desc->isDecFloat())\n \t\t\t\t{\n \t\t\t\t\t// Values inside our key buffer are not aligned,\n-\t\t\t\t\t// hence we need to use intermediate storage for makeKey()\n-\t\t\t\t\tULONG key[MAX_DEC_KEY_LONGS];\n+\t\t\t\t\t// so ensure we satisfy our platform's alignment rules\n+\t\t\t\t\tOutAligner<ULONG, MAX_DEC_KEY_LONGS> key(keyPtr, keyLength);\n \n \t\t\t\t\tif (desc->dsc_dtype == dtype_dec64)\n \t\t\t\t\t\t((Decimal64*) data)->makeKey(key);\n@@ -534,9 +535,6 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\t\t\t((Decimal128*) data)->makeKey(key);\n \t\t\t\t\telse\n \t\t\t\t\t\tfb_assert(false);\n-\n-\t\t\t\t\tfb_assert(keyLength <= sizeof(key));\n-\t\t\t\t\tmemcpy(keyPtr, key, keyLength);\n \t\t\t\t}\n \t\t\t\telse if (desc->dsc_dtype == dtype_real && *(float*) data == 0)\n \t\t\t\t{\n", "fix_pattern": "<pattern>: if `memcpy` is used to copy data to `keyPtr`, refactor the code to use a specialized alignment-aware class (e.g., `OutAligner`) that ensures proper handling of memory alignment constraints for the platform, improving performance and safety."}
{"number": 256, "change": "@@ -116,7 +116,7 @@ namespace\n \t{\n \t\tuint8* destPointer = EmulatorInterface::instance().getMemoryPointer(destAddress, true, bytes);\n \t\tuint8* sourcePointer = EmulatorInterface::instance().getMemoryPointer(sourceAddress, false, bytes);\n-\t\tmemcpy(destPointer, sourcePointer, bytes);\n+\t\tmemmove(destPointer, sourcePointer, bytes);\n \t}\n \n \tvoid zeroMemory(uint32 startAddress, uint32 bytes)\n", "fix_pattern": "<pattern>: if the source and destination memory regions overlap, replace memcpy with memmove to ensure safety and correctness without performance degradation."}
{"number": 258, "change": "@@ -158,7 +158,7 @@ buffer_washer(char * buff, int buffer_len)\n \n     for (i = 0 ; i < buffer_len - 1; i++) {\n \tif (buff[i] == '\\0') {\n-\t    memcpy(&buff[i], &buff[i+1], buffer_len - i);\n+\t    memmove(&buff[i], &buff[i+1], buffer_len - i);\n \t    buffer_len--;\n \t    buff[buffer_len] = '\\0';\n \t}\n", "fix_pattern": "<pattern>: if overlapping memory regions are involved in a copy operation, replace memcpy with memmove to ensure safe handling of overlapping areas."}
{"number": 261, "change": "@@ -34,7 +34,7 @@ const Kernel::FT volume( const Solid& solid, NoValidityCheck )\n     const CGAL::Point_3<Kernel> origin(0,0,0);\n     const size_t numShells = solid.numShells();\n     for (size_t i=0; i<numShells; i++) {\n-        std::auto_ptr<Geometry> t( tesselate( solid.shellN(i) ) );\n+\t    std::auto_ptr<Geometry> t( tesselate( solid.shellN(i), NoValidityCheck() ) );\n         const TriangulatedSurface& tin = t->as<TriangulatedSurface>();\n         const size_t numTriangles = tin.numTriangles();\n         for (size_t j=0; j<numTriangles; j++) {\n", "fix_pattern": "<pattern>: if an API call to `tesselate` is made without a validity check and there exists an overload for `tesselate` that allows skipping the validity check for performance improvements, refactor the call to utilize that overload by passing `NoValidityCheck()`."}
{"number": 274, "change": "@@ -368,10 +368,8 @@ void CPNGFile::WaitForSaves()\n \t\tfirst = false;\n #ifdef HAVE_WINTHREAD\n \t\tSleep(100);\n-#elif defined (__APPLE__)\n+#else\n \t\tsched_yield();\n-#elif defined(HAVE_PTHREAD)\n-\t\tpthread_yield();\n #endif\n \t}\n }\n", "fix_pattern": "<pattern>: if there is a conditional branch for a specific platform that includes a call to `pthread_yield()`, then refactor it to eliminate the call in favor of a more generalized fallback without the platform-specific behavior."}
{"number": 286, "change": "@@ -56,9 +56,7 @@ OperatorHandle Dispatcher::findOrRegisterSchema_(FunctionSchema&& schema, Operat\n   const auto found = findSchema(schema.operator_name());\n   if (found != c10::nullopt) {\n     if (found->schema() != schema) {\n-      std::ostringstream str;\n-      str << schema << \" vs \" << found->schema();\n-      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", str.str());\n+      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", schema, \" vs \", found->schema());\n     }\n     if (options.isDefaultAliasAnalysisKind()) {\n       // just do nothing and let it pass.\n", "fix_pattern": "<pattern>: if creating a temporary `std::ostringstream` to format a string is detected, replace it with direct string concatenation in the `TORCH_CHECK` call for improved performance and reduced object construction overhead."}
{"number": 288, "change": "@@ -38,7 +38,6 @@\n #include \"audio/dcblocker.h\"\n #include \"logger.h\"\n #include \"manager.h\"\n-#include \"cc_thread.h\"\n \n #include <cstdlib>\n #include <fstream>\n@@ -252,7 +251,7 @@ std::string PulseLayer::getAudioDeviceName(int index, PCMType type) const\n void PulseLayer::createStreams(pa_context* c)\n {\n     while (enumeratingSinks_ or enumeratingSources_)\n-        ost::Thread::sleep(20 /* ms */);\n+        usleep(20000); // 20 ms\n \n     std::string playbackDevice(preference_.getPulseDevicePlayback());\n     std::string captureDevice(preference_.getPulseDeviceRecord());\n", "fix_pattern": "<pattern>: if a platform-specific sleep function (like ost::Thread::sleep) is used which may involve more overhead, replace it with a more efficient platform-specific alternative (like usleep) for better performance in timing control."}
{"number": 291, "change": "@@ -147,10 +147,10 @@ PyObject *slotCall(PyObject *self, PyObject *args, PyObject * /* kw */)\n             data->slotName = strdup(Shiboken::String::toCString(funcName));\n         }\n \n-\n-        QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n-        QByteArray signature = QString().sprintf(\"%s(%s)\", data->slotName, data->args).toUtf8();\n-        signature = returnType + \" \" + signature;\n+        const QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n+        const QByteArray signature =\n+            returnType + ' ' + const_cast<const char *>(data->slotName)\n+            + '(' + const_cast<const char *>(data->args) + ')';\n \n         if (!pySlotName)\n             pySlotName = Shiboken::String::fromCString(PYSIDE_SLOT_LIST_ATTR);\n", "fix_pattern": "<pattern>: if QByteArray is being constructed multiple times from QString while using sprintf, replace it with direct QByteArray concatenation to avoid unnecessary conversions and improve performance. Additionally, use const correctness to avoid unnecessary copies."}
{"number": 292, "change": "@@ -110,11 +110,8 @@ int main(int argc, char ** argv)\n \t\tif (argc != 1)\n \t\t\tthrow std::runtime_error(i18n(\"no document specified\"));\n \n-\t\tcainteoir::document_events events;\n \t\trdf::graph metadata;\n-\t\tif (!cainteoir::parseDocument(argv[0], events, metadata))\n-\t\t\tfprintf(stderr, i18n(\"unsupported document format for file \\\"%s\\\"\\n\"), argv[0]);\n-\n+\t\tauto reader = cainteoir::createDocumentReader(argv[0], metadata, std::string());\n \t\tif (!metadata.empty())\n \t\t{\n \t\t\tif (output_type == rdf_metadata)\n", "fix_pattern": "<pattern>: if an API method (`cainteoir::parseDocument`) that processes files is replaced by a different method (`cainteoir::createDocumentReader`) that may offer better performance or efficiency, identify that the change signifies a shift towards a potentially more optimized API call for handling document reading while maintaining the context associated with the operation."}
{"number": 308, "change": "@@ -194,7 +194,7 @@ uint32_t scap_fd_info_len(scap_fdinfo *fdi)\n \t\tres += \n \t\t\tsizeof(uint64_t) + // unix source \n \t\t\tsizeof(uint64_t) +  // unix destination\n-\t\t\t(uint32_t)strlen(fdi->info.unix_socket_info.fname) + 2;\n+\t\t\t(uint32_t)strnlen(fdi->info.unix_socket_info.fname, SCAP_MAX_PATH_SIZE) + 2;\n \t\tbreak;\n \tcase SCAP_FD_FIFO:\n \tcase SCAP_FD_FILE:\n", "fix_pattern": "<pattern>: if the code uses strlen with an input that might exceed a specific maximum size, replace it with strnlen to prevent potential buffer over-read and improve safety."}
{"number": 310, "change": "@@ -114,7 +114,7 @@ int init_SDL(void)\n         fprintf(stderr, \"Unable to init SDL: %s\\n\", SDL_GetError());\n         return(0);\n     }\n-    sdlscreen = SDL_SetVideoMode(0,0, 32, SDL_SWSURFACE);\n+    sdlscreen = SDL_SetVideoMode(0,0, 16, SDL_SWSURFACE);\n \n     SDL_JoystickEventState(SDL_ENABLE);\n \tmyjoy[0]=SDL_JoystickOpen(0);\n", "fix_pattern": "<pattern>: when modifying the bit depth parameter (bpp) for SDL_SetVideoMode, reducing it from 32 to 16 can enhance performance by decreasing memory usage and potentially increasing rendering speed, especially in scenarios where high color depth is not necessary."}
{"number": 311, "change": "@@ -70,11 +70,16 @@ perf (bool decode)\n   double t = get_time();\n   for (int r = 0; r < RUNS; r++)\n     {\n-      notify_buffer.clear();\n+      bool write_ok = notify_buffer.start_write();\n+      assert (write_ok);\n       for (int i = 0; i < EVENTS; i++)\n         {\n           fill_notify_buffer (notify_buffer);\n         }\n+      notify_buffer.end_write();\n+\n+      bool read_ok = notify_buffer.start_read();\n+      assert (read_ok);\n       if (decode)\n         {\n           while (notify_buffer.remaining())\n@@ -84,6 +89,7 @@ perf (bool decode)\n               delete e;\n             }\n         }\n+      notify_buffer.end_read();\n     }\n   printf (\"%.2f events/sec (decode = %s)\\n\", (EVENTS * RUNS) / (get_time() - t), decode ? \"TRUE\" : \"FALSE\");\n }\n", "fix_pattern": "<pattern>: if a call to `notify_buffer.clear()` is replaced with `notify_buffer.start_write()` and `notify_buffer.end_write()`, indicating a performance improvement by using a write operation that likely aggregates and clears the buffer more efficiently than the clear operation did, then adopt that approach for managing the state of the buffer."}
{"number": 318, "change": "@@ -102,9 +102,9 @@ change_alpha( ssgBase *_branch, float _blend )\n   for (i = 0; i < ((ssgBranch *)_branch)->getNumKids(); i++)\n     change_alpha( ((ssgBranch *)_branch)->getKid(i), _blend );\n \n-  if ( strcmp(\"ssgLeaf\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVtxTable\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVTable\", _branch->getTypeName()) )\n+  if ( !_branch->isAKindOf(ssgTypeLeaf())\n+       && !_branch->isAKindOf(ssgTypeVtxTable())\n+       && !_branch->isAKindOf(ssgTypeVTable()) )\n     return;\n \n   int num_colors = ((ssgLeaf *)_branch)->getNumColours();\n", "fix_pattern": "<pattern>: if multiple `strcmp` calls are used to check the type of an object, replace them with a single call to `isAKindOf` for each type, allowing for better performance and readability by avoiding unnecessary string comparisons and leveraging type checking directly."}
{"number": 321, "change": "@@ -7,6 +7,7 @@\n #pragma once\n \n #include <sys/types.h> // for u_char\n+#include <zeek/util.h>\n #include <cstdint>\n #include <cstdio>\n \n@@ -41,7 +42,8 @@ enum HashAlgorithm { Hash_MD5, Hash_SHA1, Hash_SHA224, Hash_SHA256, Hash_SHA384,\n inline const char* digest_print(const u_char* digest, size_t n) {\n     static char buf[ZEEK_DIGEST_PRINT_LENGTH];\n     for ( size_t i = 0; i < n; ++i )\n-        snprintf(buf + i * 2, 3, \"%02x\", digest[i]);\n+        zeek::util::bytetohex(digest[i], &buf[i * 2]);\n+    buf[2 * n] = '\\0';\n     return buf;\n }\n \n", "fix_pattern": "<pattern>: if snprintf is used to format binary data to hexadecimal strings, replace it with a specialized utility function (zeek::util::bytetohex) that may provide optimized performance for this specific conversion."}
{"number": 324, "change": "@@ -161,15 +161,13 @@ void MainWindow::InitializeUi() {\n }\n \n void MainWindow::ExpandCollapse(TreeState state) {\n-    // if it's connected during the call it's called for every item apparently, which is damn slow!\n-    disconnect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    disconnect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    // we block signals so that ResizeTreeColumns isn't called for every item, which is damn slow!\n+    ui->treeView->blockSignals(true);\n     if (state == TreeState::kExpand)\n         ui->treeView->expandAll();\n     else\n         ui->treeView->collapseAll();\n-    connect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    connect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    ui->treeView->blockSignals(false);\n \n     ResizeTreeColumns();\n }\n", "fix_pattern": "<pattern>: if multiple disconnect and connect calls are made around a function that can be slow if called repeatedly (like ResizeTreeColumns), use blockSignals to prevent the signal from triggering during a performance-critical operation to improve efficiency."}
{"number": 334, "change": "@@ -122,8 +122,8 @@ void Job::on_socket_connected()\n                 }\n             }\n \n-            m_received_buffers.append(payload);\n             m_received_size += payload.size();\n+            m_received_buffers.append(move(payload));\n             flush_received_buffers();\n \n             deferred_invoke([this] { did_progress({}, m_received_size); });\n", "fix_pattern": "<pattern>: if an object is appended to a container in a manner that can lead to unnecessary copies, use std::move to transfer ownership and improve performance."}
{"number": 335, "change": "@@ -316,12 +316,6 @@ void Job::on_socket_connected()\n                 if (m_code == 204)\n                     return finish_up();\n \n-                can_read_line = m_socket->can_read_line();\n-                if (can_read_line.is_error())\n-                    return deferred_invoke([this] { did_fail(Core::NetworkJob::Error::TransmissionFailed); });\n-\n-                if (!can_read_line.value())\n-                    return;\n                 break;\n             }\n             auto parts = line.split_view(':');\n", "fix_pattern": "<pattern>: if a method call to check for a condition (like can_read_line) is followed by error checking and early returns, consider refactoring to handle both the condition check and error handling in a single call to reduce overhead from multiple API invocations and follow a more concise pattern."}
{"number": 343, "change": "@@ -63,9 +63,12 @@ public:\n     {\n         VERIFY(!ivec.is_empty());\n \n-        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(out.size()));\n+        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(T::BlockSizeInBits / 8));\n \n-        encrypt(in, out, ivec, dummy, dummy);\n+        // FIXME: Taking `out` by reference suggests that we should modify its length to match the\n+        //        ciphertext size. In practice, however, noone does that and I don't want to be the\n+        //        person who fixes this.\n+        encrypt(in, out.slice(0, in.size()), ivec, dummy, dummy);\n     }\n     virtual void decrypt(ReadonlyBytes in, Bytes& out, ReadonlyBytes ivec = {}) override\n     {\n", "fix_pattern": "<pattern>: if a ByteBuffer is created with its size determined by the `out` buffer which may vary in size, instead statically allocate a ByteBuffer of fixed size using known constants to optimize performance by avoiding dynamic size calculation during each call."}
{"number": 344, "change": "@@ -3,6 +3,7 @@\n */\n \n #include <iostream>\n+#include <random>\n \n #include <args.hxx>\n \n@@ -80,10 +81,17 @@ std::string get_random_nums_str( std::size_t count )\n \n std::vector< int > get_random_nums( std::size_t count )\n {\n+\tstd::random_device r;\n+\tstd::mt19937 gen{ r() };\n+\tstd::uniform_int_distribution< int > uniform_dist;\n+\n \tstd::vector< int > result;\n \tresult.reserve( count );\n \n-\tstd::generate_n( std::back_inserter( result ), count, [](){ return rand(); } );\n+\tstd::generate_n(\n+\t\tstd::back_inserter( result ),\n+\t\tcount,\n+\t\t[&](){ return uniform_dist( gen ); } );\n \n \treturn result;\n }\n", "fix_pattern": "<pattern>: if random numbers are being generated using the rand() function, replace it with the C++ `<random>` library for improved randomness quality and better performance characteristics by leveraging modern random number generation facilities."}
{"number": 346, "change": "@@ -101,7 +101,7 @@ bool AdminDatabase::ValidPassword(const char *username, const char *password)\n     QByteArray passb = m_prepared_select_account_passw.value(\"passw\").toByteArray();\n     QByteArray salt = m_prepared_select_account_passw.value(\"salt\").toByteArray();\n     QByteArray hashed_password = hasher.hashPassword(password, salt);\n-    if (memcmp(passb.data(),hashed_password.data(),passb.size()) == 0)\n+    if (memcmp(passb,hashed_password,passb.size()) == 0)\n         res = true;\n     return res;\n }\n", "fix_pattern": "<pattern>: if the data() method is used to retrieve raw data from a QByteArray for comparison with memcmp, directly pass the QByteArray objects to memcmp instead, optimizing performance by eliminating unnecessary calls to data() and improving type coherence."}
{"number": 349, "change": "@@ -594,17 +594,16 @@ out_err:\n \t\t\tif (strcmp(name, \".gnu_debuglink\") == 0) {\n \t\t\t\tconst char *p = (const char *)data->d_buf;\n \t\t\t\tm_debuglink.append(p);\n-\n-\t\t\t\tp += strlen(p);\n+\t\t\t\tconst char *endOfString = p + strlen(p) + 1;\n \n \t\t\t\t// Align address for the CRC32\n-\t\t\t\tunsigned long addr = (unsigned long)p;\n-\t\t\t\tunsigned long offs = 4;\n+\t\t\t\tunsigned long addr = (unsigned long)(endOfString - p);\n+\t\t\t\tunsigned long offs = 0;\n \n \t\t\t\tif ((addr & 3) != 0)\n \t\t\t\t\toffs = 4 - (addr & 3);\n \t\t\t\t// ... and read out the CRC32\n-\t\t\t\tm_debuglinkCrc = *(uint32_t *)(p + offs);\n+\t\t\t\tmemcpy((void *)&m_debuglinkCrc, endOfString + offs, sizeof(m_debuglinkCrc));\n \t\t\t}\n \n \t\t\tif ((sh_flags & (SHF_EXECINSTR | SHF_ALLOC)) != (SHF_EXECINSTR | SHF_ALLOC))\n", "fix_pattern": "<pattern>: if the code previously accesses memory using pointer arithmetic and casts directly from a string, refactor it to use memcpy for copying data to avoid potential alignment issues and improve safety when handling raw memory operations."}
{"number": 352, "change": "@@ -355,8 +355,8 @@ static int PlayerQuit[PlayerMax];          /// Player quit\n static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int player = 255)\n {\n \tconst unsigned int size = packet.Size(numcommands);\n-\tunsigned char *buf = new unsigned char[size];\n-\tpacket.Serialize(buf, numcommands);\n+\tstd::vector<unsigned char> buf(size);\n+\tpacket.Serialize(buf.data(), numcommands);\n \n \t// Send to all clients.\n \tif (NetConnectType == 1) { // server\n@@ -366,14 +366,13 @@ static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int\n \t\t\t\tif (Hosts[i].PlyNr == player) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tNetworkFildes.Send(host, buf, size);\n+\t\t\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t\t\t}\n \t\t}\n \t} else { // client\n \t\tconst CHost host(Hosts[0].Host, Hosts[0].Port);\n-\t\tNetworkFildes.Send(host, buf, size);\n+\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t}\n-\tdelete[] buf;\n }\n \n /**\n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a raw buffer (e.g., using `new`), replace it with a `std::vector` to manage memory automatically and improve safety and performance by eliminating the need for manual deallocation."}
{"number": 354, "change": "@@ -5491,7 +5491,7 @@ static void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {\n     }\n \n     /* read keys to be used for input */\n-    src = malloc(sizeof(zsetopsrc) * zsetnum);\n+    src = zmalloc(sizeof(zsetopsrc) * zsetnum);\n     for (i = 0, j = 3; i < zsetnum; i++, j++) {\n         robj *zsetobj = lookupKeyWrite(c->db,c->argv[j]);\n         if (!zsetobj) {\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, replace it with a project-specific memory allocation function (e.g., zmalloc) for better performance and potential benefits such as memory tracking or improved allocation strategies specific to the project."}
{"number": 364, "change": "@@ -498,8 +498,13 @@ void Battlenet::Session::HandleJoinRequestV2(WoWRealm::JoinRequestV2 const& join\n \n     memcpy(sessionKey + hmac.GetLength(), hmac2.GetDigest(), hmac2.GetLength());\n \n-    LoginDatabase.DirectPExecute(\"UPDATE account SET sessionkey = '%s', last_ip = '%s', last_login = NOW(), locale = %u, failed_logins = 0, os = '%s' WHERE id = %u\",\n-        ByteArrayToHexStr(sessionKey, 40, true).c_str(), GetRemoteIpAddress().to_string().c_str(), GetLocaleByName(_locale), _os.c_str(), _gameAccountInfo->Id);\n+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_LOGONPROOF);\n+    stmt->setString(0, ByteArrayToHexStr(sessionKey, 40, true).c_str());\n+    stmt->setString(1, GetRemoteIpAddress().to_string());\n+    stmt->setUInt32(2, GetLocaleByName(_locale));\n+    stmt->setString(3, _os);\n+    stmt->setString(4, _gameAccountInfo->Name);\n+    LoginDatabase.DirectExecute(stmt);\n \n     joinResponse->IPv4.emplace_back(*realm->ExternalAddress, realm->Port);\n     if (*realm->ExternalAddress != *realm->LocalAddress)\n", "fix_pattern": "<pattern>: if raw SQL queries are being constructed and executed directly, replace them with prepared statements to improve performance and security by avoiding SQL injection and allowing the database engine to optimize query execution."}
{"number": 365, "change": "@@ -887,7 +887,7 @@ class Simplex_tree {\n     while (true) {\n       if (begin1->first == begin2->first) {\n         Filtration_value filt = (std::max)({begin1->second.filtration(), begin2->second.filtration(), filtration_});\n-        intersection.push_back(std::pair<Vertex_handle, Node>(begin1->first, Node(NULL, filt)));\n+        intersection.emplace_back(begin1->first, Node(NULL, filt));\n         if (++begin1 == end1 || ++begin2 == end2)\n           return;  // ----->>\n       } else if (begin1->first < begin2->first) {\n", "fix_pattern": "<pattern>: if std::vector's push_back is used to create a new object that could be constructed in place, replace it with emplace_back to avoid unnecessary copy or move operations, improving performance."}
{"number": 367, "change": "@@ -226,7 +226,7 @@ bool Info::Read(XrdOssDF* fp, const std::string &fname)\n       for (int i =0; i < 16; ++i)\n       printf(\"%x\", m_store.m_cksum[i] & 0xff);\n     */\n-   if (strncmp(m_store.m_cksum, &tmpCksum[0], 16))\n+   if (memcmp(m_store.m_cksum, &tmpCksum[0], 16))\n    {\n       TRACE(Error, trace_pfx << \" buffer cksum and saved cksum don't match \\n\");\n       return false;\n", "fix_pattern": "<pattern>: if a comparison of two byte sequences is performed using strncmp, replace it with memcmp for improved performance, as memcmp is optimized for binary comparison and avoids string-specific nuances."}
{"number": 368, "change": "@@ -74,10 +74,9 @@ bool State::InstallHandlers(CURL *curl) {\n     // Older versions have poor transfer performance, corrected in curl commit cacdc27f.\n     curl_version_info_data *curl_ver = curl_version_info(CURLVERSION_NOW);\n     if (curl_ver->age > 0 && curl_ver->version_num >= 0x072600) {\n-        // Require a minimum speed from the transfer: must move at least 1MB every 2 minutes\n-        // (roughly 8KB/s).\n+        // Require a minimum speed from the transfer: 2 minute average must at least 10KB/s\n         curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 2*60);\n-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1024*1024);\n+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 10*1024);\n     }\n     return true;\n }\n", "fix_pattern": "<pattern>: if CURLOPT_LOW_SPEED_LIMIT is being set, adjust the limit calculation to a more appropriate value that reflects performance expectations, ensuring the speed requirement aligns with bytes per second rather than total bytes over an extended period."}
{"number": 371, "change": "@@ -35,8 +35,7 @@ IceInternal::BasicOutputStream::BasicOutputStream(IceInternal::Instance* instanc\n Ice::InputStreamI::InputStreamI(const Ice::CommunicatorPtr& communicator, const vector<Byte>& data) :\n     _communicator(communicator), _is(IceInternal::getInstance(communicator).get(), this)\n {\n-    _is.b.resize(data.size());\n-    memcpy(&_is.b[0], &data[0], data.size());\n+    _is.writeBlob(data);\n     _is.i = _is.b.begin();\n }\n \n", "fix_pattern": "<pattern>: if a vector is resized and then populated using memcpy, replace the combination with a call to a more optimized method such as writeBlob(), which likely has internal optimizations for handling the data directly."}
{"number": 372, "change": "@@ -320,7 +320,7 @@ QList<QString> TessTools::getLanguages(QString datapath) {\n       QFileInfo fileInfo = list.at(i);\n       languages.append(QString(\"%1\").arg(fileInfo.baseName()));\n     }\n-    qSort(languages);\n+    std::sort(languages.begin(), languages.end());\n \n     return languages;\n }\n", "fix_pattern": "<pattern>: if the code is using qSort from the Qt library, replace it with std::sort from the Standard Library for better performance and compatibility with C++ algorithms."}
{"number": 382, "change": "@@ -139,7 +139,10 @@ const char *AGSLinux::GetAppOutputDirectory()\n }\n \n void AGSLinux::Delay(int millis) {\n-  usleep(millis);\n+  struct timespec ts;\n+  ts.tv_sec = 0;\n+  ts.tv_nsec = millis * 1000000;\n+  nanosleep(&ts, NULL);\n }\n \n unsigned long AGSLinux::GetDiskFreeSpaceMB() {\n", "fix_pattern": "<pattern>: if the usleep function is used for sleeping in microseconds, replace it with nanosleep for better precision and to provide a more flexible structure for specifying sleep time in nanoseconds."}
{"number": 383, "change": "@@ -191,7 +191,7 @@ struct buffer : public buffer_base {\n         int rem = (pos <= lim ? lim - pos : 0);\n \n         //rem << 2? wtf?\n-        memcpy(bf.get(), bf.get() + position(), rem << 2);\n+        memmove(bf.get(), bf.get() + position(), rem << 2);\n \n         position(rem);\n         limit(capacity());\n", "fix_pattern": "<pattern>: if a memory operation involves overlapping source and destination regions, replace memcpy with memmove to ensure correct behavior without undefined behavior, as memmove handles overlapping regions safely."}
{"number": 385, "change": "@@ -98,10 +98,13 @@ int test_rw_image_access_qualifier(cl_device_id device_id, cl_context context, c\n     return -1;\n     }\n \n+    MTdata mtData = init_genrand(gRandomSeed);\n     /* Fill input array with random values */\n     for (i = 0; i < size; i++) {\n-        input[i] = (unsigned int)(rand()/((double)RAND_MAX + 1)*255);\n+        input[i] = genrand_int32(mtData);\n     }\n+    free_mtdata(mtData);\n+    mtData = NULL;\n \n     /* Zero out output array */\n     for (i = 0; i < size; i++) {\n", "fix_pattern": "<pattern>: if a random number is generated using the standard `rand()` function, which has poor randomness quality and possible performance issues in a multi-threaded context, replace it with Mersenne Twister RNG functions (`init_genrand`, `genrand_int32`, and `free_mtdata`) for improved performance and better randomness quality."}
{"number": 394, "change": "@@ -901,7 +901,8 @@ static size_t VSICurlHandleWriteFunc( void *buffer, size_t count,\n static bool VSICurlIsS3SignedURL( const char* pszURL )\n {\n     return\n-        strstr(pszURL, \".s3.amazonaws.com/\") != NULL &&\n+        (strstr(pszURL, \".s3.amazonaws.com/\") != NULL ||\n+         strstr(pszURL, \".storage.googleapis.com/\") != NULL) &&\n         (strstr(pszURL, \"&Signature=\") != NULL ||\n          strstr(pszURL, \"?Signature=\") != NULL);\n }\n", "fix_pattern": "<pattern>: if multiple calls are made to strstr with the same haystack, combine checks for efficiency by using logical OR to minimize the number of function calls."}
{"number": 398, "change": "@@ -3260,8 +3260,15 @@ void TV::ChangeChannel(int direction)\n \n QString TV::GetQueuedChanNum(void) const\n {\n+    static QRegExp regexp = QRegExp(\"([1-9]|\\\\w)\");\n+\n+    // avoid regular expression if queue is empty.\n+    if (queuedChanNum.isEmpty())\n+        return queuedChanNum;\n+\n     // strip initial zeros.\n-    int nzi = queuedChanNum.find(QRegExp(\"([1-9]|\\\\w)\"));\n+    regexp.setMinimal(true); // we don't need greedy matching\n+    int nzi = queuedChanNum.find(regexp);\n     if (nzi > 0)\n         queuedChanNum = queuedChanNum.right(queuedChanNum.length() - nzi);\n \n", "fix_pattern": "<pattern>: if a regular expression is created in every call, move the QRegExp object to a static variable to avoid repeated allocation and initialization overhead; also, set minimal matching to improve performance when searching."}
{"number": 402, "change": "@@ -89,7 +89,8 @@ public:\n             if (   ((flags() & kMethcla_BusMappingExternal) == kMethcla_BusMappingExternal)\n                 || ((flags() & kMethcla_BusMappingFeedback) == kMethcla_BusMappingFeedback)\n                 || (bus()->epoch() == env.epoch())) {\n-                memcpy(dst, bus()->data() + offset, numFrames * sizeof(sample_t));\n+                const sample_t* buffer = bus()->data();\n+                std::copy(buffer + offset, buffer + offset + numFrames, dst);\n             } else {\n                 memset(dst, 0, numFrames * sizeof(sample_t));\n             }\n", "fix_pattern": "<pattern>: if a memcpy operation copies a range of data from one location to another, consider using std::copy as a more expressive and potentially optimized alternative, which provides better type safety and integration with STL containers."}
{"number": 407, "change": "@@ -45,6 +45,7 @@\n \n /* Includes */\n #include <precomp.hpp>\n+#include <opencv2/core.hpp>\n #include <stdlib.h>\n #include <stdio.h>\n #include <stdint.h>\n@@ -476,11 +477,7 @@ inline int    RHO_HEST_REFC::initialize(void){\n     lm.tmp1     = NULL;\n     lm.Jte      = NULL;\n \n-#ifdef _WIN32\n-    fastSeed(rand());\n-#else\n-    fastSeed(random());\n-#endif\n+    fastSeed((unsigned)cv::theRNG());\n \n \n     int areAllAllocsSuccessful = ctrl.smpl   &&\n", "fix_pattern": "<pattern>: if the code uses platform-specific random number generation (like rand() for Windows or random() for other platforms), refactor it to use a central random number generator from a library (such as OpenCV's cv::theRNG) for better consistency and potentially improved performance."}
{"number": 409, "change": "@@ -802,10 +802,10 @@ void flex_rewrite::quantized_graph_rewrite(deserialized_graph &dgraph) {\n         const dnnl_dims_t scales_dims {scales_zp_dim};\n         const auto scales_md\n                 = dnn_mem_t::init_md(1, scales_dims, dnnl_f32, tag::abx);\n-        dnn_mem_t scales_mem(\n-                scales_md, get_cpu_engine(), {false, scales.data()});\n-        dnn_mem_t dummy;\n-        fill_scales(e, dummy, scales_mem);\n+        dnn_mem_t scales_dt(\n+                scales_md, get_test_engine().get(), {false, scales.data()});\n+        dnn_mem_t scales_fp(scales_md, get_test_engine().get());\n+        fill_scales(e, scales_dt, scales_fp);\n \n         std::vector<int64_t> zps;\n         for (int64_t i = 0; i < scales_zp_dim; i++) {\n", "fix_pattern": "<pattern>: When using the DNNL library, if obtaining memory for a computation is done using a CPU engine, switch to using a test engine for memory allocation to potentially improve performance in testing scenarios, and ensure that both the destination and source memories are prepared for the operation being performed."}
{"number": 412, "change": "@@ -2,7 +2,7 @@\n \n #include \"SDLImage.hh\"\n #include \"OutputSurface.hh\"\n-#include \"LocalFileReference.hh\"\n+#include \"File.hh\"\n #include \"MSXException.hh\"\n #include \"vla.hh\"\n #include \"build-info.hh\"\n@@ -183,10 +183,12 @@ static SDL_Surface* loadImage(\n \n SDL_Surface* SDLImage::readImage(const string& filename)\n {\n-\tLocalFileReference file(filename);\n-\tSDL_RWops *src = SDL_RWFromFile(file.getFilename().c_str(), \"rb\");\n+\tFile file(filename);\n+\tSDL_RWops *src = SDL_RWFromConstMem(file.mmap(), file.getSize());\n \tif (!src) {\n-\t\tthrow MSXException(\"Could not open image file \\\"\" + filename + \"\\\"\");\n+\t\tthrow MSXException(\n+\t\t\t\"Failed to create SDL_RWops for mmapped file \\\"\" + filename + \"\\\"\"\n+\t\t\t);\n \t}\n \tSDL_Surface* result = IMG_LoadPNG_RW(src);\n \tSDL_RWclose(src);\n", "fix_pattern": "<pattern>: if a file is opened with SDL_RWFromFile for reading, replace it with SDL_RWFromConstMem which utilizes memory mapping for potentially better performance, especially for large files."}
{"number": 416, "change": "@@ -691,7 +691,7 @@ QString QSystemLocalePrivate::winToQtFormat(const QString &sys_fmt)\n             if (text == QLatin1String(\"'\"))\n                 result += QLatin1String(\"''\");\n             else\n-                result += QString(QLatin1Char('\\'') + text + QLatin1Char('\\''));\n+                result += QLatin1Char('\\'') + text + QLatin1Char('\\'');\n             continue;\n         }\n \n", "fix_pattern": "<pattern>: if a QString is appended with multiple concatenations involving QLatin1Char, refactor the code to eliminate the redundant use of QString's operator by combining the operations into a single expression, resulting in improved performance by reducing overhead."}
{"number": 417, "change": "@@ -110,7 +110,7 @@ int QCollator::compare(const QChar *s1, int len1, const QChar *s2, int len2) con\n     if (d->collator)\n         return ucol_strcoll(d->collator, (const UChar *)s1, len1, (const UChar *)s2, len2);\n \n-    return QString::compare(QString(s1, len1), QString(s2, len2), d->caseSensitivity);\n+    return QString::compare_helper(s1, len1, s2, len2, d->caseSensitivity);\n }\n \n int QCollator::compare(const QString &s1, const QString &s2) const\n", "fix_pattern": "<pattern>: if an API method (QString::compare) is potentially less efficient than a specialized helper (QString::compare_helper), replace calls to the less efficient method with the specialized helper to improve performance."}
{"number": 427, "change": "@@ -72,7 +72,7 @@ QString QTlsBackendOpenSSL::getErrorsFromOpenSsl()\n         if (!errorString.isEmpty())\n             errorString.append(\", \"_L1);\n         q_ERR_error_string_n(errNum, buf, sizeof buf);\n-        errorString.append(QString::fromLatin1(buf)); // error is ascii according to man ERR_error_string\n+        errorString.append(QLatin1StringView(buf)); // error is ascii according to man ERR_error_string\n     }\n     return errorString;\n }\n", "fix_pattern": "<pattern>: if QString::fromLatin1 is used to convert a Latin1 encoded string, replace it with QLatin1StringView to avoid unnecessary QString creation and improve performance, as QLatin1StringView provides a lightweight non-owning view of the string."}
{"number": 430, "change": "@@ -606,9 +606,8 @@ QByteArray qCompress(const uchar* data, qsizetype nbytes, int compressionLevel)\n             qToBigEndian(CompressSizeHint_t(nbytes), bazip.data());\n             break;\n         case Z_MEM_ERROR:\n-            qWarning(\"qCompress: Z_MEM_ERROR: Not enough memory\");\n-            bazip.resize(0);\n-            break;\n+            return tooMuchData(ZLibOp::Compression);\n+\n         case Z_BUF_ERROR:\n             len *= 2;\n             break;\n", "fix_pattern": "<pattern>: if there is a scenario where qWarning is called due to insufficient memory and the subsequent action is to resize a QByteArray to 0, replace it with an early return that indicates the error condition, thus avoiding unnecessary operations related to resizing the QByteArray and improving performance by reducing function overhead."}
{"number": 438, "change": "@@ -74,15 +74,13 @@ void MatrixFreePDE<dim,degree>::getIntegralMF(const MatrixFree<dim,double> &data\n \n         unsigned int num_q_points = var.n_q_points;\n \n-\t\tdealii::AlignedVector<dealii::VectorizedArray<double> > JxW(num_q_points);\n-\t\tvar.fill_JxW_values(JxW);\n-\n         //loop over quadrature points\n         for (unsigned int q=0; q<num_q_points; ++q){\n \t\t\tdealii::VectorizedArray<double> val = var.get_value(q);\n+\t\t\tdealii::VectorizedArray<double> jxw = var.JxW(q);\n \t\t\tassembler_lock.lock ();\n-\t\t\tfor (unsigned i=0; i<val.n_array_elements;i++){\n-\t\t\t\tintegrated_var += val[i]*JxW[q][i];\n+\t\t\tfor (unsigned i=0; i<val.size();i++){\n+\t\t\t\tintegrated_var += val[i]*jxw[i];\n \t\t\t}\n \t\t\tassembler_lock.unlock ();\n         }\n", "fix_pattern": "<pattern>: if the code directly fills a buffer for JxW values and then accesses it in a loop, replace the buffer fill with a direct access from the method returning the value for the specific quadrature point, thus avoiding unnecessary memory allocation and copying."}
{"number": 440, "change": "@@ -3521,7 +3521,7 @@ void QQuickWindow::setColor(const QColor &color)\n     }\n     d->clearColor = color;\n     emit colorChanged(color);\n-    d->dirtyItem(contentItem());\n+    update();\n }\n \n QColor QQuickWindow::color() const\n", "fix_pattern": "<pattern>: if a call to `dirtyItem(contentItem())` is replaced with a call to `update()`, use `update()` directly to refresh the entire window instead of marking a specific item as dirty, potentially avoiding unnecessary updates and improving overall performance."}
{"number": 447, "change": "@@ -177,7 +177,9 @@ void ServerLobby::initDatabase()\n     m_ip_geolocation_table_exists = false;\n     if (!ServerConfig::m_sql_management)\n         return;\n-    int ret = sqlite3_open(ServerConfig::m_database_file.c_str(), &m_db);\n+    int ret = sqlite3_open_v2(ServerConfig::m_database_file.c_str(), &m_db,\n+        SQLITE_OPEN_SHAREDCACHE | SQLITE_OPEN_FULLMUTEX |\n+        SQLITE_OPEN_READWRITE, NULL);\n     if (ret != SQLITE_OK)\n     {\n         Log::error(\"ServerLobby\", \"Cannot open database: %s.\",\n", "fix_pattern": "<pattern>: if a database connection is being opened with sqlite3_open, consider using sqlite3_open_v2 with appropriate flags to enable shared cache and full mutex support for improved performance and better concurrency control."}
{"number": 452, "change": "@@ -1,6 +1,6 @@\n \n /*\n- * $Id: HttpReply.cc,v 1.93 2007/05/18 06:41:22 amosjeffries Exp $\n+ * $Id: HttpReply.cc,v 1.94 2007/05/22 16:37:26 rousskov Exp $\n  *\n  * DEBUG: section 58    HTTP Reply (Response)\n  * AUTHOR: Alex Rousskov\n@@ -433,7 +433,7 @@ HttpReply::bodySize(method_t method) const\n \n bool HttpReply::sanityCheckStartLine(MemBuf *buf, http_status *error)\n {\n-    if (buf->contentSize() >= protoPrefix.size() && strncmp(protoPrefix, buf->content(), protoPrefix.size()) != 0) {\n+    if (buf->contentSize() >= protoPrefix.size() && protoPrefix.compare(buf->content(), protoPrefix.size()) != 0) {\n         debugs(58, 3, \"HttpReply::sanityCheckStartLine: missing protocol prefix (\" << protoPrefix << \") in '\" << buf->content() << \"'\");\n         *error = HTTP_INVALID_HEADER;\n         return false;\n", "fix_pattern": "<pattern>: if a comparison is performed between a C-style string using `strncmp`, replace it with the corresponding `std::string::compare` method for improved safety and potential performance, as it utilizes STL optimizations."}
{"number": 454, "change": "@@ -89,9 +89,9 @@ ACLMethodData::parse()\n \n     for (Tail = &values; *Tail; Tail = &((*Tail)->next));\n     while ((t = strtokFile())) {\n-        if (strcmp(t, \"PURGE\") == 0)\n-            ++ThePurgeCount; // configuration code wants to know\n         CbDataList<HttpRequestMethod> *q = new CbDataList<HttpRequestMethod> (HttpRequestMethod(t, NULL));\n+        if (q->element == Http::METHOD_PURGE)\n+            ++ThePurgeCount; // configuration code wants to know\n         *(Tail) = q;\n         Tail = &q->next;\n     }\n", "fix_pattern": "<pattern>: if comparing strings with `strcmp` for specific known constants, replace it with a direct comparison against enum values or constants for better readability and potential performance improvement."}
{"number": 456, "change": "@@ -36,8 +36,6 @@ inline uint32_t bitmask32(size_t bottom_bits) {\n class address_encryptor {\n public:\n   explicit address_encryptor(const std::array<address::byte_type, 32>& key) {\n-    EVP_CIPHER_CTX_init(ctx_.get());\n-    OpenSSL_add_all_ciphers();\n     cipher_ = EVP_get_cipherbyname(\"aes-128-ecb\");\n     block_size_ = EVP_CIPHER_block_size(cipher_);\n     pad_ = std::vector<address::byte_type>(block_size_);\n", "fix_pattern": "<pattern>: if EVP_CIPHER_CTX_init is called for initialization and OpenSSL_add_all_ciphers is called to register ciphers, consider that these initialization functions may be called multiple times in a program. Instead, initialize ctx_ once during application startup or before first use, and ensure OpenSSL_add_all_ciphers is invoked only once to reduce overhead."}
{"number": 459, "change": "@@ -8,11 +8,13 @@\n \n #include <vector>\n \n+#include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n-#include <boost/thread.hpp>\n \n #include \"ITMImagePtrTypes.h\"\n \n+#include \"tvgutil/misc/ThreadPool.h\"\n+\n namespace spaint {\n \n /**\n@@ -93,8 +95,7 @@ public:\n   static void save_image_on_thread(const boost::shared_ptr<const ORUtils::Image<T> >& image, const std::string& path, ImageFileType fileType = IFT_UNKNOWN)\n   {\n     void (*p)(const boost::shared_ptr<const ORUtils::Image<T> >&, const std::string&, ImageFileType) = &save_image;\n-    boost::thread t(p, image, path, fileType);\n-    t.detach();\n+    tvgutil::ThreadPool::instance().start_asynch(boost::bind(p, image, path, fileType));\n   }\n \n   /**\n", "fix_pattern": "<pattern>: if a thread is created and detached using boost::thread, replace it with a ThreadPool implementation to manage threads more efficiently and reduce overhead from thread creation."}
{"number": 474, "change": "@@ -220,7 +220,7 @@ void PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)\n                 // Rotate to highest position, so it can be lopped\n                 // by decrementing e_phnum.\n                 memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));\n-                memcpy(phdr, 1+phdr, j * sizeof(*phdr));\n+                memmove(phdr, 1+phdr, j * sizeof(*phdr));  // overlapping\n                 memcpy(&phdr[j], (unsigned char *)ibuf, sizeof(*phdr));\n                 --phdr;\n                 set_te16(&ehdri.e_phnum, --e_phnum);\n", "fix_pattern": "<pattern>: if a memory copy operation involves overlapping regions, replace memcpy with memmove to ensure correct behavior and avoid potential data corruption."}
{"number": 475, "change": "@@ -379,7 +379,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n     model->materials[i].specular[2] = 0.0f;\n     model->materials[i].specular[3] = 1.0f;\n   }\n-  model->materials[0].name = strdup(\"default\");\n+  model->materials[0].name = std::string(\"default\");\n \n   /* now, read in the data */\n   nummaterials = 0;\n@@ -397,7 +397,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n       }\n       sscanf(buf, \"%s %s\", buf, buf);\n       nummaterials++;\n-      model->materials[nummaterials].name = strdup(buf);\n+      model->materials[nummaterials].name = std::string(buf);\n       break;\n     case 'N':\n       fscanf(file, \"%f\", &model->materials[nummaterials].shininess);\n", "fix_pattern": "<pattern>: if the API is using strdup to allocate strings, replace it with std::string to manage memory automatically and improve performance by eliminating unnecessary memory allocation and deallocation."}
{"number": 476, "change": "@@ -52,7 +52,6 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   int rowSize = ((3*imageW + 3) >> 2) << 2;      // how many bytes in the row (used to create padding)\n   //unsigned long fileSize = 2ul * imageH * imageW + 54; // pix data + 54 byte hdr\n   int fileSize = 54 + imageH*rowSize;        // headers (54 bytes) + pixel data\n-  memset(&rgbBuffer[rowSize - 4], 0, 4);\n \n   bmFlHdr[ 2] = (unsigned char)(fileSize      ); // all ints stored little-endian\n   bmFlHdr[ 3] = (unsigned char)(fileSize >>  8); // i.e., LSB first\n@@ -80,6 +79,9 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   outFile.write(bmInHdr, sizeof(bmInHdr));\n \n   uint8_t* buf = (uint8_t*)rgbBuffer;\n+\n+  // set zero to padding area\n+  memset(&buf[rowSize - 4], 0, 4);\n   for ( int i = imageH - 1; i >= 0; i-- ) {\n     _tft->readRectRGB( 0, i, imageW, 1, rgbBuffer ); // capture a whole line\n     int j = 0;\n", "fix_pattern": "<pattern>: the code removes unnecessary comments and maintains the use of `memset` to set a padding area to zero, which is already an efficient operation. There's no significant performance enhancement or refactoring taking place; thus, the pattern simply reflects the operation of zeroing out a memory region using `memset`."}
{"number": 482, "change": "@@ -189,8 +189,8 @@ void map_horizon::upload()\n \n void map_horizon::upload_minimap()\n {\n-  uint32_t texture[1024][1024];\n-  memset(texture, 0, 1024 * 1024 * sizeof(uint32_t));\n+  std::vector<uint32_t> texture(1024 * 1024);\n+  memset(texture.data(), 0, 1024 * 1024 * sizeof(uint32_t));\n \n   for (size_t y (0); y < 64; ++y)\n   {\n@@ -209,14 +209,14 @@ void map_horizon::upload_minimap()\n       {\n         for (size_t i (0); i < 16; ++i)\n         {\n-          texture[y * 16 + j][x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n+          texture[(y * 16 + j) * 1024 + x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n         }\n       }\n     }\n   }\n \n   minimap.bind();\n-  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture);\n+  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.data());\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n", "fix_pattern": "<pattern>: if a fixed-size array is allocated on the stack for a texture, replace it with a std::vector to take advantage of dynamic memory management and ensure better flexibility; also adjust indexing for one-dimensional access using a calculated index based on width."}
{"number": 494, "change": "@@ -32,12 +32,14 @@\n #include <mutex>\n #include <thread>\n \n+#include <android-base/chrono_utils.h>\n #include <android-base/file.h>\n #include <android-base/logging.h>\n #include <android-base/properties.h>\n #include <android-base/stringprintf.h>\n \n using android::base::StringPrintf;\n+using android::base::boot_clock;\n using namespace std::chrono_literals;\n \n namespace android {\n@@ -50,9 +52,9 @@ static std::condition_variable g_bootcharting_finished_cv;\n static bool g_bootcharting_finished;\n \n static long long get_uptime_jiffies() {\n-  std::string uptime;\n-  if (!android::base::ReadFileToString(\"/proc/uptime\", &uptime)) return 0;\n-  return 100LL * strtod(uptime.c_str(), NULL);\n+    constexpr int64_t kNanosecondsPerJiffy = 10000000;\n+    boot_clock::time_point uptime = boot_clock::now();\n+    return uptime.time_since_epoch().count() / kNanosecondsPerJiffy;\n }\n \n static std::unique_ptr<FILE, decltype(&fclose)> fopen_unique(const char* filename,\n", "fix_pattern": "<pattern>: if reading from a file using ReadFileToString incurs file I/O overhead, replace it with a high-resolution clock implementation (like boot_clock) to retrieve uptime directly without file access, significantly improving performance."}
{"number": 505, "change": "@@ -416,7 +416,7 @@ void BtLocalDevice::connectToServiceViaSearch()\n                 socket->setPreferredSecurityFlags(securityFlags);\n \n             QBluetoothServiceInfo info = foundTestServers.at(0);\n-            socket->connectToService(info.device().address(), QBluetoothUuid(QString(TEST_SERVICE_UUID)));\n+            socket->connectToService(info);\n         } else {\n             qWarning() << \"Perform search for test service before triggering this function\";\n         }\n", "fix_pattern": "<pattern>: if the API method connects to a Bluetooth service using a separate address and UUID, consolidate the parameters into a single `QBluetoothServiceInfo` object to streamline the connection process and improve performance by reducing function calls."}
{"number": 508, "change": "@@ -19,6 +19,7 @@\n #include <sys/un.h>\n #include <event.h>\n #include <stdlib.h>\n+#include <sys/socket.h>\n \n struct delegate_info {\n     const char *helper;\n@@ -58,7 +59,7 @@ delegate_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle delegate process: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a blocking read operation is replaced with a non-blocking receive operation using `recv` with the `MSG_DONTWAIT` flag to improve responsiveness and potentially avoid blocking on socket reads."}
{"number": 509, "change": "@@ -19,6 +19,7 @@\n #include <string.h>\n #include <unistd.h>\n #include <sys/un.h>\n+#include <sys/socket.h>\n #include <event.h>\n \n struct tcp_stock_connection {\n@@ -84,7 +85,7 @@ tcp_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle TCP connection: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a direct read operation is used to read data from a socket, replace it with the recv function and make use of flags like MSG_DONTWAIT to improve responsiveness by handling non-blocking I/O."}
{"number": 513, "change": "@@ -46,7 +46,6 @@\n #include \"istream/istream.hxx\"\n #include \"istream/istream_cat.hxx\"\n #include \"istream/DelayedIstream.hxx\"\n-#include \"istream/istream_hold.hxx\"\n #include \"istream/istream_iconv.hxx\"\n #include \"istream/istream_null.hxx\"\n #include \"istream/istream_pause.hxx\"\n@@ -369,12 +368,12 @@ embed_inline_widget(struct pool &pool, struct processor_env &env,\n     auto iw = NewFromPool<InlineWidget>(pool, pool, env, plain_text, widget,\n                                         delayed.second);\n \n-    Istream *hold = istream_hold_new(pool, *iw->MakeResponse(std::move(delayed.first)).Steal());\n+    UnusedHoldIstreamPtr hold(pool, iw->MakeResponse(std::move(delayed.first)));\n \n     iw->Start();\n \n     if (pause)\n         pause->Resume();\n \n-    return UnusedIstreamPtr(hold);\n+    return std::move(hold);\n }\n", "fix_pattern": "<pattern>: if an input stream is created and held using a custom function that can introduce overhead, refactor the code to use a smart pointer with move semantics to streamline resource management and improve performance."}
{"number": 521, "change": "@@ -101,19 +101,15 @@ extern \"C\" BIRDEE_BINDING_API int RunGenerativeScript(int argc, char** argv)\n \tInitPython();\n \tif (argc>0)\n \t{\n-#ifdef _WIN32\n-\t\tstd::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n-#else\n-\t\tstd::wstring_convert<std::codecvt_utf16<wchar_t>> converter;\n-#endif\n \t\tstd::vector<wchar_t*> wargv(argc);\n \t\tstd::vector<std::wstring> wargv_buf(argc);\n \t\tfor (int i = 0; i < argc; i++)\n \t\t{\n-\t\t\twargv_buf[i] = converter.from_bytes(argv[i]);\n+\t\t\tauto len = strlen(argv[i]) + 1;\n+\t\t\twargv_buf[i] = std::wstring(len, L'\\0');\n+\t\t\tmbstowcs(&wargv_buf[i][0], argv[i], len);\n \t\t\twargv[i] = (wchar_t*)wargv_buf[i].c_str();\n \t\t}\n-\n \t\tPySys_SetArgv(argc, wargv.data());\n \t}\n \ttry\n", "fix_pattern": "<pattern>: if std::wstring_convert with from_bytes is used for character conversion, replace it with mbstowcs for better performance and to remove reliance on a deprecated API. Use a direct allocation for the wstring to avoid additional overhead from the convert function."}
{"number": 524, "change": "@@ -59,9 +59,9 @@ EclipseDebugger::on_connect()\n       __debugger_if->read();\n       char* host = __debugger_if->host();\n       unsigned int port = __debugger_if->port();\n-      std::stringstream command;\n-      command << \"tktools -h \" << host << \" -p \" << port;      \n-      system(command.str().c_str());\n+      std::stringstream portstr;\n+      portstr << port;\n+      execlp(\"tktools\", \"tktools\", \"-h\", host, \"-p\", portstr.str().c_str(), (char *) 0);\n     }\n \n   } catch (Exception &e) {\n", "fix_pattern": "<pattern>: if a system call is utilized to perform shell command execution, replace it with execlp to avoid the overhead of shell interpretation and improve performance."}
{"number": 529, "change": "@@ -496,7 +496,7 @@ QString toString(IconType type)\n         case it_Align_HorizontalDistribute:\n             return QLatin1String(\"distribute-horizontal\");\n         case it_Code_Gen_Wizard:\n-            return QLatin1String(\"hi64-app-umbrello.png\");\n+            return QLatin1String(\"umbrello\");\n         case it_Document_Edit:\n             return QLatin1String(\"document-edit\");\n         case it_ClassOrPackage:\n", "fix_pattern": "<pattern>: if QLatin1String is being used to return fixed string values, refactor to return a more descriptive or meaningful string that reduces overhead or aligns with application requirements based on context."}
{"number": 538, "change": "@@ -242,5 +242,5 @@ QString MakeJob::environmentProfile() const\n \n bool MakeJob::isNMake(const QString& makeBin)\n {\n-    return QFileInfo(makeBin).baseName().toLower() == \"nmake\";\n+    return QFileInfo(makeBin).baseName().compare(QStringLiteral(\"nmake\"), Qt::CaseInsensitive);\n }\n", "fix_pattern": "<pattern>: if the comparison of QStrings involves converting one string to lowercase using toLower(), replace it with QString::compare using Qt::CaseInsensitive for better performance and to avoid unnecessary string manipulation."}
{"number": 540, "change": "@@ -93,10 +93,10 @@ void set_storage_service(http_context& ctx, routes& r) {\n         return ctx.db.local().commitlog()->active_config().commit_log_location;\n     });\n \n-    ss::get_token_endpoint.set(r, [] (const_req req) {\n+    ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n         auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n         std::vector<storage_service_json::mapper> res;\n-        return map_to_key_value(token_to_ep, res);\n+        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if an API method is using a non-movable type (like const_req) as a parameter, change it to a movable type (like std::unique_ptr<request>) to facilitate ownership transfer and improve performance. Additionally, utilize make_ready_future to streamline returns and avoid intermediate copies."}
{"number": 541, "change": "@@ -94,9 +94,12 @@ void set_storage_service(http_context& ctx, routes& r) {\n     });\n \n     ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n-        auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n-        std::vector<storage_service_json::mapper> res;\n-        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n+        return make_ready_future<json::json_return_type>(stream_range_as_array(service::get_local_storage_service().get_token_to_endpoint_map(), [](const auto& i) {\n+            storage_service_json::mapper val;\n+            val.key = boost::lexical_cast<std::string>(i.first);\n+            val.value = boost::lexical_cast<std::string>(i.second);\n+            return val;\n+        }));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if a token-to-endpoint mapping is retrieved from a service and then converted to a vector for further processing, replace this intermediate storage with a more direct approach using stream_range_as_array to apply a transformation on the map directly, reducing memory usage and improving efficiency by avoiding unnecessary vector allocation."}
{"number": 543, "change": "@@ -249,7 +249,7 @@ Common::SeekableReadStream *BaseFileManager::openPkgFile(const Common::String &f\n \tupcName.toUppercase();\n \tCommon::SeekableReadStream *file = nullptr;\n \tchar fileName[MAX_PATH_LENGTH];\n-\tstrcpy(fileName, upcName.c_str());\n+\tCommon::strlcpy(fileName, upcName.c_str(), MAX_PATH_LENGTH);\n \n \t// correct slashes\n \tfor (uint32 i = 0; i < upcName.size(); i++) {\n", "fix_pattern": "<pattern>: if a buffer is copied using strcpy, replace it with a safer and potentially more optimized function like Common::strlcpy to avoid buffer overflows and to handle string length properly."}
{"number": 544, "change": "@@ -3402,11 +3402,11 @@ bool BaseGame::getVersion(byte *verMajor, byte *verMinor, byte *extMajor, byte *\n void BaseGame::setWindowTitle() {\n \tif (_renderer) {\n \t\tchar title[512];\n-\t\tstrcpy(title, _caption[0]);\n+\t\tCommon::strlcpy(title, _caption[0], 512);\n \t\tif (title[0] != '\\0') {\n-\t\t\tstrcat(title, \" - \");\n+\t\t\tCommon::strlcat(title, \" - \", 512);\n \t\t}\n-\t\tstrcat(title, \"WME Lite\");\n+\t\tCommon::strlcat(title, \"WME Lite\", 512);\n \n \n \t\tUtf8String utf8Title;\n", "fix_pattern": "<pattern>: if using strcpy and strcat to manipulate strings, replace them with strlcpy and strlcat for improved safety and to prevent buffer overflows."}
{"number": 546, "change": "@@ -677,10 +677,8 @@ void GraphicManager::drawChar(byte ander, int x, int y, Color color) {\n void GraphicManager::refreshScreen() {\n \t// These cycles are for doubling the screen height.\n \tfor (uint16 y = 0; y < _screen.h / 2; y++) {\n-\t\tfor (uint16 x = 0; x < _screen.w; x++) {\n-\t\t\tfor (int j = 0; j < 2; j++)\n-\t\t\t\t*(byte *)_screen.getBasePtr(x, y * 2 + j) = *(byte *)_surface.getBasePtr(x, y);\n-\t\t}\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2), _surface.getBasePtr(0, y), _screen.w);\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2 + 1), _surface.getBasePtr(0, y), _screen.w);\n \t}\n \t// Now we copy the stretched picture to the screen.\n \tg_system->copyRectToScreen(_screen.getPixels(), _screen.pitch, 0, 0, kScreenWidth, kScreenHeight * 2);\n", "fix_pattern": "<pattern>: if a nested loop is used to copy pixel data from one buffer to another, replace it with memcpy(...) calls to perform the operation in a single API call for better performance."}
{"number": 547, "change": "@@ -239,10 +239,10 @@ int ScummEngine_v72he::setupStringArrayFromString(char *cStr) {\n \n \twriteVar(0, 0);\n \n-\tint len = strlen(cStr);\n+\tint len = strlen(cStr) + 1;\n \tbyte *ptr = defineArray(0, kStringArray, 0, 0, 0, len);\n \tif (ptr != nullptr)\n-\t\tstrcpy((char*)ptr, cStr);\n+\t\tCommon::strlcpy((char*)ptr, cStr, len);\n \n \treturn readVar(0);\n }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with a safer string copy function like Common::strlcpy that also prevents buffer overflows by specifying the size of the destination buffer."}
{"number": 550, "change": "@@ -268,7 +268,7 @@ void Dialogs::scrollModeDialogue() {\n }\n \n void Dialogs::store(byte what, TuneType &played) {\n-\tmemcpy(played, played + 1, sizeof(played) - 1);\n+\tmemmove(played, played + 1, sizeof(played) - 1);\n \tplayed[30] = what;\n }\n \n", "fix_pattern": "<pattern>: if a memory operation is performed that may overlap the source and destination buffers, replace memcpy with memmove to ensure correct behavior and potentially better performance in cases of overlapping memory regions."}
{"number": 554, "change": "@@ -185,10 +185,8 @@ void xbt_ex_setup_backtrace(xbt_ex_t * e)\n       maps_name = bprintf(\"/proc/%d/maps\", (int) getpid());\n       maps = fopen(maps_name, \"r\");\n \n-      sscanf(addrs[i], \"%lx\", &addr);\n-      sprintf(maps_buff, \"%#lx\", addr);\n-\n-      if (strcmp(addrs[i], maps_buff)) {\n+      addr = strtol(addrs[i], &p, 16);\n+      if (*p != '\\0') {\n         XBT_CRITICAL(\"Cannot parse backtrace address '%s' (addr=%#lx)\",\n                   addrs[i], addr);\n       }\n", "fix_pattern": "<pattern>: if a combination of sscanf and sprintf is used for parsing and formatting a hexadecimal value, replace it with a direct conversion using strtol to improve performance and eliminate unnecessary string formatting operations."}
{"number": 562, "change": "@@ -619,7 +619,7 @@ class WatchDog {\n                            timeout_in_milliseconds_/1000));\n       } else if (rc != 0) {\n         std::string message(StringPrintf(\"pthread_cond_timedwait failed: %s\", strerror(rc)));\n-        Fatal(message.c_str());\n+        Fatal(message);\n       }\n     }\n     CHECK_WATCH_DOG_PTHREAD_CALL(pthread_mutex_unlock, (&mutex_), reason);\n", "fix_pattern": "<pattern>: if a function is accepting a std::string but being called with its c_str() method, modify the call to use the std::string directly to avoid the overhead of creating a temporary C-style string."}
{"number": 564, "change": "@@ -31,7 +31,7 @@ class SQLiteConnection {\n          }\n       }\n \n-      if (sqlite3_open(path.c_str(), &_conn) != SQLITE_OK) {\n+      if (sqlite3_open_v2(path.c_str(), &_conn, SQLITE_OPEN_READONLY | SQLITE_OPEN_NOMUTEX, 0) != SQLITE_OK) {\n          BOOST_THROW_EXCEPTION(ConnectionFailedException() << ConnectionError(sqlite3_errmsg(_conn)));\n       }\n \n", "fix_pattern": "<pattern>: if the sqlite3_open function is used for read-only access, replace it with sqlite3_open_v2 using SQLITE_OPEN_READONLY and SQLITE_OPEN_NOMUTEX flags to improve performance by avoiding unnecessary locking mechanisms and ensuring no write operations can occur."}
{"number": 566, "change": "@@ -554,7 +554,7 @@ void rlc_um::reassemble_rx_sdus()\n \n       log->debug(\"Concatenating %d bytes in to current length %d. rx_window remaining bytes=%d, vr_ur_in_rx_sdu=%d, vr_ur=%d, rx_mod=%d, last_mod=%d\\n\",\n         len, rx_sdu->N_bytes, rx_window[vr_ur].buf->N_bytes, vr_ur_in_rx_sdu, vr_ur, cfg.rx_mod, (vr_ur_in_rx_sdu+1)%cfg.rx_mod);\n-      memcpy(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n+      memmove(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n       rx_sdu->N_bytes += len;\n       rx_window[vr_ur].buf->msg += len;\n       rx_window[vr_ur].buf->N_bytes -= len;\n", "fix_pattern": "<pattern>: if the source and destination memory areas may overlap during a memory copy operation, replace memcpy with memmove to ensure the operation is safe and avoid undefined behavior, which can lead to performance issues."}
{"number": 572, "change": "@@ -32,7 +32,7 @@\n \n #define VTK_MYSQL_DEFAULT_PORT 3306\n  \n-vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.22\");\n+vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.23\");\n vtkStandardNewMacro(vtkMySQLDatabase);\n \n // ----------------------------------------------------------------------\n@@ -461,12 +461,14 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n {\n   skipped = false;\n   vtkStdString queryStr = \", \";\n+  bool mustUseName = true;\n \n   int idxType = schema->GetIndexTypeFromHandle( tblHandle, idxHandle );\n   switch ( idxType )\n     {\n     case vtkSQLDatabaseSchema::PRIMARY_KEY:\n       queryStr += \"PRIMARY KEY \";\n+      mustUseName = false;\n       break;\n     case vtkSQLDatabaseSchema::UNIQUE:\n       queryStr += \"UNIQUE \";\n@@ -478,7 +480,11 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n       return vtkStdString();\n     }\n   \n-  queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+  // No index_name for PRIMARY KEYs\n+  if ( mustUseName )\n+    {\n+    queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+    }\n   queryStr += \" (\";\n         \n   // Loop over all column names of the index\n", "fix_pattern": "<pattern>: if the API call for retrieving index names may be unnecessary (specifically for PRIMARY KEYs), refactor the logic to conditionally execute the call only when required, thus potentially reducing redundant computations and avoiding unnecessary string concatenation in the query."}
{"number": 573, "change": "@@ -48,7 +48,7 @@\n #include <vtkstd/set>\n #include <vtkstd/algorithm>\n \n-vtkCxxRevisionMacro(vtkKdTree, \"1.22\");\n+vtkCxxRevisionMacro(vtkKdTree, \"1.23\");\n \n // Timing data ---------------------------------------------\n \n@@ -2280,7 +2280,8 @@ int vtkKdTree::_FindClosestPointInRegion(int regionId,\n \n   float *candidate = this->LocatorPoints + (idx * 3);\n \n-  for (int i=0; i < this->RegionList[regionId]->GetNumberOfPoints(); i++)\n+  int numPoints = this->RegionList[regionId]->GetNumberOfPoints();\n+  for (int i=0; i < numPoints; i++)\n     {\n     double dx = (x - candidate[0]) * (x - candidate[0]);\n \n", "fix_pattern": "<pattern>: if a loop iterates over the result of a method call that can be computed once, store the result in a variable before the loop to avoid repeated calls and improve performance."}
{"number": 575, "change": "@@ -3769,9 +3769,9 @@ BOOL CSoundFile::ReadABC(const uint8_t *lpStream, DWORD dwMemLength)\n \t\t\t\t\t\t\tp[t]='\\0';\n \t\t\t\t\t\tfor( t=2; isspace(p[t]); t++ ) ;\n \t\t\t\t\t\tstrcpy(buf,m_szNames[0]);\n-\t\t\t\t\t\tif( strlen(buf) + strlen(p+t) > 199 ) p[t+199-strlen(buf)] = '\\0'; // chop it of\n \t\t\t\t\t\tif( strlen(buf) ) strcat(buf,\" \"); // add a space\n-\t\t\t\t\t\tstrcat(buf, p+t);\n+\t\t\t\t\t\t// don't go past 200 bytes.\n+\t\t\t\t\t\tstrncat(buf, p+t, 200-strlen(buf)-1);\n \t\t\t\t\t\tif( strlen(buf) > 31 ) buf[31] = '\\0'; // chop it of\n \t\t\t\t\t\tstrcpy(m_szNames[0], buf);\n \t\t\t\t\t\tbreak;\n", "fix_pattern": "<pattern>: if code manually checks buffer length and concatenates two strings using strcat, replace with strncat to ensure that the buffer does not overflow, thus improving safety and potentially performance."}
{"number": 578, "change": "@@ -1295,8 +1295,8 @@ void InstrumentTrackWindow::modelChanged()\n \n \tm_nameLineEdit->setText( m_track->name() );\n \n-\tdisconnect( m_track, SIGNAL( nameChanged() ) );\n-\tdisconnect( m_track, SIGNAL( instrumentChanged() ) );\n+\tm_track->disconnect( SIGNAL( nameChanged() ), this );\n+\tm_track->disconnect( SIGNAL( instrumentChanged() ), this );\n \n \tconnect( m_track, SIGNAL( nameChanged() ),\n \t\t\tthis, SLOT( updateName() ) );\n", "fix_pattern": "<pattern>: if disconnecting signals from a QObject, refactor to use the QObject's instance's disconnect method, which is more efficient and avoids ambiguity."}
{"number": 579, "change": "@@ -35,6 +35,8 @@\n #include <QLineEdit>\n #include <QContextMenuEvent>\n \n+#include <algorithm>\n+\n #include \"qg_blockwidget.h\"\n #include \"rs_blocklist.h\"\n #include \"qg_actionhandler.h\"\n@@ -78,7 +80,7 @@ void QG_BlockModel::setBlockList(RS_BlockList* bl) {\n             listBlock.append(bl->at(i));\n     }\n     setActiveBlock(bl->getActive());\n-    qSort ( listBlock.begin(), listBlock.end(), blockLessThan );\n+    std::sort( listBlock.begin(), listBlock.end(), blockLessThan);\n \n     //called to force redraw\n     endResetModel();\n", "fix_pattern": "<pattern>: if using qSort from the Qt library, replace it with std::sort from the C++ Standard Library for potentially better performance and enhanced optimizations since std::sort is generally more efficient and widely used in modern C++."}
{"number": 581, "change": "@@ -209,7 +209,15 @@ QVector<BuildingGeoPolygonGraphicsItem::NamedEntry> BuildingGeoPolygonGraphicsIt\n \n void BuildingGeoPolygonGraphicsItem::paint(GeoPainter* painter, const ViewportParams* viewport, const QString &layer, int tileZoomLevel)\n {\n-    Q_UNUSED(tileZoomLevel);\n+    // Just display flat buildings for tile level 17\n+    if (tileZoomLevel == 17) {\n+        if (layer.endsWith(QLatin1String(\"/frame\"))) {\n+            AbstractGeoPolygonGraphicsItem::paint(painter, viewport, layer, tileZoomLevel );\n+        }\n+        return;\n+    }\n+\n+    // For level 18, 19 .. render 3D buildings in perspective\n     if (layer.endsWith(QLatin1String(\"/frame\"))) {\n         Q_ASSERT(m_cachedOuterPolygons.isEmpty());\n         Q_ASSERT(m_cachedInnerPolygons.isEmpty());\n", "fix_pattern": "<pattern>: if there is a check for specific conditions based on the input parameters that can potentially skip unnecessary processing or rendering, restructure the code to handle those conditions explicitly before calling potentially expensive API methods like AbstractGeoPolygonGraphicsItem::paint."}
{"number": 583, "change": "@@ -17,6 +17,7 @@\n \n #include \"addresstablemodel.h\"\n #include <QtDebug>\n+#include <algorithm>\n \n AddressTableModel::AddressTableModel(QObject *parent, const list<t_address_card>& data)\n \t: QAbstractTableModel(parent)\n@@ -97,7 +98,7 @@ void AddressTableModel::modifyAddress(int index, const t_address_card& card)\n \n void AddressTableModel::sort(int column, Qt::SortOrder order)\n {\n-\tqSort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n+\tstd::sort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n \t\tbool retval = false;\n \n \t\tswitch (column)\n", "fix_pattern": "<pattern>: if qSort is used to sort a range of elements, replace it with std::sort from the C++ Standard Library, as it generally has better performance characteristics due to its implementation being more modern and typically benefiting from optimizations unavailable in older libraries like Qt's qSort."}
{"number": 584, "change": "@@ -428,9 +428,10 @@ namespace net_utils\n \t\t\t\n \t\t\t\thandler_obj hndlr(ec, bytes_transfered);\n \n-\t\t\t\tchar local_buff[10000] = {0};\n+\t\t\t\tstatic const size_t max_size = 16384;\n+\t\t\t\tbuff.resize(max_size);\n \t\t\t\t\n-\t\t\t\tasync_read(local_buff, sizeof(local_buff), boost::asio::transfer_at_least(1), hndlr);\n+\t\t\t\tasync_read(&buff[0], max_size, boost::asio::transfer_at_least(1), hndlr);\n \n \t\t\t\t// Block until the asynchronous operation has completed.\n \t\t\t\twhile (ec == boost::asio::error::would_block && !boost::interprocess::ipcdetail::atomic_read32(&m_shutdowned))\n@@ -463,7 +464,7 @@ namespace net_utils\n \t\t\t\t\treturn false;*/\n \n \t\t\t\tm_bytes_received += bytes_transfered;\n-\t\t\t\tbuff.assign(local_buff, bytes_transfered);\n+\t\t\t\tbuff.resize(bytes_transfered);\n \t\t\t\treturn true;\n \t\t\t}\n \n", "fix_pattern": "<pattern>: if a local buffer is used to read data and then assigned to a std::string, replace the local buffer with a resize of the std::string to reduce memory copying and potential reallocations; also ensure the async_read function utilizes the string's internal buffer directly for efficiency."}
{"number": 585, "change": "@@ -594,7 +594,7 @@ BOOL SetEndOfFile(HANDLE hFile) {\n }\n \n DWORD SleepEx( DWORD dwMilliseconds,  BOOL bAlertable) {\n-  SDL_Delay(dwMilliseconds);\n+  usleep(dwMilliseconds * 1000);\n   return 0;\n }\n \n", "fix_pattern": "<pattern>: if using SDL_Delay for sleeping, replace it with usleep for potentially finer control over the sleep duration since usleep provides microsecond resolution compared to SDL_Delay's millisecond resolution."}
{"number": 587, "change": "@@ -155,7 +155,7 @@ void *CAudioDecoder::GetData(unsigned int size)\n   if (m_gaplessBufferSize > size)\n   {\n     memcpy(m_outputBuffer, m_gaplessBuffer, size*sizeof(float));\n-    memcpy(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n+    memmove(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n     m_gaplessBufferSize -= size;\n     return m_outputBuffer;\n   }\n", "fix_pattern": "<pattern>: if a buffer may overlap when copying data, replace memcpy(...) with memmove(...) to ensure correct behavior and maintain performance."}
{"number": 589, "change": "@@ -489,10 +489,11 @@ writeable_pgsql_selection::factory::factory(const po::variables_map &opts)\n   // select ways which use nodes already in the working set\n   m_connection.prepare(\"ways_from_nodes\",\n     \"INSERT INTO tmp_ways \"\n-      \"SELECT DISTINCT wn.way_id \"\n+      \"SELECT DISTINCT wn.way_id AS id \"\n         \"FROM current_way_nodes wn \"\n           \"JOIN tmp_nodes tn ON wn.node_id = tn.id \"\n-            \"AND wn.way_id NOT IN (SELECT id FROM tmp_ways)\");\n+          \"LEFT JOIN tmp_ways tw ON wn.way_id = tw.id \"\n+        \"WHERE tw.id IS NULL\");\n   // select nodes used by ways already in the working set\n   m_connection.prepare(\"nodes_from_way_nodes\",\n     \"INSERT INTO tmp_nodes \"\n", "fix_pattern": "<pattern>: if a query uses a subquery with NOT IN which can be inefficient, refactor the query to use a LEFT JOIN with a WHERE clause for better performance in filtering data from related tables."}
{"number": 590, "change": "@@ -496,9 +496,8 @@ NAN_METHOD(Driver::open) {\n #endif\n \n   GDALDriver *raw = driver->getGDALDriver();\n-  GDALOpenInfo *open_info = new GDALOpenInfo(path.c_str(), access);\n-  GDALDataset *ds = raw->pfnOpen(open_info);\n-  delete open_info;\n+  const char *driver_list[2] = {raw->GetDescription(), nullptr};\n+  GDALDataset *ds = (GDALDataset *)GDALOpenEx(path.c_str(), access, driver_list, NULL, NULL);\n   if (!ds) {\n     Nan::ThrowError(\"Error opening dataset\");\n     return;\n", "fix_pattern": "<pattern>: if a GDAL dataset is opened using the older GDALOpenInfo method that involves manual memory management, refactor the code to use GDALOpenEx which simplifies the process and potentially improves performance by avoiding the need to create and delete a GDALOpenInfo object."}
{"number": 593, "change": "@@ -51,8 +51,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tif (!string)\n \t\treturn;\n \t\n-\tchar *workstr = new char[strlen(string) + 1];\n-\tstrcpy(workstr, string);\n+\tchar *workstr = strdup(string);\n \tstrtok(workstr, \"\\n\");\n \t\n \tchar *token = strtok(NULL,\"\\n\");\n@@ -60,7 +59,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \t\n \tif (!token)\n \t{\n-\t\tdelete [] workstr;\n+\t\tfree(workstr);\n \t\tstringList.AddItem(new BString(string));\n \t\treturn;\n \t}\n@@ -84,7 +83,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tlasttoken = token;\n \tstringList.AddItem(newword);\n \t\t\n-\tdelete [] workstr;\n+\tfree(workstr);\n }\n \n \n", "fix_pattern": "<pattern>: when dynamically allocating a string and then copying its contents, replace the manual allocation and copy with strdup, which performs both operations in one call and simplifies the code; also, ensure to call free only once on the allocated memory."}
{"number": 595, "change": "@@ -244,7 +244,7 @@ void* VideoScaler::Run(void* pArgs)\n     int tOutputBufferSize = avpicture_get_size(mTargetPixelFormat, mTargetResX, mTargetResY) + FF_INPUT_BUFFER_PADDING_SIZE;\n \n     // allocate chunk buffer\n-    tOutputBuffer = (uint8_t*)malloc(tOutputBufferSize);\n+    tOutputBuffer = (uint8_t*)av_malloc(tOutputBufferSize);\n \n     // Allocate video frame\n     LOG(LOG_VERBOSE, \"..allocating memory for output frame\");\n", "fix_pattern": "<pattern>: if memory allocation is done using malloc, switch to av_malloc from the FFmpeg library for optimized memory handling within FFmpeg's context."}
{"number": 598, "change": "@@ -77,12 +77,11 @@ MountIsoAction::MountIsoAction(QObject *parent, const QVariantList &)\n const Solid::Device getDeviceFromBackingFile(const QString &backingFile)\n {\n     const QList<Solid::Device> blockDevices =\n-        Solid::Device::listFromQuery(\"[ IS Block AND IS GenericInterface ]\");\n+        Solid::Device::listFromQuery(\"[ IS StorageAccess AND IS GenericInterface ]\");\n \n     for (const Solid::Device &device : blockDevices) {\n-        QMap<QString, QVariant> properties = device.as<Solid::GenericInterface>()->allProperties();\n-        if (properties.contains(\"BackingFile\")\n-            && backingFile == properties[\"BackingFile\"].value<QString>()) {\n+        auto genericDevice = device.as<Solid::GenericInterface>();\n+        if (backingFile == genericDevice->property(QStringLiteral(\"BackingFile\")).toString()) {\n             return device;\n         }\n     }\n", "fix_pattern": "<pattern>: if using Solid::GenericInterface's allProperties() method to retrieve properties and then checking for a specific key on QMap, optimize by directly accessing the property via the property() method instead. This reduces the overhead of retrieving all properties when only one is needed. Additionally, ensure that the query to list devices is also contextually relevant for performance improvements."}
{"number": 602, "change": "@@ -674,22 +674,21 @@ CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {\n }\n \n namespace {\n-// SecureBuffer uses openssl to allocate a Uint8Array using\n-// OPENSSL_secure_malloc. Because we do not yet actually\n-// make use of secure heap, this has the same semantics as\n+// SecureBuffer uses OPENSSL_secure_malloc to allocate a Uint8Array.\n+// Without --secure-heap, OpenSSL's secure heap is disabled,\n+// in which case this has the same semantics as\n // using OPENSSL_malloc. However, if the secure heap is\n // initialized, SecureBuffer will automatically use it.\n void SecureBuffer(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsUint32());\n   Environment* env = Environment::GetCurrent(args);\n   uint32_t len = args[0].As<Uint32>()->Value();\n-  char* data = static_cast<char*>(OPENSSL_secure_malloc(len));\n+  void* data = OPENSSL_secure_zalloc(len);\n   if (data == nullptr) {\n     // There's no memory available for the allocation.\n     // Return nothing.\n     return;\n   }\n-  memset(data, 0, len);\n   std::shared_ptr<BackingStore> store =\n       ArrayBuffer::NewBackingStore(\n           data,\n", "fix_pattern": "<pattern>: if memory is allocated using OPENSSL_secure_malloc followed by a memset to zero out the allocated memory, replace it with OPENSSL_secure_zalloc, which allocates and initializes the memory to zero in a single call for improved performance."}
{"number": 606, "change": "@@ -434,9 +434,7 @@ void Renderer::executeCommands(const QVector<RenderCommand *> commands)\n \n     Q_FOREACH (RenderCommand *command, commands) {\n \n-        QMutexLocker locker(&m_mutex);\n         MeshData *meshData = m_meshDataManager->data(command->m_meshData);\n-        locker.unlock();\n         if (meshData == Q_NULLPTR || meshData->attributeNames().empty()) {\n             qCWarning(Rendering) << \"RenderCommand should have a mesh\";\n             continue ;\n", "fix_pattern": "<pattern>: if a mutex locker is constructed and immediately unlocked without being used to guard a critical section, remove the unnecessary QMutexLocker instantiation to improve performance."}
{"number": 607, "change": "@@ -686,7 +686,7 @@ GraphicsHelperInterface *GraphicsContext::resolveHighestOpenGLFunctions()\n             if (m_debugLogger->initialize()) {\n                 QObject::connect(m_debugLogger.data(), &QOpenGLDebugLogger::messageLogged, &logOpenGLDebugMessage);\n                 const QString mode = QString::fromLocal8Bit(debugLoggingMode);\n-                m_debugLogger->startLogging(mode.toLower().startsWith(QLatin1String(\"sync\"))\n+                m_debugLogger->startLogging(mode.startsWith(QLatin1String(\"sync\"), Qt::CaseInsensitive)\n                                             ? QOpenGLDebugLogger::SynchronousLogging\n                                             : QOpenGLDebugLogger::AsynchronousLogging);\n \n", "fix_pattern": "<pattern>: if the method QString::toLower() is used before checking if it starts with a certain substring, replace it with startsWith() using the Qt::CaseInsensitive option to avoid the overhead of converting the entire string to lowercase."}
{"number": 610, "change": "@@ -68,7 +68,7 @@ Node& CDirAdditionalPropertiesDlg::MakeNode(Node& parentNode, const std::vector<\n \t++it;\n \tif (it != path.end())\n \t{\n-\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name.c_str())).c_str(), parentNode.hItem);\n+\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name)).c_str(), parentNode.hItem);\n \t\treturn MakeNode(node, path, it);\n \t}\n \tnode.canonicalName = strutils::join(path.begin(), path.end(), _T(\".\"));\n", "fix_pattern": "<pattern>: if a function is called on a string (like c_str()) that's unnecessary for the operation, replace it with direct usage of the string object to reduce overhead and improve clarity."}
{"number": 613, "change": "@@ -679,10 +679,18 @@ void write_sparse_samples(const MPI_Comm comm, const string& filename, accumulat\n     index += sizeof(s.wins);\n   }\n \n+  // Compute offsets.  MPI_File_write_ordered would do this for us, but MPI_File_write_ordered\n+  // is completely broken performance-wise.\n+  uint64_t offset = 0;\n+  {\n+    uint64_t buffer_size = buffer.size();\n+    CHECK(MPI_Exscan(&buffer_size,&offset,1,datatype<uint64_t>(),MPI_SUM,comm));\n+  }\n+\n   // Write the file\n   MPI_File file;\n   file_open(comm,filename,&file);\n-  CHECK(MPI_File_write_ordered(file,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+  CHECK(MPI_File_write_at_all(file,offset,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n   CHECK(MPI_File_close(&file));\n }\n \n", "fix_pattern": "<pattern>: if the code is using MPI_File_write_ordered, which is known to have performance issues, replace it with an MPI_File_write_at_all call that computes offsets manually using an MPI_Exscan to optimize performance for collective writes."}
{"number": 616, "change": "@@ -223,9 +223,8 @@ JNIEXPORT jbyteArray JNICALL Java_org_tensorflow_Session_run(\n   jbyteArray ret = nullptr;\n   if (run_metadata != nullptr) {\n     ret = env->NewByteArray(run_metadata->length);\n-    jbyte* elems = env->GetByteArrayElements(ret, nullptr);\n-    memcpy(elems, run_metadata->data, run_metadata->length);\n-    env->ReleaseByteArrayElements(ret, elems, JNI_COMMIT);\n+    env->SetByteArrayRegion(ret, 0, run_metadata->length,\n+                            reinterpret_cast<const jbyte*>(run_metadata->data));\n   }\n   TF_DeleteStatus(status);\n   return ret;\n", "fix_pattern": "<pattern>: if GetByteArrayElements is used to obtain a pointer for memcpy followed by ReleaseByteArrayElements, replace the sequence with SetByteArrayRegion to directly copy data into the Java byte array, improving performance by avoiding unnecessary memory management overhead."}
{"number": 619, "change": "@@ -92,7 +92,11 @@ void StringReader(png_structp png_ptr, png_bytep data, png_size_t length) {\n   DecodeContext* const ctx =\n       absl::bit_cast<DecodeContext*>(png_get_io_ptr(png_ptr));\n   if (static_cast<png_size_t>(ctx->data_left) < length) {\n-    memset(data, 0, length);\n+    // Don't zero out the data buffer as it has been lazily allocated (copy on\n+    // write) and zeroing it out here can produce an OOM. Since the buffer is\n+    // only used for reading data from the image, this doesn't result in any\n+    // data leak, so it is safe to just leave the buffer be as it is and just\n+    // exit with error.\n     png_error(png_ptr, \"More bytes requested to read than available\");\n   } else {\n     memcpy(data, ctx->data, length);\n", "fix_pattern": "<pattern>: if a buffer has been lazily allocated with copy-on-write semantics and is only used for reading, avoid unnecessary zeroing out of the buffer to prevent potential out-of-memory errors (OOM) and improve performance by bypassing the memset call."}
{"number": 624, "change": "@@ -31,6 +31,7 @@\n #include <boost/intrusive_ptr.hpp>\n \n #include \"mongo/platform/atomic_word.h\"\n+#include \"mongo/util/allocator.h\"\n \n namespace mongo {\n \n@@ -56,7 +57,7 @@ public:\n     }\n \n     static SharedBuffer allocate(size_t bytes) {\n-        return takeOwnership(static_cast<char*>(malloc(sizeof(Holder) + bytes)));\n+        return takeOwnership(static_cast<char*>(mongoMalloc(sizeof(Holder) + bytes)));\n     }\n \n     /**\n", "fix_pattern": "<pattern>: if a memory allocation is performed using malloc from Standard C, replace it with mongoMalloc from the MongoDB Project to potentially benefit from custom memory management optimizations specific to that library."}
{"number": 630, "change": "@@ -29,7 +29,7 @@ void RageSound_Null::MixerThread()\n {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \n \t/* not sure if a nansleep is needed, but certainly helps\n \t * when there is LOG->Trace in GetData() */\n", "fix_pattern": "<pattern>: if a loop is detected that uses sleep from the Standard C++ library, replace it with SDL_Delay from the SDL library for potentially better performance and responsiveness in a multimedia context."}
{"number": 631, "change": "@@ -265,7 +265,7 @@ int RageSound_Linux::MixerThread_start(void *p) {\n void RageSound_Linux::MixerThread() {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \twhile(!shutdown) { while (GetData()); }\n }\n \t\n", "fix_pattern": "<pattern>: if using a sleep function in a busy-wait loop, replace it with a library-specific delay function (like SDL_Delay) to improve performance and avoid unnecessary CPU usage."}
{"number": 632, "change": "@@ -73,7 +73,7 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n \n   /* I don't like this but I can't think of another place to put it. */\n   while (!SOUNDMAN)\n-    sleep(10);\n+    SDL_Delay(10);\n   \n   for (unsigned i = 0; i < P->sounds.size(); ++i) {\n     if (P->sounds[i]->stopping)\n@@ -88,6 +88,8 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n     }\n   }\n \n+  mix.read(buf); \n+\n   memcpy(stream, buf, len);\n   P->last_cursor_pos += buffersize_frames;\n }\n", "fix_pattern": "<pattern>: if a call to sleep is made using a standard C++ sleep function, replace it with a platform-specific equivalent like SDL_Delay for improved performance in scenarios involving multimedia applications or game development where frame timing is critical."}
{"number": 639, "change": "@@ -34,8 +34,8 @@ screen_status_printf(const char *format, ...)\n {\n \tva_list ap;\n \tva_start(ap,format);\n-\tchar *msg = g_strdup_vprintf(format,ap);\n+\tchar msg[256];\n+\tvsnprintf(msg, sizeof(msg), format, ap);\n \tva_end(ap);\n \tscreen_status_message(msg);\n-\tg_free(msg);\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation is being used to create a formatted string with g_strdup_vprintf followed by g_free, refactor the code to use a stack-allocated buffer with vsnprintf to avoid the overhead of heap allocation and deallocation."}
{"number": 648, "change": "@@ -145,8 +145,8 @@ void QWaylandSurfaceItem::init(QWaylandSurface *surface)\n     setAcceptHoverEvents(true);\n     connect(surface, SIGNAL(mapped()), this, SLOT(surfaceMapped()));\n     connect(surface, SIGNAL(unmapped()), this, SLOT(surfaceUnmapped()));\n-    connect(surface, SIGNAL(destroyed(QObject *)), this, SLOT(surfaceDestroyed(QObject *)));\n-    connect(surface, SIGNAL(damaged(const QRect &)), this, SLOT(surfaceDamaged(const QRect &)));\n+    connect(surface, SIGNAL(destroyed(QObject*)), this, SLOT(surfaceDestroyed(QObject*)));\n+    connect(surface, SIGNAL(damaged(QRect)), this, SLOT(surfaceDamaged(QRect)));\n     connect(surface, SIGNAL(parentChanged(QWaylandSurface*,QWaylandSurface*)),\n             this, SLOT(parentChanged(QWaylandSurface*,QWaylandSurface*)));\n     connect(surface, SIGNAL(sizeChanged()), this, SLOT(updateSize()));\n", "fix_pattern": "<pattern>: if a signal is connected to a slot, and the signal parameter type is modified from a reference type (e.g., const QRect &) to a value type (e.g., QRect), then change the signal's parameter type to the value type to potentially enhance performance by avoiding unnecessary reference copying."}
{"number": 650, "change": "@@ -1712,20 +1712,18 @@ float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {\n static void CreateClusterTree(CLUSTERER *Clusterer) {\n   ClusteringContext context;\n   ClusterPair HeapEntry;\n-  TEMPCLUSTER *PotentialCluster;\n \n   // each sample and its nearest neighbor form a \"potential\" cluster\n   // save these in a heap with the \"best\" potential clusters on top\n   context.tree = Clusterer->KDTree;\n-  context.candidates =\n-      static_cast<TEMPCLUSTER *>(malloc(Clusterer->NumberOfSamples * sizeof(TEMPCLUSTER)));\n+  context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];\n   context.next = 0;\n   context.heap = new ClusterHeap(Clusterer->NumberOfSamples);\n   KDWalk(context.tree, reinterpret_cast<void_proc>(MakePotentialClusters), &context);\n \n   // form potential clusters into actual clusters - always do \"best\" first\n   while (context.heap->Pop(&HeapEntry)) {\n-    PotentialCluster = HeapEntry.data();\n+    TEMPCLUSTER *PotentialCluster = HeapEntry.data();\n \n     // if main cluster of potential cluster is already in another cluster\n     // then we don't need to worry about it\n@@ -1761,7 +1759,7 @@ static void CreateClusterTree(CLUSTERER *Clusterer) {\n   FreeKDTree(context.tree);\n   Clusterer->KDTree = nullptr;\n   delete context.heap;\n-  free(context.candidates);\n+  delete[] context.candidates;\n } // CreateClusterTree\n \n /**\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, switch to using new to allocate memory and delete[] to deallocate it, improving performance and type-safety in C++."}
{"number": 653, "change": "@@ -117,7 +117,14 @@ struct heif_error libde265_new_decoder(void** dec)\n   struct heif_error err = { heif_error_Ok, heif_suberror_Unspecified, kSuccess };\n \n   decoder->ctx = de265_new_decoder();\n-  de265_start_worker_threads(decoder->ctx,1);\n+#if defined(__EMSCRIPTEN__)\n+  // Speed up decoding from JavaScript.\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_DEBLOCKING, 1);\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_SAO, 1);\n+#else\n+  // Worker threads are not supported when running on Emscripten.\n+  de265_start_worker_threads(decoder->ctx, 1);\n+#endif\n \n   *dec = decoder;\n   return err;\n", "fix_pattern": "<pattern>: if the code is running under Emscripten, disable specific decoding parameters to potentially improve performance, otherwise, start worker threads for decoding."}
{"number": 657, "change": "@@ -102,7 +102,7 @@ ffmpeg_mptr::seek_to(int frame)\n \n \t\tstring command;\n \t\t\n-\t\tcommand=strprintf(\"ffmpeg -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",filename.c_str());\n+\t\tcommand=strprintf(\"ffmpeg -ss 00:00:00.%d -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",frame,filename.c_str());\n \t\t\n \t\tfile=popen(command.c_str(),POPEN_BINARY_READ_TYPE);\n \n@@ -133,7 +133,8 @@ ffmpeg_mptr::seek_to(int frame)\n \t\t\t}\n \t\t\t// Close the unneeded pipein\n \t\t\tclose(p[1]);\n-\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n+\t\t\tstring time = strprintf(\"00:00:00.%d\",frame);\n+\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-ss\", time.c_str(), \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n \t\t\t// We should never reach here unless the exec failed\n \t\t\tcerr<<\"Unable to open pipe to ffmpeg\"<<endl;\n \t\t\t_exit(1);\n", "fix_pattern": "<pattern>: if the API call to execlp is made with command-line parameters that do not include a timestamp, enhance the command by adding a timestamp parameter. This adjustment can optimize the ffmpeg processing by enabling seeking to a specific frame in the media input, thereby potentially reducing the processing time."}
{"number": 677, "change": "@@ -57,7 +57,7 @@ AccountOpResult AccountMgr::CreateAccount(std::string username, std::string pass\n \n     if(!loginDatabase.PExecute(\"INSERT INTO account(username,sha_pass_hash,joindate) VALUES('%s',SHA1(CONCAT('%s',':','%s')),NOW())\", username.c_str(), username.c_str(), password.c_str()))\n         return AOR_DB_INTERNAL_ERROR;                       // unexpected error\n-    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM account, realmlist WHERE account.id NOT IN (SELECT acctid FROM realmcharacters)\");\n+    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist,account LEFT JOIN realmcharacters ON acctid=account.id WHERE acctid IS NULL\");\n \n     return AOR_OK;                                          // everything's fine\n }\n", "fix_pattern": "<pattern>: when performing an insert operation that selects from multiple tables, refactor the query to use a LEFT JOIN to prevent inserting duplicate records, optimizing the execution by filtering on NULL values instead of using a subquery."}
{"number": 679, "change": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n \n+#include \"cstring.h\"\n #include \"uni2name.h\"\n #include \"unicode/unifilt.h\"\n #include \"unicode/uchar.h\"\n@@ -93,7 +94,7 @@ void UnicodeNameTransliterator::handleTransliterate(Replaceable& text, UTransPos\n         UChar32 c = text.char32At(cursor);\n         if ((len=u_charName(c, U_UNICODE_CHAR_NAME, buf, sizeof(buf), &status)) <= 0 || U_FAILURE(status)) {\n             sprintf(buf, \"U+%04lX\", c);\n-            len = strlen(buf);\n+            len = uprv_strlen(buf);\n         }\n \n         str.truncate(1);\n", "fix_pattern": "<pattern>: if the standard strlen function is used for measuring string length, replace it with uprv_strlen from the ICU library to leverage potential performance optimizations specific to Unicode string handling."}
{"number": 680, "change": "@@ -449,7 +449,7 @@ static UChar * convertFromUTF8(UChar *outBuf, int32_t outBufCapacity, int32_t *o\n     UChar *dest = outBuf;\n     u_strFromUTF8(dest, outBufCapacity, outputLength, in, inLength, status);\n     if (*status == U_BUFFER_OVERFLOW_ERROR) {\n-        dest = static_cast<UChar *>(malloc(*outputLength * sizeof(UChar)));\n+        dest = static_cast<UChar *>(uprv_malloc(*outputLength * sizeof(UChar)));\n         if (dest == NULL) {\n             *status = U_MEMORY_ALLOCATION_ERROR;\n             return NULL;\n", "fix_pattern": "<pattern>: if a call to malloc from the standard C library is replaced with uprv_malloc from the ICU library, then it likely indicates an improvement in memory management specific to the ICU library, which is optimized for performance and compatibility within its ecosystem."}
{"number": 684, "change": "@@ -120,7 +120,8 @@ void KLoadFileMetaDataThread::run()\n             if (variants.isEmpty()) {\n                 // the file has not been indexed, query the meta data\n                 // directly from the file\n-                KFileMetaInfo metaInfo(urls.first());\n+                const QString path = urls.first().toLocalFile();\n+                KFileMetaInfo metaInfo(path, QString(), KFileMetaInfo::Fastest);\n                 const QHash<QString, KFileMetaInfoItem> metaInfoItems = metaInfo.items();\n                 foreach (const KFileMetaInfoItem& metaInfoItem, metaInfoItems) {\n                     const QString uriString = metaInfoItem.name();\n", "fix_pattern": "<pattern>: if the KFileMetaInfo constructor is called with a QString that can be directly converted to a local file path, replace it with a direct call to toLocalFile() to improve performance by avoiding unnecessary conversions and using the Fastest option for efficiency."}
{"number": 685, "change": "@@ -56,7 +56,8 @@ static QString lookupIconNameFor(const KUrl &url, KUriFilterData::UriTypes type)\n             if (service && service->icon() != QLatin1String( \"unknown\" ))\n                 iconName = service->icon();\n             // Try to find an icon with the same name as the binary (useful for non-kde apps)\n-            else if ( !KIconLoader::global()->loadIcon( exeName, KIconLoader::NoGroup, 16, KIconLoader::DefaultState, QStringList(), 0, true ).isNull() )\n+            // Use iconPath rather than loadIcon() as the latter uses QPixmap (not threadsafe)\n+            else if ( !KIconLoader::global()->iconPath( exeName, KIconLoader::NoGroup, true ).isNull() )\n                 iconName = exeName;\n             else\n                 // not found, use default\n", "fix_pattern": "<pattern>: if an API method loads heavy graphical resources (QPixmap) that may not be thread-safe, replace it with a method that retrieves a path to the resource (iconPath) instead to improve performance and ensure thread safety."}
{"number": 686, "change": "@@ -1442,8 +1442,8 @@ void Applet::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QW\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, \"Wallpaper\");\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, w->pluginName());\n                     w->restore(wallpaperConfig);\n-                    disconnect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n-                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n+                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)),\n+                            Qt::UniqueConnection);\n                 }\n \n                 painter->save();\n", "fix_pattern": "<pattern>: if a disconnect and then immediate reconnect is detected for a Qt signal, use Qt::UniqueConnection in the connect call to avoid redundant signals and improve performance by ensuring the connection is only made if it doesn't already exist."}
{"number": 694, "change": "@@ -278,12 +278,12 @@ zmsg_t *cmb_msg_encode (char *tag, json_object *o)\n \n     if (!(zmsg = zmsg_new ()))\n         err_exit (\"zmsg_new\");\n-    if (zmsg_addstr (zmsg, \"%s\", tag) < 0)\n-        err_exit (\"zmsg_addstr\");\n+    if (zmsg_addmem (zmsg, tag, strlen (tag)) < 0)\n+        err_exit (\"zmsg_addmem\");\n     if (o) {\n         const char *s = json_object_to_json_string (o);\n-        if (zmsg_addstr (zmsg, \"%s\", s) < 0)\n-            err_exit (\"zmsg_addstr\");\n+        if (zmsg_addmem (zmsg, s, strlen (s)) < 0)\n+            err_exit (\"zmsg_addmem\");\n     }\n     return zmsg;\n }\n", "fix_pattern": "<pattern>: if the code is using zmsg_addstr to add strings to the zmsg, replace it with zmsg_addmem to directly add the memory representation of the strings along with their length, improving efficiency by eliminating the need for the function to determine the string length internally."}
{"number": 695, "change": "@@ -417,8 +417,7 @@ static json_object *deep_copy (plugin_ctx_t *p, json_object *dir,\n     }\n     return dcpy;\n stall:\n-    if (dcpy)\n-        free (dcpy);\n+    json_object_put (dcpy);\n     return NULL;\n }\n \n", "fix_pattern": "<pattern>: if dynamically allocated memory is managed by a library's specific API, replace the standard `free` call with the appropriate library function to avoid potential memory management issues and improve performance by taking advantage of the library's optimized handling for its objects."}
{"number": 701, "change": "@@ -338,7 +338,7 @@ void showSplashScreen()\n #if defined(Q_OS_UNIX)\n void setupDpi()\n {\n-    if (qgetenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\").isEmpty())\n+    if (qEnvironmentVariableIsEmpty(\"QT_AUTO_SCREEN_SCALE_FACTOR\"))\n         qputenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\", \"1\");\n }\n #endif  // Q_OS_UNIX\n", "fix_pattern": "<pattern>: if a call is made to qgetenv followed by an isEmpty check, replace it with a direct call to qEnvironmentVariableIsEmpty for better performance, as it avoids the overhead of creating a QString object."}
{"number": 702, "change": "@@ -28,6 +28,8 @@\n \n #include \"apicontroller.h\"\n \n+#include <algorithm>\n+\n #include <QJsonDocument>\n #include <QMetaObject>\n \n@@ -69,9 +71,13 @@ const DataMap &APIController::data() const\n \n void APIController::checkParams(const QSet<QString> &requiredParams) const\n {\n-    const QSet<QString> params {this->params().keys().toSet()};\n+    const bool hasAllRequiredParams = std::all_of(requiredParams.cbegin(), requiredParams.cend()\n+        , [this](const QString &requiredParam)\n+    {\n+        return params().contains(requiredParam);\n+    });\n \n-    if (!params.contains(requiredParams))\n+    if (!hasAllRequiredParams)\n         throw APIError(APIErrorType::BadParams);\n }\n \n", "fix_pattern": "<pattern>: if an operation involves checking for the presence of multiple required parameters in a set, replace the set construction and lookup with a more efficient method using std::all_of to directly check each required parameter's existence, minimizing temporary object creation and improving readability."}
{"number": 707, "change": "@@ -189,7 +189,7 @@ TcpSocketImplTest::Test1_HandleRecv (Ptr<Socket> sock)\n   {\n     rxBytes1 += sz;\n     rxPayload = new uint8_t[sz];\n-    memcpy (rxPayload, p->PeekData(), sz);\n+    p->CopyData (rxPayload, sz);\n   }\n   else\n   {\n", "fix_pattern": "<pattern>: if memcpy is used to transfer data from a packet buffer, replace it with the packet's optimized CopyData method to leverage potential internal optimizations and reduce overhead."}
{"number": 709, "change": "@@ -1718,7 +1718,7 @@ static void lCompose(\n #if 1 // def __COMPOSITE_PROFILE\n     double nsendrecvloc = (senddispl[nrank] + recvdispl[nrank])*sizeof(uint16_t);\n     double nsendrecv;\n-    MPI_Allreduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, comm);\n+    MPI_Reduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, master, comm);\n     const double t1 = MPI_Wtime();\n     if (rank == master)\n     {\n", "fix_pattern": "<pattern>: if the communication pattern allows for reduction to a specific root instead of broadcasting to all processes, replace MPI_Allreduce with MPI_Reduce to optimize performance by reducing the amount of data communicated across the network."}
{"number": 711, "change": "@@ -1533,7 +1533,7 @@ void NJClient::mixInChannel(bool muted, float vol, float pan, DecodeState *chan,\n     // advance the queue\n     chan->decode_samplesout += needed/chan->decode_codec->GetNumChannels();\n     chan->decode_codec->m_samples_used -= needed+chan->dump_samples;\n-    memcpy(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n+    memmove(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n     chan->dump_samples=0;\n   }\n   else\n", "fix_pattern": "<pattern>: if overlapping memory regions are detected, replace memcpy with memmove to ensure correct behavior since memmove handles such cases properly."}
{"number": 712, "change": "@@ -143,8 +143,8 @@ void convert_inplace_test_do_it( dl_ctx_t       dl_ctx,        dl_typeid_t type,\n \t\t*out_buffer = (unsigned char*)malloc(*out_size + 1);\n \t\tmemset(*out_buffer, 0xFE, *out_size + 1);\n \n-\t\tmemcpy( *out_buffer, convert_buffer, convert_size );\n-\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, *out_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, convert_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tmemcpy(*out_buffer, convert_buffer, *out_size);\n \t}\n \n \tfree(convert_buffer);\n", "fix_pattern": "<pattern>: if a memcpy operation is performed after an API call that alters the buffer's content, refactor the code to first call the API and then perform the memcpy only if necessary, using the proper output size calculated from the API call, which avoids potentially copying unnecessary data or incorrect sizes."}
{"number": 715, "change": "@@ -14,7 +14,7 @@ int _tflitetensor_name(ErlNifEnv *env, TfLiteTensor * tensor, ERL_NIF_TERM &out)\n     unsigned char * ptr;\n     size_t len = strlen(tensor_name_str);\n     if ((ptr = enif_make_new_binary(env, len, &tensor_name)) != nullptr) {\n-        strncpy((char *)ptr, tensor_name_str, len);\n+        memcpy((char *)ptr, tensor_name_str, len);\n         out = tensor_name;\n         return true;\n     } else {\n", "fix_pattern": "<pattern>: if strncpy is used to copy a fixed length of bytes, replace it with memcpy for better performance since strncpy performs null-termination checks and padding that are unnecessary in this context."}
{"number": 716, "change": "@@ -201,7 +201,7 @@ namespace erlang {\n             unsigned char *ptr;\n             size_t len = strlen(c_string);\n             if ((ptr = enif_make_new_binary(env, len, &binary_str)) != nullptr) {\n-                strcpy((char *) ptr, c_string);\n+                memcpy((char *)ptr, c_string, len);\n                 return binary_str;\n             } else {\n                 fprintf(stderr, \"internal error: cannot allocate memory for binary string\\r\\n\");\n", "fix_pattern": "<pattern>: if a function is copying a string and the length of the source is known, replace strcpy with memcpy for potentially better performance and to handle non-null-terminated data safely."}
{"number": 720, "change": "@@ -64,10 +64,10 @@ bool FormFieldRestrictedValues::safeForIntegerCoercion(FormRestrictions restrict\n     foreach(SelectRestriction sr, restrictions.first) {\n         if(sr.variable == name) {\n             foreach(QString value, sr.values) {\n-                // TODO: Would prefer to use a more general regex (e.g. allowing zero-padded values or leading/trailing\n-                // spaces) but these values cannot currently be injected back correctly (even though we could coerce\n+                // TODO: Would prefer to use a more general regex (e.g. allowing leading/trailing spaces)\n+                // but these values cannot currently be injected back correctly (even though we could coerce\n                 // and solve them), so we are quite conservative for now.\n-                if(!value.contains(QRegExp(\"^(0|([1-9][0-9]*))$\"))) {\n+                if(!value.contains(QRegExp(\"^([0-9]*)$\"))) {\n                     return false;\n                 }\n             }\n", "fix_pattern": "<pattern>: if a more specific regex pattern that constrains valid input is replaced with a more general pattern that allows additional cases (like leading/trailing spaces), ensure that it doesn't introduce significant performance overhead when the regex engine has to handle a broader set of matches; specific patterns can lead to faster evaluations and less backtracking compared to general patterns."}
{"number": 722, "change": "@@ -130,7 +130,7 @@ static Node *convertToCLinkFormat( xmlDocPtr doc, xmlNodePtr cur, int depth ) {\n \n Node *Parser::parse(const std::string &data, size_t len) {\n   // First, parse the XML memory buffer ito a DOM object\n-  xmlDocPtr doc = xmlParseMemory( data.c_str(), (int)len );\n+  xmlDocPtr doc = xmlReadMemory(data.c_str(), (int)len, NULL, NULL, XML_PARSE_NOERROR);\n   if ( doc == NULL ) {\n     LogWarn(\"XML file parsing failed:\");\n     LogWarn(\"%s\", data.c_str());\n", "fix_pattern": "<pattern>: if an API method for parsing XML is replaced with a different, more configurable method that allows for options (like error handling), then switch from a basic parsing function to a more flexible one (xmlReadMemory) that can handle additional parameters for better error control and customization."}
{"number": 725, "change": "@@ -270,8 +270,9 @@ extern \"C\" void report_segfault(int signo)\n \n extern \"C\" void report_abort(int signo)\n {\n-    log(CRITICAL, \"Aborted\");\n-    log(NOTICE, \"Please report this bug to \" PACKAGE_BUGREPORT);\n+    //Don't print to the log in signal handler, as that involves memory allocation.\n+    fprintf(stderr, \"Aborted\");\n+    fprintf(stderr, \"Please report this bug to \" PACKAGE_BUGREPORT);\n \n #if !defined(HAVE_SIGACTION)\n     signal(signo, SIG_DFL);\n", "fix_pattern": "<pattern>: if logging functions are called within a signal handler, switch to using fprintf to stderr to avoid memory allocation issues associated with the logging API"}
{"number": 742, "change": "@@ -5,7 +5,7 @@\n         Quesa interactive renderer TriMesh implementation.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2004, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1443,11 +1443,12 @@ IRGeometry_Submit_TriMesh(TQ3ViewObject\t\t\t\ttheView,\n \tTQ3Status\t\t\tqd3dStatus;\n \tCQ3ObjectRef\t\tcachedGeom;\n \tCLockTriMeshData\tlocker;\n+\tbool\t\t\t\twasValid;\n \n \t\n \t// Look for a cached optimized geometry.\n-\tcachedGeom = GetCachedOptimizedTriMesh( theGeom );\n-\tif ( ! cachedGeom.isvalid() )\n+\tcachedGeom = GetCachedOptimizedTriMesh( theGeom, wasValid );\n+\tif ( ! wasValid )\n \t{\n \t\t// no cached data or stale cache\n \t\tcachedGeom = CQ3ObjectRef( Q3TriMesh_Optimize( theGeom ) );\n", "fix_pattern": "<pattern>: if an API method is upgraded to provide additional information about the validity of the cached geometry directly via an output parameter (instead of checking validity through a separate method call), leverage the new API method to potentially reduce the overhead of multiple validations and improve performance."}
{"number": 743, "change": "@@ -5,7 +5,7 @@\n         Implementation of Quesa API calls.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2008, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1277,14 +1277,14 @@ OpaqueTQ3Object::GetElement ( TQ3ElementType theType, void *theData )\n \n \t// If we've actually been passed a set, use it directly\n \tif ( Q3_OBJECT_IS_CLASS ( this, E3Set ) )\n-\t\treturn Q3Set_Get ( (TQ3SetObject) this, theType, theData ) ;\n+\t\treturn ( (E3Set*) this )->Get ( theType, theData ) ;\n \t\n \t// otherwise use the set within the instance data\n \t\n \tif ( theSet == NULL )\n \t\treturn kQ3Failure ;\n \t\n-\treturn Q3Set_Get ( theSet, theType, (void*)theData ) ;\n+\treturn ( (E3Set*) theSet )->Get ( theType, theData ) ;\n \t}\n \n \n", "fix_pattern": "<pattern>: if the original Q3Set_Get function is being replaced with the more efficient E3Set::Get member function call, then refactor the API usage to utilize the class method for potentially better performance and cleaner code."}
{"number": 748, "change": "@@ -73,11 +73,11 @@ QgsMapCanvasContextMenu::QgsMapCanvasContextMenu( QgsMapCanvas* canvas, const QP\n   }\n   else if ( mPickResult.feature.isValid() && mPickResult.layer )\n   {\n-    QgsCoordinateTransform ct( mPickResult.layer->crs(), mCanvas->mapSettings().destinationCrs() );\n+    const QgsCoordinateTransform* ct = QgsCoordinateTransformCache::instance()->transform( mPickResult.layer->crs().authid(), mCanvas->mapSettings().destinationCrs().authid() );\n     mRubberBand = new QgsGeometryRubberBand( mCanvas, mPickResult.feature.geometry()->type() );\n     mRubberBand->setIconType( QgsGeometryRubberBand::ICON_NONE );\n     mRubberBand->setOutlineWidth( 2 );\n-    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( ct ) );\n+    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( *ct ) );\n     if ( mPickResult.layer->type() == QgsMapLayer::RedliningLayer )\n     {\n       addAction( QIcon( \":/images/themes/default/mActionToggleEditing.svg\" ), tr( \"Edit\" ), this, SLOT( editFeature() ) );\n", "fix_pattern": "<pattern>: if a new instance of QgsCoordinateTransform is created every time a transformation is needed, utilize a caching mechanism (QgsCoordinateTransformCache) to retrieve pre-constructed coordinate transforms based on CRS identifiers to improve performance."}
{"number": 749, "change": "@@ -35,10 +35,11 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     PyObject* ret_keypoints = PyList_New(num_keypoints);\n     // import cv2\n     PyObject* cv2_mod = PyImport_ImportModule(\"cv2\");\n+    PyObject* cv2_keypoint_class = PyObject_GetAttrString(cv2_mod, \"KeyPoint\");\n \n     for(size_t i = 0; i < num_keypoints; ++i) {\n         // cv2_keypoint = cv2.KeyPoint()\n-        PyObject* cv2_keypoint = PyObject_CallMethod(cv2_mod, const_cast<char*>(\"KeyPoint\"), NULL);\n+        PyObject* cv2_keypoint = PyObject_CallObject(cv2_keypoint_class, NULL);\n \n         // build values\n         PyObject* cv2_keypoint_size = Py_BuildValue(\"f\", keypoints[i].size);\n@@ -68,6 +69,7 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     }\n \n     Py_DECREF(cv2_mod);\n+    Py_DECREF(cv2_keypoint_class);\n \n     return ret_keypoints;\n }\n", "fix_pattern": "<pattern>: if an API call to PyObject_CallMethod is made to create an object, refactor the code to first retrieve the class using PyObject_GetAttrString and then call it using PyObject_CallObject to avoid redundant lookup performance costs. Additionally, manage the reference counts with Py_DECREF to prevent memory leaks."}
{"number": 751, "change": "@@ -223,9 +223,9 @@ void DBuiltinIconEngine::paint(QPainter *painter, const QRect &rect,\n \n     // \u5982\u679c\u6709 background \u5219\u7ed8\u5236\u80cc\u666f\u56fe\u5148\n     QString bgFileName = entry->filename + QStringLiteral(\".background\");\n-    QIcon bgIcon = QIcon(bgFileName);\n-    if (!bgIcon.isNull()) {\n-        bgIcon.paint(painter, rect, Qt::AlignCenter, mode, state);\n+\n+    if (QFile::exists(bgFileName)) {\n+        QIcon(bgFileName).paint(painter, rect, Qt::AlignCenter, mode, state);\n     }\n \n     QPixmap pm = entry->pixmap(pixmapSize, mode, state);\n", "fix_pattern": "<pattern>: if a QIcon is created but then checked for nullity before painting, first check for file existence using QFile::exists to avoid unnecessary construction of the QIcon object, which improves performance by preventing the instantiation of an unused QIcon."}
{"number": 765, "change": "@@ -1040,7 +1040,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n         loadLibrary(id_lib);\n \n     uint nPage = 0;\n-    if(!QFileInfo(url).exists())\n+    if(!QFileInfo::exists(url))\n     {\n         if(strings.count()>0)\n         {\n@@ -1099,7 +1099,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n             ts.device()->write(file.readAll());\n         }\n     }\n-    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo(url).exists())\n+    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo::exists(url))\n     {\n         QString id=strings[2];\n         fb2mobi fb;\n", "fix_pattern": "<pattern>: if QFileInfo is used to check the existence of a file multiple times in conditions, replace the object creation with a static call to QFileInfo::exists to optimize performance by avoiding unnecessary instantiation."}
{"number": 768, "change": "@@ -240,7 +240,7 @@ void DeleteWindow(Window *w)\n \n \tv = --_last_window;\n \tcount = (byte*)v - (byte*)w;\n-\tmemcpy(w, w + 1, count);\n+\tmemmove(w, w + 1, count);\n }\n \n Window *FindWindowById(WindowClass cls, WindowNumber number)\n", "fix_pattern": "<pattern>: if a source and destination overlap in a memory copy operation, replace memcpy with memmove to prevent undefined behavior and ensure correctness. memmove handles overlapping regions correctly, which can lead to performance improvements in cases where safety is a concern."}
{"number": 772, "change": "@@ -571,16 +571,11 @@ struct Converter_std_map\n         PyObject* value;\n         Py_ssize_t pos = 0;\n \n-        Py_INCREF(pyobj);\n-\n         while (PyDict_Next(pyobj, &pos, &key, &value)) {\n             result.insert(typename StdMap::value_type(\n                     Converter<typename StdMap::key_type>::toCpp(key),\n                     Converter<typename StdMap::mapped_type>::toCpp(value)));\n         }\n-\n-        Py_DECREF(pyobj);\n-\n         return result;\n     }\n };\n", "fix_pattern": "<pattern>: if Py_INCREF and Py_DECREF are called consecutively on the same PyObject, remove the redundant calls to improve performance as they balance each other out without any net change."}
{"number": 778, "change": "@@ -119,16 +119,12 @@ QList<QCameraDevice> QGstreamerVideoDevices::videoDevices() const\n \n void QGstreamerVideoDevices::addDevice(GstDevice *device)\n {\n-    gchar *type = gst_device_get_device_class(device);\n-    gst_object_ref(device);\n-    if (!strcmp(type, \"Video/Source\") || !strcmp(type, \"Source/Video\")) {\n+    if (gst_device_has_classes(device, \"Video/Source\")) {\n+        gst_object_ref(device);\n         m_videoSources.push_back({device, QByteArray::number(m_idGenerator)});\n         videoInputsChanged();\n         m_idGenerator++;\n-    } else {\n-        gst_object_unref(device);\n     }\n-    g_free(type);\n }\n \n void QGstreamerVideoDevices::removeDevice(GstDevice *device)\n", "fix_pattern": "<pattern>: if a comparison of device classes is performed using strcmp, replace it with the more efficient function gst_device_has_classes to avoid the overhead of string comparison and potentially streamline the logic flow for checking device classes."}
{"number": 780, "change": "@@ -55,7 +55,7 @@ std::string raw_text(const GumboNode * node)\n     else if( child_node->type == GUMBO_NODE_ELEMENT )\n     {\n       inner_text.push_back(' ');\n-      inner_text.append(text(child_node));\n+      inner_text.append(raw_text(child_node));\n     }\n   }\n \n", "fix_pattern": "<pattern>: if an API method used for text extraction (text) is replaced by a more efficient method (raw_text), it indicates that the new method offers better performance or fewer overheads in the context of extracting text from nodes in the HTML parsing process."}
{"number": 790, "change": "@@ -8,8 +8,11 @@ namespace pink {\n \n PinkEpoll::PinkEpoll()\n {\n-  epfd_ = epoll_create(1024); \n-  fcntl(epfd_, F_SETFD, fcntl(epfd_, F_GETFD) | FD_CLOEXEC);\n+  epfd_ = epoll_create1(EPOLL_CLOEXEC);\n+  if (epfd_ < 0) {\n+    log_err(\"epoll create fail\")\n+    exit(1)\n+  }\n   events_ = (struct epoll_event *)malloc(sizeof(struct epoll_event) * PINK_MAX_CLIENTS);\n   if (!events_) {\n     log_err(\"init epoll_event error\");\n", "fix_pattern": "<pattern>: if epoll_create is used without the additional flags for better security and atomicity, replace it with epoll_create1 with appropriate flags, which provides a more robust and safer method for creating epoll instances."}
{"number": 795, "change": "@@ -2585,8 +2585,12 @@ QString QWebPage::userAgentForUrl(const QUrl& url) const\n \n     QChar securityStrength(QLatin1Char('N'));\n #if !defined(QT_NO_OPENSSL)\n-    if (QSslSocket::supportsSsl())\n-        securityStrength = QLatin1Char('U');\n+    // we could check QSslSocket::supportsSsl() here, but this makes\n+    // OpenSSL, certificates etc being loaded in all cases were QWebPage\n+    // is used. This loading is not needed for non-https.\n+    securityStrength = QLatin1Char('U');\n+    // this may lead to a false positive: We indicate SSL since it is\n+    // compiled in even though supportsSsl() might return false\n #endif\n     ua = ua.arg(securityStrength);\n \n", "fix_pattern": "<pattern>: if a method call (like QSslSocket::supportsSsl()) introduces unnecessary overhead for performance-sensitive paths, remove that call and set a derived security property (like securityStrength) directly, while noting the implications of potential false positives."}
{"number": 798, "change": "@@ -716,7 +716,7 @@ void CreateMainFrame(FrameCreationCallback inOnFrame,int inWidth,int inHeight,\n             }\n \n             sdl_flags |= SDL_OPENGL;\n-            if (!(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags | SDL_OPENGL)))\n+            if (!SDL_VideoModeOK( use_w, use_h, 32, sdl_flags) || !(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags)))\n             {\n                if (pass==2 && aa_pass==0)\n                {\n", "fix_pattern": "<pattern>: if a call to SDL_SetVideoMode is made without a prior check for video mode validity, first validate with SDL_VideoModeOK to potentially avoid an unnecessary set video mode operation, improving performance by preventing failures or retries."}
{"number": 799, "change": "@@ -846,8 +846,7 @@ QScriptEnginePrivate::~QScriptEnginePrivate()\n \n QScriptValue QScriptEnginePrivate::scriptValueFromVariant(const QVariant &v)\n {\n-    Q_Q(QScriptEngine);\n-    QScriptValue result = q->create(v.userType(), v.data());\n+    QScriptValue result = create(v.userType(), v.data());\n     Q_ASSERT(result.isValid());\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is called on a pointer context (Q_Q), and the method being called is already a member function of the same context (i.e., `create`), remove the pointer context and call the method directly to improve code readability and possibly reduce overhead."}
{"number": 803, "change": "@@ -54,15 +54,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made sequentially with the same file descriptor, cache the result of F_GETFD and only call F_SETFD if the flags need to be changed, thus avoiding unnecessary system calls for improved performance."}
{"number": 806, "change": "@@ -797,10 +797,10 @@ bool RageDisplay_OGL::BeginFrame()\n \n void RageDisplay_OGL::EndFrame()\n {\n-\t// Give up the CPU to the OpenGL host if it wants it; in any case, make\n-\t// sure the frame is done. This helps graphics smoothness a lot by\n-\t// making sure we get the most out of each frame.\n-\tglFinish();\n+\t// glFlush(), not glFinish(); NVIDIA_GLX's glFinish()'s behavior is\n+\t// nowhere near performance-friendly and uses unholy amounts of CPU for\n+\t// Gog-knows-what.\n+\tglFlush();\n \n \twind->SwapBuffers();\n \tProcessStatsOnFlip();\n", "fix_pattern": "<pattern>: if glFinish() is used as a means to sync with the GPU, replace it with glFlush() to improve performance, as glFinish() can introduce significant CPU overhead that affects rendering efficiency."}
{"number": 807, "change": "@@ -236,8 +236,6 @@ void GLC_Texture::glcBindTexture(void)\n \t\tglLoadTexture();\n \t}\n \tglBindTexture(GL_TEXTURE_2D, m_GlTextureID);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n \n QImage GLC_Texture::loadFromFile(const QString& fileName)\n", "fix_pattern": "<pattern>: if multiple OpenGL texture parameter settings with the same target are called consecutively, consolidate them into a single function call to improve performance and reduce state changes."}
{"number": 812, "change": "@@ -112,7 +112,7 @@ namespace\n         DBusActivateTimeout()\n         {\n             bool ok;\n-            mTimeoutMs = qgetenv(\"QTXDG_DBUSACTIVATE_TIMEOUT\").toInt(&ok);\n+            mTimeoutMs = qEnvironmentVariableIntValue(\"QTXDG_DBUSACTIVATE_TIMEOUT\", &ok);\n             if (!ok)\n                 mTimeoutMs = 1500;\n         }\n", "fix_pattern": "<pattern>: if using qgetenv() followed by toInt() to retrieve an environment variable as an integer, replace it with qEnvironmentVariableIntValue() to reduce overhead and improve performance by directly reading and converting in one call."}
{"number": 822, "change": "@@ -407,8 +407,6 @@ void QrcParserPrivate::collectResourceFilesForSourceFile(const QString &sourceFi\n                                                          const QLocale *locale) const\n {\n     // TODO: use FileName from fileutils for file pathes\n-    QTC_CHECK(QFileInfo(sourceFile).isFile());\n-    QTC_CHECK(QFileInfo(sourceFile).isAbsolute());\n \n     QStringList langs = allUiLanguages(locale);\n     SMap::const_iterator file = m_files.find(sourceFile);\n", "fix_pattern": "<pattern>: if multiple QFileInfo instances are created for the same file, instantiate QFileInfo once and reuse it for various checks to avoid unnecessary object creation overhead."}
{"number": 830, "change": "@@ -135,9 +135,8 @@ KMKernel::KMKernel(QObject *parent) :\n     mSystemTray(Q_NULLPTR),\n     mDebugBaloo(false)\n {\n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n+\n     if (!s_networkConfigMgr) {\n         s_networkConfigMgr = new QNetworkConfigurationManager(QCoreApplication::instance());\n     }\n", "fix_pattern": "<pattern>: if there is an environment variable check using qgetenv followed by a check for emptiness with isEmpty(), replace it with a direct call to qEnvironmentVariableIsEmpty to simplify the check and improve performance."}
{"number": 835, "change": "@@ -77,7 +77,7 @@ bool BasicIndexingJob::index()\n     }\n \n     if (fileInfo.isDir()) {\n-        doc.addBoolTerm(QLatin1String(\"folder\"), QLatin1String(\"T\"));\n+        doc.addBoolTerm(QStringLiteral(\"Tfolder\"));\n \n         // This is an optimization for folders. They do not need to go through\n         // file indexing, so there are no indexers for folders\n", "fix_pattern": "<pattern>: if a QLatin1String is constructed using a string literal for values that will not change, replace it with QStringLiteral for potentially better performance and memory usage."}
{"number": 838, "change": "@@ -264,17 +264,29 @@ void agiGLPipeline::BeginFrame()\n \n     gl_context_->MakeCurrent();\n \n-    if (PARAM_frameclear.get_or(true))\n+    bool frameclear = PARAM_frameclear.get_or(true);\n+\n+    if (frameclear)\n     {\n         agiGL->EnableDisable(GL_SCISSOR_TEST, false);\n+        agiGL->DepthMask(true);\n         glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n-        glClear(GL_COLOR_BUFFER_BIT);\n     }\n \n     if (fbo_ != 0)\n     {\n+        if (frameclear)\n+        {\n+            glClear(GL_COLOR_BUFFER_BIT);\n+        }\n+\n         glBindFramebuffer(GL_FRAMEBUFFER, fbo_);\n     }\n+\n+    if (frameclear)\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n+    }\n }\n \n void agiGLPipeline::BeginScene()\n", "fix_pattern": "<pattern>: if a condition is checked multiple times with the same result, cache the result in a variable to avoid unnecessary repeated calls, and ensure to organize the flow of API calls for better clarity and potential performance improvements."}
{"number": 840, "change": "@@ -527,8 +527,7 @@ vdraw_send_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)\n \t\treturn TCL_ERROR;\n \t}\n \n-\tsprintf(solid_name, RT_VDRW_PREFIX);\n-\tstrncat(solid_name, dgop->dgo_currVHead->vdc_name, RT_VDRW_MAXNAME);\n+\tsnprintf(solid_name, RT_VDRW_MAXNAME+RT_VDRW_PREFIX_LEN+1, \"%s%s\", RT_VDRW_PREFIX, dgop->dgo_currVHead->vdc_name);\n \tif ((dp = db_lookup(dgop->dgo_wdbp->dbip, solid_name, LOOKUP_QUIET)) == DIR_NULL) {\n \t\treal_flag = 0;\n \t} else {\n", "fix_pattern": "<pattern>: if a string is being constructed using sprintf followed by strncat, replace it with snprintf to streamline the operation and enhance performance by eliminating the need for multiple function calls and potential buffer overflow risks."}
{"number": 844, "change": "@@ -1,4 +1,4 @@\n-/* $Id: clearspd.c,v 1.2 2000/04/10 16:25:15 brianp Exp $ */\n+/* $Id: clearspd.c,v 1.3 2000/12/07 21:50:39 brianp Exp $ */\n \n /*\n  * Simple GLUT program to measure glClear() and glutSwapBuffers() speed.\n@@ -7,6 +7,9 @@\n \n /*\n  * $Log: clearspd.c,v $\n+ * Revision 1.3  2000/12/07 21:50:39  brianp\n+ * call glFinish() before getting t1 time\n+ *\n  * Revision 1.2  2000/04/10 16:25:15  brianp\n  * fixed visual selection and reporting results\n  *\n@@ -71,14 +74,15 @@ static void Display( void )\n          glClear( BufferMask );\n          glutSwapBuffers();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n    }\n    else {\n       t0 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       for (i=0;i<Loops;i++) {\n          glClear( BufferMask );\n-         glFlush();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       glutSwapBuffers();\n    }\n", "fix_pattern": "<pattern>: if performance-critical sections involve OpenGL rendering APIs, replace glFlush() with glFinish() when synchronization is needed to ensure all previous rendering commands are complete before proceeding, as glFinish() blocks until all commands are executed, leading to more predictable timing in performance measurements."}
{"number": 847, "change": "@@ -17,10 +17,10 @@\n //===----------------------------------------------------------------------===//\n \n #include \"../SwiftShims/GlobalObjects.h\"\n+#include \"../SwiftShims/LibcShims.h\"\n #include \"swift/Runtime/Metadata.h\"\n #include \"swift/Runtime/Debug.h\"\n #include <stdlib.h>\n-#include <random>\n \n namespace swift {\n // FIXME(ABI)#76 : does this declaration need SWIFT_RUNTIME_STDLIB_INTERFACE?\n@@ -116,18 +116,10 @@ static swift::_SwiftHashingParameters initializeHashingParameters() {\n   if (determinism && 0 == strcmp(determinism, \"1\")) {\n     return { 0, 0, true };\n   }\n-#if defined(__APPLE__)\n-  // Use arc4random if available.\n   __swift_uint64_t seed0 = 0, seed1 = 0;\n-  arc4random_buf(&seed0, sizeof(seed0));\n-  arc4random_buf(&seed1, sizeof(seed1));\n+  swift::_stdlib_random(&seed0, sizeof(seed0));\n+  swift::_stdlib_random(&seed1, sizeof(seed1));\n   return { seed0, seed1, false };\n-#else\n-  std::random_device randomDevice;\n-  std::mt19937_64 engine(randomDevice());\n-  std::uniform_int_distribution<__swift_uint64_t> distribution;\n-  return { distribution(engine), distribution(engine), false };\n-#endif\n }\n \n SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_BEGIN\n", "fix_pattern": "<pattern>: if the code is using platform-specific random number generation (arc4random_buf) for macOS, replace it with a more generic and potentially optimized API (swift::_stdlib_random) to improve performance and maintain consistency across different platforms."}
{"number": 850, "change": "@@ -536,8 +536,6 @@ hasMergeGroup(MergeGroupKind Kind) {\n void swift::\n collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n                     llvm::SmallDenseMap<ValueDecl*, ValueDecl*> &DefaultMap) {\n-  Type BaseTy = PD->getDeclaredInterfaceType();\n-  DeclContext *DC = PD->getInnermostDeclContext();\n   auto HandleMembers = [&](DeclRange Members) {\n     for (Decl *D : Members) {\n       auto *VD = dyn_cast<ValueDecl>(D);\n@@ -550,11 +548,8 @@ collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n       if (VD->getBaseName().empty())\n         continue;\n \n-      ResolvedMemberResult Result = resolveValueMember(*DC, BaseTy,\n-                                                       VD->getFullName());\n-      assert(Result);\n-      for (auto *Default : Result.getMemberDecls(InterestedMemberKind::All)) {\n-        if (PD == Default->getDeclContext()->getExtendedProtocolDecl()) {\n+      for (auto *Default: PD->lookupDirect(VD->getFullName())) {\n+        if (Default->getDeclContext()->getExtendedProtocolDecl() == PD) {\n           DefaultMap.insert({Default, VD});\n         }\n       }\n", "fix_pattern": "<pattern>: if a resolved member lookup is performed via resolveValueMember, replace it with a direct lookup using PD->lookupDirect to improve performance by avoiding unnecessary resolution overhead."}
{"number": 853, "change": "@@ -504,11 +504,6 @@ Future<std::shared_ptr<parquet::arrow::FileReader>> ParquetFileFormat::GetReader\n                                                          default_fragment_scan_options));\n   auto properties = MakeReaderProperties(*this, parquet_scan_options.get(), source.path(),\n                                          source.filesystem(), options->pool);\n-  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n-  // TODO(ARROW-12259): workaround since we have Future<(move-only type)>\n-  auto reader_fut = parquet::ParquetFileReader::OpenAsync(\n-      std::move(input), std::move(properties), metadata);\n-  auto path = source.path();\n   auto self = checked_pointer_cast<const ParquetFileFormat>(shared_from_this());\n \n   return source.OpenAsync().Then(\n", "fix_pattern": "<pattern>: NA"}
{"number": 863, "change": "@@ -596,11 +596,9 @@ void e6y_PreprocessLevel(void)\n \n void gld_InitGLVersion(void)\n {\n-  char ver[256];\n   int MajorVersion, MinorVersion;\n   glversion = OPENGL_VERSION_1_0;\n-  strncpy(ver, glGetString(GL_VERSION), sizeof(ver));\n-  if (sscanf(ver, \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n+  if (sscanf(glGetString(GL_VERSION), \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n   {\n     if (MajorVersion > 1)\n     {\n", "fix_pattern": "<pattern>: if the code copies a string from `glGetString` to a temporary buffer using `strncpy`, directly use the result of `glGetString` in `sscanf` to save memory and eliminate an unnecessary copy."}
{"number": 865, "change": "@@ -729,11 +729,8 @@ int QString16::localeAwareCompare(QStringView16 str1, QStringView16 str2)\n    }\n \n #if defined(Q_OS_WIN32)\n-   QString16 tmp1(str1.begin(), str1.end());\n-   QString16 tmp2(str2.begin(), str2.end());\n-\n-   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)tmp1.constData(), tmp1.size_storage(),\n-        (wchar_t *)tmp2.constData(), tmp2.size_storage());\n+   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)str1.charData(), str1.size_storage(),\n+        (wchar_t *)str2.charData(), str2.size_storage());\n \n    switch (retval) {\n       case CSTR_LESS_THAN:\n", "fix_pattern": "<pattern>: if temporary QString16 objects are created to convert QString data before passing it to an API, replace them with direct access to the char data and size functions of QString to eliminate unnecessary object creation and improve performance."}
{"number": 885, "change": "@@ -41,7 +41,18 @@ void GLIndexBuf::bind()\n \n void GLIndexBuf::bind_as_ssbo(uint binding)\n {\n-  bind();\n+  if (ibo_id_ == 0 || data_ != nullptr) {\n+    /* Calling `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo_id_)` changes the index buffer\n+     * of the currently bound VAO.\n+     *\n+     * In the OpenGL backend, the VAO state persists even after `GLVertArray::update_bindings`\n+     * is called.\n+     *\n+     * NOTE: For safety, we could call `glBindVertexArray(0)` right after drawing a `GPUBatch`.\n+     * However, for performance reasons, we have chosen not to do so. */\n+    glBindVertexArray(0);\n+    bind();\n+  }\n   BLI_assert(ibo_id_ != 0);\n   glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, ibo_id_);\n }\n", "fix_pattern": "<pattern>: if a binding operation is performed via glBindVertexArray before a specific condition (like checking if ibo_id_ is 0 or data_ is not null), it is refactored to avoid unnecessary binding calls, which can lead to performance improvements by preventing redundant state changes in the OpenGL pipeline."}
{"number": 890, "change": "@@ -15,6 +15,7 @@\n #endif\n #include <folly/ScopeGuard.h>\n #include <folly/String.h>\n+#include <folly/system/Pid.h>\n \n #if defined(_WIN32) || defined(O_PATH)\n #define CAN_OPEN_SYMLINKS 1\n@@ -453,9 +454,19 @@ w_string FileDescriptor::getOpenedPath() const {\n #elif defined(__linux__) || defined(__sun)\n   char procpath[1024];\n #if defined(__linux__)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/fd/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/fd/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #elif defined(__sun)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/path/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/path/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #endif\n \n   // Avoid an extra stat by speculatively attempting to read into\n", "fix_pattern": "<pattern>: if a process ID is repeatedly fetched using getpid(), replace it with a cached version provided by folly::get_cached_pid() to avoid the performance overhead of system calls."}
{"number": 904, "change": "@@ -180,7 +180,16 @@ void DrawCallPerfBenchmark::destroyBenchmark()\n \n void DrawCallPerfBenchmark::drawBenchmark()\n {\n-    glClear(GL_COLOR_BUFFER_BIT);\n+    // This workaround fixes a huge queue of graphics commands accumulating on the GL\n+    // back-end. The GL back-end doesn't have a proper NULL device at the moment.\n+    // TODO(jmadill): Remove this when/if we ever get a proper OpenGL NULL device.\n+    const auto &eglParams = GetParam().eglParameters;\n+    if (eglParams.deviceType != EGL_PLATFORM_ANGLE_DEVICE_TYPE_NULL_ANGLE ||\n+        (eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE &&\n+         eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE))\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT);\n+    }\n \n     const auto &params = GetParam();\n \n", "fix_pattern": "<pattern>: if calling glClear is causing performance issues due to excessive accumulation of graphics commands in the GL back-end, conditionally execute glClear based on the type of EGL device to mitigate the performance impact."}
{"number": 905, "change": "@@ -938,7 +938,10 @@ egl::ConfigSet Renderer11::generateConfigs()\n         // Additional high bit depth formats added in D3D 10.0\n         // https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064.aspx\n         colorBufferFormats.push_back(GL_RGBA16F);\n-        colorBufferFormats.push_back(GL_RGB10_A2);\n+\n+        // TODO(geofflang): Re-enable once client code has been updated to filter configs better and\n+        // not use RGB10A2 accidentally when requesting RGBA8\n+        // colorBufferFormats.push_back(GL_RGB10_A2);\n     }\n \n     if (!mPresentPathFastEnabled)\n", "fix_pattern": "<pattern>: if a call to push back an invalid or unoptimized color format is detected, comment it out until client code can be updated to filter configurations properly, thus avoiding unnecessary overhead or potential misconfigurations."}
{"number": 912, "change": "@@ -94,7 +94,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\t    node_type != abnode_type::equipment)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_server_dn(pnode, dn, sizeof(dn));\n-\t\tstrcat(dn, \"/cn=Microsoft Private MDB\");\n+\t\tHX_strlcat(dn, \"/cn=Microsoft Private MDB\", arsizeof(dn));\n \t\tif (NULL == pbuff) {\n \t\t\tpprop->value.pv = ndr_stack_alloc(\n \t\t\t\tNDR_STACK_OUT, strlen(dn) + 1);\n@@ -471,7 +471,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\tif (node_type != abnode_type::person)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_user_info(pnode, USER_STORE_PATH, dn, GX_ARRAY_SIZE(dn));\n-\t\tstrcat(dn, \"/config/portrait.jpg\");\n+\t\tHX_strlcat(dn, \"/config/portrait.jpg\", arsizeof(dn));\n \t\tif (!common_util_load_file(dn, &pprop->value.bin))\n \t\t\treturn ecNotFound;\n \t\treturn ecSuccess;\n", "fix_pattern": "<pattern>: if using strcat to concatenate strings where buffer size is a concern, replace it with a safer alternative such as HX_strlcat which takes the size of the destination buffer to prevent buffer overflows."}
{"number": 914, "change": "@@ -167,9 +167,10 @@ void EPollEngine::DelFd(EventHandler* eh)\n \t\treturn;\n \t}\n \n+\t// Do not initialize epoll_event because for EPOLL_CTL_DEL operations the event is ignored and can be NULL.\n+\t// In kernel versions before 2.6.9, the EPOLL_CTL_DEL operation required a non-NULL pointer in event,\n+\t// even though this argument is ignored. Since Linux 2.6.9, event can be specified as NULL when using EPOLL_CTL_DEL.\n \tstruct epoll_event ev;\n-\tmemset(&ev, 0, sizeof(ev));\n-\tev.data.fd = fd;\n \tint i = epoll_ctl(EngineHandle, EPOLL_CTL_DEL, fd, &ev);\n \n \tif (i < 0)\n", "fix_pattern": "<pattern>: if an epoll_event is being initialized for an EPOLL_CTL_DEL operation, avoid unnecessary initialization with memset or setting its fields, as the event data can be NULL and is ignored in this context."}
{"number": 922, "change": "@@ -460,7 +460,7 @@ float DeserializeFloat(const char *str, const char **outEndStr)\n \t\treturn FLOAT_NAN;\n \tif (MATH_NEXT_WORD_IS(str, \"NaN(\"))\n \t{\n-\t\tMATH_SKIP_WORD(str, \"NaN(\");\n+\t\tstr += strlen(\"NaN(\"); //MATH_SKIP_WORD(str, \"NaN(\");\n \t\tu32 x;\n \t\tint n = sscanf(str, \"%X\", (unsigned int *)&x);\n \t\tif (n != 1)\n", "fix_pattern": "<pattern>: if a specific word is skipped using a function that likely incurs function call overhead, replace the function call with a direct manipulation of the pointer to improve performance by reducing function call overhead."}
{"number": 927, "change": "@@ -28,9 +28,10 @@ void QKlamptDisplay::initializeGL(){\n }\n \n void QKlamptDisplay::paintGL(){\n-  glClear(0);\n   if(gui != NULL)\n     gui->SendGLRender();\n+  else\n+    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n }\n \n \n", "fix_pattern": "<pattern>: if glClear is called without any bitmask during a certain condition (like a clear operation being redundant), then ensure it explicitly clears the color and depth buffers only when necessary by combining the relevant bitmasks in one call."}
{"number": 931, "change": "@@ -1096,7 +1096,7 @@ grLfbWriteRegion( GrBuffer_t dst_buffer,\n       }\n \n       glBindTexture(GL_TEXTURE_2D, default_texture);\n-      glTexImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n+      glTexSubImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n \n       set_copy_shader();\n \n", "fix_pattern": "<pattern>: if a texture is already created and needs to be updated, replace glTexImage2D with glTexSubImage2D to improve performance by avoiding the overhead of reallocating texture memory."}
{"number": 939, "change": "@@ -240,8 +240,8 @@ ConVar filesystem_unbuffered_io( \"filesystem_unbuffered_io\", \"1\", 0, \"\" );\n #define UseUnbufferedIO() true\n #endif\n \n-ConVar filesystem_native( \"filesystem_native\", \"1\", 0, \"Use native FS or STDIO\" );\n-ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", IsX360() ? \"64\" : \"16\", 0, \"\" );\n+ConVar filesystem_native( \"filesystem_native\", \"0\", 0, \"Use native FS or STDIO\" );\n+ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", \"64\", 0, \"\" );\n ConVar filesystem_report_buffered_io( \"filesystem_report_buffered_io\", \"0\" );\n \n //-----------------------------------------------------------------------------\n@@ -417,7 +417,7 @@ FILE *CFileSystem_Stdio::FS_fopen( const char *filenameT, const char *options, u\n \n \tCBaseFileSystem::FixUpPath ( filenameT, filename, sizeof( filename ) );\n \n-#ifdef _WIN32\n+#if defined(_WIN32) && 0\n \tif ( CWin32ReadOnlyFile::CanOpen( filename, options ) )\n \t{\n \t\tpFile = CWin32ReadOnlyFile::FS_fopen( filename, options, size );\n", "fix_pattern": "<pattern>: if there are changes to configuration variables (ConVar) that affect performance, ensure the values are optimized for the specific platform or environment, such as setting \"filesystem_native\" to \"0\" to potentially favor the STDIO approach over native file system access for performance reasons."}
{"number": 942, "change": "@@ -136,19 +136,14 @@ void OpenGL::setupContext()\n \tstate.boundTextures.clear();\n \tstate.boundTextures.resize(maxTextureUnits, 0);\n \n-\tGLenum curgltextureunit;\n-\tglGetIntegerv(GL_ACTIVE_TEXTURE, (GLint *) &curgltextureunit);\n-\n-\tstate.curTextureUnit = (int) curgltextureunit - GL_TEXTURE0;\n-\n-\t// Retrieve currently bound textures for each texture unit.\n \tfor (int i = 0; i < (int) state.boundTextures.size(); i++)\n \t{\n \t\tglActiveTexture(GL_TEXTURE0 + i);\n-\t\tglGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint *) &state.boundTextures[i]);\n+\t\tglBindTexture(GL_TEXTURE_2D, 0);\n \t}\n \n-\tglActiveTexture(curgltextureunit);\n+\tglActiveTexture(GL_TEXTURE0);\n+\tstate.curTextureUnit = 0;\n \n \tcreateDefaultTexture();\n \n", "fix_pattern": "<pattern>: if OpenGL calls are used to query the current active texture unit and bound textures, replace the querying logic with direct calls to set the texture state, minimizing API calls and redundant state retrievals."}
{"number": 945, "change": "@@ -66,7 +66,7 @@ namespace mapnik\n         if (!png_ptr) return;\n \n         // switch on optimization only if supported\n-#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)\n+#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_MMX_CODE_SUPPORTED)\n         png_uint_32 mask, flags;\n \n         flags = png_get_asm_flags(png_ptr);\n", "fix_pattern": "<pattern>: if an API directive checks for specific library versions or features, ensure that the check is using the correct defined macros for the intended assembly optimizations (i.e., update from PNG_ASSEMBLER_CODE_SUPPORTED to PNG_MMX_CODE_SUPPORTED)."}
{"number": 949, "change": "@@ -155,10 +155,13 @@ inline BOOL Win32uiHostGlue::DynamicApplicationInit(const TCHAR *cmd, const TCHA\n     TCHAR err_buf[256];\n     // It's critical Python is loaded *and initialized* before we load win32ui\n     // as just loading win32ui will cause it to call into Python.\n-    const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n-    for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n-        wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n-        hModCore = LoadLibrary(fname);\n+    hModCore = GetModuleHandle(py_dll);  // Check if Python is already loaded\n+    if (hModCore == NULL) {\n+        const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n+        for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n+            wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n+            hModCore = LoadLibrary(fname);\n+        }\n     }\n     if (hModCore == NULL) {\n         wsprintf(err_buf, _T(\"The application can not locate %s (%d)\\n\"), py_dll, GetLastError());\n", "fix_pattern": "<pattern>: if loading a library using LoadLibrary, first check if the library is already loaded using GetModuleHandle to avoid unnecessary calls to LoadLibrary, which can improve performance by reducing the overhead of multiple library load attempts."}
{"number": 954, "change": "@@ -378,14 +378,8 @@ bool PlVkRenderer::initialize(PDECODER_PARAMETERS params)\n \n     pl_vk_inst_params vkInstParams = pl_vk_inst_default_params;\n     {\n-        bool ok;\n-        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\", &ok);\n-        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\", &ok);\n-#ifdef QT_DEBUG\n-        if (!ok) {\n-            vkInstParams.debug = true;\n-        }\n-#endif\n+        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\");\n+        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\");\n     }\n     vkInstParams.get_proc_addr = (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();\n     vkInstParams.extensions = instanceExtensions.data();\n", "fix_pattern": "<pattern>: if the second parameter of `qEnvironmentVariableIntValue` is not utilized, remove it to avoid unnecessary performance overhead associated with passing an unused pointer."}
{"number": 959, "change": "@@ -38,15 +38,15 @@ void UpdateDetector::versionCheck( Theme *theme )\n     QUrl url(\"http://download.owncloud.com/clientupdater.php\");\n     QString ver = QString(\"%1.%2.%3\").arg(MIRALL_VERSION_MAJOR).arg(MIRALL_VERSION_MINOR).arg(MIRALL_VERSION_MICRO);\n \n-    QString platform = QString::fromLocal8Bit(\"stranger\");\n+    QString platform = QLatin1String(\"stranger\");\n #ifdef Q_OS_LINUX\n-    platform = QString::fromLocal8Bit(\"linux\");\n+    platform = QLatin1String(\"linux\");\n #endif\n #ifdef Q_OS_WIN32\n-    platform = QString::fromLocal8Bit( \"win32\" );\n+    platform = QLatin1String( \"win32\" );\n #endif\n #ifdef Q_OS_MACOS\n-    platform = QString::fromLocal8Bit( \"macos\" );\n+    platform = QLatin1String( \"macos\" );\n #endif\n \n     url.addQueryItem( \"version\", ver );\n", "fix_pattern": "<pattern>: if QString::fromLocal8Bit is used with static strings, replace it with QLatin1String for better performance since QLatin1String is optimized for such use cases in the Qt framework."}
{"number": 963, "change": "@@ -218,8 +218,6 @@ void table_t::stop()\n         time(&start);\n \n         fprintf(stderr, \"Sorting data and creating indexes for %s\\n\", name.c_str());\n-        pgsql_exec_simple(sql_conn, PGRES_COMMAND_OK, (fmt(\"ANALYZE %1%\") % name).str());\n-        fprintf(stderr, \"Analyzing %s finished\\n\", name.c_str());\n \n         // Special handling for empty geometries because geohash chokes on\n         // empty geometries on postgis 1.5.\n", "fix_pattern": "<pattern>: if a call to `pgsql_exec_simple` is immediately followed by a logging statement using `fprintf`, consider using a logging mechanism that combines both actions to reduce overhead from executing two separate functions in tight succession."}
{"number": 969, "change": "@@ -1100,9 +1100,11 @@ void Loader::fillEvaluationObject(const ScopeChain::Ptr &scope, LanguageObject *\n void Loader::fillEvaluationObjectBasics(const ScopeChain::Ptr &scopeChain, LanguageObject *object, EvaluationObject *evaluationObject)\n {\n     // append the property declarations\n-    foreach (const PropertyDeclaration &pd, object->propertyDeclarations)\n-        if (!evaluationObject->scope->declarations.contains(pd.name))\n-            evaluationObject->scope->declarations.insert(pd.name, pd);\n+    foreach (const PropertyDeclaration &pd, object->propertyDeclarations) {\n+        PropertyDeclaration &scopePropertyDeclaration = evaluationObject->scope->declarations[pd.name];\n+        if (!scopePropertyDeclaration.isValid())\n+            scopePropertyDeclaration = pd;\n+    }\n \n     applyFunctions(&m_engine, object, evaluationObject, scopeChain);\n     applyBindings(object, scopeChain);\n", "fix_pattern": "<pattern>: if multiple calls to check for existence and then insert into a map are detected, refactor the code to access the map once and modify the existing value if it is invalid, which reduces the overhead of multiple lookups."}
{"number": 971, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if string join operations are performed with regular char or QString, replace them with QLatin1Char for improved performance when dealing with Latin-1 encoded strings, as it avoids unnecessary conversions."}
{"number": 973, "change": "@@ -1,5 +1,6 @@\n #include \"TextureGL.h\"\n #include <cassert>\n+#include \"utils.h\"\n \n namespace Graphics {\n \n@@ -109,16 +110,18 @@ TextureGL::~TextureGL()\n void TextureGL::Update(const void *data, const vector2f &dataSize, ImageFormat format, ImageType type)\n {\n \tglEnable(m_target);\n+\tglBindTexture(m_target, m_texture);\n \n \tswitch (m_target) {\n \t\tcase GL_TEXTURE_2D:\n-\t\t\tglTexImage2D(m_target, 0, GLTextureFormat(GetDescriptor().format), dataSize.x, dataSize.y, 0, GLImageFormat(format), GLImageType(type), data);\n+\t\t\tglTexSubImage2D(m_target, 0, 0, 0, dataSize.x, dataSize.y, GLImageFormat(format), GLImageType(type), data);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tassert(0);\n \t}\n \n+\tglBindTexture(m_target, 0);\n \tglDisable(m_target);\n }\n \n", "fix_pattern": "<pattern>: if a texture is being created or updated with glTexImage2D, replace it with glBindTexture and glTexSubImage2D to optimize the texture upload process, as the latter can update an existing texture without recreating it, reducing overhead and potentially improving performance."}
{"number": 979, "change": "@@ -1078,11 +1078,12 @@ void QIcon::addFile(const QString &fileName, const QSize &size, Mode mode, State\n     if (!d) {\n \n         QFileInfo info(fileName);\n-        QIconEngine *engine = iconEngineFromSuffix(fileName, info.suffix());\n+        QString suffix = info.suffix();\n #ifndef QT_NO_MIMETYPE\n-        if (!engine)\n-            engine = iconEngineFromSuffix(fileName, QMimeDatabase().mimeTypeForFile(info).preferredSuffix());\n+        if (suffix.isEmpty())\n+            suffix = QMimeDatabase().mimeTypeForFile(info).preferredSuffix(); // determination from contents\n #endif // !QT_NO_MIMETYPE\n+        QIconEngine *engine = iconEngineFromSuffix(fileName, suffix);\n         d = new QIconPrivate(engine ? engine : new QPixmapIconEngine);\n     }\n \n", "fix_pattern": "<pattern>: if an icon engine is retrieved using a suffix derived from the filename that depends on file info, first check if the suffix is empty and retrieve it conditionally only once, storing it in a variable to avoid redundant calls for the same operation."}
{"number": 984, "change": "@@ -859,9 +859,9 @@ void GLPaintContour::finalize_geometry()\n \n     if (!this->contour_indices.empty()) {\n         glsafe(::glGenBuffers(1, &this->m_contour_EBO_id));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, this->m_contour_EBO_id));\n-        glsafe(::glBufferData(GL_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, 0));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this->m_contour_EBO_id));\n+        glsafe(::glBufferData(GL_ELEMENT_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));\n         this->contour_indices.clear();\n     }\n }\n", "fix_pattern": "<pattern>: if the OpenGL API is being used to bind and buffer a data array, ensure to use the appropriate buffer type that matches the intended usage; replace `GL_ARRAY_BUFFER` with `GL_ELEMENT_ARRAY_BUFFER` when dealing with element indices to enhance performance and correctness."}
{"number": 986, "change": "@@ -461,7 +461,7 @@ void QPainterPrivate::draw_helper(const QPainterPath &originalPath, DrawOperatio\n     p.drawPath(originalPath);\n \n #ifndef QT_NO_DEBUG\n-    static bool do_fallback_overlay = qgetenv(\"QT_PAINT_FALLBACK_OVERLAY\").size() > 0;\n+    static bool do_fallback_overlay = !qEnvironmentVariableIsEmpty(\"QT_PAINT_FALLBACK_OVERLAY\");\n     if (do_fallback_overlay) {\n         QImage block(8, 8, QImage::Format_ARGB32_Premultiplied);\n         QPainter pt(&block);\n", "fix_pattern": "<pattern>: if checking for the existence of an environment variable using qgetenv and then calling size() on its return is done, replace it with directly using qEnvironmentVariableIsEmpty for better performance and clarity."}
{"number": 988, "change": "@@ -562,9 +562,9 @@ void DapEngine::updateItem(const QString &iname)\n void DapEngine::reexpandItems(const QSet<QString> &inames)\n {\n     QSet<QString> expandedInames = inames;\n-    const QList<QString> &watcherNames = watchHandler()->watcherNames().keys();\n-    for (const QString &inames : watcherNames)\n-        expandedInames.insert(watchHandler()->watcherName(inames));\n+    const auto &watcherNames = watchHandler()->watcherNames();\n+    for (auto it = watcherNames.begin(); it != watcherNames.end(); ++it)\n+        expandedInames.insert(watchHandler()->watcherName(it.key()));\n \n     QList<QString> inamesVector = expandedInames.values();\n     inamesVector.sort();\n", "fix_pattern": "<pattern>: if a QList's keys() method is used to retrieve keys, then refactor the code to operate directly on the QList to reduce unnecessary intermediate copies and improve iterator access for performance."}
{"number": 989, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if the code is using QString to perform string joining and manipulation, replace character literals with QLatin1Char() to optimize performance and reduce overhead in character operations within QString methods."}
{"number": 992, "change": "@@ -184,7 +184,7 @@ void QXcbConnection::xi2Select(xcb_window_t window)\n     mask.mask_len = sizeof(bitMask);\n     mask.mask = xiBitMask;\n     // Enable each touchscreen\n-    foreach (XInput2DeviceData *dev, m_touchDevices.values()) {\n+    foreach (XInput2DeviceData *dev, m_touchDevices) {\n         mask.deviceid = dev->xiDeviceInfo->deviceid;\n         Status result = XISelectEvents(xDisplay, window, &mask, 1);\n         // If we have XInput >= 2.2 and successfully enable a touchscreen, then\n", "fix_pattern": "<pattern>: if accessing elements of a QList via the values() method results in performance overhead, replace it by directly iterating over the QList to avoid unnecessary copying of the underlying data."}
{"number": 997, "change": "@@ -253,11 +253,6 @@ void OpenGLShaderRenderer::renderCrossair(const Common::Point crossairPosition)\n \t_triangleShader->setUniform(\"useStipple\", false);\n \t_triangleShader->setUniform(\"mvpMatrix\", identity);\n \n-\tglMatrixMode(GL_PROJECTION);\n-\tglLoadIdentity();\n-\tglOrtho(0, _screenW, _screenH, 0, 0, 1);\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglLoadIdentity();\n \tglEnable(GL_BLEND);\n \tglBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ZERO);\n \n", "fix_pattern": "<pattern>: if multiple OpenGL matrix operations are called in a sequence, it's beneficial to group them under a single matrix mode and minimize state changes to improve performance."}
{"number": 998, "change": "@@ -116,11 +116,7 @@ void Mesh::render() const {\n void Mesh::render(uint32_t mode, int count, int offset) const {\n     glBindVertexArray(_vao);\n     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _ibo);\n-\n     glDrawElements(mode, count, GL_UNSIGNED_SHORT, reinterpret_cast<void *>(offset));\n-\n-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n-    glBindVertexArray(0);\n }\n \n void Mesh::computeAABB() {\n", "fix_pattern": "<pattern>: if glBindBuffer and glBindVertexArray are being called with the argument 0, it may indicate an intention to unbind or reset state. This can be simplified or optimized by considering whether these calls are necessary, or if their logic can be handled more effectively within the rendering pipeline. If performance is a priority, it may be beneficial to review and restrict unnecessary state changes."}
{"number": 1000, "change": "@@ -194,7 +194,7 @@ inline void GlTexture::Upload(\n     GLenum data_format, GLenum data_type\n ) {\n     Bind();\n-    glTexSubImage2D(GL_TEXTURE_2D,0,0,0,width,height,data_format,data_type,data);\n+    glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, data_format, data_type, data);\n     CheckGlDieOnError();\n }\n \n", "fix_pattern": "<pattern>: when updating texture data for the whole texture, use glTexImage2D instead of glTexSubImage2D for improved performance, as the former can handle the entire texture in one call versus modifying sub-regions."}
{"number": 1002, "change": "@@ -32,14 +32,7 @@ GlobeGPS::GlobeGPS(QWidget* parent) : MarbleWidget(parent), loadedDives(0), edit\n \tQStringList list = mtm.mapThemeIds();\n \tQString  subsurfaceDataPath;\n \tQDir marble;\n-\tbool foundGoogleMap = false;\n-\tQ_FOREACH(const QString& theme, list){\n-\t\tif (theme == \"earth/googlesat/googlesat.dgml\"){\n-\t\t\tfoundGoogleMap = true;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tif (!foundGoogleMap) {\n+\tif (!list.contains(\"earth/googlesat/googlesat.dgml\")) {\n \t\tsubsurfaceDataPath = getSubsurfaceDataPath(\"marbledata\");\n \t\tif (subsurfaceDataPath != \"\") {\n \t\t\tMarbleDirs::setMarbleDataPath(subsurfaceDataPath);\n", "fix_pattern": "<pattern>: if a loop is used to check for the existence of an item in a QStringList, replace it with the QStringList::contains() method for better performance and readability."}
{"number": 1010, "change": "@@ -89,9 +89,6 @@ void vw_Start2DMode(GLdouble zNear, GLdouble zFar)\n  */\n void vw_End2DMode()\n {\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglPopMatrix();\n-\n \t// we don't switch to 0 unit, in 2D mode only 0 unit should be used\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n@@ -100,6 +97,7 @@ void vw_End2DMode()\n \tglPopMatrix();\n \n \tglMatrixMode(GL_MODELVIEW);\n+\tglPopMatrix();\n \n \tglPopAttrib();\n }\n", "fix_pattern": "<pattern>: if glMatrixMode(GL_MODELVIEW) is called immediately before glPopMatrix(), it can be removed to avoid unnecessary state changes, as glPopMatrix() resets the matrix without needing to set the mode first."}
{"number": 1018, "change": "@@ -602,12 +602,20 @@ void Database::PurgeExpiredInstances()\n \t\treturn;\n \t}\n \n+\tstd::vector<std::string> instance_ids;\n \tfor (auto row = results.begin(); row != results.end(); ++row) {\n-\t\tquery = StringFormat(\"DELETE FROM instance_list WHERE id=%u\", atoi(row[0]));\n-\t\tQueryDatabase(query);\n-\n-\t\tDeleteInstance(atoi(row[0]));\n+\t\tinstance_ids.emplace_back(row[0]);\n \t}\n+\n+\tstd::string imploded_instance_ids = implode(\",\", instance_ids);\n+\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list_player WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM respawn_times WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM spawn_condition_values WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"UPDATE character_corpses SET is_buried = 1, instance_id = 0 WHERE instance_id IN ({})\", imploded_instance_ids));\n+\n+\t\n }\n \n void Database::SetInstanceDuration(uint16 instance_id, uint32 new_duration)\n", "fix_pattern": "<pattern>: if multiple deletes and an update are performed on the same instance_id, consolidate them into a single query for better performance by using a formatted string that incorporates instance_ids as a comma-separated list. This reduces the number of separate database calls and can improve overall efficiency."}
{"number": 1020, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified before being passed to the JS_DefinePropertyById function, and to simplify the call, set the configurable attribute directly on the descriptor and pass it without individually specifying getter, setter, and attributes. This reduces the overhead of constructing the property descriptor with multiple parameters and improves readability."}
{"number": 1021, "change": "@@ -23,6 +23,7 @@\n #include <map>\n #include <tuple>\n #include <chrono>\n+#include <cassert>\n \n #include \"async_handler.h\"\n #include \"cache.h\"\n@@ -274,13 +275,13 @@ namespace {\n \t\t\treturn LoadDummyBitmap<T>(s.directory, f);\n \t\t}\n \n+#ifndef NDEBUG\n \t\t// Test if the file was requested asynchronously before.\n \t\t// If not the file can't be expected to exist -> bug.\n-\t\tFileRequestAsync* request = AsyncHandler::RequestFile(s.directory, f);\n-\t\tif (!request->IsReady()) {\n-\t\t\tOutput::Debug(\"BUG: File Not Requested: %s/%s\", s.directory, f.c_str());\n-\t\t\treturn BitmapRef();\n-\t\t}\n+\t\t// This test is expensive and turned off in release builds.\n+\t\tauto* req = AsyncHandler::RequestFile(s.directory, f);\n+\t\tassert(req != nullptr && req->IsReady());\n+#endif\n \n \t\tBitmapRef ret = LoadBitmap(s.directory, f, transparent, Bitmap::Flag_ReadOnly | (\n \t\t\t\t\t\t\t\t\t\t T == Material::Chipset? Bitmap::Flag_Chipset:\n", "fix_pattern": "<pattern>: if a check for readiness is performed during debugging, replace the runtime check with an assert to avoid performance overhead in release builds while still ensuring the condition is verified during development."}
{"number": 1028, "change": "@@ -118,7 +118,8 @@ KFileItemModelRolesUpdater::KFileItemModelRolesUpdater(KFileItemModel *model, QO\n     m_directoryContentsCounter = new KDirectoryContentsCounter(m_model, this);\n     connect(m_directoryContentsCounter, &KDirectoryContentsCounter::result, this, &KFileItemModelRolesUpdater::slotDirectoryContentsCountReceived);\n \n-    const auto plugins = KPluginMetaData::findPlugins(QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\"));\n+    const QString pluginNamespace = QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\");\n+    const auto plugins = KPluginMetaData::findPlugins(pluginNamespace, {}, KPluginMetaData::AllowEmptyMetaData);\n     for (const KPluginMetaData &data : plugins) {\n         auto instance = QPluginLoader(data.fileName()).instance();\n         auto plugin = qobject_cast<KOverlayIconPlugin *>(instance);\n", "fix_pattern": "<pattern>: if constructing a namespace string for KPluginMetaData::findPlugins involves repeated string manipulations, refactor the creation of the string into a separate variable to enhance readability and performance, while ensuring consistent use of the API."}
{"number": 1029, "change": "@@ -172,7 +172,8 @@ void SignalHistoryModel::onObjectAdded(QObject* object)\n   Q_ASSERT(thread() == QThread::currentThread());\n \n   // blacklist event dispatchers\n-  if (QString(object->metaObject()->className()).startsWith(\"QPAEventDispatcher\"))\n+  if (qstrncmp(object->metaObject()->className(), \"QPAEventDispatcher\", 18) == 0\n+    || qstrncmp(object->metaObject()->className(), \"QGuiEventDispatcher\", 19) == 0)\n     return;\n \n   beginInsertRows(QModelIndex(), m_tracedObjects.size(), m_tracedObjects.size());\n", "fix_pattern": "<pattern>: if a QString method is used to check for a prefix, replace it with qstrncmp for improved performance by avoiding QString overhead, especially in scenarios where only a few characters of comparison are needed."}
{"number": 1040, "change": "@@ -30,7 +30,7 @@\n #include \"vtkIdTypeArray.h\"\n #include \"vtkObjectFactory.h\"\n \n-vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18\");\n+vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18.6.1\");\n vtkStandardNewMacro(vtkDataSetAttributes);\n \n //--------------------------------------------------------------------------\n@@ -1470,16 +1470,16 @@ void vtkDataSetAttributes::CopyData(vtkDataSetAttributes::FieldList& list,\n                                     vtkDataSetAttributes* fromDSA,\n                                     int idx, vtkIdType fromId, vtkIdType toId)\n {\n-  vtkDataArray *fromDA;\n-  vtkDataArray *toDA;\n+  vtkAbstractArray *fromDA;\n+  vtkAbstractArray *toDA;\n   \n   int i;\n   for (i=0; i < list.NumberOfFields; i++)\n     {\n     if ( list.FieldIndices[i] >= 0 )\n       {\n-      toDA = this->GetArray(list.FieldIndices[i]);\n-      fromDA = fromDSA->GetArray(list.DSAIndices[idx][i]);\n+      toDA = this->GetAbstractArray(list.FieldIndices[i]);\n+      fromDA = fromDSA->GetAbstractArray(list.DSAIndices[idx][i]);\n       this->CopyTuple(fromDA, toDA, fromId, toId);\n       }\n     }\n", "fix_pattern": "<pattern>: if a specific API (vtkDataArray*) is replaced by a more generalized one (vtkAbstractArray*), it may indicate a move to more versatile or polymorphic data handling, which can improve performance through more efficient memory management and reduced type-checking overhead when handling datasets."}
{"number": 1041, "change": "@@ -57,7 +57,7 @@ extern \"C\" vtkglX::__GLXextFuncPtr glXGetProcAddressARB(const GLubyte *);\n // GLU is currently not linked in VTK.  We do not support it here.\n #define GLU_SUPPORTED   0\n \n-vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.29\");\n+vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.30\");\n vtkStandardNewMacro(vtkOpenGLExtensionManager);\n \n namespace vtkgl\n@@ -180,7 +180,7 @@ int vtkOpenGLExtensionManager::ExtensionSupported(const char *name)\n   // Workaround for a bug on renderer string=\"Quadro4 900 XGL/AGP/SSE2\"\n   // version string=\"1.5.8 NVIDIA 96.43.01\" or \"1.5.6 NVIDIA 87.56\"\n   // The driver reports it supports 1.5 but the 1.4 core promoted extension\n-  // GL_EXT_blend_func_separate is implemented in software.\n+  // GL_EXT_blend_func_separate is implemented in software (poor performance).\n   // All the NV2x chipsets are probably affected. NV2x chipsets are used\n   // in GeForce4 and Quadro4.\n   // It will make this method return false with \"GL_VERSION_1_4\" and true\n", "fix_pattern": "<pattern>: If a revision macro is updated to reflect a change in performance characteristics (from version 1.29 to 1.30) and includes a comment indicating poor performance related to a feature, then document the revision change alongside a performance note to provide context for why the change is notable."}
{"number": 1043, "change": "@@ -90,7 +90,7 @@ namespace rwe\n \n         glGenerateMipmap(GL_TEXTURE_2D);\n \n-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if the texture magnification filter could impact performance, and a performance improvement can be achieved by changing the filter from GL_LINEAR to GL_NEAREST, then update the parameter to use GL_NEAREST for better performance in scenarios where linear filtering is not necessary."}
{"number": 1052, "change": "@@ -64,7 +64,7 @@\n #define VTK_PV_ANIMATION_GROUP \"animateable\"\n \n vtkStandardNewMacro(vtkPVAnimationManager);\n-vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.47\");\n+vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.48\");\n vtkCxxSetObjectMacro(vtkPVAnimationManager, HorizantalParent, vtkKWWidget);\n vtkCxxSetObjectMacro(vtkPVAnimationManager, VerticalParent, vtkKWWidget);\n //*****************************************************************************\n@@ -205,7 +205,6 @@ void vtkPVAnimationManager::Create(vtkKWApplication* app, const char* )\n \n   this->ActiveTrackSelector->SetParent(\n     this->VAnimationInterface->GetSelectorFrame());\n-  this->ActiveTrackSelector->SetAnimationManager(this);\n   this->ActiveTrackSelector->Create(app, \"-relief flat\");\n   this->Script(\"pack %s -anchor n -side top -expand t -fill both\",\n     this->ActiveTrackSelector->GetWidgetName());\n", "fix_pattern": "<pattern>: if the vtkCxxRevisionMacro is updated to a new version number without changing any other logic or behavior in the code, correctly increment the versioning to reflect updates, indicating a potential change in functionality or fixes within the class."}
{"number": 1056, "change": "@@ -50,22 +50,15 @@ void dirvec_sort(struct dirvec *dv)\n \n struct directory *dirvec_find(const struct dirvec *dv, const char *path)\n {\n-\tchar *base;\n \tint i;\n-\tstruct directory *ret = NULL;\n-\n-\tbase = g_path_get_basename(path);\n \n \tdb_lock();\n \tfor (i = dv->nr; --i >= 0; )\n-\t\tif (!strcmp(directory_get_name(dv->base[i]), base)) {\n-\t\t\tret = dv->base[i];\n-\t\t\tbreak;\n-\t\t}\n+\t\tif (!strcmp(directory_get_name(dv->base[i]), path))\n+\t\t\treturn dv->base[i];\n \tdb_unlock();\n \n-\tg_free(base);\n-\treturn ret;\n+\treturn NULL;\n }\n \n int dirvec_delete(struct dirvec *dv, struct directory *del)\n", "fix_pattern": "<pattern>: if a temporary variable is used to hold the result of g_path_get_basename(path) only for comparison purposes, remove the unnecessary allocation of the temporary variable and directly compare the directory name with the original path instead."}
{"number": 1064, "change": "@@ -58,15 +58,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made to get and set file descriptor flags, combine them to reduce the number of system calls and avoid unnecessary operations when the new flags are equal to the old flags."}
{"number": 1078, "change": "@@ -45,11 +45,18 @@ ErrorOr<int> serenity_main(Main::Arguments arguments)\n \n     TRY(Core::System::pledge(\"stdio rpath exec\"));\n \n-    Vector<String> exec_environment_strings;\n     Vector<StringView> exec_environment;\n-    if (auto* term = getenv(\"TERM\")) {\n-        exec_environment_strings.append(String::formatted(\"TERM={}\", term));\n-        exec_environment.append(exec_environment_strings.last());\n+    for (size_t i = 0; environ[i]; ++i) {\n+        StringView env_view { environ[i] };\n+        auto maybe_needle = env_view.find('=');\n+\n+        if (!maybe_needle.has_value())\n+            continue;\n+\n+        if (env_view.substring_view(0, maybe_needle.value()) != \"TERM\"sv)\n+            continue;\n+\n+        exec_environment.append(env_view);\n     }\n \n     Vector<String> exec_arguments;\n", "fix_pattern": "<pattern>: if the code checks for a specific environment variable using getenv, refactor it to iterate through the `environ` array for potentially better performance and to handle cases where the environment variable may not exist or might be defined differently. This avoids the overhead of a string formatting operation unless necessary."}
{"number": 1082, "change": "@@ -76,7 +76,7 @@ static int newPage(const char *name, int level, int width, int height, int count\n \tglTexImage2D(GL_TEXTURE_2D, level, wz_texture_compression, width, height, 0,\n \t             GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n \tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n+\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if a texture filtering parameter is set using glTexParameteri(), consider switching from GL_LINEAR_MIPMAP_LINEAR to GL_NEAREST_MIPMAP_LINEAR to potentially improve performance due to the reduced computational cost of nearest filtering compared to linear filtering."}
{"number": 1086, "change": "@@ -76,15 +76,14 @@ void GlLine::draw(float,Camera *) {\n \t\tglLineStipple(factor,pattern);\n \t\tglEnable(GL_LINE_STIPPLE);\n \t}\n-\tglBegin(GL_LINE_STRIP);\n \n-\tfor(unsigned int i=0; i < _points.size(); ++i) {\n-\t\tif (i < _colors.size()) {\n-\t\t\tsetColor(_colors[i]);\n-\t\t}\n-\t\tglVertex3fv((float *)&_points[i]);\n-\t}\n-\tglEnd();\n+\tglEnableClientState(GL_VERTEX_ARRAY);\n+\tglEnableClientState(GL_COLOR_ARRAY);\n+\tglVertexPointer(3, GL_FLOAT, 3 * sizeof(float), &_points[0]);\n+\tglColorPointer(4, GL_UNSIGNED_BYTE, 4 * sizeof(unsigned char), &_colors[0]);\n+\tglDrawArrays(GL_LINE_STRIP, 0, _points.size());\n+\tglDisableClientState(GL_VERTEX_ARRAY);\n+\tglDisableClientState(GL_COLOR_ARRAY);\n \n \tOpenGlConfigManager::getInst().desactivateLineAndPointAntiAliasing();\n \n", "fix_pattern": "<pattern>: if OpenGL drawing commands use `glBegin` and `glEnd` for drawing multiple vertices and colors, refactor the code to use vertex array capabilities, enabling the appropriate client states and using `glDrawArrays` for improved performance and reduced overhead."}
{"number": 1089, "change": "@@ -563,7 +563,6 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n     int return_code;\n     LSTATUS status;\n     unsigned int i;\n-    char str[256];\n     VkResult res;\n \n     WINE_TRACE(\"Starting VR info initialization.\\n\");\n@@ -587,14 +586,8 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n         WINE_ERR(\"Could not get IVRClientCore, error %d.\\n\", return_code);\n     }\n \n-    if ((env_str = getenv(\"SteamGameId\")))\n-        app_id = atoi(env_str);\n-    else\n-        app_id = 1245040; /* Proton 5.0 */\n-\n     /* Without overriding the app_key vrclient waits 2 seconds for a valid appkey before returning. */\n-    sprintf(str, \"{ \\\"app_key\\\" : \\\"steam.app.%u\\\" }\", app_id);\n-    error = client_core->Init(vr::VRApplication_Background, str);\n+    error = client_core->Init(vr::VRApplication_Background, NULL);\n     if (error != vr::VRInitError_None)\n     {\n         if (error == vr::VRInitError_Init_NoServerForBackgroundApp)\n", "fix_pattern": "<pattern>: if the initialization of a string with `sprintf` for API calls is unnecessary (as seen in the removal of dynamic app_id generation), directly pass `NULL` to avoid unnecessary string manipulation and potential performance overhead."}
{"number": 1092, "change": "@@ -88,13 +88,18 @@ QVariant DateFilter::doFilter(const QVariant &input, const QVariant &argument,\n                               bool autoescape) const\n {\n   Q_UNUSED(autoescape)\n-  auto d = QDateTime::fromString(getSafeString(input),\n+    QDateTime d;\n+    if (input.type() == QVariant::DateTime) {\n+        d = input.toDateTime();\n+    } else if (input.type() == QVariant::Date) {\n+        d.setDate(input.toDate());\n+    } else {\n #if QT_VERSION < QT_VERSION_CHECK(5, 11, 0)\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss\"));\n #else\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\"));\n #endif\n-  );\n+    }\n \n   auto argString = getSafeString(argument);\n \n", "fix_pattern": "<pattern>: if the input type is checked for QVariant::DateTime or QVariant::Date, avoid calling QDateTime::fromString multiple times and directly use toDateTime() and setDate() methods to improve performance by reducing redundant string conversions."}
{"number": 1093, "change": "@@ -213,7 +213,12 @@ void EffectChain::render_to_screen(unsigned char *src)\n \t\tassert(false);\n \t}\n \n-\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\tstatic bool first = true;\n+\tif (first) {\n+\t\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\t} else {\n+\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, format, GL_UNSIGNED_BYTE, src);\n+\t}\n \tcheck_error();\n \tglUniform1i(glGetUniformLocation(glsl_program_num, \"input_tex\"), 0);\n \n", "fix_pattern": "<pattern>: if the initial texture data is uploaded once using glTexImage2D, subsequent updates should be performed using glTexSubImage2D to improve performance by avoiding full texture reallocation. Use a flag to track whether it is the first call or not."}
{"number": 1103, "change": "@@ -383,8 +383,6 @@ void Renderer::render(uint32_t delta) {\n       const auto& batch = graphics_batches[i];\n       const auto program = batch.depth_shader.gl_program;\n       glUseProgram(program);\n-      glBindVertexArray(batch.gl_depth_vao);\n-\n       glUniformMatrix4fv(glGetUniformLocation(program, \"camera_view\"), 1, GL_FALSE, glm::value_ptr(camera_transform));\n       \n       // FIXME: These copies should happen outside of the render loop\n", "fix_pattern": "<pattern>: if glBindVertexArray is called redundantly, ensure that it's only called when necessary, potentially by checking if the current VAO is different from the one being bound to avoid unnecessary state changes."}
{"number": 1110, "change": "@@ -2459,7 +2459,6 @@ void MainScene(HDC hDC)\n \n         if (Success)\n         {\n-            glFlush();\n             SwapBuffers(hDC);\n         }\n \n", "fix_pattern": "<pattern>: if glFlush() is called without subsequent rendering commands that require completion, consider removing it or consolidating it to reduce unnecessary sync point overhead in OpenGL rendering."}
{"number": 1115, "change": "@@ -1573,7 +1573,7 @@ void KStartupInfoData::setApplicationId(const QString &desktop)\n     // the spec requires this is always a full path, in order for everyone to be able to find it\n     QString desk = QStandardPaths::locate(QStandardPaths::ApplicationsLocation, desktop);\n     if (desk.isEmpty()) {\n-        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, \"kservices5/\" + desktop);\n+        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, QLatin1String(\"kservices5/\") + desktop);\n     }\n     if (desk.isEmpty()) {\n         return;\n", "fix_pattern": "<pattern>: if a QString created from a literal is concatenated with another QString, use QLatin1String to avoid unnecessary conversion overhead for better performance."}
{"number": 1118, "change": "@@ -95,9 +95,9 @@ KAboutPerson KAboutPerson::fromJSON(const QJsonObject &obj)\n {\n     const QString name = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Name\"));\n     const QString task = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Task\"));\n-    const QString email = obj[QStringLiteral(\"Email\")].toString();\n-    const QString website = obj[QStringLiteral(\"Website\")].toString();\n-    const QUrl avatarUrl = obj[QStringLiteral(\"AvatarUrl\")].toVariant().toUrl();\n+    const QString email = obj.value(QLatin1String(\"Email\")).toString();\n+    const QString website = obj.value(QLatin1String(\"Website\")).toString();\n+    const QUrl avatarUrl = obj.value(QLatin1String(\"AvatarUrl\")).toVariant().toUrl();\n     return KAboutPerson(name, task, email, website, avatarUrl);\n }\n \n", "fix_pattern": "<pattern>: if accessing keys in a QJsonObject using QStringLiteral results in potential repeated conversions from QString to QByteArray, use QLatin1String instead for improved performance."}
{"number": 1119, "change": "@@ -99,9 +99,7 @@ KNotesApp::KNotesApp()\n {\n     Akonadi::ControlGui::widgetNeedsAkonadi(this);\n \n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n \n     if (KNotesGlobalConfig::self()->autoCreateResourceOnStart()) {\n         NoteShared::LocalResourceCreator *creator = new NoteShared::LocalResourceCreator(this);\n", "fix_pattern": "<pattern>: if checking for an environment variable and its value's emptiness, replace qgetenv and isEmpty with the more direct qEnvironmentVariableIsEmpty for improved performance."}
