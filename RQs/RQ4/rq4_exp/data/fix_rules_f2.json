{"number": 1, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.7 2005/06/12 17:21:53 brun Exp $\n+// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.8 2005/06/14 05:06:03 brun Exp $\n // Author: Wim Lavrijsen, Jan 2005\n \n // Bindings\n@@ -138,7 +138,7 @@ PyObject* PyROOT::RootObjectByValueExecutor::Execute( G__CallFunc* func, void* s\n    void* result2 = result1;\n    if ( fClass->GetClassInfo() && fClass->GetClassInfo()->Linkage() != -1 ) {\n       result2 = new char[ fClass->Size() ];\n-      mempcpy( result2, result1, fClass->Size() );\n+      memcpy( result2, result1, fClass->Size() );\n    }\n    G__pop_tempobject();            // doesn't call dtor\n \n", "fix_pattern": "<pattern>: if the code uses mempcpy unnecessarily when memcpy suffices, replace it with memcpy for improved performance since memcpy is typically optimized for this use case and avoids potential unnecessary complications."}
{"number": 3, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.30 2007/01/15 10:15:47 brun Exp $\n+// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.31 2007/02/06 11:48:48 rdm Exp $\n // Author: Fons Rademakers   11/09/95\n \n /*************************************************************************\n@@ -28,7 +28,6 @@\n #include \"TObjArray.h\"\n #include \"TError.h\"\n #include \"TROOT.h\"\n-#include \"TRandom.h\"\n \n ClassImp(TObjArray)\n \n@@ -615,7 +614,7 @@ void TObjArray::Randomize(Int_t ntimes)\n \n    for (Int_t i=0;i<ntimes;i++) {\n       for (Int_t j=0;j<fLast;j++) {\n-         Int_t k = (Int_t)gRandom->Uniform(0,fLast);\n+         Int_t k = (Int_t)(fLast*rand()/(RAND_MAX+1.0));\n          if (k == j) continue;\n          TObject *obj = fCont[j];\n          fCont[j] = fCont[k];\n", "fix_pattern": "<pattern>: if a call to gRandom->Uniform is replaced with a direct use of rand() from the Standard C Library, consider if this change is made to avoid the overhead or dependency of the ROOT Framework for simpler random number generation."}
{"number": 5, "change": "@@ -2859,7 +2859,7 @@ Int_t TGX11::SetTextFont(char *fontname, ETextSetMode mode)\n          XSetFont(fDisplay, *gGCtext, gTextFont->fid);\n          XSetFont(fDisplay, *gGCinvt, gTextFont->fid);\n          gFont[gCurrentFontNumber].id = gTextFont;\n-         strcpy(gFont[gCurrentFontNumber].name,fontname);\n+         strlcpy(gFont[gCurrentFontNumber].name,fontname,80);\n          gCurrentFontNumber++;\n          if (gCurrentFontNumber == kMAXFONT) gCurrentFontNumber = 0;\n       }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with strlcpy to ensure safety by preventing buffer overflows through size checking."}
{"number": 6, "change": "@@ -1058,7 +1058,7 @@ Bool_t TXMLPlayer::ProduceSTLstreamer(ostream& fs, TClass* cl, TStreamerSTL* el,\n       strlcpy(tabs2, tabs, sizeof(tabs2));\n \n       if (isptr) {\n-         strncat(tabs2, tab1, sizeof(tabs2));\n+         strlcat(tabs2, tab1, sizeof(tabs2));\n          fs << tabs << \"if (\" << (isarr ? \"*cont\" : \"cont\") << \"==0) {\" << endl;\n          fs << tabs2 << \"buf.WriteSTLsize(0\" << (isstr ? \",true);\" : \");\") << endl;\n          fs << tabs << \"} else {\" << endl;\n", "fix_pattern": "<pattern>: if using strncat for concatenating strings, replace it with strlcat to improve safety and avoid buffer overflow issues, as strlcat provides better boundary checks compared to strncat."}
{"number": 8, "change": "@@ -558,15 +558,15 @@ void ProofdExec()\n       char *buf = (char *) vb;\n       char *end = buf + len;\n       const char name[] = \"PROOF_ALLVARS=\";\n-      char *all = new char[strlen(name)+len]; // strlen(\"PROOF_ALLVARS=\") = 14\n-      strncpy(all, name, strlen(name)+len);\n-      all[strlen(name)+len-1] = 0;\n+      int alen = strlen(name)+len;\n+      char *all = new char[alen]; // strlen(\"PROOF_ALLVARS=\") = 14\n+      strlcpy(all, name, alen);\n       while (buf < end) {\n          if (gDebug > 0) ErrorInfo(\"ProofdExec: setting: %s\", buf);\n          char *p = index(buf, '=');\n          if (p) {\n-            if (buf != (char *) vb) strncat(all, \",\", 1); // skip the first one\n-            strncat(all, buf, p-buf);\n+            if (buf != (char *) vb) strlcat(all, \",\", alen); // skip the first one\n+            strlcat(all, buf, alen);\n             putenv(buf);\n          }\n          buf += strlen(buf) + 1;\n", "fix_pattern": "<pattern>: if string manipulation is done using strncpy and strncat, replace them with strlcpy and strlcat for improved safety and performance, as strlcpy and strlcat not only copy and concatenate strings but also ensure null-termination and respect buffer sizes more effectively."}
{"number": 13, "change": "@@ -24,10 +24,7 @@ pythonizations.\n PyObject *CallPyObjMethod(PyObject *obj, const char *meth)\n {\n    // Helper; call method with signature: obj->meth()\n-   Py_INCREF(obj);\n-   PyObject* result = PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n-   Py_DECREF(obj);\n-   return result;\n+   return PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n }\n \n TClass *GetTClass(const CPyCppyy::CPPInstance *pyobj)\n", "fix_pattern": "<pattern>: if a reference counting operation is followed immediately by an API call and then a decref, it's unnecessary to increment the reference count before the call and decrement it after, as the called method is expected to manage the reference count appropriately. Thus, directly call the method without the extra reference counting."}
{"number": 15, "change": "@@ -46,7 +46,7 @@ void uThread::destory(bool force = false) {\n     //check whether we should cache it or not\n     totalNumberofUTs--;\n     if (slowpath(force) || (utCache.push(this) < 0)) {\n-        free((ptr_t) (stackBottom));       //Free the allocated memory for stack\n+        munmap((ptr_t) (stackBottom), stackSize);       //Free the allocated memory for stack\n     }\n }\n \n", "fix_pattern": "<pattern>: if freeing memory that was allocated with mmap or similar methods, use munmap instead of free to ensure proper memory deallocation in line with the allocation method used."}
{"number": 24, "change": "@@ -128,14 +128,14 @@ void MonitorPictureDialog::updateMonitorWidgets(QString primaryMonitor)\n \n     for (MonitorPicture *picture : qAsConst(pictures)) {\n         if (picture->monitorWidget->output->name() == primaryMonitor\n-                || primaryMonitor == QStringLiteral(\"\")) {\n+                || primaryMonitor == QLatin1String()) {\n             x0 = picture->originX + picture->pos().x();\n             y0 = picture->originY + picture->pos().y();\n             break;\n         }\n     }\n \n-    if( primaryMonitor == QStringLiteral(\"\") ) {\n+    if( primaryMonitor == QLatin1String() ) {\n         for(MonitorPicture *picture : qAsConst(pictures)) {\n             int x1 = picture->originX + picture->pos().x();\n             int y1 = picture->originY + picture->pos().y();\n", "fix_pattern": "<pattern>: if a comparison against an empty QStringLiteral is detected, replace it with a comparison against QLatin1String() for improved performance, as QLatin1String is more efficient for this use case in Qt Framework."}
{"number": 29, "change": "@@ -557,9 +557,7 @@ template<typename real_t, typename index_t>\n \n #ifdef HAVE_MPI\n     if(nprocs>1){\n-      double lpredicted;\n-      MPI_Allreduce(&predicted, &lpredicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n-      predicted = lpredicted;\n+      MPI_Allreduce(MPI_IN_PLACE, &predicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n     }\n #endif\n     \n", "fix_pattern": "<pattern>: if a variable is used to receive a result from MPI_Allreduce and then assigned back to an original variable, simplify the call by using MPI_IN_PLACE to avoid unnecessary data copying, allowing for in-place reduction."}
{"number": 32, "change": "@@ -46,10 +46,11 @@\n // zlib compress2 function resulted in a 40+% reduction versus the original image.\n uint8_t* GFXRECON_zlib_compress2(uint8_t* data, int32_t data_len, int32_t* out_len, int32_t quality)\n {\n-    uint8_t* target = reinterpret_cast<uint8_t*>(malloc(data_len));\n+    unsigned long alloc_len = compressBound(data_len);\n+    uint8_t*      target    = reinterpret_cast<uint8_t*>(malloc(alloc_len));\n     if (nullptr != target)\n     {\n-        unsigned long ret_len = data_len;\n+        unsigned long ret_len = alloc_len;\n         if (Z_OK == compress2(target, &ret_len, data, data_len, quality))\n         {\n             *out_len = ret_len;\n", "fix_pattern": "<pattern>: when allocating memory for compressed data, use `compressBound(data_len)` to ensure sufficient space is allocated to accommodate compressed bytes instead of the uncompressed data length."}
{"number": 39, "change": "@@ -20,14 +20,14 @@\n #include \"vtkByteSwap.h\"\n #include \"vtkCellData.h\"\n #include \"vtkDataArray.h\"\n-#include \"vtkDataCompressor.h\"\n+#include \"vtkZLibDataCompressor.h\"\n #include \"vtkDataSet.h\"\n #include \"vtkOutputStream.h\"\n #include \"vtkPointData.h\"\n #include \"vtkPoints.h\"\n #include \"vtkUnsignedCharArray.h\"\n \n-vtkCxxRevisionMacro(vtkXMLWriter, \"1.14\");\n+vtkCxxRevisionMacro(vtkXMLWriter, \"1.15\");\n vtkCxxSetObjectMacro(vtkXMLWriter, Compressor, vtkDataCompressor);\n \n //----------------------------------------------------------------------------\n@@ -55,7 +55,7 @@ vtkXMLWriter::vtkXMLWriter()\n \n   // Initialize compression data.\n   this->BlockSize = 32768;\n-  this->Compressor = 0;\n+  this->Compressor = vtkZLibDataCompressor::New();\n   this->CompressionHeader = 0;\n   \n   this->EncodeAppendedData = 1;\n", "fix_pattern": "<pattern>: if a class is updated to use a more efficient compression method (from a null pointer to a specific compressor implementation), replace null compressor assignment with the new compressor instantiation for improved data handling efficiency."}
{"number": 41, "change": "@@ -956,9 +956,8 @@ int vtkGDALRasterReader::RequestData(vtkInformation* vtkNotUsed(request),\n   }\n \n   // Get the projection.\n-  char* proj = strdup(this->Impl->GDALData->GetProjectionRef());\n-  this->ProjectionWKT = proj;\n-  OGRSpatialReference spRef(proj);\n+  this->ProjectionWKT = this->Impl->GDALData->GetProjectionRef();\n+  OGRSpatialReference spRef(this->ProjectionWKT.c_str());\n \n   char* projection;\n   spRef.exportToProj4(&projection);\n", "fix_pattern": "<pattern>: if a string is obtained from an API and duplicated using strdup, directly assign the string to a member variable (e.g., std::string) to avoid unnecessary memory allocation and copying, and use the underlying c_str() method for interoperability with C APIs."}
{"number": 47, "change": "@@ -180,11 +180,16 @@ void ProblemReporter::reparse()\n     if( !m_javaSupport->isValid() )\n \treturn;\n \n+    // @todo: use the project database to decide which files to parse instead of this!\n+    // ugly hack: do not parse non .java ending files\n+    if ( !m_fileName.endsWith(\".java\") )\n+        return;\n+\n     m_timer->stop();\n \n     kdDebug(9013) << \"ProblemReporter::reparse()\" << endl;\n     m_javaSupport->backgroundParser()->addFile( m_fileName );\n-    kdDebug(9013) << \"---> file added\" << endl;\n+    kdDebug(9013) << \"---> file added \" << m_fileName << endl;\n }\n \n void ProblemReporter::slotSelected( QListViewItem* item )\n", "fix_pattern": "<pattern>: if logging a debug message occurs unconditionally, introduce a condition to skip logging for certain cases (such as files that do not end with a specific extension) to avoid unnecessary performance costs from function calls and streamline the logging process."}
{"number": 54, "change": "@@ -16,7 +16,7 @@\n #include <QKeyEvent>\n #include <QKeySequence>\n #include <QList>\n-#include <QRegExp>\n+#include <QRegularExpression>\n #include <QStandardPaths>\n #include <QString>\n #include <QStringList>\n@@ -370,7 +370,7 @@ KeyboardMacrosPluginCommands::KeyboardMacrosPluginCommands(KeyboardMacrosPlugin\n \n bool KeyboardMacrosPluginCommands::exec(KTextEditor::View *view, const QString &cmd, QString &msg, const KTextEditor::Range &)\n {\n-    QStringList actionAndName = cmd.split(QRegExp(QStringLiteral(\"\\\\s+\")));\n+    QStringList actionAndName = cmd.split(QRegularExpression(QStringLiteral(\"\\\\s+\")));\n     if (actionAndName.length() != 2) {\n         msg = i18n(\"Usage: %1 <name>.\", actionAndName.at(0));\n         return false;\n", "fix_pattern": "<pattern>: if using QRegExp for regular expression operations, replace it with QRegularExpression for better performance and support for Unicode properties."}
{"number": 62, "change": "@@ -65,9 +65,8 @@ int main(int argc, char **argv)\n                     // that makes the operation much heavier than it needs to be\n                     isWallpaper = true;\n                 } else {\n-                    if (QFileInfo(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile)).exists()\n-                    || QFileInfo(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile)).exists()\n-                    ) {\n+                    if (QFileInfo::exists(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile))\n+                        || QFileInfo::exists(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile))) {\n                         isWallpaper = true;\n                         isKPackage = true;\n                         // Similarly to above, we could read all the information out of the kpackage, but\n", "fix_pattern": "<pattern>: if the QFileInfo constructor is used just to check for file existence, replace it with the QFileInfo::exists static method to improve performance by avoiding unnecessary object creation."}
{"number": 64, "change": "@@ -123,7 +123,9 @@ void fill_curl_eh(CURL *eh, C_Element *cube, bool isOverlay, FtpElement *elem) {\n     curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, my_fwrite);\n     curl_easy_setopt(eh, CURLOPT_WRITEDATA, elem);\n     curl_easy_setopt(eh, CURLOPT_PRIVATE, elem);\n-    curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    //curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_LIMIT, 1);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_TIME, 10);\n     curl_easy_setopt(eh, CURLOPT_CONNECTTIMEOUT, 10);\n     curl_multi_add_handle(curlm, eh);\n }\n", "fix_pattern": "<pattern>: if a timeout option is set on a CURL handle, consider using low-speed options instead to avoid cancelling connections with low traffic that may still be valid, enhancing the performance of network operations."}
{"number": 67, "change": "@@ -1276,14 +1276,7 @@ FileDescriptor V4L2VideoDevice::exportDmabufFd(unsigned int index,\n \t\treturn FileDescriptor();\n \t}\n \n-\tFileDescriptor fd(expbuf.fd);\n-\t/*\n-\t * FileDescriptor takes a duplicate of fd, so we must close the\n-\t * original here, otherwise it will be left dangling.\n-\t */\n-\t::close(expbuf.fd);\n-\n-\treturn fd;\n+\treturn FileDescriptor(std::move(expbuf.fd));\n }\n \n /**\n", "fix_pattern": "<pattern>: if a duplicate of a file descriptor is created and the original is closed immediately after, use std::move to transfer ownership of the file descriptor directly into the FileDescriptor constructor to eliminate the need for an intermediate variable and potential dangling reference."}
{"number": 70, "change": "@@ -1,12 +1,12 @@\n #include <stdlib.h>\n #include <stdio.h>\n-#include <string.h>\n+#include <sys/types.h>\n+#include <signal.h>\n \n int main(void)\n {\n   int i, pid;\n   FILE *fp;\n-  char str[32];\n \n   for(i = 0; i < 5; i++){\n     system(\"gmsh -pid fichier.msh fichier.pos > /tmp/gmsh.pid &\");\n@@ -18,7 +18,6 @@ int main(void)\n     fscanf(fp, \"%d\", &pid);\n     fclose(fp);\n \n-    sprintf(str, \"kill %d\", pid);\n-    system(str);\n+    kill(pid, 9);\n   }    \n } \n", "fix_pattern": "<pattern>: if a command to be executed via system() is constructed using sprintf, replace it with a direct call to kill() to eliminate unnecessary string handling and improve performance."}
{"number": 72, "change": "@@ -483,7 +483,7 @@ void CreateOutputFile(const std::string &fileName, int format,\n           glLoadMatrixd(modelview);\n         }\n         else{\n-          buffer.fill(CTX::instance()->batch);\n+          drawContext::global()->drawCurrentOpenglWindow(true);\n         }\n         res = gl2psEndPage();\n       }\n@@ -513,10 +513,9 @@ void CreateOutputFile(const std::string &fileName, int format,\n         gl2psBeginPage(base.c_str(), \"Gmsh\", viewport,\n                        GL2PS_TEX, GL2PS_NO_SORT, GL2PS_NONE, GL_RGBA, 0, NULL,\n                        0, 0, 0, buffsize, fp, base.c_str());\n-        PixelBuffer buffer(width, height, GL_RGB, GL_UNSIGNED_BYTE);\n         int oldtext = CTX::instance()->print.text;\n         CTX::instance()->print.text = 1;\n-        buffer.fill(CTX::instance()->batch);\n+        drawContext::global()->drawCurrentOpenglWindow(true);\n         CTX::instance()->print.text = oldtext;\n         res = gl2psEndPage();\n       }\n", "fix_pattern": "<pattern>: if a buffer is filled but immediately after the drawing operation is executed, remove the unnecessary buffer fill and directly call the drawing method to enhance performance."}
{"number": 73, "change": "@@ -88,8 +88,7 @@ AudioEncoder::EncodedInfo AudioEncoderCopyRed::EncodeInternal(\n       DCHECK_EQ(info.redundant.size(), 2u);\n     }\n     // Save primary to secondary.\n-    secondary_encoded_.SetSize(info.encoded_bytes);\n-    memcpy(secondary_encoded_.data(), encoded, info.encoded_bytes);\n+    secondary_encoded_.SetData(encoded, info.encoded_bytes);\n     secondary_info_ = info;\n     DCHECK_EQ(info.speech, info.redundant[0].speech);\n   }\n", "fix_pattern": "<pattern>: if memory is manually copied using memcpy after resizing a buffer, replace it with a more efficient API such as SetData that handles both setting the size and copying the data in a single method call."}
{"number": 76, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified and additional attributes are set, refactor by using the existing descriptor directly to avoid unnecessary parameters and streamline the code for better clarity and potential performance improvements."}
{"number": 78, "change": "@@ -484,8 +484,7 @@ IniFile::TildeExpansion(const char *file, char *path)\n \n     /* Buffer overflow has already been checked. */\n \n-    strcpy(path, home);\n-    strcat(path, file + 1);\n+    snprintf(path, LINELEN, \"%s%s\", home, file + 1);\n     return;\n }\n \n", "fix_pattern": "<pattern>: if multiple string manipulations are performed with strcpy and strcat, replace with snprintf for a single operation that combines both operations into one, improving performance and reducing buffer overflow risks."}
{"number": 84, "change": "@@ -321,7 +321,7 @@ bool romLoaded(Logger* logger, System system, const std::string& path, void* rom\n   case System::kAtariLynx:\n     rom = util::loadFile(logger, path, &size);\n \n-    if (!strcmp(\"LYNX\", (char *)rom))\n+    if (!memcmp(\"LYNX\", (void *)rom, 5))\n     {\n         RA_OnLoadNewRom((BYTE*)rom + 0x0040, size - 0x0040);\n     }\n", "fix_pattern": "<pattern>: if a string comparison is made using strcmp for a fixed-length comparison, replace it with memcmp to improve performance by comparing raw memory directly."}
{"number": 94, "change": "@@ -160,6 +160,7 @@ void PackageKitBackend::acquireFetching(bool f)\n \n void PackageKitBackend::reloadPackageList()\n {\n+    qDebug() << \"xxx\";\n     acquireFetching(true);\n     if (m_refresher) {\n         disconnect(m_refresher.data(), &PackageKit::Transaction::finished, this, &PackageKitBackend::reloadPackageList);\n@@ -185,9 +186,9 @@ void PackageKitBackend::reloadPackageList()\n \n         const auto pkgNames = component.packageNames();\n         if (pkgNames.isEmpty()) {\n-            auto launchable = component.launchable(AppStream::Launchable::KindDesktopId);\n-            if (component.kind() == AppStream::Component::KindDesktopApp && !launchable.entries().isEmpty()) {\n-                const QString file = locateService(launchable.entries().constFirst());\n+            const auto entries = component.launchable(AppStream::Launchable::KindDesktopId).entries();\n+            if (component.kind() == AppStream::Component::KindDesktopApp && !entries.isEmpty()) {\n+                const QString file = locateService(entries.first());\n                 if (!file.isEmpty()) {\n                     acquireFetching(true);\n                     auto trans = PackageKit::Daemon::searchFiles(file);\n", "fix_pattern": "<pattern>: if an API method is called multiple times on the same object within a conditional statement, store the result in a variable to avoid redundant calls, which improves performance by reducing unnecessary computations."}
{"number": 95, "change": "@@ -573,7 +573,7 @@ void PreviewJob::slotResult(KJob *job)\n         const KIO::filesize_t size = (KIO::filesize_t)statResult.numberValue(KIO::UDSEntry::UDS_SIZE, 0);\n         const QUrl itemUrl = d->currentItem.item.mostLocalUrl();\n \n-        if (itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) {\n+        if ((itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) && !d->currentItem.item.isSlow()) {\n             skipCurrentItem = !d->ignoreMaximumSize && size > d->maximumLocalSize && !d->currentItem.plugin.value(QStringLiteral(\"IgnoreMaximumSize\"), false);\n         } else {\n             // For remote items the \"IgnoreMaximumSize\" plugin property is not respected\n", "fix_pattern": "<pattern>: if a conditional checks for local file protocols through `isLocalFile()` or `protocolClass()`, enhance the conditional logic by adding an additional check for `isSlow()` to avoid unnecessary processing when dealing with slow items."}
{"number": 99, "change": "@@ -268,9 +268,7 @@ int main(int argc, char* argv[])\n \t\t\t}\n \n \t\t\tcout << endl;\n-\t\t\t\n-\t\t\tstrcpy(szNewPassword, newpassword);\n-\n+\t\t\tkc_strlcpy(szNewPassword, newpassword, sizeof(szNewPassword));\n \t\t\trepassword = get_password(\"Re-Enter password:\");\n \t\t\tif(strcmp(newpassword, repassword) != 0) {\n \t\t\t\tcerr << \"Passwords don't match\" << endl;\n", "fix_pattern": "<pattern>: if a string copy operation is performed using strcpy, replace it with kc_strlcpy to ensure safer copy operations that prevent buffer overflows."}
{"number": 106, "change": "@@ -52,6 +52,8 @@ namespace {\n \n   // Using native file handles instead of file descriptors for reducing the resource consumption.\n \n+  const HANDLE InvalidFile = INVALID_HANDLE_VALUE;\n+\n   HANDLE openFile(const FileName &path, bool readOnly)\n   {\n     DWORD access = readOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);\n@@ -82,6 +84,8 @@ namespace {\n \n   // For non-Windows \n \n+  const FILE *InvalidFile = 0;\n+\n   struct FileNameHandle : public std::string\n   {\n     FileNameHandle(FileName name) : std::string(name) {}\n@@ -119,7 +123,7 @@ public:\n };\n \n FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openReadOnly) :\n-  file(0),\n+  file(InvalidFile),\n   name(fileName),\n   readOnly(true),\n   size(0)\n@@ -129,12 +133,12 @@ FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openRea\n   if(!openReadOnly)\n     file = openFile(name, false);\n \n-  if(file)\n+  if(file != InvalidFile)\n     readOnly = false;\n   else\n     file = openFile(name, true);\n \n-  if(!file) {\n+  if(file == InvalidFile) {\n     debug(\"Could not open file \" + String((const char *) name));\n   }\n }\n", "fix_pattern": "<pattern>: if a variable is being checked against a file handle, replace the direct comparison with a predefined constant (INVALID_HANDLE_VALUE) for better readability and potential optimization in checks against the invalid file state."}
{"number": 107, "change": "@@ -2343,7 +2343,7 @@ void dbookmarkswindow::slotBookmarkReceived(const QModelIndex &index)\n \n bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n {\n-  qint64 count = 0;\n+  bool exists = false;\n \n   {\n     QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\", \"bookmarks\");\n@@ -2358,9 +2358,9 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \tint temporary = dmisc::passphraseWasAuthenticated() ? 0 : 1;\n \n \tquery.setForwardOnly(true);\n-\tquery.prepare(\"SELECT COUNT(*) FROM bookmarks WHERE \"\n+\tquery.prepare(\"SELECT EXISTS(SELECT 1 FROM bookmarks WHERE \"\n \t\t      \"url_hash = ? AND \"\n-\t\t      \"temporary = ?\");\n+\t\t      \"temporary = ?)\");\n \tquery.bindValue\n \t  (0,\n \t   dmisc::hashedString(url.\n@@ -2371,14 +2371,14 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \n \tif(ok && query.exec())\n \t  if(query.next())\n-\t    count = query.value(0).toLongLong();\n+\t    exists = query.value(0).toBool();\n       }\n \n     db.close();\n   }\n \n   QSqlDatabase::removeDatabase(\"bookmarks\");\n-  return count > 0;\n+  return exists;\n }\n \n void dbookmarkswindow::slotRefresh(void)\n", "fix_pattern": "<pattern>: if a query is used to count rows in a SQL table, replace it with a query that checks for existence instead (e.g., using \"SELECT EXISTS(...)\") to improve performance by reducing the amount of data processed."}
{"number": 108, "change": "@@ -98,13 +98,8 @@ void Pool::joinAll()\n \n Pool::WorkerCountType Pool::getWorkQueueCount() const\n {\n-\tPool::WorkerCountType size = 0;\n-\t\n-\tenqueuedWorkMutex.lock();\n-\tsize = enqueuedWork.size();\n-\tenqueuedWorkMutex.unlock();\n-\t\n-\treturn size;\n+\tstd::lock_guard<std::mutex> l(enqueuedWorkMutex);\t\n+\treturn enqueuedWork.size();\n }\n \n Pool::WorkerCountType Pool::getActiveWorkerCount() const\n", "fix_pattern": "<pattern>: if manual locking and unlocking of a mutex is performed, use a std::lock_guard to manage the mutex automatically and ensure proper unlocking after the scope ends, improving code clarity and safety."}
{"number": 118, "change": "@@ -165,7 +165,7 @@ std::string PluginSerializer::SerializeToFile(const std::string& content_url,\n     return \"\";\n   }\n \n-  size_t num_written = fwrite(body.c_str(), 1, body.size(), file);\n+  size_t num_written = fwrite(body.data(), 1, body.size(), file);\n   fclose(file);\n   if (num_written != body.size()) {\n     LOG(ERROR) << \"Failed to WriteDataToFile for \" << string_path\n", "fix_pattern": "<pattern>: if a string's underlying data is accessed for writing (such as with fwrite), prefer to use body.data() instead of body.c_str() to avoid the potential overhead of constructing a null-terminated string when it's not necessary."}
{"number": 120, "change": "@@ -240,7 +240,7 @@ HandleSet ForwardChainer::get_chaining_result()\n \n Source* ForwardChainer::select_source()\n {\n-\tstd::lock_guard<std::mutex> lock(_part_mutex);\n+\tstd::unique_lock<std::mutex> lock(_part_mutex);\n \n \tstd::vector<double> weights = _sources.get_weights();\n \n@@ -270,7 +270,7 @@ Source* ForwardChainer::select_source()\n \t\t\ture_logger().debug() << \"Reset all exhausted flags to retry them\";\n \t\t\t_sources.reset_exhausted();\n \t\t\t// Try again\n-\t\t\t// NEXT TODO: be careful of locks\n+\t\t\tlock.unlock();\n \t\t\treturn select_source();\n \t\t} else {\n \t\t\t_sources.exhausted = true;\n", "fix_pattern": "<pattern>: if a std::lock_guard is replaced with a std::unique_lock that is immediately unlocked, consider whether locking is necessary at all for the given scope; if there are no operations requiring protection, remove the lock entirely."}
{"number": 128, "change": "@@ -37,7 +37,7 @@\n #endif\n \n #include <math.h>\n-#include <string.h>\n+#include \"string2.h\"\n #include \"typedefs.h\"\n #include \"macros.h\"\n #include \"copyrite.h\"\n@@ -157,7 +157,7 @@ int main (int argc,char *argv[])\n     iatoms->resinfo[resind] = atoms->resinfo[atoms->atom[index[i]].resind];\n     /* allocate some space for the rtp name and copy from name */\n     snew(iatoms->resinfo[resind].rtp,1);\n-    strcpy(iatoms->resinfo[resind].rtp, atoms->resinfo[resind].name);\n+    iatoms->resinfo[resind].rtp = gmx_strdup(atoms->resinfo[resind].name);\n \n     iatoms->nres = max(iatoms->nres, iatoms->atom[i].resind+1);\n   }\n", "fix_pattern": "<pattern>: if a direct string copy is performed using `strcpy`, replace it with a project-specific optimized function `gmx_strdup` that may handle memory allocation more efficiently and ensure the destination is properly handled."}
{"number": 131, "change": "@@ -126,8 +126,7 @@ TiffIFD* TiffIFD::parseDngPrivateData(TiffEntry *t) {\n   */\n   uint32 size = t->count;\n   const uchar8 *data = t->getData();\n-  string id((const char*)data);\n-  if (0 != id.compare(\"Adobe\"))\n+  if (0 != memcmp(data, \"Adobe\", 6))\n     ThrowTPE(\"Not Adobe Private data\");\n \n   data+=6;\n", "fix_pattern": "<pattern>: if a string comparison is needed and the length of the string is known, replace std::string::compare with memcmp for lower-level performance improvements, as memcmp is generally faster for fixed-length comparisons."}
{"number": 136, "change": "@@ -48,7 +48,7 @@ namespace tp {\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlWriteCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &response.body);\n-\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); //10s timeout\n+\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L); //5s timeout\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, CurlHeadersCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEHEADER, &response.headers);\n", "fix_pattern": "<pattern>: if a timeout value is being configured for a CURL request, ensure to set a lower timeout value for better responsiveness and improved resource utilization; in this case, reducing from 10 seconds to 5 seconds."}
{"number": 137, "change": "@@ -229,11 +229,10 @@ ProgClient::run_program(const string &progname, const string &args\n     startupinfo.hStdInput = hClient;\n     startupinfo.dwFlags |= STARTF_USESTDHANDLES;\n \n-    // For some reason Windows wants a modifiable copy!\n-    BOOL ok;\n-    char * cmdline = strdup((progname + ' ' + args).c_str());\n-    ok = CreateProcess(0, cmdline, 0, 0, TRUE, 0, 0, 0, &startupinfo, &procinfo);\n-    free(cmdline);\n+    // For some reason Windows wants a modifiable command line!\n+    string cmdline = progname + ' ' + args;\n+    BOOL ok = CreateProcess(0, &cmdline[0], 0, 0, TRUE, 0, 0, 0,\n+\t\t\t    &startupinfo, &procinfo);\n     if (!ok) {\n \tthrow Xapian::NetworkError(\"CreateProcess failed\",\n \t\t\t\t   get_progcontext(progname, args),\n", "fix_pattern": "<pattern>: if a modifiable command line is required for CreateProcess, construct the command line as a std::string and use its internal buffer directly instead of creating a separate modifiable copy with strdup and then freeing it. This avoids unnecessary memory allocation and deallocation overhead."}
{"number": 138, "change": "@@ -1430,10 +1430,6 @@ GlassTable::readahead_key(const string &key) const\n     LOGCALL(DB, bool, \"GlassTable::readahead_key\", key);\n     Assert(!key.empty());\n \n-    // An overlong key cannot be found.\n-    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n-\tRETURN(false);\n-\n     // Three cases:\n     //\n     // handle == -1:  Lazy table in a multi-file database which isn't yet open.\n@@ -1450,6 +1446,10 @@ GlassTable::readahead_key(const string &key) const\n     if (level == 0)\n \tRETURN(false);\n \n+    // An overlong key cannot be found.\n+    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n+\tRETURN(true);\n+\n     form_key(key);\n \n     // We'll only readahead the first level, since descending the B-tree would\n", "fix_pattern": "<pattern>: if the return value is used to indicate the success or failure of a key search operation in a B-tree, change the logic to return true for the case of an overlong key, as it indicates an immediate failure to locate a valid key that should be found within the defined limits."}
{"number": 146, "change": "@@ -473,7 +473,8 @@ struct TextShaper\n \t{\n \t\t/* Fribidi assumes that the text is encoded in UTF-32, so we have to\n \t\t   convert from UTF-8 to UTF-32, assuming that the string is indeed in UTF-8.*/\n-\t\tstd::u32string u32 = utf8::utf8to32(text);\n+\t\tstd::u32string u32;\n+\t\tutf8::unchecked::utf8to32(text.begin(), text.end(), std::back_inserter(u32));\n \n \t\t// Step 1: Initialize fribidi variables.\n \t\t// TODO: Don't forget to delete them at the end.\n@@ -877,6 +878,11 @@ static bool breaksWord(char const c)\n \treturn c == ASCII_SPACE || breaksLine(c);\n }\n \n+/* This funtion might not be fail-proof. It presumes that a \"char\" equals a \"character\" in any language.\n+   Since the game was translated into different other languages, an Arabic or Chinese \"character\"\n+   could occupy several bytes (that is, \"char\"s) in memory (assuming the string is in UTF-8). Therefore,\n+   expressions such as \"++curChar\" might not yield the next \"character\", but just a byte of its\n+   representation. */\n std::vector<TextLine> iV_FormatText(const char *String, UDWORD MaxWidth, UDWORD Justify, iV_fonts fontID, bool ignoreNewlines /*= false*/)\n {\n \tstd::vector<TextLine> lineDrawResults;\n", "fix_pattern": "<pattern>: if the conversion from UTF-8 to UTF-32 is done using a function that performs safety checks (like utf8::utf8to32), refactor the code to use a variant of the function that skips those checks (like utf8::unchecked::utf8to32) combined with std::back_inserter for better performance, while being cautious of handling multi-byte characters properly."}
{"number": 156, "change": "@@ -36,7 +36,9 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    strncpy(pchCommand, pszCommand, COMMAND_SIZE);\n+    int command_len = strlen(pszCommand);\n+    memcpy(pchCommand, pszCommand, command_len);\n+    memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n     nChecksum = 0;\n }\n", "fix_pattern": "<pattern>: if a string is copied using strncpy, replace it with memcpy followed by memset to ensure the destination is properly null-terminated while improving performance with direct memory operations."}
{"number": 157, "change": "@@ -36,7 +36,7 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    int command_len = strlen(pszCommand);\n+    size_t command_len = strnlen(pszCommand, COMMAND_SIZE);\n     memcpy(pchCommand, pszCommand, command_len);\n     memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n", "fix_pattern": "<pattern>: if the code uses strlen to determine the length of a string, replace it with strnlen while providing a maximum length to avoid potential overflow issues and improve safety when the size of the string is limited."}
{"number": 168, "change": "@@ -1285,7 +1285,7 @@ void FMultiPatchTexture::ResolvePatches()\n \t\t{\n \t\t\tif (Parts[i].Texture == nullptr)\n \t\t\t{\n-\t\t\t\tmemcpy(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n+\t\t\t\tmemmove(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n \t\t\t\ti--;\n \t\t\t\tNumParts--;\n \t\t\t}\n", "fix_pattern": "<pattern>: if a block of memory is being moved within the same array (i.e., source and destination overlap), replace memcpy with memmove to safely handle overlapping regions."}
{"number": 174, "change": "@@ -46,6 +46,7 @@\n  * Stride Prefetcher template instantiations.\n  */\n \n+#include \"base/random.hh\"\n #include \"debug/HWPrefetch.hh\"\n #include \"mem/cache/prefetch/stride.hh\"\n \n@@ -176,7 +177,7 @@ StridePrefetcher::pcTableVictim(Addr pc, int master_id)\n {\n     // Rand replacement for now\n     int set = pcHash(pc);\n-    int way = rand() % pcTableAssoc;\n+    int way = random_mt.random<int>(0, pcTableAssoc - 1);\n \n     DPRINTF(HWPrefetch, \"Victimizing lookup table[%d][%d].\\n\", set, way);\n     return &pcTable[master_id][set][way];\n", "fix_pattern": "<pattern>: if the code uses the standard `rand()` function for generating random numbers, replace it with a project-specific random number generator method for improved performance and potentially better randomness properties."}
{"number": 180, "change": "@@ -48,8 +48,8 @@ extern \"C\" JNIEXPORT void JNICALL Java_Main_waitUntilJitted(JNIEnv* env,\n     if (code_cache->ContainsPc(header->GetCode())) {\n       break;\n     } else {\n-      // yield to scheduler to give time to the JIT compiler.\n-      sched_yield();\n+      // Sleep to yield to the compiler thread.\n+      sleep(0);\n       // Will either ensure it's compiled or do the compilation itself.\n       jit->CompileMethod(method, Thread::Current(), /* osr */ false);\n     }\n", "fix_pattern": "<pattern>: if the original code uses `sched_yield()` to yield time to the JIT compiler, replace it with `sleep(0)` to achieve a similar effect with potentially better performance in terms of scheduling efficiency."}
{"number": 181, "change": "@@ -108,11 +108,8 @@ static LRESULT HandleCopyData(LPARAM lParam) {\n \tCOPYDATASTRUCT *pcds = reinterpret_cast<COPYDATASTRUCT *>(lParam);\n \t// Copy into an temporary buffer to ensure \\0 terminated\n \tif (pcds->lpData) {\n-\t\tchar *dataCopy = new char[pcds->cbData + 1];\n-\t\tstrncpy(dataCopy, static_cast<char *>(pcds->lpData), pcds->cbData);\n-\t\tdataCopy[pcds->cbData] = '\\0';\n-\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy);\n-\t\tdelete []dataCopy;\n+\t\tstd::string dataCopy(static_cast<char *>(pcds->lpData), pcds->cbData);\n+\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy.c_str());\n \t}\n \treturn 0;\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation and manual string copy using strncpy is used, replace it with a std::string construction to avoid memory management overhead and ensure better safety and performance."}
{"number": 182, "change": "@@ -1490,16 +1490,13 @@ BOOL SciTEWin::TabSizeMessage(HWND hDlg, UINT message, WPARAM wParam) {\n \t\t\tint tabSize = wEditor.Call(SCI_GETTABWIDTH);\n \t\t\tif (tabSize > 99)\n \t\t\t\ttabSize = 99;\n-\t\t\tchar tmp[3];\n-\t\t\tsprintf(tmp, \"%d\", tabSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDTABSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDTABSIZE, tabSize, FALSE);\n \n \t\t\t::SendDlgItemMessage(hDlg, IDINDENTSIZE, EM_LIMITTEXT, 2, 1);\n \t\t\tint indentSize = wEditor.Call(SCI_GETINDENT);\n \t\t\tif (indentSize > 99)\n \t\t\t\tindentSize = 99;\n-\t\t\tsprintf(tmp, \"%d\", indentSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDINDENTSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDINDENTSIZE, indentSize, FALSE);\n \n \t\t\t::CheckDlgButton(hDlg, IDUSETABS, wEditor.Call(SCI_GETUSETABS));\n \t\t\treturn TRUE;\n", "fix_pattern": "<pattern>: if there is a need to set an integer value to a dialog item using a string conversion via sprintf and then SetDlgItemTextA, replace it with a direct call to SetDlgItemInt for better performance, avoiding unnecessary string formatting."}
{"number": 190, "change": "@@ -1,3 +1,5 @@\n+#define OPENSSL_SUPPRESS_DEPRECATED\n+\n #include <psibase/crypto.hpp>\n \n #include <openssl/sha.h>\n@@ -126,8 +128,11 @@ namespace psibase\n    Checksum256 sha256(const char* data, size_t length)\n    {\n       //std::array<unsigned char, 256 / 8> result;\n+      SHA256_CTX ctx;\n+      SHA256_Init(&ctx);\n+      SHA256_Update(&ctx, (const unsigned char*)data, length);\n       Checksum256 result;\n-      SHA256((const unsigned char*)data, length, (unsigned char*)result.data());\n+      SHA256_Final((unsigned char*)result.data(), &ctx);\n       return result;\n    }\n \n", "fix_pattern": "<pattern>: when using the SHA256 function from OpenSSL, instead of calling a single function that may lead to inefficiencies, refactor the code to use the initialization, update, and finalization steps with the SHA256_CTX context, which allows for better control of the hashing process and may improve performance by reducing memory allocations and managing state more explicitly."}
{"number": 198, "change": "@@ -54,7 +54,13 @@ int sock;\n #ifdef UNIX_ASYNC_DNS\n   static XP_Bool done = FALSE;\n \n-  LOG(\"XFE_InitDNS_Early\", (\"calling DNS_SpawnProcess.\\n\"));\n+  /*\n+   * The following used to be LOG() instead of fprintf(). But, LOG() uses\n+   * PR_smprintf() which fires up NSPR.\n+   */\n+#ifdef PROC1_DEBUG_PRINT\n+  fprintf(stderr, \"\\tproc1 (%d): %s\\n\", getpid(), \"XFE_InitDNS_Early: calling DNS_SpawnProcess.\");\n+#endif\n   sock = DNS_SpawnProcess(argc, argv);\n \n   XP_ASSERT(!done);\n", "fix_pattern": "<pattern>: if a logging function (LOG) introduces significant overhead due to additional processing (like memory allocation via PR_smprintf), replace it with a lower-overhead alternative (like fprintf) when debugging output is necessary to improve performance."}
{"number": 201, "change": "@@ -482,15 +482,13 @@ void dprintf(const char *format, ...)\n {\n #if DEBUG\n     va_list ap;\n-\tchar\t*buffer;\n+\tStr255 buffer;\n \t\n \tva_start(ap, format);\n-\tbuffer = PR_vsmprintf(format, ap);\n+\tbuffer[0] = PR_vsnprintf((char *)buffer + 1, sizeof(buffer) - 1, format, ap);\n \tva_end(ap);\n \t\n-\tc2pstr(buffer);\n-\tDebugStr( (unsigned char *)buffer);\n-\tfree(buffer);\n+\tDebugStr(buffer);\n #endif /* DEBUG */\n }\n \n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a buffer (e.g., via PR_vsmprintf and subsequent free), replace it with a statically sized buffer (e.g., Str255) using PR_vsnprintf to eliminate the overhead of heap allocation and deallocation."}
{"number": 204, "change": "@@ -230,8 +230,10 @@ nsresult nsCollationMac::CreateRawSortKey(const nsCollationStrength strength,\n     }\n     else {\n       // No CJK support, just copy the row string.\n-      strcpy((char *) key, str);\n-      while (*key) {\n+      // Collation key is not a string, use memcpy instead of strcpy.\n+      nsCRT::memcpy(key, str, str_len);\n+      PRUint8 *end = key + str_len;\n+      while (key < end) {\n         if ((unsigned char) *key < 128) {\n           key++;\n         }\n", "fix_pattern": "<pattern>: if a string is being copied to a buffer where the length is known, replace strcpy with memcpy to eliminate null-termination overhead and improve performance."}
{"number": 208, "change": "@@ -152,9 +152,8 @@ void Pass::match(Plasma::RunnerContext &context)\n     QList<Plasma::QueryMatch> matches;\n \n     lock.lockForRead();\n-    QRegularExpression re(\".*\" + input + \".*\", QRegularExpression::CaseInsensitiveOption);\n     for (const auto& password: passwords) {\n-        if (re.match(password).hasMatch()) {\n+        if (password.contains(input,Qt::CaseInsensitive)) {\n             Plasma::QueryMatch match(this);\n             match.setType(input.length() == password.length() ?\n                 Plasma::QueryMatch::ExactMatch : Plasma::QueryMatch::CompletionMatch);\n", "fix_pattern": "<pattern>: if a QRegularExpression is used to perform a match on a QString, replace it with QString's built-in contains method for better performance as it avoids regex overhead."}
{"number": 214, "change": "@@ -182,12 +182,12 @@ void PaymentServerTests::paymentServerTests()\n     QCOMPARE(PaymentServer::verifyExpired(r.paymentRequest.getDetails()), true);\n \n     // Test BIP70 DoS protection:\n-    unsigned char randData[BIP70_MAX_PAYMENTREQUEST_SIZE + 1];\n-    GetRandBytes(randData, sizeof(randData));\n+    auto randdata = FastRandomContext().randbytes(BIP70_MAX_PAYMENTREQUEST_SIZE + 1);\n+\n     // Write data to a temp file:\n     QTemporaryFile tempFile;\n     tempFile.open();\n-    tempFile.write((const char*)randData, sizeof(randData));\n+    tempFile.write((const char*)randdata.data(), randdata.size());\n     tempFile.close();\n     // compares 50001 <= BIP70_MAX_PAYMENTREQUEST_SIZE == false\n     QCOMPARE(PaymentServer::verifySize(tempFile.size()), false);\n", "fix_pattern": "<pattern>: if using a direct buffer approach for generating random bytes and writing them to a file, switch to a higher-level abstraction that combines randomness generation and data management (e.g., using FastRandomContext with std::vector for automatic memory handling) for improved performance and safety."}
{"number": 215, "change": "@@ -14,6 +14,7 @@\n #define TRGCDC_SHORT_NAMES\n \n #include <math.h>\n+#include <TRandom.h>\n #include <iostream>\n #include <fstream>\n #include \"framework/datastore/StoreArray.h\"\n@@ -1030,7 +1031,7 @@ namespace Belle2 {\n       //...Loop over CDCHits...\n       for (unsigned i = 0; i < nHits; i++) {\n         const CDCHit& h = *CDCHits[i];\n-        double tmp = rand() / (double(RAND_MAX));\n+        double tmp = gRandom->Uniform(0.0, 1.0) / (double(RAND_MAX));\n         if (tmp < _inefficiency)\n           continue;\n \n", "fix_pattern": "<pattern>: if random number generation is performed using the standard C++ `rand()` function, switch to using `gRandom->Uniform(min, max)` from the ROOT TRandom class for improved performance and better statistical properties in scientific computing contexts."}
{"number": 218, "change": "@@ -27,7 +27,8 @@ void AMQPMessage::setMessage(const char * data,uint32_t length) {\n \tif (this->data)\n \t\tfree(this->data);\n \n-\tthis->data = strdup(data);\n+\tthis->data = (char*)malloc(length);\n+\tmemcpy(this->data,data,length);\n \tthis->len = length;\n }\n \n", "fix_pattern": "<pattern>: if strdup is used to allocate and copy a string, replace it with malloc followed by memcpy for potentially better performance and control over allocation size."}
{"number": 222, "change": "@@ -127,8 +127,8 @@ bool fetch_mod(wchar_t *version) {\n \t}\n \tFILE *out = NULL;\n \tcurl_easy_setopt(curl, CURLOPT_URL, fetch_url_utf8);\n-\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 3200L);\n-\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 40000L);\n+\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 2000L);\n+\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 20000L);\n \tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);\n \tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);\n \tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n", "fix_pattern": "<pattern>: if there is a need to improve performance related to network timeouts in a curl request, consider adjusting timeout values to lower settings that do not compromise functionality; this can reduce the time spent waiting for network operations to complete, enhancing responsiveness."}
{"number": 227, "change": "@@ -261,7 +261,7 @@ void pqColorMapEditor::setColorTransferFunction(vtkSMProxy* ctf)\n   this->Internals->ProxyWidget = widget;\n   this->updatePanel();\n \n-  QObject::connect(widget, SIGNAL(changeFinished()), this, SLOT(updateIfNeeded()));\n+  QObject::connect(widget, SIGNAL(changeAvailable()), this, SLOT(updateIfNeeded()));\n }\n \n //-----------------------------------------------------------------------------\n", "fix_pattern": "<pattern>: NA"}
{"number": 228, "change": "@@ -1,4 +1,4 @@\n-/* Copyright (c) 2019-2023, Arm Limited and Contributors\n+/* Copyright (c) 2019-2024, Arm Limited and Contributors\n  *\n  * SPDX-License-Identifier: Apache-2.0\n  *\n@@ -58,6 +58,10 @@ void LightingSubpass::draw(CommandBuffer &command_buffer)\n \tauto &pipeline_layout = resource_cache.request_pipeline_layout(shader_modules);\n \tcommand_buffer.bind_pipeline_layout(pipeline_layout);\n \n+\t// we know, that the lighting subpass does not have any vertex stage input -> reset the vertex input state\n+\tassert(pipeline_layout.get_resources(ShaderResourceType::Input, VK_SHADER_STAGE_VERTEX_BIT).empty());\n+\tcommand_buffer.set_vertex_input_state({});\n+\n \t// Get image views of the attachments\n \tauto &render_target = get_render_context().get_active_frame().get_render_target();\n \tauto &target_views  = render_target.get_views();\n", "fix_pattern": "<pattern>: if a vertex input state is set after asserting that no vertex stage input resources are present, ensure that the assertion is checked before setting the vertex input state to optimize potential errors in graphics pipeline configuration."}
{"number": 231, "change": "@@ -13,7 +13,6 @@\n #include <arpa/inet.h>\n #include <assert.h>\n #include <errno.h>\n-#include <fcntl.h>\n #include <inttypes.h>\n #include <netinet/in.h>\n #include <poll.h>\n@@ -123,12 +122,10 @@ static void await_debugger(struct GdbContext* dbg, ScopedFd& listen_fd) {\n   struct sockaddr_in client_addr;\n   socklen_t len = sizeof(client_addr);\n \n-  dbg->sock_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &len);\n+  dbg->sock_fd =\n+      accept4(listen_fd, (struct sockaddr*)&client_addr, &len, SOCK_NONBLOCK);\n   // We might restart this debugging session, so don't set the\n   // socket fd CLOEXEC.\n-  if (fcntl(dbg->sock_fd, F_SETFL, O_NONBLOCK)) {\n-    FATAL() << \"Can't make client socket NONBLOCK\";\n-  }\n }\n \n struct debugger_params {\n", "fix_pattern": "<pattern>: if the accept method is called and the socket needs to be set to non-blocking mode afterwards, replace it with accept4 which allows setting the socket to non-blocking mode in a single call for better performance."}
{"number": 232, "change": "@@ -85,7 +85,7 @@ static ScopedFd create_memfd_file(const string& orig_path, dev_t orig_device,\n        << \"-inode-\" << orig_inode << \"-\" << orig_path;\n   real_name = name.str().substr(0, 255);\n \n-  ScopedFd fd = memfd_create(real_name.c_str(), 0);\n+  ScopedFd fd = syscall(SYS_memfd_create, real_name.c_str(), 0);\n   return fd;\n }\n \n", "fix_pattern": "<pattern>: if the code uses a higher-level API function like memfd_create that incurs additional overhead due to abstraction, refactor it to directly use the syscall interface for better performance by reducing function call overhead and leveraging lower-level operations directly."}
{"number": 240, "change": "@@ -1,5 +1,5 @@\n /*\n-   Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.\n+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -1307,7 +1307,7 @@ TransporterFacade::close_clnt(trp_client* clnt)\n         clnt->do_forceSend(1);\n         first = false;\n       }\n-      clnt->do_poll(0);\n+      clnt->do_poll(10);\n       not_finished = (m_threads.get(clnt->m_blockNo) == clnt);\n       clnt->complete_poll();\n     } while (not_finished);\n", "fix_pattern": "<pattern>: if the timeout parameter for an API method is set to zero, which may result in the method to be non-blocking and potentially lead to busy-waiting, adjust the timeout to a positive value to allow for more efficient waiting (e.g., using a sleep mechanism) which can enhance performance in scenarios with polling."}
{"number": 241, "change": "@@ -6112,7 +6112,6 @@ void* background_thread(void*)\n   mysql_mutex_lock(&background_mutex);\n   mysql_mutex_lock(&stop_cond_mutex);\n \n-  rocksdb::WriteBatch wb;\n   time_t last_stat_recompute = 0;\n   for (;;)\n   {\n@@ -6128,9 +6127,8 @@ void* background_thread(void*)\n     assert(ret == 0 || ret == ETIMEDOUT);\n \n     if (rdb && rocksdb_background_sync) {\n-      auto wo = rocksdb::WriteOptions();\n-      wo.sync = true;\n-      rocksdb::Status s= rdb->Write(wo, &wb);\n+      assert(!db_options.allow_mmap_writes);\n+      rocksdb::Status s= rdb->SyncWAL();\n       if (!s.ok())\n         rocksdb_handle_io_error(s, ROCKSDB_IO_ERROR_BG_THREAD);\n     }\n", "fix_pattern": "<pattern>: if a write operation is performed with `rocksdb::Write`, and it is determined that write-ahead logging (WAL) should be synchronized without custom write options, replace the write operation with `rocksdb::DB::SyncWAL()` for improved performance, especially when synchronous writes are unnecessary. This change also removes complexity from write options and directly manages the log synchronization."}
{"number": 242, "change": "@@ -41,10 +41,10 @@ double HkIClientImpl::CDPClientProxy__GetLinkSaturation(uint iClientID)\n \t// ISERVER_LOGARG_UI(iClientID);\n \n \tchar *tmp; \n-\tWriteProcMem(&tmp, &Client, 4); \n-\tWriteProcMem(&Client, &OldClient, 4); \n+\tmemcpy(&tmp, &Client, 4);\n+\tmemcpy(&Client, &OldClient, 4);\n \tdouble dRet = HookClient->CDPClientProxy__GetLinkSaturation(iClientID); \n-\tWriteProcMem(&Client, &tmp, 4); \n+\tmemcpy(&Client, &tmp, 4);\n \n \treturn dRet;\n }\n", "fix_pattern": "<pattern>: if multiple calls to a memory writing API (in this case WriteProcMem) are detected for copying fixed-size blocks of memory, replace them with calls to memcpy for better performance and reduced overhead."}
{"number": 251, "change": "@@ -67,14 +67,8 @@ void OGGLoader::into(Loadable& resource, const LoaderOptions& options) {\n     Sound* sound = dynamic_cast<Sound*>(res_ptr);\n     assert(sound && \"You passed a Resource that is not a Sound to the OGG loader\");\n \n-    std::ifstream t(filename_.encode().c_str(), std::ios::binary);\n-    std::vector<uint8_t> data;\n-\n-    t.seekg(0, std::ios::end);\n-    data.reserve(t.tellg());\n-    t.seekg(0, std::ios::beg);\n-\n-    data.assign((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());\n+    std::string buf = data_->str();\n+    std::vector<uint8_t> data(buf.begin(), buf.end());\n \n     StreamWrapper stream(stb_vorbis_open_memory(&data[0], data.size(),nullptr, nullptr));\n \n", "fix_pattern": "<pattern>: if reading data from a file using std::ifstream involves seeking the file size and using std::istreambuf_iterator, replace it with reading data into a string buffer first and then constructing the vector from the string to reduce overhead from seeking and iterating."}
{"number": 253, "change": "@@ -63,9 +63,11 @@ BOOL WINAPI DllMain(HINSTANCE h, DWORD reason, LPVOID reserved)\n \t\tstrcpy(++p, FBDLLNAME);\n \t\tp += strlen(FBDLLNAME);\n \t\t*p = 0;\n-\t\thFBDLLInstance = LoadLibrary(buffer);\n-\t\tif (!hFBDLLInstance) {\n-\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\tif (!GetModuleHandle(buffer) && !GetModuleHandle(FBDLLNAME)) {\n+\t\t\thFBDLLInstance = LoadLibrary(buffer);\n+\t\t\tif (!hFBDLLInstance) {\n+\t\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase DLL_PROCESS_DETACH:\n", "fix_pattern": "<pattern>: if the code checks for the loaded module using LoadLibrary, replace it with GetModuleHandle to avoid loading the library again if it's already been loaded; then only fall back to LoadLibrary if the module is not currently loaded."}
{"number": 256, "change": "@@ -116,7 +116,7 @@ namespace\n \t{\n \t\tuint8* destPointer = EmulatorInterface::instance().getMemoryPointer(destAddress, true, bytes);\n \t\tuint8* sourcePointer = EmulatorInterface::instance().getMemoryPointer(sourceAddress, false, bytes);\n-\t\tmemcpy(destPointer, sourcePointer, bytes);\n+\t\tmemmove(destPointer, sourcePointer, bytes);\n \t}\n \n \tvoid zeroMemory(uint32 startAddress, uint32 bytes)\n", "fix_pattern": "<pattern>: if the source and destination memory regions overlap, replace memcpy with memmove to ensure safety and correctness without performance degradation."}
{"number": 257, "change": "@@ -419,9 +419,7 @@ int vfsLoadFile( const char *filename, void **bufferptr, int index ){\n \t\t}\n \n \t\tif ( count == index ) {\n-\t\t\tstrcpy( g_strLoadedFileLocation, file->unzFilePath );\n-\t\t\tstrcat( g_strLoadedFileLocation, \" :: \" );\n-\t\t\tstrcat( g_strLoadedFileLocation, filename );\n+\t\t\tsnprintf( g_strLoadedFileLocation, sizeof( g_strLoadedFileLocation ), \"%s :: %s\", file->unzFilePath, filename );\n \n \t\t\tmemcpy( file->zipfile, &file->zipinfo, sizeof( unz_s ) );\n \n", "fix_pattern": "<pattern>: if multiple string concatenations using strcpy and strcat are detected, refactor the code to use snprintf for a single, more efficient string formatting operation, which also prevents buffer overflows."}
{"number": 258, "change": "@@ -158,7 +158,7 @@ buffer_washer(char * buff, int buffer_len)\n \n     for (i = 0 ; i < buffer_len - 1; i++) {\n \tif (buff[i] == '\\0') {\n-\t    memcpy(&buff[i], &buff[i+1], buffer_len - i);\n+\t    memmove(&buff[i], &buff[i+1], buffer_len - i);\n \t    buffer_len--;\n \t    buff[buffer_len] = '\\0';\n \t}\n", "fix_pattern": "<pattern>: if overlapping memory regions are involved in a copy operation, replace memcpy with memmove to ensure safe handling of overlapping areas."}
{"number": 261, "change": "@@ -34,7 +34,7 @@ const Kernel::FT volume( const Solid& solid, NoValidityCheck )\n     const CGAL::Point_3<Kernel> origin(0,0,0);\n     const size_t numShells = solid.numShells();\n     for (size_t i=0; i<numShells; i++) {\n-        std::auto_ptr<Geometry> t( tesselate( solid.shellN(i) ) );\n+\t    std::auto_ptr<Geometry> t( tesselate( solid.shellN(i), NoValidityCheck() ) );\n         const TriangulatedSurface& tin = t->as<TriangulatedSurface>();\n         const size_t numTriangles = tin.numTriangles();\n         for (size_t j=0; j<numTriangles; j++) {\n", "fix_pattern": "<pattern>: if an API call to `tesselate` is made without a validity check and there exists an overload for `tesselate` that allows skipping the validity check for performance improvements, refactor the call to utilize that overload by passing `NoValidityCheck()`."}
{"number": 274, "change": "@@ -368,10 +368,8 @@ void CPNGFile::WaitForSaves()\n \t\tfirst = false;\n #ifdef HAVE_WINTHREAD\n \t\tSleep(100);\n-#elif defined (__APPLE__)\n+#else\n \t\tsched_yield();\n-#elif defined(HAVE_PTHREAD)\n-\t\tpthread_yield();\n #endif\n \t}\n }\n", "fix_pattern": "<pattern>: if there is a conditional branch for a specific platform that includes a call to `pthread_yield()`, then refactor it to eliminate the call in favor of a more generalized fallback without the platform-specific behavior."}
{"number": 286, "change": "@@ -56,9 +56,7 @@ OperatorHandle Dispatcher::findOrRegisterSchema_(FunctionSchema&& schema, Operat\n   const auto found = findSchema(schema.operator_name());\n   if (found != c10::nullopt) {\n     if (found->schema() != schema) {\n-      std::ostringstream str;\n-      str << schema << \" vs \" << found->schema();\n-      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", str.str());\n+      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", schema, \" vs \", found->schema());\n     }\n     if (options.isDefaultAliasAnalysisKind()) {\n       // just do nothing and let it pass.\n", "fix_pattern": "<pattern>: if creating a temporary `std::ostringstream` to format a string is detected, replace it with direct string concatenation in the `TORCH_CHECK` call for improved performance and reduced object construction overhead."}
{"number": 288, "change": "@@ -38,7 +38,6 @@\n #include \"audio/dcblocker.h\"\n #include \"logger.h\"\n #include \"manager.h\"\n-#include \"cc_thread.h\"\n \n #include <cstdlib>\n #include <fstream>\n@@ -252,7 +251,7 @@ std::string PulseLayer::getAudioDeviceName(int index, PCMType type) const\n void PulseLayer::createStreams(pa_context* c)\n {\n     while (enumeratingSinks_ or enumeratingSources_)\n-        ost::Thread::sleep(20 /* ms */);\n+        usleep(20000); // 20 ms\n \n     std::string playbackDevice(preference_.getPulseDevicePlayback());\n     std::string captureDevice(preference_.getPulseDeviceRecord());\n", "fix_pattern": "<pattern>: if a platform-specific sleep function (like ost::Thread::sleep) is used which may involve more overhead, replace it with a more efficient platform-specific alternative (like usleep) for better performance in timing control."}
{"number": 291, "change": "@@ -147,10 +147,10 @@ PyObject *slotCall(PyObject *self, PyObject *args, PyObject * /* kw */)\n             data->slotName = strdup(Shiboken::String::toCString(funcName));\n         }\n \n-\n-        QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n-        QByteArray signature = QString().sprintf(\"%s(%s)\", data->slotName, data->args).toUtf8();\n-        signature = returnType + \" \" + signature;\n+        const QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n+        const QByteArray signature =\n+            returnType + ' ' + const_cast<const char *>(data->slotName)\n+            + '(' + const_cast<const char *>(data->args) + ')';\n \n         if (!pySlotName)\n             pySlotName = Shiboken::String::fromCString(PYSIDE_SLOT_LIST_ATTR);\n", "fix_pattern": "<pattern>: if QByteArray is being constructed multiple times from QString while using sprintf, replace it with direct QByteArray concatenation to avoid unnecessary conversions and improve performance. Additionally, use const correctness to avoid unnecessary copies."}
{"number": 292, "change": "@@ -110,11 +110,8 @@ int main(int argc, char ** argv)\n \t\tif (argc != 1)\n \t\t\tthrow std::runtime_error(i18n(\"no document specified\"));\n \n-\t\tcainteoir::document_events events;\n \t\trdf::graph metadata;\n-\t\tif (!cainteoir::parseDocument(argv[0], events, metadata))\n-\t\t\tfprintf(stderr, i18n(\"unsupported document format for file \\\"%s\\\"\\n\"), argv[0]);\n-\n+\t\tauto reader = cainteoir::createDocumentReader(argv[0], metadata, std::string());\n \t\tif (!metadata.empty())\n \t\t{\n \t\t\tif (output_type == rdf_metadata)\n", "fix_pattern": "<pattern>: if an API method (`cainteoir::parseDocument`) that processes files is replaced by a different method (`cainteoir::createDocumentReader`) that may offer better performance or efficiency, identify that the change signifies a shift towards a potentially more optimized API call for handling document reading while maintaining the context associated with the operation."}
{"number": 297, "change": "@@ -254,7 +254,7 @@ QSSGShaderCache::QSSGShaderCache(QSSGRhiContext &ctx,\n         m_persistentShaderStorageFileName = persistentQsbcFileName();\n         if (!m_persistentShaderStorageFileName.isEmpty()) {\n             const bool skipCacheFile = qEnvironmentVariableIntValue(\"QT_QUICK3D_NO_SHADER_CACHE_LOAD\");\n-            if (!skipCacheFile && QFileInfo(m_persistentShaderStorageFileName).exists()) {\n+            if (!skipCacheFile && QFileInfo::exists(m_persistentShaderStorageFileName)) {\n                 if (shaderDebug)\n                     qDebug(\"Attempting to seed material shader cache from %s\", qPrintable(m_persistentShaderStorageFileName));\n                 if (m_persistentShaderBakingCache.load(m_persistentShaderStorageFileName)) {\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is created just to check for file existence, replace it with a static method call QFileInfo::exists for better performance."}
{"number": 308, "change": "@@ -194,7 +194,7 @@ uint32_t scap_fd_info_len(scap_fdinfo *fdi)\n \t\tres += \n \t\t\tsizeof(uint64_t) + // unix source \n \t\t\tsizeof(uint64_t) +  // unix destination\n-\t\t\t(uint32_t)strlen(fdi->info.unix_socket_info.fname) + 2;\n+\t\t\t(uint32_t)strnlen(fdi->info.unix_socket_info.fname, SCAP_MAX_PATH_SIZE) + 2;\n \t\tbreak;\n \tcase SCAP_FD_FIFO:\n \tcase SCAP_FD_FILE:\n", "fix_pattern": "<pattern>: if the code uses strlen with an input that might exceed a specific maximum size, replace it with strnlen to prevent potential buffer over-read and improve safety."}
{"number": 309, "change": "@@ -499,12 +499,12 @@ void handleAccessMemory(void *arg, Sift::MemoryLockType lock_signal, Sift::Memor\n    if (mem_op == Sift::MemRead)\n    {\n       // The simulator is requesting data from us\n-      memcpy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n+      PIN_SafeCopy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n    }\n    else if (mem_op == Sift::MemWrite)\n    {\n       // The simulator is requesting that we write data back to memory\n-      memcpy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n+      PIN_SafeCopy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n    }\n    else\n    {\n", "fix_pattern": "<pattern>: if a direct memory copy using memcpy is detected, replace it with a specialized third-party API method (e.g., PIN_SafeCopy) that is designed for more efficient or safer handling of memory operations in the context of the application (e.g., ensuring safety when dealing with instrumentation in a Pin-based environment)."}
{"number": 318, "change": "@@ -102,9 +102,9 @@ change_alpha( ssgBase *_branch, float _blend )\n   for (i = 0; i < ((ssgBranch *)_branch)->getNumKids(); i++)\n     change_alpha( ((ssgBranch *)_branch)->getKid(i), _blend );\n \n-  if ( strcmp(\"ssgLeaf\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVtxTable\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVTable\", _branch->getTypeName()) )\n+  if ( !_branch->isAKindOf(ssgTypeLeaf())\n+       && !_branch->isAKindOf(ssgTypeVtxTable())\n+       && !_branch->isAKindOf(ssgTypeVTable()) )\n     return;\n \n   int num_colors = ((ssgLeaf *)_branch)->getNumColours();\n", "fix_pattern": "<pattern>: if multiple `strcmp` calls are used to check the type of an object, replace them with a single call to `isAKindOf` for each type, allowing for better performance and readability by avoiding unnecessary string comparisons and leveraging type checking directly."}
{"number": 324, "change": "@@ -161,15 +161,13 @@ void MainWindow::InitializeUi() {\n }\n \n void MainWindow::ExpandCollapse(TreeState state) {\n-    // if it's connected during the call it's called for every item apparently, which is damn slow!\n-    disconnect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    disconnect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    // we block signals so that ResizeTreeColumns isn't called for every item, which is damn slow!\n+    ui->treeView->blockSignals(true);\n     if (state == TreeState::kExpand)\n         ui->treeView->expandAll();\n     else\n         ui->treeView->collapseAll();\n-    connect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    connect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    ui->treeView->blockSignals(false);\n \n     ResizeTreeColumns();\n }\n", "fix_pattern": "<pattern>: if multiple disconnect and connect calls are made around a function that can be slow if called repeatedly (like ResizeTreeColumns), use blockSignals to prevent the signal from triggering during a performance-critical operation to improve efficiency."}
{"number": 332, "change": "@@ -399,7 +399,8 @@ int main(int argc, char* argv[])\n                                 first = false;\n                             else\n                                 argument_builder.append(\", \"sv);\n-                            argument_builder.append(StringView(stream.copy_into_contiguous_buffer()).trim_whitespace());\n+                            ByteBuffer buffer = stream.copy_into_contiguous_buffer();\n+                            argument_builder.append(StringView(buffer).trim_whitespace());\n                         }\n                         dbgln(\"[wasm runtime] Stub function {} was called with the following arguments: {}\", name, argument_builder.to_string());\n                         Vector<Wasm::Value> result;\n", "fix_pattern": "<pattern>: if an API call is made to copy data into a contiguous buffer inline, separate that call into its own variable before using it, which can improve readability and potentially optimize performance by reducing unnecessary copies and exposing optimization opportunities."}
{"number": 334, "change": "@@ -122,8 +122,8 @@ void Job::on_socket_connected()\n                 }\n             }\n \n-            m_received_buffers.append(payload);\n             m_received_size += payload.size();\n+            m_received_buffers.append(move(payload));\n             flush_received_buffers();\n \n             deferred_invoke([this] { did_progress({}, m_received_size); });\n", "fix_pattern": "<pattern>: if an object is appended to a container in a manner that can lead to unnecessary copies, use std::move to transfer ownership and improve performance."}
{"number": 335, "change": "@@ -316,12 +316,6 @@ void Job::on_socket_connected()\n                 if (m_code == 204)\n                     return finish_up();\n \n-                can_read_line = m_socket->can_read_line();\n-                if (can_read_line.is_error())\n-                    return deferred_invoke([this] { did_fail(Core::NetworkJob::Error::TransmissionFailed); });\n-\n-                if (!can_read_line.value())\n-                    return;\n                 break;\n             }\n             auto parts = line.split_view(':');\n", "fix_pattern": "<pattern>: if a method call to check for a condition (like can_read_line) is followed by error checking and early returns, consider refactoring to handle both the condition check and error handling in a single call to reduce overhead from multiple API invocations and follow a more concise pattern."}
{"number": 344, "change": "@@ -3,6 +3,7 @@\n */\n \n #include <iostream>\n+#include <random>\n \n #include <args.hxx>\n \n@@ -80,10 +81,17 @@ std::string get_random_nums_str( std::size_t count )\n \n std::vector< int > get_random_nums( std::size_t count )\n {\n+\tstd::random_device r;\n+\tstd::mt19937 gen{ r() };\n+\tstd::uniform_int_distribution< int > uniform_dist;\n+\n \tstd::vector< int > result;\n \tresult.reserve( count );\n \n-\tstd::generate_n( std::back_inserter( result ), count, [](){ return rand(); } );\n+\tstd::generate_n(\n+\t\tstd::back_inserter( result ),\n+\t\tcount,\n+\t\t[&](){ return uniform_dist( gen ); } );\n \n \treturn result;\n }\n", "fix_pattern": "<pattern>: if random numbers are being generated using the rand() function, replace it with the C++ `<random>` library for improved randomness quality and better performance characteristics by leveraging modern random number generation facilities."}
{"number": 349, "change": "@@ -594,17 +594,16 @@ out_err:\n \t\t\tif (strcmp(name, \".gnu_debuglink\") == 0) {\n \t\t\t\tconst char *p = (const char *)data->d_buf;\n \t\t\t\tm_debuglink.append(p);\n-\n-\t\t\t\tp += strlen(p);\n+\t\t\t\tconst char *endOfString = p + strlen(p) + 1;\n \n \t\t\t\t// Align address for the CRC32\n-\t\t\t\tunsigned long addr = (unsigned long)p;\n-\t\t\t\tunsigned long offs = 4;\n+\t\t\t\tunsigned long addr = (unsigned long)(endOfString - p);\n+\t\t\t\tunsigned long offs = 0;\n \n \t\t\t\tif ((addr & 3) != 0)\n \t\t\t\t\toffs = 4 - (addr & 3);\n \t\t\t\t// ... and read out the CRC32\n-\t\t\t\tm_debuglinkCrc = *(uint32_t *)(p + offs);\n+\t\t\t\tmemcpy((void *)&m_debuglinkCrc, endOfString + offs, sizeof(m_debuglinkCrc));\n \t\t\t}\n \n \t\t\tif ((sh_flags & (SHF_EXECINSTR | SHF_ALLOC)) != (SHF_EXECINSTR | SHF_ALLOC))\n", "fix_pattern": "<pattern>: if the code previously accesses memory using pointer arithmetic and casts directly from a string, refactor it to use memcpy for copying data to avoid potential alignment issues and improve safety when handling raw memory operations."}
{"number": 352, "change": "@@ -355,8 +355,8 @@ static int PlayerQuit[PlayerMax];          /// Player quit\n static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int player = 255)\n {\n \tconst unsigned int size = packet.Size(numcommands);\n-\tunsigned char *buf = new unsigned char[size];\n-\tpacket.Serialize(buf, numcommands);\n+\tstd::vector<unsigned char> buf(size);\n+\tpacket.Serialize(buf.data(), numcommands);\n \n \t// Send to all clients.\n \tif (NetConnectType == 1) { // server\n@@ -366,14 +366,13 @@ static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int\n \t\t\t\tif (Hosts[i].PlyNr == player) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tNetworkFildes.Send(host, buf, size);\n+\t\t\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t\t\t}\n \t\t}\n \t} else { // client\n \t\tconst CHost host(Hosts[0].Host, Hosts[0].Port);\n-\t\tNetworkFildes.Send(host, buf, size);\n+\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t}\n-\tdelete[] buf;\n }\n \n /**\n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a raw buffer (e.g., using `new`), replace it with a `std::vector` to manage memory automatically and improve safety and performance by eliminating the need for manual deallocation."}
{"number": 354, "change": "@@ -5491,7 +5491,7 @@ static void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {\n     }\n \n     /* read keys to be used for input */\n-    src = malloc(sizeof(zsetopsrc) * zsetnum);\n+    src = zmalloc(sizeof(zsetopsrc) * zsetnum);\n     for (i = 0, j = 3; i < zsetnum; i++, j++) {\n         robj *zsetobj = lookupKeyWrite(c->db,c->argv[j]);\n         if (!zsetobj) {\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, replace it with a project-specific memory allocation function (e.g., zmalloc) for better performance and potential benefits such as memory tracking or improved allocation strategies specific to the project."}
{"number": 359, "change": "@@ -1584,7 +1584,7 @@ static redisReply *sendScan(unsigned long long *it) {\n     assert(reply->element[1]->type == REDIS_REPLY_ARRAY);\n \n     /* Update iterator */\n-    *it = atoi(reply->element[0]->str);\n+    *it = strtoull(reply->element[0]->str, NULL, 10);\n \n     return reply;\n }\n", "fix_pattern": "<pattern>: if converting a string to an integer, replace atoi with strtoull for better performance and to avoid potential overflow issues, as strtoull handles larger values and is more precise in conversion."}
{"number": 364, "change": "@@ -498,8 +498,13 @@ void Battlenet::Session::HandleJoinRequestV2(WoWRealm::JoinRequestV2 const& join\n \n     memcpy(sessionKey + hmac.GetLength(), hmac2.GetDigest(), hmac2.GetLength());\n \n-    LoginDatabase.DirectPExecute(\"UPDATE account SET sessionkey = '%s', last_ip = '%s', last_login = NOW(), locale = %u, failed_logins = 0, os = '%s' WHERE id = %u\",\n-        ByteArrayToHexStr(sessionKey, 40, true).c_str(), GetRemoteIpAddress().to_string().c_str(), GetLocaleByName(_locale), _os.c_str(), _gameAccountInfo->Id);\n+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_LOGONPROOF);\n+    stmt->setString(0, ByteArrayToHexStr(sessionKey, 40, true).c_str());\n+    stmt->setString(1, GetRemoteIpAddress().to_string());\n+    stmt->setUInt32(2, GetLocaleByName(_locale));\n+    stmt->setString(3, _os);\n+    stmt->setString(4, _gameAccountInfo->Name);\n+    LoginDatabase.DirectExecute(stmt);\n \n     joinResponse->IPv4.emplace_back(*realm->ExternalAddress, realm->Port);\n     if (*realm->ExternalAddress != *realm->LocalAddress)\n", "fix_pattern": "<pattern>: if raw SQL queries are being constructed and executed directly, replace them with prepared statements to improve performance and security by avoiding SQL injection and allowing the database engine to optimize query execution."}
{"number": 365, "change": "@@ -887,7 +887,7 @@ class Simplex_tree {\n     while (true) {\n       if (begin1->first == begin2->first) {\n         Filtration_value filt = (std::max)({begin1->second.filtration(), begin2->second.filtration(), filtration_});\n-        intersection.push_back(std::pair<Vertex_handle, Node>(begin1->first, Node(NULL, filt)));\n+        intersection.emplace_back(begin1->first, Node(NULL, filt));\n         if (++begin1 == end1 || ++begin2 == end2)\n           return;  // ----->>\n       } else if (begin1->first < begin2->first) {\n", "fix_pattern": "<pattern>: if std::vector's push_back is used to create a new object that could be constructed in place, replace it with emplace_back to avoid unnecessary copy or move operations, improving performance."}
{"number": 367, "change": "@@ -226,7 +226,7 @@ bool Info::Read(XrdOssDF* fp, const std::string &fname)\n       for (int i =0; i < 16; ++i)\n       printf(\"%x\", m_store.m_cksum[i] & 0xff);\n     */\n-   if (strncmp(m_store.m_cksum, &tmpCksum[0], 16))\n+   if (memcmp(m_store.m_cksum, &tmpCksum[0], 16))\n    {\n       TRACE(Error, trace_pfx << \" buffer cksum and saved cksum don't match \\n\");\n       return false;\n", "fix_pattern": "<pattern>: if a comparison of two byte sequences is performed using strncmp, replace it with memcmp for improved performance, as memcmp is optimized for binary comparison and avoids string-specific nuances."}
{"number": 368, "change": "@@ -74,10 +74,9 @@ bool State::InstallHandlers(CURL *curl) {\n     // Older versions have poor transfer performance, corrected in curl commit cacdc27f.\n     curl_version_info_data *curl_ver = curl_version_info(CURLVERSION_NOW);\n     if (curl_ver->age > 0 && curl_ver->version_num >= 0x072600) {\n-        // Require a minimum speed from the transfer: must move at least 1MB every 2 minutes\n-        // (roughly 8KB/s).\n+        // Require a minimum speed from the transfer: 2 minute average must at least 10KB/s\n         curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 2*60);\n-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1024*1024);\n+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 10*1024);\n     }\n     return true;\n }\n", "fix_pattern": "<pattern>: if CURLOPT_LOW_SPEED_LIMIT is being set, adjust the limit calculation to a more appropriate value that reflects performance expectations, ensuring the speed requirement aligns with bytes per second rather than total bytes over an extended period."}
{"number": 369, "change": "@@ -1579,10 +1579,11 @@ int XrdHttpProtocol::StartChunkedResp(int code, const char *desc, const char *he\n /******************************************************************************/\n   \n int XrdHttpProtocol::ChunkResp(const char *body, long long bodylen) {\n-  if (ChunkRespHeader((bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen))\n+  long long content_length = (bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen;\n+  if (ChunkRespHeader(content_length))\n     return -1;\n \n-  if (body && SendData(body, bodylen))\n+  if (body && SendData(body, content_length))\n     return -1;\n \n   return ChunkRespFooter();\n", "fix_pattern": "<pattern>: if the content length is calculated multiple times from the provided arguments, store the result in a variable to avoid redundant calculations, improving readability and potential performance due to less computation."}
{"number": 383, "change": "@@ -191,7 +191,7 @@ struct buffer : public buffer_base {\n         int rem = (pos <= lim ? lim - pos : 0);\n \n         //rem << 2? wtf?\n-        memcpy(bf.get(), bf.get() + position(), rem << 2);\n+        memmove(bf.get(), bf.get() + position(), rem << 2);\n \n         position(rem);\n         limit(capacity());\n", "fix_pattern": "<pattern>: if a memory operation involves overlapping source and destination regions, replace memcpy with memmove to ensure correct behavior without undefined behavior, as memmove handles overlapping regions safely."}
{"number": 386, "change": "@@ -33,7 +33,7 @@\n #include <wx/debug.h>\n #include <wx/fileconf.h>\n #include <wx/filename.h>\n-#include <wx/ffile.h>\n+#include <wx/wfstream.h>\n \n \n const wxChar* const traceSettings = wxT( \"KICAD_SETTINGS\" );\n@@ -392,9 +392,10 @@ bool JSON_SETTINGS::SaveToFile( const wxString& aDirectory, bool aForce )\n         std::stringstream buffer;\n         buffer << std::setw( 2 ) << *this << std::endl;\n \n-        wxFFile   file( path.GetFullPath(), \"wb\" );\n+        wxFFileOutputStream fileStream( path.GetFullPath(), \"wb\" );\n \n-        if( !file.IsOpened() || !file.Write( buffer.str().c_str(), buffer.str().size() ) )\n+        if( !fileStream.IsOk()\n+                || !fileStream.WriteAll( buffer.str().c_str(), buffer.str().size() ) )\n         {\n             wxLogTrace( traceSettings, \"Warning: could not save %s\", GetFullFilename() );\n             success = false;\n", "fix_pattern": "<pattern>: if wxFFile is used for file output, replace it with wxFFileOutputStream to leverage the optimized WriteAll method for performance improvements in file writing operations."}
{"number": 389, "change": "@@ -53,7 +53,8 @@ bool mitk::MovieGeneratorOpenCV::InitGenerator()\n \n bool mitk::MovieGeneratorOpenCV::AddFrame( void *data )\n {\n-  cvSetImageData(m_currentFrame,data,m_width*3);\n+  //cvSetImageData(m_currentFrame,data,m_width*3);\n+  memcpy(data,m_currentFrame->imageData,m_width*m_height*3);\n   cvWriteFrame(m_aviWriter,m_currentFrame);\n   return true;\n }\n", "fix_pattern": "<pattern>: if an API call is used to set image data, replace it with a direct memory copy using memcpy for improved performance, as this avoids the overhead associated with the API function and can lead to faster execution."}
{"number": 391, "change": "@@ -39,7 +39,7 @@\n #include \"vtkUnsignedLongArray.h\"\n #include \"vtkUnsignedShortArray.h\"\n \n-vtkCxxRevisionMacro(vtkCompleteArrays, \"1.8\");\n+vtkCxxRevisionMacro(vtkCompleteArrays, \"1.9\");\n vtkStandardNewMacro(vtkCompleteArrays);\n \n vtkCxxSetObjectMacro(vtkCompleteArrays,Controller,vtkMultiProcessController);\n@@ -101,10 +101,7 @@ int vtkCompleteArrays::RequestData(\n       {\n       noNeed = 1;\n       }\n-    for (idx = 1; idx < numProcs; ++idx)\n-      {\n-      this->Controller->Send(&noNeed, 1, idx, 3389001);\n-      }\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n@@ -151,7 +148,7 @@ int vtkCompleteArrays::RequestData(\n     }\n   else\n     { // remote processes\n-    this->Controller->Receive(&noNeed, 1, 0, 3389001);\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n", "fix_pattern": "<pattern>: if a loop is used to send messages individually to multiple destinations using the Send method, replace it with a Broadcast call to streamline communication, reducing overhead."}
{"number": 392, "change": "@@ -28,7 +28,7 @@\n #include <QRegExp>\n \n vtkStandardNewMacro(vtkSMXYChartViewProxy);\n-vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.7\");\n+vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.8\");\n //----------------------------------------------------------------------------\n vtkSMXYChartViewProxy::vtkSMXYChartViewProxy()\n {\n@@ -53,6 +53,8 @@ vtkContextView* vtkSMXYChartViewProxy::NewChartView()\n   // Construct a new chart view and return the view of it\n   this->Chart = vtkChartXY::New();\n   this->ChartView->GetScene()->AddItem(this->Chart);\n+  // Do not use the buffer id for now - performance issues.\n+  this->ChartView->GetScene()->SetUseBufferId(false);\n \n   return this->ChartView;\n }\n", "fix_pattern": "<pattern>: if a performance issue is identified with the usage of buffer IDs in VTK's rendering context, disable the use of buffer IDs by calling `SetUseBufferId(false)` to potentially improve rendering performance while transitioning between versions."}
{"number": 394, "change": "@@ -901,7 +901,8 @@ static size_t VSICurlHandleWriteFunc( void *buffer, size_t count,\n static bool VSICurlIsS3SignedURL( const char* pszURL )\n {\n     return\n-        strstr(pszURL, \".s3.amazonaws.com/\") != NULL &&\n+        (strstr(pszURL, \".s3.amazonaws.com/\") != NULL ||\n+         strstr(pszURL, \".storage.googleapis.com/\") != NULL) &&\n         (strstr(pszURL, \"&Signature=\") != NULL ||\n          strstr(pszURL, \"?Signature=\") != NULL);\n }\n", "fix_pattern": "<pattern>: if multiple calls are made to strstr with the same haystack, combine checks for efficiency by using logical OR to minimize the number of function calls."}
{"number": 398, "change": "@@ -3260,8 +3260,15 @@ void TV::ChangeChannel(int direction)\n \n QString TV::GetQueuedChanNum(void) const\n {\n+    static QRegExp regexp = QRegExp(\"([1-9]|\\\\w)\");\n+\n+    // avoid regular expression if queue is empty.\n+    if (queuedChanNum.isEmpty())\n+        return queuedChanNum;\n+\n     // strip initial zeros.\n-    int nzi = queuedChanNum.find(QRegExp(\"([1-9]|\\\\w)\"));\n+    regexp.setMinimal(true); // we don't need greedy matching\n+    int nzi = queuedChanNum.find(regexp);\n     if (nzi > 0)\n         queuedChanNum = queuedChanNum.right(queuedChanNum.length() - nzi);\n \n", "fix_pattern": "<pattern>: if a regular expression is created in every call, move the QRegExp object to a static variable to avoid repeated allocation and initialization overhead; also, set minimal matching to improve performance when searching."}
{"number": 400, "change": "@@ -150,7 +150,7 @@ WebSocketParser::addStreamData(const char* data, unsigned int len) {\n WebSocketFrame*\n WebSocketParser::getNextFrame() {\n   if (!mHeaderHandled) {\n-    char* pos = strstr(mData, \"\\r\\n\\r\\n\");\n+    char* pos = (char*) memmem(mData, mLength, \"\\r\\n\\r\\n\", 4);\n \n     if (pos) {\n       char* data = (char*) malloc(pos - mData);\n", "fix_pattern": "<pattern>: if the API method strstr is used for finding a substring in a large data buffer, replace it with the more efficient memmem function, which allows for specification of the length of the haystack, resulting in better performance."}
{"number": 402, "change": "@@ -89,7 +89,8 @@ public:\n             if (   ((flags() & kMethcla_BusMappingExternal) == kMethcla_BusMappingExternal)\n                 || ((flags() & kMethcla_BusMappingFeedback) == kMethcla_BusMappingFeedback)\n                 || (bus()->epoch() == env.epoch())) {\n-                memcpy(dst, bus()->data() + offset, numFrames * sizeof(sample_t));\n+                const sample_t* buffer = bus()->data();\n+                std::copy(buffer + offset, buffer + offset + numFrames, dst);\n             } else {\n                 memset(dst, 0, numFrames * sizeof(sample_t));\n             }\n", "fix_pattern": "<pattern>: if a memcpy operation copies a range of data from one location to another, consider using std::copy as a more expressive and potentially optimized alternative, which provides better type safety and integration with STL containers."}
{"number": 407, "change": "@@ -45,6 +45,7 @@\n \n /* Includes */\n #include <precomp.hpp>\n+#include <opencv2/core.hpp>\n #include <stdlib.h>\n #include <stdio.h>\n #include <stdint.h>\n@@ -476,11 +477,7 @@ inline int    RHO_HEST_REFC::initialize(void){\n     lm.tmp1     = NULL;\n     lm.Jte      = NULL;\n \n-#ifdef _WIN32\n-    fastSeed(rand());\n-#else\n-    fastSeed(random());\n-#endif\n+    fastSeed((unsigned)cv::theRNG());\n \n \n     int areAllAllocsSuccessful = ctrl.smpl   &&\n", "fix_pattern": "<pattern>: if the code uses platform-specific random number generation (like rand() for Windows or random() for other platforms), refactor it to use a central random number generator from a library (such as OpenCV's cv::theRNG) for better consistency and potentially improved performance."}
{"number": 408, "change": "@@ -30,14 +30,7 @@ namespace log4cpp {\n                                const std::string& fileName) : \n             LayoutAppender(name),\n             _fileName(fileName) {\n-#if defined(__OPENVMS__)\n-        // shr=get, File Sharing Options, Allow users to read\n-        // ctx=rec, Force record mode access\n-        // rop=rea, Record-processing options, Locks record for a read operation for this process, while allowing other accessors to read the record. \n-        _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644, \"shr=get\",\"ctx=rec\",\"rop=rea\");\n-#else\n         _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644);\n-#endif\n     }\n     \n     FileAppender::FileAppender(const std::string& name, int fd) :\n", "fix_pattern": "<pattern>: NA"}
{"number": 409, "change": "@@ -802,10 +802,10 @@ void flex_rewrite::quantized_graph_rewrite(deserialized_graph &dgraph) {\n         const dnnl_dims_t scales_dims {scales_zp_dim};\n         const auto scales_md\n                 = dnn_mem_t::init_md(1, scales_dims, dnnl_f32, tag::abx);\n-        dnn_mem_t scales_mem(\n-                scales_md, get_cpu_engine(), {false, scales.data()});\n-        dnn_mem_t dummy;\n-        fill_scales(e, dummy, scales_mem);\n+        dnn_mem_t scales_dt(\n+                scales_md, get_test_engine().get(), {false, scales.data()});\n+        dnn_mem_t scales_fp(scales_md, get_test_engine().get());\n+        fill_scales(e, scales_dt, scales_fp);\n \n         std::vector<int64_t> zps;\n         for (int64_t i = 0; i < scales_zp_dim; i++) {\n", "fix_pattern": "<pattern>: When using the DNNL library, if obtaining memory for a computation is done using a CPU engine, switch to using a test engine for memory allocation to potentially improve performance in testing scenarios, and ensure that both the destination and source memories are prepared for the operation being performed."}
{"number": 411, "change": "@@ -20,7 +20,7 @@ XMLException::XMLException(const string& msg)\n auto_ptr<XMLElement> XMLLoader::loadXML(const string& filename,\n                                         const string& systemID)\n {\n-\txmlDocPtr doc = xmlParseFile(filename.c_str());\n+\txmlDocPtr doc = xmlReadFile(filename.c_str(), NULL, 0);\n \tif (!doc) {\n \t\tthrow XMLException(filename + \": Document parsing failed\");\n \t}\n", "fix_pattern": "<pattern>: if the code is using xmlParseFile to parse an XML file, replace it with xmlReadFile, which allows for additional options and generally offers better performance and flexibility in handling XML parsing with more control over the input parameters."}
{"number": 412, "change": "@@ -2,7 +2,7 @@\n \n #include \"SDLImage.hh\"\n #include \"OutputSurface.hh\"\n-#include \"LocalFileReference.hh\"\n+#include \"File.hh\"\n #include \"MSXException.hh\"\n #include \"vla.hh\"\n #include \"build-info.hh\"\n@@ -183,10 +183,12 @@ static SDL_Surface* loadImage(\n \n SDL_Surface* SDLImage::readImage(const string& filename)\n {\n-\tLocalFileReference file(filename);\n-\tSDL_RWops *src = SDL_RWFromFile(file.getFilename().c_str(), \"rb\");\n+\tFile file(filename);\n+\tSDL_RWops *src = SDL_RWFromConstMem(file.mmap(), file.getSize());\n \tif (!src) {\n-\t\tthrow MSXException(\"Could not open image file \\\"\" + filename + \"\\\"\");\n+\t\tthrow MSXException(\n+\t\t\t\"Failed to create SDL_RWops for mmapped file \\\"\" + filename + \"\\\"\"\n+\t\t\t);\n \t}\n \tSDL_Surface* result = IMG_LoadPNG_RW(src);\n \tSDL_RWclose(src);\n", "fix_pattern": "<pattern>: if a file is opened with SDL_RWFromFile for reading, replace it with SDL_RWFromConstMem which utilizes memory mapping for potentially better performance, especially for large files."}
{"number": 417, "change": "@@ -110,7 +110,7 @@ int QCollator::compare(const QChar *s1, int len1, const QChar *s2, int len2) con\n     if (d->collator)\n         return ucol_strcoll(d->collator, (const UChar *)s1, len1, (const UChar *)s2, len2);\n \n-    return QString::compare(QString(s1, len1), QString(s2, len2), d->caseSensitivity);\n+    return QString::compare_helper(s1, len1, s2, len2, d->caseSensitivity);\n }\n \n int QCollator::compare(const QString &s1, const QString &s2) const\n", "fix_pattern": "<pattern>: if an API method (QString::compare) is potentially less efficient than a specialized helper (QString::compare_helper), replace calls to the less efficient method with the specialized helper to improve performance."}
{"number": 419, "change": "@@ -704,10 +704,9 @@ void QSslSocketBackendPrivate::transmit()\n                 // Write encrypted data from the buffer into the read BIO.\n                 int writtenToBio = q_BIO_write(readBio, data.constData(), encryptedBytesRead);\n \n-                // do the actual read() here and throw away the results.\n+                // Throw away the results.\n                 if (writtenToBio > 0) {\n-                    // ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek\n-                    plainSocket->read(data.data(), writtenToBio);\n+                    plainSocket->skip(writtenToBio);\n                 } else {\n                     // ### Better error handling.\n                     setErrorAndEmit(QAbstractSocket::SslInternalError,\n", "fix_pattern": "<pattern>: if data read from a socket is not needed, replace the read operation with skip() to avoid unnecessary memory copying and improve performance."}
{"number": 426, "change": "@@ -2585,7 +2585,7 @@ static int qMetaTypeCustomType_unlocked(const char *typeName, int length)\n #if QT_CONFIG(thread)\n         Q_ASSERT(!reg->lock.tryLockForWrite());\n #endif\n-        if (auto ti = reg->aliases.value(QByteArray(typeName, length), nullptr)) {\n+        if (auto ti = reg->aliases.value(QByteArray::fromRawData(typeName, length), nullptr)) {\n             return ti->typeId;\n         }\n     }\n", "fix_pattern": "<pattern>: if a QByteArray is created using the constructor with QByteArray(typeName, length), then refactor the code to use QByteArray::fromRawData(typeName, length) for a more efficient creation without unnecessary overhead."}
{"number": 430, "change": "@@ -606,9 +606,8 @@ QByteArray qCompress(const uchar* data, qsizetype nbytes, int compressionLevel)\n             qToBigEndian(CompressSizeHint_t(nbytes), bazip.data());\n             break;\n         case Z_MEM_ERROR:\n-            qWarning(\"qCompress: Z_MEM_ERROR: Not enough memory\");\n-            bazip.resize(0);\n-            break;\n+            return tooMuchData(ZLibOp::Compression);\n+\n         case Z_BUF_ERROR:\n             len *= 2;\n             break;\n", "fix_pattern": "<pattern>: if there is a scenario where qWarning is called due to insufficient memory and the subsequent action is to resize a QByteArray to 0, replace it with an early return that indicates the error condition, thus avoiding unnecessary operations related to resizing the QByteArray and improving performance by reducing function overhead."}
{"number": 438, "change": "@@ -74,15 +74,13 @@ void MatrixFreePDE<dim,degree>::getIntegralMF(const MatrixFree<dim,double> &data\n \n         unsigned int num_q_points = var.n_q_points;\n \n-\t\tdealii::AlignedVector<dealii::VectorizedArray<double> > JxW(num_q_points);\n-\t\tvar.fill_JxW_values(JxW);\n-\n         //loop over quadrature points\n         for (unsigned int q=0; q<num_q_points; ++q){\n \t\t\tdealii::VectorizedArray<double> val = var.get_value(q);\n+\t\t\tdealii::VectorizedArray<double> jxw = var.JxW(q);\n \t\t\tassembler_lock.lock ();\n-\t\t\tfor (unsigned i=0; i<val.n_array_elements;i++){\n-\t\t\t\tintegrated_var += val[i]*JxW[q][i];\n+\t\t\tfor (unsigned i=0; i<val.size();i++){\n+\t\t\t\tintegrated_var += val[i]*jxw[i];\n \t\t\t}\n \t\t\tassembler_lock.unlock ();\n         }\n", "fix_pattern": "<pattern>: if the code directly fills a buffer for JxW values and then accesses it in a loop, replace the buffer fill with a direct access from the method returning the value for the specific quadrature point, thus avoiding unnecessary memory allocation and copying."}
{"number": 439, "change": "@@ -84,10 +84,15 @@ void tst_QPacketProtocol::init()\n     QVERIFY(m_server->listen(QHostAddress(\"127.0.0.1\")));\n \n     m_client = new QTcpSocket(this);\n+\n+    QSignalSpy serverSpy(m_server, SIGNAL(newConnection()));\n+    QSignalSpy clientSpy(m_client, SIGNAL(connected()));\n+\n     m_client->connectToHost(m_server->serverAddress(), m_server->serverPort());\n \n-    QVERIFY(m_client->waitForConnected());\n-    QVERIFY(m_server->waitForNewConnection(10000));\n+    QVERIFY(clientSpy.count() > 0 || clientSpy.wait());\n+    QVERIFY(serverSpy.count() > 0 || serverSpy.wait());\n+\n     m_serverConn = m_server->nextPendingConnection();\n }\n \n", "fix_pattern": "<pattern>: if the code uses synchronous blocking methods (like waitForConnected and waitForNewConnection) that can potentially stall execution, refactor it to utilize signals and slots with QSignalSpy, allowing for a non-blocking check of connection status while still waiting for events effectively."}
{"number": 440, "change": "@@ -3521,7 +3521,7 @@ void QQuickWindow::setColor(const QColor &color)\n     }\n     d->clearColor = color;\n     emit colorChanged(color);\n-    d->dirtyItem(contentItem());\n+    update();\n }\n \n QColor QQuickWindow::color() const\n", "fix_pattern": "<pattern>: if a call to `dirtyItem(contentItem())` is replaced with a call to `update()`, use `update()` directly to refresh the entire window instead of marking a specific item as dirty, potentially avoiding unnecessary updates and improving overall performance."}
{"number": 441, "change": "@@ -435,15 +435,14 @@ void QQuickWindow::physicalDpiChanged()\n void QQuickWindow::handleScreenChanged(QScreen *screen)\n {\n     Q_D(QQuickWindow);\n+    disconnect(d->physicalDpiChangedConnection);\n     if (screen) {\n         physicalDpiChanged();\n         // When physical DPI changes on the same screen, either the resolution or the device pixel\n         // ratio changed. We must check what it is. Device pixel ratio does not have its own\n         // ...Changed() signal.\n-        d->physicalDpiChangedConnection = connect(screen, SIGNAL(physicalDotsPerInchChanged(qreal)),\n-                                                  this, SLOT(physicalDpiChanged()));\n-    } else {\n-        disconnect(d->physicalDpiChangedConnection);\n+        d->physicalDpiChangedConnection = connect(screen, &QScreen::physicalDotsPerInchChanged,\n+                                                  this, &QQuickWindow::physicalDpiChanged);\n     }\n \n     d->forcePolish();\n", "fix_pattern": "<pattern>: if using the old SIGNAL/SLOT macros for connecting signals and slots, replace them with the new method syntax for better performance and type safety; also ensure proper disconnecting of existing connections before re-connecting."}
{"number": 443, "change": "@@ -571,7 +571,7 @@ Status TensorToNdarray(const Tensor& t, PyObject** ret) {\n   if (!status.ok()) {\n     return status;\n   }\n-  return TF_TensorToPyArray(std::move(tf_tensor), ret);\n+  return TF_TensorToMaybeAliasedPyArray(std::move(tf_tensor), ret);\n }\n \n }  // namespace tensorflow\n", "fix_pattern": "<pattern>: if an API function that directly converts a TensorFlow tensor to a Python array is replaced with a potentially more optimized function that allows for aliasing, then consider using TF_TensorToMaybeAliasedPyArray for better performance or reduced memory overhead."}
{"number": 447, "change": "@@ -177,7 +177,9 @@ void ServerLobby::initDatabase()\n     m_ip_geolocation_table_exists = false;\n     if (!ServerConfig::m_sql_management)\n         return;\n-    int ret = sqlite3_open(ServerConfig::m_database_file.c_str(), &m_db);\n+    int ret = sqlite3_open_v2(ServerConfig::m_database_file.c_str(), &m_db,\n+        SQLITE_OPEN_SHAREDCACHE | SQLITE_OPEN_FULLMUTEX |\n+        SQLITE_OPEN_READWRITE, NULL);\n     if (ret != SQLITE_OK)\n     {\n         Log::error(\"ServerLobby\", \"Cannot open database: %s.\",\n", "fix_pattern": "<pattern>: if a database connection is being opened with sqlite3_open, consider using sqlite3_open_v2 with appropriate flags to enable shared cache and full mutex support for improved performance and better concurrency control."}
{"number": 449, "change": "@@ -159,8 +159,8 @@ const QString get_dc_nickname(const char *model, uint32_t deviceid)\n {\n \tconst DiveComputerNode *existNode = dcList.getExact(model, deviceid);\n \tif (!existNode)\n-\t\treturn QString(\"\");\n-\tif (existNode->nickName != \"\")\n+\t\treturn QString();\n+\telse if (!existNode->nickName.isEmpty())\n \t\treturn existNode->nickName;\n \telse\n \t\treturn model;\n", "fix_pattern": "<pattern>: if returning an empty QString, use the default constructor QString() instead of QString(\"\") for better clarity and consistency; if checking for empty strings, utilize isEmpty() method instead of comparing to an empty string literal."}
{"number": 452, "change": "@@ -1,6 +1,6 @@\n \n /*\n- * $Id: HttpReply.cc,v 1.93 2007/05/18 06:41:22 amosjeffries Exp $\n+ * $Id: HttpReply.cc,v 1.94 2007/05/22 16:37:26 rousskov Exp $\n  *\n  * DEBUG: section 58    HTTP Reply (Response)\n  * AUTHOR: Alex Rousskov\n@@ -433,7 +433,7 @@ HttpReply::bodySize(method_t method) const\n \n bool HttpReply::sanityCheckStartLine(MemBuf *buf, http_status *error)\n {\n-    if (buf->contentSize() >= protoPrefix.size() && strncmp(protoPrefix, buf->content(), protoPrefix.size()) != 0) {\n+    if (buf->contentSize() >= protoPrefix.size() && protoPrefix.compare(buf->content(), protoPrefix.size()) != 0) {\n         debugs(58, 3, \"HttpReply::sanityCheckStartLine: missing protocol prefix (\" << protoPrefix << \") in '\" << buf->content() << \"'\");\n         *error = HTTP_INVALID_HEADER;\n         return false;\n", "fix_pattern": "<pattern>: if a comparison is performed between a C-style string using `strncmp`, replace it with the corresponding `std::string::compare` method for improved safety and potential performance, as it utilizes STL optimizations."}
{"number": 469, "change": "@@ -249,7 +249,7 @@ ColorCorrectionPrivate::ColorCorrectionPrivate(ColorCorrection *parent)\n \n     // Establish a D-Bus communication interface with KolorServer\n     m_csi = new ColorServerInterface(\n-        QStringLiteral(\"org.kde.kded\"),\n+        QStringLiteral(\"org.kde.kded5\"),\n         QStringLiteral(\"/modules/kolorserver\"),\n         QDBusConnection::sessionBus(),\n         this);\n", "fix_pattern": "<pattern>: if a QStringLiteral is being adjusted to use a specific versioning scheme in the context of an API (like 'kded5' instead of 'kded'), ensure the version is updated to maintain compatibility or performance benefits without direct performance implications."}
{"number": 481, "change": "@@ -496,6 +496,7 @@ void\n GlassTable::compact(byte * p)\n {\n     LOGCALL_VOID(DB, \"GlassTable::compact\", (void*)p);\n+    Assert(p != buffer);\n     Assert(writable);\n     int e = block_size;\n     byte * b = buffer;\n@@ -504,10 +505,10 @@ GlassTable::compact(byte * p)\n \tItem item(p, c);\n \tint l = item.size();\n \te -= l;\n-\tmemmove(b + e, item.get_address(), l);\n+\tmemcpy(b + e, item.get_address(), l);\n \tsetD(p, c, e);  /* reform in b */\n     }\n-    memmove(p + e, b + e, block_size - e);  /* copy back */\n+    memcpy(p + e, b + e, block_size - e);  /* copy back */\n     e -= dir_end;\n     SET_TOTAL_FREE(p, e);\n     SET_MAX_FREE(p, e);\n", "fix_pattern": "<pattern>: if using memmove for non-overlapping memory regions, replace it with memcpy for better performance, ensuring to assert that the pointers do not point to the same buffer before copying."}
{"number": 494, "change": "@@ -32,12 +32,14 @@\n #include <mutex>\n #include <thread>\n \n+#include <android-base/chrono_utils.h>\n #include <android-base/file.h>\n #include <android-base/logging.h>\n #include <android-base/properties.h>\n #include <android-base/stringprintf.h>\n \n using android::base::StringPrintf;\n+using android::base::boot_clock;\n using namespace std::chrono_literals;\n \n namespace android {\n@@ -50,9 +52,9 @@ static std::condition_variable g_bootcharting_finished_cv;\n static bool g_bootcharting_finished;\n \n static long long get_uptime_jiffies() {\n-  std::string uptime;\n-  if (!android::base::ReadFileToString(\"/proc/uptime\", &uptime)) return 0;\n-  return 100LL * strtod(uptime.c_str(), NULL);\n+    constexpr int64_t kNanosecondsPerJiffy = 10000000;\n+    boot_clock::time_point uptime = boot_clock::now();\n+    return uptime.time_since_epoch().count() / kNanosecondsPerJiffy;\n }\n \n static std::unique_ptr<FILE, decltype(&fclose)> fopen_unique(const char* filename,\n", "fix_pattern": "<pattern>: if reading from a file using ReadFileToString incurs file I/O overhead, replace it with a high-resolution clock implementation (like boot_clock) to retrieve uptime directly without file access, significantly improving performance."}
{"number": 505, "change": "@@ -416,7 +416,7 @@ void BtLocalDevice::connectToServiceViaSearch()\n                 socket->setPreferredSecurityFlags(securityFlags);\n \n             QBluetoothServiceInfo info = foundTestServers.at(0);\n-            socket->connectToService(info.device().address(), QBluetoothUuid(QString(TEST_SERVICE_UUID)));\n+            socket->connectToService(info);\n         } else {\n             qWarning() << \"Perform search for test service before triggering this function\";\n         }\n", "fix_pattern": "<pattern>: if the API method connects to a Bluetooth service using a separate address and UUID, consolidate the parameters into a single `QBluetoothServiceInfo` object to streamline the connection process and improve performance by reducing function calls."}
{"number": 506, "change": "@@ -212,7 +212,7 @@ void Video_Dumb::flip() {\n   }\n \n #ifdef UGS_LINUX\n-  sleep(0);\n+  usleep(1);\n #endif\n \n   framecount++;\n", "fix_pattern": "<pattern>: if the code is using the sleep function with a duration of 0 seconds to yield control, replace it with usleep(1) to yield control more effectively while allowing for a minimal sleep time and potentially reducing CPU usage."}
{"number": 508, "change": "@@ -19,6 +19,7 @@\n #include <sys/un.h>\n #include <event.h>\n #include <stdlib.h>\n+#include <sys/socket.h>\n \n struct delegate_info {\n     const char *helper;\n@@ -58,7 +59,7 @@ delegate_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle delegate process: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a blocking read operation is replaced with a non-blocking receive operation using `recv` with the `MSG_DONTWAIT` flag to improve responsiveness and potentially avoid blocking on socket reads."}
{"number": 509, "change": "@@ -19,6 +19,7 @@\n #include <string.h>\n #include <unistd.h>\n #include <sys/un.h>\n+#include <sys/socket.h>\n #include <event.h>\n \n struct tcp_stock_connection {\n@@ -84,7 +85,7 @@ tcp_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle TCP connection: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a direct read operation is used to read data from a socket, replace it with the recv function and make use of flags like MSG_DONTWAIT to improve responsiveness by handling non-blocking I/O."}
{"number": 513, "change": "@@ -46,7 +46,6 @@\n #include \"istream/istream.hxx\"\n #include \"istream/istream_cat.hxx\"\n #include \"istream/DelayedIstream.hxx\"\n-#include \"istream/istream_hold.hxx\"\n #include \"istream/istream_iconv.hxx\"\n #include \"istream/istream_null.hxx\"\n #include \"istream/istream_pause.hxx\"\n@@ -369,12 +368,12 @@ embed_inline_widget(struct pool &pool, struct processor_env &env,\n     auto iw = NewFromPool<InlineWidget>(pool, pool, env, plain_text, widget,\n                                         delayed.second);\n \n-    Istream *hold = istream_hold_new(pool, *iw->MakeResponse(std::move(delayed.first)).Steal());\n+    UnusedHoldIstreamPtr hold(pool, iw->MakeResponse(std::move(delayed.first)));\n \n     iw->Start();\n \n     if (pause)\n         pause->Resume();\n \n-    return UnusedIstreamPtr(hold);\n+    return std::move(hold);\n }\n", "fix_pattern": "<pattern>: if an input stream is created and held using a custom function that can introduce overhead, refactor the code to use a smart pointer with move semantics to streamline resource management and improve performance."}
{"number": 521, "change": "@@ -101,19 +101,15 @@ extern \"C\" BIRDEE_BINDING_API int RunGenerativeScript(int argc, char** argv)\n \tInitPython();\n \tif (argc>0)\n \t{\n-#ifdef _WIN32\n-\t\tstd::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n-#else\n-\t\tstd::wstring_convert<std::codecvt_utf16<wchar_t>> converter;\n-#endif\n \t\tstd::vector<wchar_t*> wargv(argc);\n \t\tstd::vector<std::wstring> wargv_buf(argc);\n \t\tfor (int i = 0; i < argc; i++)\n \t\t{\n-\t\t\twargv_buf[i] = converter.from_bytes(argv[i]);\n+\t\t\tauto len = strlen(argv[i]) + 1;\n+\t\t\twargv_buf[i] = std::wstring(len, L'\\0');\n+\t\t\tmbstowcs(&wargv_buf[i][0], argv[i], len);\n \t\t\twargv[i] = (wchar_t*)wargv_buf[i].c_str();\n \t\t}\n-\n \t\tPySys_SetArgv(argc, wargv.data());\n \t}\n \ttry\n", "fix_pattern": "<pattern>: if std::wstring_convert with from_bytes is used for character conversion, replace it with mbstowcs for better performance and to remove reliance on a deprecated API. Use a direct allocation for the wstring to avoid additional overhead from the convert function."}
{"number": 524, "change": "@@ -59,9 +59,9 @@ EclipseDebugger::on_connect()\n       __debugger_if->read();\n       char* host = __debugger_if->host();\n       unsigned int port = __debugger_if->port();\n-      std::stringstream command;\n-      command << \"tktools -h \" << host << \" -p \" << port;      \n-      system(command.str().c_str());\n+      std::stringstream portstr;\n+      portstr << port;\n+      execlp(\"tktools\", \"tktools\", \"-h\", host, \"-p\", portstr.str().c_str(), (char *) 0);\n     }\n \n   } catch (Exception &e) {\n", "fix_pattern": "<pattern>: if a system call is utilized to perform shell command execution, replace it with execlp to avoid the overhead of shell interpretation and improve performance."}
{"number": 526, "change": "@@ -35,7 +35,8 @@ struct repo_t *repo_new(const char *reponame) {\n \n   CALLOC(repo, 1, sizeof(struct repo_t), return NULL);\n \n-  if (asprintf(&repo->name, \"%s\", reponame) == -1) {\n+  repo->name = strdup(reponame);\n+  if (repo->name == NULL) {\n     fprintf(stderr, \"error: failed to allocate memory\\n\");\n     free(repo);\n     return NULL;\n", "fix_pattern": "<pattern>: if asprintf is used to allocate and format a string with a single argument and there is no formatting required (just a copy), replace it with strdup for better performance and simpler code."}
{"number": 529, "change": "@@ -496,7 +496,7 @@ QString toString(IconType type)\n         case it_Align_HorizontalDistribute:\n             return QLatin1String(\"distribute-horizontal\");\n         case it_Code_Gen_Wizard:\n-            return QLatin1String(\"hi64-app-umbrello.png\");\n+            return QLatin1String(\"umbrello\");\n         case it_Document_Edit:\n             return QLatin1String(\"document-edit\");\n         case it_ClassOrPackage:\n", "fix_pattern": "<pattern>: if QLatin1String is being used to return fixed string values, refactor to return a more descriptive or meaningful string that reduces overhead or aligns with application requirements based on context."}
{"number": 538, "change": "@@ -242,5 +242,5 @@ QString MakeJob::environmentProfile() const\n \n bool MakeJob::isNMake(const QString& makeBin)\n {\n-    return QFileInfo(makeBin).baseName().toLower() == \"nmake\";\n+    return QFileInfo(makeBin).baseName().compare(QStringLiteral(\"nmake\"), Qt::CaseInsensitive);\n }\n", "fix_pattern": "<pattern>: if the comparison of QStrings involves converting one string to lowercase using toLower(), replace it with QString::compare using Qt::CaseInsensitive for better performance and to avoid unnecessary string manipulation."}
{"number": 540, "change": "@@ -93,10 +93,10 @@ void set_storage_service(http_context& ctx, routes& r) {\n         return ctx.db.local().commitlog()->active_config().commit_log_location;\n     });\n \n-    ss::get_token_endpoint.set(r, [] (const_req req) {\n+    ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n         auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n         std::vector<storage_service_json::mapper> res;\n-        return map_to_key_value(token_to_ep, res);\n+        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if an API method is using a non-movable type (like const_req) as a parameter, change it to a movable type (like std::unique_ptr<request>) to facilitate ownership transfer and improve performance. Additionally, utilize make_ready_future to streamline returns and avoid intermediate copies."}
{"number": 541, "change": "@@ -94,9 +94,12 @@ void set_storage_service(http_context& ctx, routes& r) {\n     });\n \n     ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n-        auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n-        std::vector<storage_service_json::mapper> res;\n-        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n+        return make_ready_future<json::json_return_type>(stream_range_as_array(service::get_local_storage_service().get_token_to_endpoint_map(), [](const auto& i) {\n+            storage_service_json::mapper val;\n+            val.key = boost::lexical_cast<std::string>(i.first);\n+            val.value = boost::lexical_cast<std::string>(i.second);\n+            return val;\n+        }));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if a token-to-endpoint mapping is retrieved from a service and then converted to a vector for further processing, replace this intermediate storage with a more direct approach using stream_range_as_array to apply a transformation on the map directly, reducing memory usage and improving efficiency by avoiding unnecessary vector allocation."}
{"number": 543, "change": "@@ -249,7 +249,7 @@ Common::SeekableReadStream *BaseFileManager::openPkgFile(const Common::String &f\n \tupcName.toUppercase();\n \tCommon::SeekableReadStream *file = nullptr;\n \tchar fileName[MAX_PATH_LENGTH];\n-\tstrcpy(fileName, upcName.c_str());\n+\tCommon::strlcpy(fileName, upcName.c_str(), MAX_PATH_LENGTH);\n \n \t// correct slashes\n \tfor (uint32 i = 0; i < upcName.size(); i++) {\n", "fix_pattern": "<pattern>: if a buffer is copied using strcpy, replace it with a safer and potentially more optimized function like Common::strlcpy to avoid buffer overflows and to handle string length properly."}
{"number": 544, "change": "@@ -3402,11 +3402,11 @@ bool BaseGame::getVersion(byte *verMajor, byte *verMinor, byte *extMajor, byte *\n void BaseGame::setWindowTitle() {\n \tif (_renderer) {\n \t\tchar title[512];\n-\t\tstrcpy(title, _caption[0]);\n+\t\tCommon::strlcpy(title, _caption[0], 512);\n \t\tif (title[0] != '\\0') {\n-\t\t\tstrcat(title, \" - \");\n+\t\t\tCommon::strlcat(title, \" - \", 512);\n \t\t}\n-\t\tstrcat(title, \"WME Lite\");\n+\t\tCommon::strlcat(title, \"WME Lite\", 512);\n \n \n \t\tUtf8String utf8Title;\n", "fix_pattern": "<pattern>: if using strcpy and strcat to manipulate strings, replace them with strlcpy and strlcat for improved safety and to prevent buffer overflows."}
{"number": 545, "change": "@@ -270,7 +270,7 @@ bool SXString::scCallMethod(ScScript *script, ScStack *stack, ScStack *thisStack\n \t\tScValue *val = stack->pop();\n \t\tchar separators[MAX_PATH_LENGTH] = \",\";\n \t\tif (!val->isNULL()) {\n-\t\t\tstrcpy(separators, val->getString());\n+\t\t\tCommon::strlcpy(separators, val->getString(), MAX_PATH_LENGTH);\n \t\t}\n \n \t\tSXArray *array = new SXArray(_gameRef);\n", "fix_pattern": "<pattern>: if a string is copied using strcpy, replace it with a safer alternative like Common::strlcpy that prevents buffer overflows by limiting the number of copied characters."}
{"number": 546, "change": "@@ -677,10 +677,8 @@ void GraphicManager::drawChar(byte ander, int x, int y, Color color) {\n void GraphicManager::refreshScreen() {\n \t// These cycles are for doubling the screen height.\n \tfor (uint16 y = 0; y < _screen.h / 2; y++) {\n-\t\tfor (uint16 x = 0; x < _screen.w; x++) {\n-\t\t\tfor (int j = 0; j < 2; j++)\n-\t\t\t\t*(byte *)_screen.getBasePtr(x, y * 2 + j) = *(byte *)_surface.getBasePtr(x, y);\n-\t\t}\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2), _surface.getBasePtr(0, y), _screen.w);\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2 + 1), _surface.getBasePtr(0, y), _screen.w);\n \t}\n \t// Now we copy the stretched picture to the screen.\n \tg_system->copyRectToScreen(_screen.getPixels(), _screen.pitch, 0, 0, kScreenWidth, kScreenHeight * 2);\n", "fix_pattern": "<pattern>: if a nested loop is used to copy pixel data from one buffer to another, replace it with memcpy(...) calls to perform the operation in a single API call for better performance."}
{"number": 550, "change": "@@ -268,7 +268,7 @@ void Dialogs::scrollModeDialogue() {\n }\n \n void Dialogs::store(byte what, TuneType &played) {\n-\tmemcpy(played, played + 1, sizeof(played) - 1);\n+\tmemmove(played, played + 1, sizeof(played) - 1);\n \tplayed[30] = what;\n }\n \n", "fix_pattern": "<pattern>: if a memory operation is performed that may overlap the source and destination buffers, replace memcpy with memmove to ensure correct behavior and potentially better performance in cases of overlapping memory regions."}
{"number": 551, "change": "@@ -817,7 +817,6 @@ bool TTFFont::cacheGlyph(Glyph &glyph, uint32 chr) const {\n \t}\n \n \tuint8 *dst = (uint8 *)glyph.image.getPixels();\n-\tmemset(dst, 0, glyph.image.h * glyph.image.pitch);\n \n \tswitch (bitmap->pixel_mode) {\n \tcase FT_PIXEL_MODE_MONO:\n", "fix_pattern": "code removed:\n```\n    memset(dst, 0, glyph.image.h * glyph.image.pitch);\n```\ncode added:\n```\n    bzero(dst, glyph.image.h * glyph.image.pitch);\n```\n<pattern>: if a call to memset is used to zero out a block of memory, consider using bzero (or an equivalent) when clearing memory for better performance and potential clarity in intent, assuming that the environment supports it."}
{"number": 554, "change": "@@ -185,10 +185,8 @@ void xbt_ex_setup_backtrace(xbt_ex_t * e)\n       maps_name = bprintf(\"/proc/%d/maps\", (int) getpid());\n       maps = fopen(maps_name, \"r\");\n \n-      sscanf(addrs[i], \"%lx\", &addr);\n-      sprintf(maps_buff, \"%#lx\", addr);\n-\n-      if (strcmp(addrs[i], maps_buff)) {\n+      addr = strtol(addrs[i], &p, 16);\n+      if (*p != '\\0') {\n         XBT_CRITICAL(\"Cannot parse backtrace address '%s' (addr=%#lx)\",\n                   addrs[i], addr);\n       }\n", "fix_pattern": "<pattern>: if a combination of sscanf and sprintf is used for parsing and formatting a hexadecimal value, replace it with a direct conversion using strtol to improve performance and eliminate unnecessary string formatting operations."}
{"number": 564, "change": "@@ -31,7 +31,7 @@ class SQLiteConnection {\n          }\n       }\n \n-      if (sqlite3_open(path.c_str(), &_conn) != SQLITE_OK) {\n+      if (sqlite3_open_v2(path.c_str(), &_conn, SQLITE_OPEN_READONLY | SQLITE_OPEN_NOMUTEX, 0) != SQLITE_OK) {\n          BOOST_THROW_EXCEPTION(ConnectionFailedException() << ConnectionError(sqlite3_errmsg(_conn)));\n       }\n \n", "fix_pattern": "<pattern>: if the sqlite3_open function is used for read-only access, replace it with sqlite3_open_v2 using SQLITE_OPEN_READONLY and SQLITE_OPEN_NOMUTEX flags to improve performance by avoiding unnecessary locking mechanisms and ensuring no write operations can occur."}
{"number": 573, "change": "@@ -48,7 +48,7 @@\n #include <vtkstd/set>\n #include <vtkstd/algorithm>\n \n-vtkCxxRevisionMacro(vtkKdTree, \"1.22\");\n+vtkCxxRevisionMacro(vtkKdTree, \"1.23\");\n \n // Timing data ---------------------------------------------\n \n@@ -2280,7 +2280,8 @@ int vtkKdTree::_FindClosestPointInRegion(int regionId,\n \n   float *candidate = this->LocatorPoints + (idx * 3);\n \n-  for (int i=0; i < this->RegionList[regionId]->GetNumberOfPoints(); i++)\n+  int numPoints = this->RegionList[regionId]->GetNumberOfPoints();\n+  for (int i=0; i < numPoints; i++)\n     {\n     double dx = (x - candidate[0]) * (x - candidate[0]);\n \n", "fix_pattern": "<pattern>: if a loop iterates over the result of a method call that can be computed once, store the result in a variable before the loop to avoid repeated calls and improve performance."}
{"number": 578, "change": "@@ -1295,8 +1295,8 @@ void InstrumentTrackWindow::modelChanged()\n \n \tm_nameLineEdit->setText( m_track->name() );\n \n-\tdisconnect( m_track, SIGNAL( nameChanged() ) );\n-\tdisconnect( m_track, SIGNAL( instrumentChanged() ) );\n+\tm_track->disconnect( SIGNAL( nameChanged() ), this );\n+\tm_track->disconnect( SIGNAL( instrumentChanged() ), this );\n \n \tconnect( m_track, SIGNAL( nameChanged() ),\n \t\t\tthis, SLOT( updateName() ) );\n", "fix_pattern": "<pattern>: if disconnecting signals from a QObject, refactor to use the QObject's instance's disconnect method, which is more efficient and avoids ambiguity."}
{"number": 579, "change": "@@ -35,6 +35,8 @@\n #include <QLineEdit>\n #include <QContextMenuEvent>\n \n+#include <algorithm>\n+\n #include \"qg_blockwidget.h\"\n #include \"rs_blocklist.h\"\n #include \"qg_actionhandler.h\"\n@@ -78,7 +80,7 @@ void QG_BlockModel::setBlockList(RS_BlockList* bl) {\n             listBlock.append(bl->at(i));\n     }\n     setActiveBlock(bl->getActive());\n-    qSort ( listBlock.begin(), listBlock.end(), blockLessThan );\n+    std::sort( listBlock.begin(), listBlock.end(), blockLessThan);\n \n     //called to force redraw\n     endResetModel();\n", "fix_pattern": "<pattern>: if using qSort from the Qt library, replace it with std::sort from the C++ Standard Library for potentially better performance and enhanced optimizations since std::sort is generally more efficient and widely used in modern C++."}
{"number": 583, "change": "@@ -17,6 +17,7 @@\n \n #include \"addresstablemodel.h\"\n #include <QtDebug>\n+#include <algorithm>\n \n AddressTableModel::AddressTableModel(QObject *parent, const list<t_address_card>& data)\n \t: QAbstractTableModel(parent)\n@@ -97,7 +98,7 @@ void AddressTableModel::modifyAddress(int index, const t_address_card& card)\n \n void AddressTableModel::sort(int column, Qt::SortOrder order)\n {\n-\tqSort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n+\tstd::sort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n \t\tbool retval = false;\n \n \t\tswitch (column)\n", "fix_pattern": "<pattern>: if qSort is used to sort a range of elements, replace it with std::sort from the C++ Standard Library, as it generally has better performance characteristics due to its implementation being more modern and typically benefiting from optimizations unavailable in older libraries like Qt's qSort."}
{"number": 584, "change": "@@ -428,9 +428,10 @@ namespace net_utils\n \t\t\t\n \t\t\t\thandler_obj hndlr(ec, bytes_transfered);\n \n-\t\t\t\tchar local_buff[10000] = {0};\n+\t\t\t\tstatic const size_t max_size = 16384;\n+\t\t\t\tbuff.resize(max_size);\n \t\t\t\t\n-\t\t\t\tasync_read(local_buff, sizeof(local_buff), boost::asio::transfer_at_least(1), hndlr);\n+\t\t\t\tasync_read(&buff[0], max_size, boost::asio::transfer_at_least(1), hndlr);\n \n \t\t\t\t// Block until the asynchronous operation has completed.\n \t\t\t\twhile (ec == boost::asio::error::would_block && !boost::interprocess::ipcdetail::atomic_read32(&m_shutdowned))\n@@ -463,7 +464,7 @@ namespace net_utils\n \t\t\t\t\treturn false;*/\n \n \t\t\t\tm_bytes_received += bytes_transfered;\n-\t\t\t\tbuff.assign(local_buff, bytes_transfered);\n+\t\t\t\tbuff.resize(bytes_transfered);\n \t\t\t\treturn true;\n \t\t\t}\n \n", "fix_pattern": "<pattern>: if a local buffer is used to read data and then assigned to a std::string, replace the local buffer with a resize of the std::string to reduce memory copying and potential reallocations; also ensure the async_read function utilizes the string's internal buffer directly for efficiency."}
{"number": 585, "change": "@@ -594,7 +594,7 @@ BOOL SetEndOfFile(HANDLE hFile) {\n }\n \n DWORD SleepEx( DWORD dwMilliseconds,  BOOL bAlertable) {\n-  SDL_Delay(dwMilliseconds);\n+  usleep(dwMilliseconds * 1000);\n   return 0;\n }\n \n", "fix_pattern": "<pattern>: if using SDL_Delay for sleeping, replace it with usleep for potentially finer control over the sleep duration since usleep provides microsecond resolution compared to SDL_Delay's millisecond resolution."}
{"number": 587, "change": "@@ -155,7 +155,7 @@ void *CAudioDecoder::GetData(unsigned int size)\n   if (m_gaplessBufferSize > size)\n   {\n     memcpy(m_outputBuffer, m_gaplessBuffer, size*sizeof(float));\n-    memcpy(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n+    memmove(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n     m_gaplessBufferSize -= size;\n     return m_outputBuffer;\n   }\n", "fix_pattern": "<pattern>: if a buffer may overlap when copying data, replace memcpy(...) with memmove(...) to ensure correct behavior and maintain performance."}
{"number": 589, "change": "@@ -489,10 +489,11 @@ writeable_pgsql_selection::factory::factory(const po::variables_map &opts)\n   // select ways which use nodes already in the working set\n   m_connection.prepare(\"ways_from_nodes\",\n     \"INSERT INTO tmp_ways \"\n-      \"SELECT DISTINCT wn.way_id \"\n+      \"SELECT DISTINCT wn.way_id AS id \"\n         \"FROM current_way_nodes wn \"\n           \"JOIN tmp_nodes tn ON wn.node_id = tn.id \"\n-            \"AND wn.way_id NOT IN (SELECT id FROM tmp_ways)\");\n+          \"LEFT JOIN tmp_ways tw ON wn.way_id = tw.id \"\n+        \"WHERE tw.id IS NULL\");\n   // select nodes used by ways already in the working set\n   m_connection.prepare(\"nodes_from_way_nodes\",\n     \"INSERT INTO tmp_nodes \"\n", "fix_pattern": "<pattern>: if a query uses a subquery with NOT IN which can be inefficient, refactor the query to use a LEFT JOIN with a WHERE clause for better performance in filtering data from related tables."}
{"number": 590, "change": "@@ -496,9 +496,8 @@ NAN_METHOD(Driver::open) {\n #endif\n \n   GDALDriver *raw = driver->getGDALDriver();\n-  GDALOpenInfo *open_info = new GDALOpenInfo(path.c_str(), access);\n-  GDALDataset *ds = raw->pfnOpen(open_info);\n-  delete open_info;\n+  const char *driver_list[2] = {raw->GetDescription(), nullptr};\n+  GDALDataset *ds = (GDALDataset *)GDALOpenEx(path.c_str(), access, driver_list, NULL, NULL);\n   if (!ds) {\n     Nan::ThrowError(\"Error opening dataset\");\n     return;\n", "fix_pattern": "<pattern>: if a GDAL dataset is opened using the older GDALOpenInfo method that involves manual memory management, refactor the code to use GDALOpenEx which simplifies the process and potentially improves performance by avoiding the need to create and delete a GDALOpenInfo object."}
{"number": 591, "change": "@@ -591,7 +591,7 @@ void CmdRaytracingRender::activated(int iMsg)\n         doCommand(Doc,\"f = open(TempFile,'wb')\");\n         doCommand(Doc,\"f.write(PageFile.read())\");\n         doCommand(Doc,\"f.close()\");\n-        doCommand(Doc,\"subprocess.call('\\\"%s\\\" '+TempFile,shell=True)\",renderer.c_str());\n+        doCommand(Doc,\"subprocess.Popen([\\\"%s\\\",TempFile])\",renderer.c_str());\n         doCommand(Doc,\"del TempFile,PageFile\");            \n         commitCommand();\n     }\n", "fix_pattern": "<pattern>: if the command being executed involves a shell call with subprocess.call, replace it with subprocess.Popen and pass the command as a list to avoid the overhead of shell parsing and improve performance."}
{"number": 593, "change": "@@ -51,8 +51,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tif (!string)\n \t\treturn;\n \t\n-\tchar *workstr = new char[strlen(string) + 1];\n-\tstrcpy(workstr, string);\n+\tchar *workstr = strdup(string);\n \tstrtok(workstr, \"\\n\");\n \t\n \tchar *token = strtok(NULL,\"\\n\");\n@@ -60,7 +59,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \t\n \tif (!token)\n \t{\n-\t\tdelete [] workstr;\n+\t\tfree(workstr);\n \t\tstringList.AddItem(new BString(string));\n \t\treturn;\n \t}\n@@ -84,7 +83,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tlasttoken = token;\n \tstringList.AddItem(newword);\n \t\t\n-\tdelete [] workstr;\n+\tfree(workstr);\n }\n \n \n", "fix_pattern": "<pattern>: when dynamically allocating a string and then copying its contents, replace the manual allocation and copy with strdup, which performs both operations in one call and simplifies the code; also, ensure to call free only once on the allocated memory."}
{"number": 595, "change": "@@ -244,7 +244,7 @@ void* VideoScaler::Run(void* pArgs)\n     int tOutputBufferSize = avpicture_get_size(mTargetPixelFormat, mTargetResX, mTargetResY) + FF_INPUT_BUFFER_PADDING_SIZE;\n \n     // allocate chunk buffer\n-    tOutputBuffer = (uint8_t*)malloc(tOutputBufferSize);\n+    tOutputBuffer = (uint8_t*)av_malloc(tOutputBufferSize);\n \n     // Allocate video frame\n     LOG(LOG_VERBOSE, \"..allocating memory for output frame\");\n", "fix_pattern": "<pattern>: if memory allocation is done using malloc, switch to av_malloc from the FFmpeg library for optimized memory handling within FFmpeg's context."}
{"number": 598, "change": "@@ -77,12 +77,11 @@ MountIsoAction::MountIsoAction(QObject *parent, const QVariantList &)\n const Solid::Device getDeviceFromBackingFile(const QString &backingFile)\n {\n     const QList<Solid::Device> blockDevices =\n-        Solid::Device::listFromQuery(\"[ IS Block AND IS GenericInterface ]\");\n+        Solid::Device::listFromQuery(\"[ IS StorageAccess AND IS GenericInterface ]\");\n \n     for (const Solid::Device &device : blockDevices) {\n-        QMap<QString, QVariant> properties = device.as<Solid::GenericInterface>()->allProperties();\n-        if (properties.contains(\"BackingFile\")\n-            && backingFile == properties[\"BackingFile\"].value<QString>()) {\n+        auto genericDevice = device.as<Solid::GenericInterface>();\n+        if (backingFile == genericDevice->property(QStringLiteral(\"BackingFile\")).toString()) {\n             return device;\n         }\n     }\n", "fix_pattern": "<pattern>: if using Solid::GenericInterface's allProperties() method to retrieve properties and then checking for a specific key on QMap, optimize by directly accessing the property via the property() method instead. This reduces the overhead of retrieving all properties when only one is needed. Additionally, ensure that the query to list devices is also contextually relevant for performance improvements."}
{"number": 602, "change": "@@ -674,22 +674,21 @@ CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {\n }\n \n namespace {\n-// SecureBuffer uses openssl to allocate a Uint8Array using\n-// OPENSSL_secure_malloc. Because we do not yet actually\n-// make use of secure heap, this has the same semantics as\n+// SecureBuffer uses OPENSSL_secure_malloc to allocate a Uint8Array.\n+// Without --secure-heap, OpenSSL's secure heap is disabled,\n+// in which case this has the same semantics as\n // using OPENSSL_malloc. However, if the secure heap is\n // initialized, SecureBuffer will automatically use it.\n void SecureBuffer(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsUint32());\n   Environment* env = Environment::GetCurrent(args);\n   uint32_t len = args[0].As<Uint32>()->Value();\n-  char* data = static_cast<char*>(OPENSSL_secure_malloc(len));\n+  void* data = OPENSSL_secure_zalloc(len);\n   if (data == nullptr) {\n     // There's no memory available for the allocation.\n     // Return nothing.\n     return;\n   }\n-  memset(data, 0, len);\n   std::shared_ptr<BackingStore> store =\n       ArrayBuffer::NewBackingStore(\n           data,\n", "fix_pattern": "<pattern>: if memory is allocated using OPENSSL_secure_malloc followed by a memset to zero out the allocated memory, replace it with OPENSSL_secure_zalloc, which allocates and initializes the memory to zero in a single call for improved performance."}
{"number": 606, "change": "@@ -434,9 +434,7 @@ void Renderer::executeCommands(const QVector<RenderCommand *> commands)\n \n     Q_FOREACH (RenderCommand *command, commands) {\n \n-        QMutexLocker locker(&m_mutex);\n         MeshData *meshData = m_meshDataManager->data(command->m_meshData);\n-        locker.unlock();\n         if (meshData == Q_NULLPTR || meshData->attributeNames().empty()) {\n             qCWarning(Rendering) << \"RenderCommand should have a mesh\";\n             continue ;\n", "fix_pattern": "<pattern>: if a mutex locker is constructed and immediately unlocked without being used to guard a critical section, remove the unnecessary QMutexLocker instantiation to improve performance."}
{"number": 607, "change": "@@ -686,7 +686,7 @@ GraphicsHelperInterface *GraphicsContext::resolveHighestOpenGLFunctions()\n             if (m_debugLogger->initialize()) {\n                 QObject::connect(m_debugLogger.data(), &QOpenGLDebugLogger::messageLogged, &logOpenGLDebugMessage);\n                 const QString mode = QString::fromLocal8Bit(debugLoggingMode);\n-                m_debugLogger->startLogging(mode.toLower().startsWith(QLatin1String(\"sync\"))\n+                m_debugLogger->startLogging(mode.startsWith(QLatin1String(\"sync\"), Qt::CaseInsensitive)\n                                             ? QOpenGLDebugLogger::SynchronousLogging\n                                             : QOpenGLDebugLogger::AsynchronousLogging);\n \n", "fix_pattern": "<pattern>: if the method QString::toLower() is used before checking if it starts with a certain substring, replace it with startsWith() using the Qt::CaseInsensitive option to avoid the overhead of converting the entire string to lowercase."}
{"number": 612, "change": "@@ -442,13 +442,13 @@ Ref<const readable_block_store_t> read_sections(const MPI_Comm comm, const strin\n   Array<char> raw;\n   {\n     Log::Scope scope(\"read data\");\n-    const auto our_size = CHECK_CAST_INT(partition_loop(total_size,ranks,rank).size());\n-    raw.resize(our_size,false);\n+    const auto chunk = partition_loop(total_size,ranks,rank);\n+    raw.resize(CHECK_CAST_INT(chunk.size()),false);\n     MPI_File file;\n     const int r = MPI_File_open(comm,(char*)filename.c_str(),MPI_MODE_RDONLY,MPI_INFO_NULL,&file);\n     if (r != MPI_SUCCESS)\n       die(\"failed to open '%s' for reading: %s\",filename,error_string(r));\n-    CHECK(MPI_File_read_ordered(file,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+    CHECK(MPI_File_read_at_all(file,chunk.lo,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n     CHECK(MPI_File_close(&file));\n   }\n \n", "fix_pattern": "<pattern>: if the code is reading ordered data with MPI_File_read_ordered, switch to MPI_File_read_at_all for better performance when handling large chunks of data by specifying the offset directly, thus avoiding potential bottlenecks in ordered reads."}
{"number": 613, "change": "@@ -679,10 +679,18 @@ void write_sparse_samples(const MPI_Comm comm, const string& filename, accumulat\n     index += sizeof(s.wins);\n   }\n \n+  // Compute offsets.  MPI_File_write_ordered would do this for us, but MPI_File_write_ordered\n+  // is completely broken performance-wise.\n+  uint64_t offset = 0;\n+  {\n+    uint64_t buffer_size = buffer.size();\n+    CHECK(MPI_Exscan(&buffer_size,&offset,1,datatype<uint64_t>(),MPI_SUM,comm));\n+  }\n+\n   // Write the file\n   MPI_File file;\n   file_open(comm,filename,&file);\n-  CHECK(MPI_File_write_ordered(file,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+  CHECK(MPI_File_write_at_all(file,offset,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n   CHECK(MPI_File_close(&file));\n }\n \n", "fix_pattern": "<pattern>: if the code is using MPI_File_write_ordered, which is known to have performance issues, replace it with an MPI_File_write_at_all call that computes offsets manually using an MPI_Exscan to optimize performance for collective writes."}
{"number": 616, "change": "@@ -223,9 +223,8 @@ JNIEXPORT jbyteArray JNICALL Java_org_tensorflow_Session_run(\n   jbyteArray ret = nullptr;\n   if (run_metadata != nullptr) {\n     ret = env->NewByteArray(run_metadata->length);\n-    jbyte* elems = env->GetByteArrayElements(ret, nullptr);\n-    memcpy(elems, run_metadata->data, run_metadata->length);\n-    env->ReleaseByteArrayElements(ret, elems, JNI_COMMIT);\n+    env->SetByteArrayRegion(ret, 0, run_metadata->length,\n+                            reinterpret_cast<const jbyte*>(run_metadata->data));\n   }\n   TF_DeleteStatus(status);\n   return ret;\n", "fix_pattern": "<pattern>: if GetByteArrayElements is used to obtain a pointer for memcpy followed by ReleaseByteArrayElements, replace the sequence with SetByteArrayRegion to directly copy data into the Java byte array, improving performance by avoiding unnecessary memory management overhead."}
{"number": 619, "change": "@@ -92,7 +92,11 @@ void StringReader(png_structp png_ptr, png_bytep data, png_size_t length) {\n   DecodeContext* const ctx =\n       absl::bit_cast<DecodeContext*>(png_get_io_ptr(png_ptr));\n   if (static_cast<png_size_t>(ctx->data_left) < length) {\n-    memset(data, 0, length);\n+    // Don't zero out the data buffer as it has been lazily allocated (copy on\n+    // write) and zeroing it out here can produce an OOM. Since the buffer is\n+    // only used for reading data from the image, this doesn't result in any\n+    // data leak, so it is safe to just leave the buffer be as it is and just\n+    // exit with error.\n     png_error(png_ptr, \"More bytes requested to read than available\");\n   } else {\n     memcpy(data, ctx->data, length);\n", "fix_pattern": "<pattern>: if a buffer has been lazily allocated with copy-on-write semantics and is only used for reading, avoid unnecessary zeroing out of the buffer to prevent potential out-of-memory errors (OOM) and improve performance by bypassing the memset call."}
{"number": 624, "change": "@@ -31,6 +31,7 @@\n #include <boost/intrusive_ptr.hpp>\n \n #include \"mongo/platform/atomic_word.h\"\n+#include \"mongo/util/allocator.h\"\n \n namespace mongo {\n \n@@ -56,7 +57,7 @@ public:\n     }\n \n     static SharedBuffer allocate(size_t bytes) {\n-        return takeOwnership(static_cast<char*>(malloc(sizeof(Holder) + bytes)));\n+        return takeOwnership(static_cast<char*>(mongoMalloc(sizeof(Holder) + bytes)));\n     }\n \n     /**\n", "fix_pattern": "<pattern>: if a memory allocation is performed using malloc from Standard C, replace it with mongoMalloc from the MongoDB Project to potentially benefit from custom memory management optimizations specific to that library."}
{"number": 629, "change": "@@ -948,8 +948,7 @@ static const char * DoParseBindingFunc(key_binding_t& bind, const char * func_st\n \t// line tokeniser.\n \n \tstatic char buffer[600];\n-\tstrncpy(buffer, func_str, sizeof(buffer));\n-\tbuffer[sizeof(buffer) - 1] = 0;\n+\tStringCopy(buffer, sizeof(buffer), func_str);\n \n \tfor (unsigned int k = 0 ; buffer[k] ; k++)\n \t\tif (buffer[k] == ',' || buffer[k] == ':')\n", "fix_pattern": "<pattern>: if using strncpy for string copying, replace it with a project-specific optimized StringCopy function for better performance and potential additional safety features."}
{"number": 630, "change": "@@ -29,7 +29,7 @@ void RageSound_Null::MixerThread()\n {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \n \t/* not sure if a nansleep is needed, but certainly helps\n \t * when there is LOG->Trace in GetData() */\n", "fix_pattern": "<pattern>: if a loop is detected that uses sleep from the Standard C++ library, replace it with SDL_Delay from the SDL library for potentially better performance and responsiveness in a multimedia context."}
{"number": 631, "change": "@@ -265,7 +265,7 @@ int RageSound_Linux::MixerThread_start(void *p) {\n void RageSound_Linux::MixerThread() {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \twhile(!shutdown) { while (GetData()); }\n }\n \t\n", "fix_pattern": "<pattern>: if using a sleep function in a busy-wait loop, replace it with a library-specific delay function (like SDL_Delay) to improve performance and avoid unnecessary CPU usage."}
{"number": 641, "change": "@@ -101,7 +101,9 @@ tag_pool_get_item(enum tag_type type, const char *value, size_t length)\n \tslot_p = &slots[calc_hash_n(type, value, length) % NUM_SLOTS];\n \tfor (slot = *slot_p; slot != NULL; slot = slot->next) {\n \t\tif (slot->item.type == type &&\n-\t\t    strcmp(value, slot->item.value) == 0 && slot->ref < 0xff) {\n+\t\t    length == strlen(slot->item.value) &&\n+\t\t    memcmp(value, slot->item.value, length) == 0 &&\n+\t\t    slot->ref < 0xff) {\n \t\t\tassert(slot->ref > 0);\n \t\t\t++slot->ref;\n \t\t\treturn &slot->item;\n", "fix_pattern": "<pattern>: if a strcmp comparison is used, replace it with a combination of strlen to check lengths and memcmp to compare the strings for potentially better performance by avoiding null termination checks and leveraging raw memory comparison."}
{"number": 644, "change": "@@ -1860,7 +1860,7 @@ void CSoundFile::LoadMixPlugins(FileReader &file)\n \t\t\t\t\tif(m_MixPlugins[plug].pPluginData)\n \t\t\t\t\t{\n \t\t\t\t\t\tm_MixPlugins[plug].nPluginDataSize = pluginDataChunkSize;\n-\t\t\t\t\t\tmemcpy(m_MixPlugins[plug].pPluginData, pluginDataChunk.GetRawData(), pluginDataChunkSize);\n+\t\t\t\t\t\tpluginDataChunk.ReadRaw(m_MixPlugins[plug].pPluginData, pluginDataChunkSize);\n \t\t\t\t\t}\n \t\t\t\t}\n \n", "fix_pattern": "<pattern>: if an API method using `memcpy` to copy data from one memory location to another is detected, replace it with a more specialized method (in this case, `ReadRaw()`) that likely includes optimizations specific to the data source being read from."}
{"number": 647, "change": "@@ -45,10 +45,10 @@ public:\n         : m_vector(vector)\n     {}\n \n-    void emplace_back(T && value)\n+    void emplace_back(T &&value)\n     {\n         QMutexLocker lock(&m_mutex);\n-        m_vector.emplace_back(value);\n+        m_vector.push_back(std::move(value));\n     }\n \n     void emplace_back(const T &value)\n", "fix_pattern": "<pattern>: when transferring ownership of an object to a vector, use std::move to avoid unnecessary copies, replacing emplace_back with push_back to insert the element into the vector directly."}
{"number": 648, "change": "@@ -145,8 +145,8 @@ void QWaylandSurfaceItem::init(QWaylandSurface *surface)\n     setAcceptHoverEvents(true);\n     connect(surface, SIGNAL(mapped()), this, SLOT(surfaceMapped()));\n     connect(surface, SIGNAL(unmapped()), this, SLOT(surfaceUnmapped()));\n-    connect(surface, SIGNAL(destroyed(QObject *)), this, SLOT(surfaceDestroyed(QObject *)));\n-    connect(surface, SIGNAL(damaged(const QRect &)), this, SLOT(surfaceDamaged(const QRect &)));\n+    connect(surface, SIGNAL(destroyed(QObject*)), this, SLOT(surfaceDestroyed(QObject*)));\n+    connect(surface, SIGNAL(damaged(QRect)), this, SLOT(surfaceDamaged(QRect)));\n     connect(surface, SIGNAL(parentChanged(QWaylandSurface*,QWaylandSurface*)),\n             this, SLOT(parentChanged(QWaylandSurface*,QWaylandSurface*)));\n     connect(surface, SIGNAL(sizeChanged()), this, SLOT(updateSize()));\n", "fix_pattern": "<pattern>: if a signal is connected to a slot, and the signal parameter type is modified from a reference type (e.g., const QRect &) to a value type (e.g., QRect), then change the signal's parameter type to the value type to potentially enhance performance by avoiding unnecessary reference copying."}
{"number": 653, "change": "@@ -117,7 +117,14 @@ struct heif_error libde265_new_decoder(void** dec)\n   struct heif_error err = { heif_error_Ok, heif_suberror_Unspecified, kSuccess };\n \n   decoder->ctx = de265_new_decoder();\n-  de265_start_worker_threads(decoder->ctx,1);\n+#if defined(__EMSCRIPTEN__)\n+  // Speed up decoding from JavaScript.\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_DEBLOCKING, 1);\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_SAO, 1);\n+#else\n+  // Worker threads are not supported when running on Emscripten.\n+  de265_start_worker_threads(decoder->ctx, 1);\n+#endif\n \n   *dec = decoder;\n   return err;\n", "fix_pattern": "<pattern>: if the code is running under Emscripten, disable specific decoding parameters to potentially improve performance, otherwise, start worker threads for decoding."}
{"number": 657, "change": "@@ -102,7 +102,7 @@ ffmpeg_mptr::seek_to(int frame)\n \n \t\tstring command;\n \t\t\n-\t\tcommand=strprintf(\"ffmpeg -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",filename.c_str());\n+\t\tcommand=strprintf(\"ffmpeg -ss 00:00:00.%d -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",frame,filename.c_str());\n \t\t\n \t\tfile=popen(command.c_str(),POPEN_BINARY_READ_TYPE);\n \n@@ -133,7 +133,8 @@ ffmpeg_mptr::seek_to(int frame)\n \t\t\t}\n \t\t\t// Close the unneeded pipein\n \t\t\tclose(p[1]);\n-\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n+\t\t\tstring time = strprintf(\"00:00:00.%d\",frame);\n+\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-ss\", time.c_str(), \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n \t\t\t// We should never reach here unless the exec failed\n \t\t\tcerr<<\"Unable to open pipe to ffmpeg\"<<endl;\n \t\t\t_exit(1);\n", "fix_pattern": "<pattern>: if the API call to execlp is made with command-line parameters that do not include a timestamp, enhance the command by adding a timestamp parameter. This adjustment can optimize the ffmpeg processing by enabling seeking to a specific frame in the media input, thereby potentially reducing the processing time."}
{"number": 669, "change": "@@ -197,8 +197,7 @@ ImageDescriptor::ImageDescriptor(int _Width, int _Height, uint32 *_Pixels)\n \tVScale = 1.0;\n \tUScale = 1.0;\n \tSize = _Width * _Height * 4;\n-\tPixels = new uint32[_Width * _Height];\n-\tmemcpy(Pixels, _Pixels, Size);\n+\tPixels = _Pixels;\n \tFormat = RGBA8;\n \tMipMapCount = 0;\n }\n", "fix_pattern": "<pattern>: if pixels are being copied from a source array to a newly allocated array using memcpy, and it is safe to assign the source directly to the target, replace the memcpy with direct assignment, which avoids unnecessary memory operations."}
{"number": 679, "change": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n \n+#include \"cstring.h\"\n #include \"uni2name.h\"\n #include \"unicode/unifilt.h\"\n #include \"unicode/uchar.h\"\n@@ -93,7 +94,7 @@ void UnicodeNameTransliterator::handleTransliterate(Replaceable& text, UTransPos\n         UChar32 c = text.char32At(cursor);\n         if ((len=u_charName(c, U_UNICODE_CHAR_NAME, buf, sizeof(buf), &status)) <= 0 || U_FAILURE(status)) {\n             sprintf(buf, \"U+%04lX\", c);\n-            len = strlen(buf);\n+            len = uprv_strlen(buf);\n         }\n \n         str.truncate(1);\n", "fix_pattern": "<pattern>: if the standard strlen function is used for measuring string length, replace it with uprv_strlen from the ICU library to leverage potential performance optimizations specific to Unicode string handling."}
{"number": 680, "change": "@@ -449,7 +449,7 @@ static UChar * convertFromUTF8(UChar *outBuf, int32_t outBufCapacity, int32_t *o\n     UChar *dest = outBuf;\n     u_strFromUTF8(dest, outBufCapacity, outputLength, in, inLength, status);\n     if (*status == U_BUFFER_OVERFLOW_ERROR) {\n-        dest = static_cast<UChar *>(malloc(*outputLength * sizeof(UChar)));\n+        dest = static_cast<UChar *>(uprv_malloc(*outputLength * sizeof(UChar)));\n         if (dest == NULL) {\n             *status = U_MEMORY_ALLOCATION_ERROR;\n             return NULL;\n", "fix_pattern": "<pattern>: if a call to malloc from the standard C library is replaced with uprv_malloc from the ICU library, then it likely indicates an improvement in memory management specific to the ICU library, which is optimized for performance and compatibility within its ecosystem."}
{"number": 685, "change": "@@ -56,7 +56,8 @@ static QString lookupIconNameFor(const KUrl &url, KUriFilterData::UriTypes type)\n             if (service && service->icon() != QLatin1String( \"unknown\" ))\n                 iconName = service->icon();\n             // Try to find an icon with the same name as the binary (useful for non-kde apps)\n-            else if ( !KIconLoader::global()->loadIcon( exeName, KIconLoader::NoGroup, 16, KIconLoader::DefaultState, QStringList(), 0, true ).isNull() )\n+            // Use iconPath rather than loadIcon() as the latter uses QPixmap (not threadsafe)\n+            else if ( !KIconLoader::global()->iconPath( exeName, KIconLoader::NoGroup, true ).isNull() )\n                 iconName = exeName;\n             else\n                 // not found, use default\n", "fix_pattern": "<pattern>: if an API method loads heavy graphical resources (QPixmap) that may not be thread-safe, replace it with a method that retrieves a path to the resource (iconPath) instead to improve performance and ensure thread safety."}
{"number": 686, "change": "@@ -1442,8 +1442,8 @@ void Applet::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QW\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, \"Wallpaper\");\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, w->pluginName());\n                     w->restore(wallpaperConfig);\n-                    disconnect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n-                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n+                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)),\n+                            Qt::UniqueConnection);\n                 }\n \n                 painter->save();\n", "fix_pattern": "<pattern>: if a disconnect and then immediate reconnect is detected for a Qt signal, use Qt::UniqueConnection in the connect call to avoid redundant signals and improve performance by ensuring the connection is only made if it doesn't already exist."}
{"number": 689, "change": "@@ -37,10 +37,10 @@\n StyledCalendarDelegate::StyledCalendarDelegate(QObject *parent)\n     : QStyledItemDelegate(parent)\n {\n-    mPixmap.insert(Enable, KIconLoader().loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n-    mPixmap.insert(RemoveFromList, KIconLoader().loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n-    mPixmap.insert(AddToList, KIconLoader().loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n-    mPixmap.insert(Quickview, KIconLoader().loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n+    mPixmap.insert(Enable, KIconLoader::global()->loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n+    mPixmap.insert(RemoveFromList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n+    mPixmap.insert(AddToList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n+    mPixmap.insert(Quickview, KIconLoader::global()->loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n }\n \n StyledCalendarDelegate::~StyledCalendarDelegate()\n", "fix_pattern": "<pattern>: if multiple calls are made to `KIconLoader().loadIcon`, replace them with calls to `KIconLoader::global()->loadIcon` to utilize a singleton instance of `KIconLoader`, which reduces overhead from repeated constructions of the `KIconLoader` object."}
{"number": 693, "change": "@@ -433,8 +433,9 @@ void ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n         }\n     }\n     if (useModSeq > 0) {\n-        // FIXME: issue the corresponding command\n-        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n+        QMap<QByteArray, quint64> fetchModifier;\n+        fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n+        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n     } else {\n         flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n     }\n", "fix_pattern": "<pattern>: if a command fetch is being issued without optional modifiers that could improve behavior or performance, refactor the fetch call to include and pass additional parameters like `fetchModifier` for enhanced functionality."}
{"number": 694, "change": "@@ -278,12 +278,12 @@ zmsg_t *cmb_msg_encode (char *tag, json_object *o)\n \n     if (!(zmsg = zmsg_new ()))\n         err_exit (\"zmsg_new\");\n-    if (zmsg_addstr (zmsg, \"%s\", tag) < 0)\n-        err_exit (\"zmsg_addstr\");\n+    if (zmsg_addmem (zmsg, tag, strlen (tag)) < 0)\n+        err_exit (\"zmsg_addmem\");\n     if (o) {\n         const char *s = json_object_to_json_string (o);\n-        if (zmsg_addstr (zmsg, \"%s\", s) < 0)\n-            err_exit (\"zmsg_addstr\");\n+        if (zmsg_addmem (zmsg, s, strlen (s)) < 0)\n+            err_exit (\"zmsg_addmem\");\n     }\n     return zmsg;\n }\n", "fix_pattern": "<pattern>: if the code is using zmsg_addstr to add strings to the zmsg, replace it with zmsg_addmem to directly add the memory representation of the strings along with their length, improving efficiency by eliminating the need for the function to determine the string length internally."}
{"number": 695, "change": "@@ -417,8 +417,7 @@ static json_object *deep_copy (plugin_ctx_t *p, json_object *dir,\n     }\n     return dcpy;\n stall:\n-    if (dcpy)\n-        free (dcpy);\n+    json_object_put (dcpy);\n     return NULL;\n }\n \n", "fix_pattern": "<pattern>: if dynamically allocated memory is managed by a library's specific API, replace the standard `free` call with the appropriate library function to avoid potential memory management issues and improve performance by taking advantage of the library's optimized handling for its objects."}
{"number": 706, "change": "@@ -29,8 +29,8 @@ void MPI_Sys::sample(Sys &in)\n \n         for (int i = 0; i < in.num(); i++)\n         {\n-            MPI_Allreduce(MPI_IN_PLACE, in.precMu.at(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n-            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.at(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precMu.col(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.col(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n         }\n         bcast_sum_cov_norm();\n     }\n", "fix_pattern": "<pattern>: if an API method retrieves a row or column of data using a potentially less efficient method (like at(index)), replace it with a direct method call that accesses the data column directly (like col(index)) for improved performance, specifically in the context of matrix or array data structures."}
{"number": 709, "change": "@@ -1718,7 +1718,7 @@ static void lCompose(\n #if 1 // def __COMPOSITE_PROFILE\n     double nsendrecvloc = (senddispl[nrank] + recvdispl[nrank])*sizeof(uint16_t);\n     double nsendrecv;\n-    MPI_Allreduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, comm);\n+    MPI_Reduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, master, comm);\n     const double t1 = MPI_Wtime();\n     if (rank == master)\n     {\n", "fix_pattern": "<pattern>: if the communication pattern allows for reduction to a specific root instead of broadcasting to all processes, replace MPI_Allreduce with MPI_Reduce to optimize performance by reducing the amount of data communicated across the network."}
{"number": 711, "change": "@@ -1533,7 +1533,7 @@ void NJClient::mixInChannel(bool muted, float vol, float pan, DecodeState *chan,\n     // advance the queue\n     chan->decode_samplesout += needed/chan->decode_codec->GetNumChannels();\n     chan->decode_codec->m_samples_used -= needed+chan->dump_samples;\n-    memcpy(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n+    memmove(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n     chan->dump_samples=0;\n   }\n   else\n", "fix_pattern": "<pattern>: if overlapping memory regions are detected, replace memcpy with memmove to ensure correct behavior since memmove handles such cases properly."}
{"number": 712, "change": "@@ -143,8 +143,8 @@ void convert_inplace_test_do_it( dl_ctx_t       dl_ctx,        dl_typeid_t type,\n \t\t*out_buffer = (unsigned char*)malloc(*out_size + 1);\n \t\tmemset(*out_buffer, 0xFE, *out_size + 1);\n \n-\t\tmemcpy( *out_buffer, convert_buffer, convert_size );\n-\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, *out_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, convert_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tmemcpy(*out_buffer, convert_buffer, *out_size);\n \t}\n \n \tfree(convert_buffer);\n", "fix_pattern": "<pattern>: if a memcpy operation is performed after an API call that alters the buffer's content, refactor the code to first call the API and then perform the memcpy only if necessary, using the proper output size calculated from the API call, which avoids potentially copying unnecessary data or incorrect sizes."}
{"number": 714, "change": "@@ -62,7 +62,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             std::vector<bool> vMatch(nTx, false);\n             std::vector<uint256> vMatchTxid1;\n             for (unsigned int j=0; j<nTx; j++) {\n-                bool fInclude = (rand() & ((1 << (att/2)) - 1)) == 0;\n+                bool fInclude = insecure_randbits(att / 2) == 0;\n                 vMatch[j] = fInclude;\n                 if (fInclude)\n                     vMatchTxid1.push_back(vTxid[j]);\n", "fix_pattern": "<pattern>: if a call to the standard `rand()` function is replaced with a custom API that is optimized for generating random bits, use `insecure_randbits(...)` for potentially better performance and more control over the randomness generation."}
{"number": 716, "change": "@@ -201,7 +201,7 @@ namespace erlang {\n             unsigned char *ptr;\n             size_t len = strlen(c_string);\n             if ((ptr = enif_make_new_binary(env, len, &binary_str)) != nullptr) {\n-                strcpy((char *) ptr, c_string);\n+                memcpy((char *)ptr, c_string, len);\n                 return binary_str;\n             } else {\n                 fprintf(stderr, \"internal error: cannot allocate memory for binary string\\r\\n\");\n", "fix_pattern": "<pattern>: if a function is copying a string and the length of the source is known, replace strcpy with memcpy for potentially better performance and to handle non-null-terminated data safely."}
{"number": 720, "change": "@@ -64,10 +64,10 @@ bool FormFieldRestrictedValues::safeForIntegerCoercion(FormRestrictions restrict\n     foreach(SelectRestriction sr, restrictions.first) {\n         if(sr.variable == name) {\n             foreach(QString value, sr.values) {\n-                // TODO: Would prefer to use a more general regex (e.g. allowing zero-padded values or leading/trailing\n-                // spaces) but these values cannot currently be injected back correctly (even though we could coerce\n+                // TODO: Would prefer to use a more general regex (e.g. allowing leading/trailing spaces)\n+                // but these values cannot currently be injected back correctly (even though we could coerce\n                 // and solve them), so we are quite conservative for now.\n-                if(!value.contains(QRegExp(\"^(0|([1-9][0-9]*))$\"))) {\n+                if(!value.contains(QRegExp(\"^([0-9]*)$\"))) {\n                     return false;\n                 }\n             }\n", "fix_pattern": "<pattern>: if a more specific regex pattern that constrains valid input is replaced with a more general pattern that allows additional cases (like leading/trailing spaces), ensure that it doesn't introduce significant performance overhead when the regex engine has to handle a broader set of matches; specific patterns can lead to faster evaluations and less backtracking compared to general patterns."}
{"number": 737, "change": "@@ -431,7 +431,12 @@ void xyUpdate(){\n \n \tgvFPS = 1000 / fLength;\n \t//Wait for FPS limit\n-\tif(gvMaxFPS != 0) SDL_Delay((1000 / gvMaxFPS) - (fLength / gvMaxFPS));\n+\t//\t\tdelay\t4294967290\tunsigned int\n+\tUint32 current_time = (static_cast<Uint32>(fLength) / gvMaxFPS);\n+\tUint32 max_delay = (1000 / gvMaxFPS);\n+\tif (current_time < max_delay) {\n+\t\tif (gvMaxFPS != 0) SDL_Delay(max_delay - current_time);\n+\t}\n \t/*while(fLength < 1000 / gvMaxFPS){\n \t\tgvTicks = SDL_GetTicks();\n \t\tfLength = gvTicks - gvTickLast;\n", "fix_pattern": "<pattern>: if a delay is calculated and potentially called multiple times based on frame length and maximum FPS, first compute `current_time` and `max_delay` once, then perform the delay only if needed, thus avoiding redundant calculations and improving performance."}
{"number": 742, "change": "@@ -5,7 +5,7 @@\n         Quesa interactive renderer TriMesh implementation.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2004, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1443,11 +1443,12 @@ IRGeometry_Submit_TriMesh(TQ3ViewObject\t\t\t\ttheView,\n \tTQ3Status\t\t\tqd3dStatus;\n \tCQ3ObjectRef\t\tcachedGeom;\n \tCLockTriMeshData\tlocker;\n+\tbool\t\t\t\twasValid;\n \n \t\n \t// Look for a cached optimized geometry.\n-\tcachedGeom = GetCachedOptimizedTriMesh( theGeom );\n-\tif ( ! cachedGeom.isvalid() )\n+\tcachedGeom = GetCachedOptimizedTriMesh( theGeom, wasValid );\n+\tif ( ! wasValid )\n \t{\n \t\t// no cached data or stale cache\n \t\tcachedGeom = CQ3ObjectRef( Q3TriMesh_Optimize( theGeom ) );\n", "fix_pattern": "<pattern>: if an API method is upgraded to provide additional information about the validity of the cached geometry directly via an output parameter (instead of checking validity through a separate method call), leverage the new API method to potentially reduce the overhead of multiple validations and improve performance."}
{"number": 743, "change": "@@ -5,7 +5,7 @@\n         Implementation of Quesa API calls.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2008, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1277,14 +1277,14 @@ OpaqueTQ3Object::GetElement ( TQ3ElementType theType, void *theData )\n \n \t// If we've actually been passed a set, use it directly\n \tif ( Q3_OBJECT_IS_CLASS ( this, E3Set ) )\n-\t\treturn Q3Set_Get ( (TQ3SetObject) this, theType, theData ) ;\n+\t\treturn ( (E3Set*) this )->Get ( theType, theData ) ;\n \t\n \t// otherwise use the set within the instance data\n \t\n \tif ( theSet == NULL )\n \t\treturn kQ3Failure ;\n \t\n-\treturn Q3Set_Get ( theSet, theType, (void*)theData ) ;\n+\treturn ( (E3Set*) theSet )->Get ( theType, theData ) ;\n \t}\n \n \n", "fix_pattern": "<pattern>: if the original Q3Set_Get function is being replaced with the more efficient E3Set::Get member function call, then refactor the API usage to utilize the class method for potentially better performance and cleaner code."}
{"number": 748, "change": "@@ -73,11 +73,11 @@ QgsMapCanvasContextMenu::QgsMapCanvasContextMenu( QgsMapCanvas* canvas, const QP\n   }\n   else if ( mPickResult.feature.isValid() && mPickResult.layer )\n   {\n-    QgsCoordinateTransform ct( mPickResult.layer->crs(), mCanvas->mapSettings().destinationCrs() );\n+    const QgsCoordinateTransform* ct = QgsCoordinateTransformCache::instance()->transform( mPickResult.layer->crs().authid(), mCanvas->mapSettings().destinationCrs().authid() );\n     mRubberBand = new QgsGeometryRubberBand( mCanvas, mPickResult.feature.geometry()->type() );\n     mRubberBand->setIconType( QgsGeometryRubberBand::ICON_NONE );\n     mRubberBand->setOutlineWidth( 2 );\n-    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( ct ) );\n+    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( *ct ) );\n     if ( mPickResult.layer->type() == QgsMapLayer::RedliningLayer )\n     {\n       addAction( QIcon( \":/images/themes/default/mActionToggleEditing.svg\" ), tr( \"Edit\" ), this, SLOT( editFeature() ) );\n", "fix_pattern": "<pattern>: if a new instance of QgsCoordinateTransform is created every time a transformation is needed, utilize a caching mechanism (QgsCoordinateTransformCache) to retrieve pre-constructed coordinate transforms based on CRS identifiers to improve performance."}
{"number": 749, "change": "@@ -35,10 +35,11 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     PyObject* ret_keypoints = PyList_New(num_keypoints);\n     // import cv2\n     PyObject* cv2_mod = PyImport_ImportModule(\"cv2\");\n+    PyObject* cv2_keypoint_class = PyObject_GetAttrString(cv2_mod, \"KeyPoint\");\n \n     for(size_t i = 0; i < num_keypoints; ++i) {\n         // cv2_keypoint = cv2.KeyPoint()\n-        PyObject* cv2_keypoint = PyObject_CallMethod(cv2_mod, const_cast<char*>(\"KeyPoint\"), NULL);\n+        PyObject* cv2_keypoint = PyObject_CallObject(cv2_keypoint_class, NULL);\n \n         // build values\n         PyObject* cv2_keypoint_size = Py_BuildValue(\"f\", keypoints[i].size);\n@@ -68,6 +69,7 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     }\n \n     Py_DECREF(cv2_mod);\n+    Py_DECREF(cv2_keypoint_class);\n \n     return ret_keypoints;\n }\n", "fix_pattern": "<pattern>: if an API call to PyObject_CallMethod is made to create an object, refactor the code to first retrieve the class using PyObject_GetAttrString and then call it using PyObject_CallObject to avoid redundant lookup performance costs. Additionally, manage the reference counts with Py_DECREF to prevent memory leaks."}
{"number": 751, "change": "@@ -223,9 +223,9 @@ void DBuiltinIconEngine::paint(QPainter *painter, const QRect &rect,\n \n     // \u5982\u679c\u6709 background \u5219\u7ed8\u5236\u80cc\u666f\u56fe\u5148\n     QString bgFileName = entry->filename + QStringLiteral(\".background\");\n-    QIcon bgIcon = QIcon(bgFileName);\n-    if (!bgIcon.isNull()) {\n-        bgIcon.paint(painter, rect, Qt::AlignCenter, mode, state);\n+\n+    if (QFile::exists(bgFileName)) {\n+        QIcon(bgFileName).paint(painter, rect, Qt::AlignCenter, mode, state);\n     }\n \n     QPixmap pm = entry->pixmap(pixmapSize, mode, state);\n", "fix_pattern": "<pattern>: if a QIcon is created but then checked for nullity before painting, first check for file existence using QFile::exists to avoid unnecessary construction of the QIcon object, which improves performance by preventing the instantiation of an unused QIcon."}
{"number": 757, "change": "@@ -692,9 +692,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    continue;\n \t}\n \n-\t// This should be safe here.\n-\tchar* theData = NULL;\n-\ttheData = (char*) alloca(blobsize+4);\n+\tchar* theData = (char*) malloc(blobsize+4);\n \n \tif (theData == 0) {\n \t    std::cerr << \"Could Not allocate memory for data!\" << std::endl;\n@@ -709,6 +707,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    // bad writes to the offline-data files.\n \t    std::cerr << \"Bad read of data for \" << rawfilename\n \t\t<< \" expected: \" << blobsize << \" got:\" << bytesRead << std::endl;\n+\t    if (theData) free(theData);\n \t    continue;\n \t}\n \n@@ -717,6 +716,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t// This is the first index into the DataQueue.\n \tBlob datablob(blobsize, theData);\n \tDataQueues::enqueuePerformanceData(datablob);\n+\tif (theData) free(theData);\n \n     } // while\n \n", "fix_pattern": "<pattern>: if the code is using alloca to allocate memory on the stack, replace it with malloc for heap allocation, ensuring proper memory management, including freeing the allocated memory later in the code."}
{"number": 763, "change": "@@ -10,7 +10,6 @@\n #include \"archive.hh\"\n #include \"callback.hh\"\n #include \"remote-store.hh\"\n-#include \"sync.hh\"\n \n #include <nlohmann/json.hpp>\n #include <regex>\n@@ -1103,7 +1102,7 @@ std::map<StorePath, StorePath> copyPaths(\n     };\n \n     // total is accessed by each copy, which are each handled in separate threads\n-    Sync<uint64_t> _total = 0;\n+    std::atomic<uint64_t> total = 0;\n \n     for (auto & missingPath : sortedMissing) {\n         auto info = srcStore.queryPathInfo(missingPath);\n@@ -1126,9 +1125,8 @@ std::map<StorePath, StorePath> copyPaths(\n             PushActivity pact(act.id);\n \n             LambdaSink progressSink([&](std::string_view data) {\n-                auto total(_total.lock());\n-                *total += data.size();\n-                act.progress(*total, info->narSize);\n+                total += data.size();\n+                act.progress(total, info->narSize);\n             });\n             TeeSink tee { sink, progressSink };\n \n", "fix_pattern": "<pattern>: if a synchronization mechanism like a lock is used on an integer to ensure thread safety, replace it with an atomic variable to improve performance by avoiding the overhead of locking while still ensuring thread safety with atomic operations."}
{"number": 765, "change": "@@ -1040,7 +1040,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n         loadLibrary(id_lib);\n \n     uint nPage = 0;\n-    if(!QFileInfo(url).exists())\n+    if(!QFileInfo::exists(url))\n     {\n         if(strings.count()>0)\n         {\n@@ -1099,7 +1099,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n             ts.device()->write(file.readAll());\n         }\n     }\n-    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo(url).exists())\n+    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo::exists(url))\n     {\n         QString id=strings[2];\n         fb2mobi fb;\n", "fix_pattern": "<pattern>: if QFileInfo is used to check the existence of a file multiple times in conditions, replace the object creation with a static call to QFileInfo::exists to optimize performance by avoiding unnecessary instantiation."}
{"number": 767, "change": "@@ -295,7 +295,7 @@ static bool CreateMainSurface(int w, int h)\n \n \tDEBUG(misc, 0) (\"sdl: using mode %dx%d\", w, h);\n \n-\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_HWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n+\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_SWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n \tif(newscreen == NULL)\n \t\treturn false;\n \n", "fix_pattern": "<pattern>: if the SDL_SetVideoMode function is called with SDL_HWSURFACE, replace it with SDL_SWSURFACE for potentially better performance in environments that may not fully support hardware surfaces, thus avoiding unnecessary overhead associated with hardware surface rendering."}
{"number": 768, "change": "@@ -240,7 +240,7 @@ void DeleteWindow(Window *w)\n \n \tv = --_last_window;\n \tcount = (byte*)v - (byte*)w;\n-\tmemcpy(w, w + 1, count);\n+\tmemmove(w, w + 1, count);\n }\n \n Window *FindWindowById(WindowClass cls, WindowNumber number)\n", "fix_pattern": "<pattern>: if a source and destination overlap in a memory copy operation, replace memcpy with memmove to prevent undefined behavior and ensure correctness. memmove handles overlapping regions correctly, which can lead to performance improvements in cases where safety is a concern."}
{"number": 772, "change": "@@ -571,16 +571,11 @@ struct Converter_std_map\n         PyObject* value;\n         Py_ssize_t pos = 0;\n \n-        Py_INCREF(pyobj);\n-\n         while (PyDict_Next(pyobj, &pos, &key, &value)) {\n             result.insert(typename StdMap::value_type(\n                     Converter<typename StdMap::key_type>::toCpp(key),\n                     Converter<typename StdMap::mapped_type>::toCpp(value)));\n         }\n-\n-        Py_DECREF(pyobj);\n-\n         return result;\n     }\n };\n", "fix_pattern": "<pattern>: if Py_INCREF and Py_DECREF are called consecutively on the same PyObject, remove the redundant calls to improve performance as they balance each other out without any net change."}
{"number": 778, "change": "@@ -119,16 +119,12 @@ QList<QCameraDevice> QGstreamerVideoDevices::videoDevices() const\n \n void QGstreamerVideoDevices::addDevice(GstDevice *device)\n {\n-    gchar *type = gst_device_get_device_class(device);\n-    gst_object_ref(device);\n-    if (!strcmp(type, \"Video/Source\") || !strcmp(type, \"Source/Video\")) {\n+    if (gst_device_has_classes(device, \"Video/Source\")) {\n+        gst_object_ref(device);\n         m_videoSources.push_back({device, QByteArray::number(m_idGenerator)});\n         videoInputsChanged();\n         m_idGenerator++;\n-    } else {\n-        gst_object_unref(device);\n     }\n-    g_free(type);\n }\n \n void QGstreamerVideoDevices::removeDevice(GstDevice *device)\n", "fix_pattern": "<pattern>: if a comparison of device classes is performed using strcmp, replace it with the more efficient function gst_device_has_classes to avoid the overhead of string comparison and potentially streamline the logic flow for checking device classes."}
{"number": 780, "change": "@@ -55,7 +55,7 @@ std::string raw_text(const GumboNode * node)\n     else if( child_node->type == GUMBO_NODE_ELEMENT )\n     {\n       inner_text.push_back(' ');\n-      inner_text.append(text(child_node));\n+      inner_text.append(raw_text(child_node));\n     }\n   }\n \n", "fix_pattern": "<pattern>: if an API method used for text extraction (text) is replaced by a more efficient method (raw_text), it indicates that the new method offers better performance or fewer overheads in the context of extracting text from nodes in the HTML parsing process."}
{"number": 795, "change": "@@ -2585,8 +2585,12 @@ QString QWebPage::userAgentForUrl(const QUrl& url) const\n \n     QChar securityStrength(QLatin1Char('N'));\n #if !defined(QT_NO_OPENSSL)\n-    if (QSslSocket::supportsSsl())\n-        securityStrength = QLatin1Char('U');\n+    // we could check QSslSocket::supportsSsl() here, but this makes\n+    // OpenSSL, certificates etc being loaded in all cases were QWebPage\n+    // is used. This loading is not needed for non-https.\n+    securityStrength = QLatin1Char('U');\n+    // this may lead to a false positive: We indicate SSL since it is\n+    // compiled in even though supportsSsl() might return false\n #endif\n     ua = ua.arg(securityStrength);\n \n", "fix_pattern": "<pattern>: if a method call (like QSslSocket::supportsSsl()) introduces unnecessary overhead for performance-sensitive paths, remove that call and set a derived security property (like securityStrength) directly, while noting the implications of potential false positives."}
{"number": 798, "change": "@@ -716,7 +716,7 @@ void CreateMainFrame(FrameCreationCallback inOnFrame,int inWidth,int inHeight,\n             }\n \n             sdl_flags |= SDL_OPENGL;\n-            if (!(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags | SDL_OPENGL)))\n+            if (!SDL_VideoModeOK( use_w, use_h, 32, sdl_flags) || !(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags)))\n             {\n                if (pass==2 && aa_pass==0)\n                {\n", "fix_pattern": "<pattern>: if a call to SDL_SetVideoMode is made without a prior check for video mode validity, first validate with SDL_VideoModeOK to potentially avoid an unnecessary set video mode operation, improving performance by preventing failures or retries."}
{"number": 799, "change": "@@ -846,8 +846,7 @@ QScriptEnginePrivate::~QScriptEnginePrivate()\n \n QScriptValue QScriptEnginePrivate::scriptValueFromVariant(const QVariant &v)\n {\n-    Q_Q(QScriptEngine);\n-    QScriptValue result = q->create(v.userType(), v.data());\n+    QScriptValue result = create(v.userType(), v.data());\n     Q_ASSERT(result.isValid());\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is called on a pointer context (Q_Q), and the method being called is already a member function of the same context (i.e., `create`), remove the pointer context and call the method directly to improve code readability and possibly reduce overhead."}
{"number": 803, "change": "@@ -54,15 +54,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made sequentially with the same file descriptor, cache the result of F_GETFD and only call F_SETFD if the flags need to be changed, thus avoiding unnecessary system calls for improved performance."}
{"number": 806, "change": "@@ -797,10 +797,10 @@ bool RageDisplay_OGL::BeginFrame()\n \n void RageDisplay_OGL::EndFrame()\n {\n-\t// Give up the CPU to the OpenGL host if it wants it; in any case, make\n-\t// sure the frame is done. This helps graphics smoothness a lot by\n-\t// making sure we get the most out of each frame.\n-\tglFinish();\n+\t// glFlush(), not glFinish(); NVIDIA_GLX's glFinish()'s behavior is\n+\t// nowhere near performance-friendly and uses unholy amounts of CPU for\n+\t// Gog-knows-what.\n+\tglFlush();\n \n \twind->SwapBuffers();\n \tProcessStatsOnFlip();\n", "fix_pattern": "<pattern>: if glFinish() is used as a means to sync with the GPU, replace it with glFlush() to improve performance, as glFinish() can introduce significant CPU overhead that affects rendering efficiency."}
{"number": 810, "change": "@@ -101,16 +101,14 @@ Painter& Painter::draw(const std::string& str, bool difference)\n     if (str.empty())\n         return *this;\n \n+    if (!cairo_has_current_point(m_cr.get()))\n+        return *this;\n+\n     double x, y;\n-    cairo_font_extents_t fe;\n     cairo_text_extents_t textext;\n \n-    cairo_font_extents(m_cr.get(), &fe);\n     cairo_text_extents(m_cr.get(), str.c_str(), &textext);\n \n-    if (!cairo_has_current_point(m_cr.get()))\n-        return *this;\n-\n     AutoSaveRestore sr(*this);\n \n     cairo_get_current_point(m_cr.get(), &x, &y);\n", "fix_pattern": "<pattern>: if a function call to cairo_font_extents is unnecessary and does not affect the outcome of subsequent logic (like checking cairo_has_current_point), remove it to improve performance by avoiding redundant API calls."}
{"number": 812, "change": "@@ -112,7 +112,7 @@ namespace\n         DBusActivateTimeout()\n         {\n             bool ok;\n-            mTimeoutMs = qgetenv(\"QTXDG_DBUSACTIVATE_TIMEOUT\").toInt(&ok);\n+            mTimeoutMs = qEnvironmentVariableIntValue(\"QTXDG_DBUSACTIVATE_TIMEOUT\", &ok);\n             if (!ok)\n                 mTimeoutMs = 1500;\n         }\n", "fix_pattern": "<pattern>: if using qgetenv() followed by toInt() to retrieve an environment variable as an integer, replace it with qEnvironmentVariableIntValue() to reduce overhead and improve performance by directly reading and converting in one call."}
{"number": 822, "change": "@@ -407,8 +407,6 @@ void QrcParserPrivate::collectResourceFilesForSourceFile(const QString &sourceFi\n                                                          const QLocale *locale) const\n {\n     // TODO: use FileName from fileutils for file pathes\n-    QTC_CHECK(QFileInfo(sourceFile).isFile());\n-    QTC_CHECK(QFileInfo(sourceFile).isAbsolute());\n \n     QStringList langs = allUiLanguages(locale);\n     SMap::const_iterator file = m_files.find(sourceFile);\n", "fix_pattern": "<pattern>: if multiple QFileInfo instances are created for the same file, instantiate QFileInfo once and reuse it for various checks to avoid unnecessary object creation overhead."}
{"number": 830, "change": "@@ -135,9 +135,8 @@ KMKernel::KMKernel(QObject *parent) :\n     mSystemTray(Q_NULLPTR),\n     mDebugBaloo(false)\n {\n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n+\n     if (!s_networkConfigMgr) {\n         s_networkConfigMgr = new QNetworkConfigurationManager(QCoreApplication::instance());\n     }\n", "fix_pattern": "<pattern>: if there is an environment variable check using qgetenv followed by a check for emptiness with isEmpty(), replace it with a direct call to qEnvironmentVariableIsEmpty to simplify the check and improve performance."}
{"number": 835, "change": "@@ -77,7 +77,7 @@ bool BasicIndexingJob::index()\n     }\n \n     if (fileInfo.isDir()) {\n-        doc.addBoolTerm(QLatin1String(\"folder\"), QLatin1String(\"T\"));\n+        doc.addBoolTerm(QStringLiteral(\"Tfolder\"));\n \n         // This is an optimization for folders. They do not need to go through\n         // file indexing, so there are no indexers for folders\n", "fix_pattern": "<pattern>: if a QLatin1String is constructed using a string literal for values that will not change, replace it with QStringLiteral for potentially better performance and memory usage."}
{"number": 838, "change": "@@ -264,17 +264,29 @@ void agiGLPipeline::BeginFrame()\n \n     gl_context_->MakeCurrent();\n \n-    if (PARAM_frameclear.get_or(true))\n+    bool frameclear = PARAM_frameclear.get_or(true);\n+\n+    if (frameclear)\n     {\n         agiGL->EnableDisable(GL_SCISSOR_TEST, false);\n+        agiGL->DepthMask(true);\n         glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n-        glClear(GL_COLOR_BUFFER_BIT);\n     }\n \n     if (fbo_ != 0)\n     {\n+        if (frameclear)\n+        {\n+            glClear(GL_COLOR_BUFFER_BIT);\n+        }\n+\n         glBindFramebuffer(GL_FRAMEBUFFER, fbo_);\n     }\n+\n+    if (frameclear)\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n+    }\n }\n \n void agiGLPipeline::BeginScene()\n", "fix_pattern": "<pattern>: if a condition is checked multiple times with the same result, cache the result in a variable to avoid unnecessary repeated calls, and ensure to organize the flow of API calls for better clarity and potential performance improvements."}
{"number": 840, "change": "@@ -527,8 +527,7 @@ vdraw_send_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)\n \t\treturn TCL_ERROR;\n \t}\n \n-\tsprintf(solid_name, RT_VDRW_PREFIX);\n-\tstrncat(solid_name, dgop->dgo_currVHead->vdc_name, RT_VDRW_MAXNAME);\n+\tsnprintf(solid_name, RT_VDRW_MAXNAME+RT_VDRW_PREFIX_LEN+1, \"%s%s\", RT_VDRW_PREFIX, dgop->dgo_currVHead->vdc_name);\n \tif ((dp = db_lookup(dgop->dgo_wdbp->dbip, solid_name, LOOKUP_QUIET)) == DIR_NULL) {\n \t\treal_flag = 0;\n \t} else {\n", "fix_pattern": "<pattern>: if a string is being constructed using sprintf followed by strncat, replace it with snprintf to streamline the operation and enhance performance by eliminating the need for multiple function calls and potential buffer overflow risks."}
{"number": 844, "change": "@@ -1,4 +1,4 @@\n-/* $Id: clearspd.c,v 1.2 2000/04/10 16:25:15 brianp Exp $ */\n+/* $Id: clearspd.c,v 1.3 2000/12/07 21:50:39 brianp Exp $ */\n \n /*\n  * Simple GLUT program to measure glClear() and glutSwapBuffers() speed.\n@@ -7,6 +7,9 @@\n \n /*\n  * $Log: clearspd.c,v $\n+ * Revision 1.3  2000/12/07 21:50:39  brianp\n+ * call glFinish() before getting t1 time\n+ *\n  * Revision 1.2  2000/04/10 16:25:15  brianp\n  * fixed visual selection and reporting results\n  *\n@@ -71,14 +74,15 @@ static void Display( void )\n          glClear( BufferMask );\n          glutSwapBuffers();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n    }\n    else {\n       t0 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       for (i=0;i<Loops;i++) {\n          glClear( BufferMask );\n-         glFlush();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       glutSwapBuffers();\n    }\n", "fix_pattern": "<pattern>: if performance-critical sections involve OpenGL rendering APIs, replace glFlush() with glFinish() when synchronization is needed to ensure all previous rendering commands are complete before proceeding, as glFinish() blocks until all commands are executed, leading to more predictable timing in performance measurements."}
{"number": 847, "change": "@@ -17,10 +17,10 @@\n //===----------------------------------------------------------------------===//\n \n #include \"../SwiftShims/GlobalObjects.h\"\n+#include \"../SwiftShims/LibcShims.h\"\n #include \"swift/Runtime/Metadata.h\"\n #include \"swift/Runtime/Debug.h\"\n #include <stdlib.h>\n-#include <random>\n \n namespace swift {\n // FIXME(ABI)#76 : does this declaration need SWIFT_RUNTIME_STDLIB_INTERFACE?\n@@ -116,18 +116,10 @@ static swift::_SwiftHashingParameters initializeHashingParameters() {\n   if (determinism && 0 == strcmp(determinism, \"1\")) {\n     return { 0, 0, true };\n   }\n-#if defined(__APPLE__)\n-  // Use arc4random if available.\n   __swift_uint64_t seed0 = 0, seed1 = 0;\n-  arc4random_buf(&seed0, sizeof(seed0));\n-  arc4random_buf(&seed1, sizeof(seed1));\n+  swift::_stdlib_random(&seed0, sizeof(seed0));\n+  swift::_stdlib_random(&seed1, sizeof(seed1));\n   return { seed0, seed1, false };\n-#else\n-  std::random_device randomDevice;\n-  std::mt19937_64 engine(randomDevice());\n-  std::uniform_int_distribution<__swift_uint64_t> distribution;\n-  return { distribution(engine), distribution(engine), false };\n-#endif\n }\n \n SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_BEGIN\n", "fix_pattern": "<pattern>: if the code is using platform-specific random number generation (arc4random_buf) for macOS, replace it with a more generic and potentially optimized API (swift::_stdlib_random) to improve performance and maintain consistency across different platforms."}
{"number": 850, "change": "@@ -536,8 +536,6 @@ hasMergeGroup(MergeGroupKind Kind) {\n void swift::\n collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n                     llvm::SmallDenseMap<ValueDecl*, ValueDecl*> &DefaultMap) {\n-  Type BaseTy = PD->getDeclaredInterfaceType();\n-  DeclContext *DC = PD->getInnermostDeclContext();\n   auto HandleMembers = [&](DeclRange Members) {\n     for (Decl *D : Members) {\n       auto *VD = dyn_cast<ValueDecl>(D);\n@@ -550,11 +548,8 @@ collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n       if (VD->getBaseName().empty())\n         continue;\n \n-      ResolvedMemberResult Result = resolveValueMember(*DC, BaseTy,\n-                                                       VD->getFullName());\n-      assert(Result);\n-      for (auto *Default : Result.getMemberDecls(InterestedMemberKind::All)) {\n-        if (PD == Default->getDeclContext()->getExtendedProtocolDecl()) {\n+      for (auto *Default: PD->lookupDirect(VD->getFullName())) {\n+        if (Default->getDeclContext()->getExtendedProtocolDecl() == PD) {\n           DefaultMap.insert({Default, VD});\n         }\n       }\n", "fix_pattern": "<pattern>: if a resolved member lookup is performed via resolveValueMember, replace it with a direct lookup using PD->lookupDirect to improve performance by avoiding unnecessary resolution overhead."}
{"number": 863, "change": "@@ -596,11 +596,9 @@ void e6y_PreprocessLevel(void)\n \n void gld_InitGLVersion(void)\n {\n-  char ver[256];\n   int MajorVersion, MinorVersion;\n   glversion = OPENGL_VERSION_1_0;\n-  strncpy(ver, glGetString(GL_VERSION), sizeof(ver));\n-  if (sscanf(ver, \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n+  if (sscanf(glGetString(GL_VERSION), \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n   {\n     if (MajorVersion > 1)\n     {\n", "fix_pattern": "<pattern>: if the code copies a string from `glGetString` to a temporary buffer using `strncpy`, directly use the result of `glGetString` in `sscanf` to save memory and eliminate an unnecessary copy."}
{"number": 864, "change": "@@ -254,8 +254,14 @@ namespace pos{\n       static void get(T* &data, std::string path, PixelConfigKey key){\n \n       unsigned int theKey=key.key();\n-    \n-      assert(theKey<=getConfig().size());\n+      \n+      static PixelConfigList configList=getConfig();\n+\n+      if (theKey>configList.size()){\n+\tconfigList=getConfig();\n+      }\n+\n+      assert(theKey<=configList.size());\n     \n       unsigned int last=path.find_last_of(\"/\");\n       assert(last!=std::string::npos);\n@@ -278,7 +284,7 @@ namespace pos{\n //      std::cout << \"[pos::PixelConfigFile::get()]\\t\\t\\tExtracted ext :\"<<ext <<std::endl;\n     \n       unsigned int version;\n-      int err=getConfig()[theKey].find(dir,version);   \n+      int err=configList[theKey].find(dir,version);   \n       // assert(err==0);\n       if(0!=err) \n \t{\n", "fix_pattern": "<pattern>: if a configuration list is retrieved multiple times within a function call, store it in a static variable to avoid redundant calls to getConfig() and improve performance, ensuring to check for size validity."}
{"number": 885, "change": "@@ -41,7 +41,18 @@ void GLIndexBuf::bind()\n \n void GLIndexBuf::bind_as_ssbo(uint binding)\n {\n-  bind();\n+  if (ibo_id_ == 0 || data_ != nullptr) {\n+    /* Calling `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo_id_)` changes the index buffer\n+     * of the currently bound VAO.\n+     *\n+     * In the OpenGL backend, the VAO state persists even after `GLVertArray::update_bindings`\n+     * is called.\n+     *\n+     * NOTE: For safety, we could call `glBindVertexArray(0)` right after drawing a `GPUBatch`.\n+     * However, for performance reasons, we have chosen not to do so. */\n+    glBindVertexArray(0);\n+    bind();\n+  }\n   BLI_assert(ibo_id_ != 0);\n   glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, ibo_id_);\n }\n", "fix_pattern": "<pattern>: if a binding operation is performed via glBindVertexArray before a specific condition (like checking if ibo_id_ is 0 or data_ is not null), it is refactored to avoid unnecessary binding calls, which can lead to performance improvements by preventing redundant state changes in the OpenGL pipeline."}
{"number": 886, "change": "@@ -1583,7 +1583,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\tglClear(GL_COLOR_BUFFER_BIT);\n \t\tif (sdl.opengl.pixel_buffer_object) {\n \t\t\tglUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, sdl.draw.width,\n \t\t\t                sdl.draw.height, GL_BGRA_EXT,\n \t\t\t                GL_UNSIGNED_INT_8_8_8_8_REV, 0);\n@@ -1591,7 +1590,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\t} else if (changedLines) {\n \t\t\tint y = 0;\n \t\t\tsize_t index = 0;\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\twhile (y < sdl.draw.height) {\n \t\t\t\tif (!(index & 1)) {\n \t\t\t\t\ty += changedLines[index];\n", "fix_pattern": "<pattern>: if glBindTexture is called multiple times with the same parameters consecutively, remove redundant calls to improve performance."}
{"number": 890, "change": "@@ -15,6 +15,7 @@\n #endif\n #include <folly/ScopeGuard.h>\n #include <folly/String.h>\n+#include <folly/system/Pid.h>\n \n #if defined(_WIN32) || defined(O_PATH)\n #define CAN_OPEN_SYMLINKS 1\n@@ -453,9 +454,19 @@ w_string FileDescriptor::getOpenedPath() const {\n #elif defined(__linux__) || defined(__sun)\n   char procpath[1024];\n #if defined(__linux__)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/fd/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/fd/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #elif defined(__sun)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/path/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/path/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #endif\n \n   // Avoid an extra stat by speculatively attempting to read into\n", "fix_pattern": "<pattern>: if a process ID is repeatedly fetched using getpid(), replace it with a cached version provided by folly::get_cached_pid() to avoid the performance overhead of system calls."}
{"number": 898, "change": "@@ -905,17 +905,18 @@ void CVideoPlayer::OpenDefaultStreams(bool reset)\n     CloseStream(m_CurrentVideo, true);\n \n   // open audio stream\n-  if(m_PlayerOptions.video_only)\n-    streams.clear();\n-  else\n-    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n   valid   = false;\n-\n-  for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+  if(!m_PlayerOptions.video_only)\n   {\n-    if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n-      valid = true;\n+    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n+\n+    for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+    {\n+      if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n+        valid = true;\n+    }\n   }\n+\n   if(!valid)\n     CloseStream(m_CurrentAudio, true);\n \n", "fix_pattern": "<pattern>: if a conditionally clearing a collection (streams.clear()) is followed by a reassignment based on the same condition, restructure the code to eliminate the unnecessary clearing operation and directly assign when conditions allow, improving performance by reducing redundant operations."}
{"number": 904, "change": "@@ -180,7 +180,16 @@ void DrawCallPerfBenchmark::destroyBenchmark()\n \n void DrawCallPerfBenchmark::drawBenchmark()\n {\n-    glClear(GL_COLOR_BUFFER_BIT);\n+    // This workaround fixes a huge queue of graphics commands accumulating on the GL\n+    // back-end. The GL back-end doesn't have a proper NULL device at the moment.\n+    // TODO(jmadill): Remove this when/if we ever get a proper OpenGL NULL device.\n+    const auto &eglParams = GetParam().eglParameters;\n+    if (eglParams.deviceType != EGL_PLATFORM_ANGLE_DEVICE_TYPE_NULL_ANGLE ||\n+        (eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE &&\n+         eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE))\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT);\n+    }\n \n     const auto &params = GetParam();\n \n", "fix_pattern": "<pattern>: if calling glClear is causing performance issues due to excessive accumulation of graphics commands in the GL back-end, conditionally execute glClear based on the type of EGL device to mitigate the performance impact."}
{"number": 905, "change": "@@ -938,7 +938,10 @@ egl::ConfigSet Renderer11::generateConfigs()\n         // Additional high bit depth formats added in D3D 10.0\n         // https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064.aspx\n         colorBufferFormats.push_back(GL_RGBA16F);\n-        colorBufferFormats.push_back(GL_RGB10_A2);\n+\n+        // TODO(geofflang): Re-enable once client code has been updated to filter configs better and\n+        // not use RGB10A2 accidentally when requesting RGBA8\n+        // colorBufferFormats.push_back(GL_RGB10_A2);\n     }\n \n     if (!mPresentPathFastEnabled)\n", "fix_pattern": "<pattern>: if a call to push back an invalid or unoptimized color format is detected, comment it out until client code can be updated to filter configurations properly, thus avoiding unnecessary overhead or potential misconfigurations."}
{"number": 907, "change": "@@ -75,7 +75,12 @@ std::vector<uint32_t> preprocessSpirv(\n \t}\n \n \tstd::vector<uint32_t> optimized;\n-\topt.Run(code.data(), code.size(), &optimized);\n+\tspvtools::OptimizerOptions options;\n+#if defined(NDEBUG)\n+\toptions.set_run_validator(false);\n+#endif\n+\n+\topt.Run(code.data(), code.size(), &optimized, options);\n \n \tif(false)\n \t{\n", "fix_pattern": "<pattern>: if an API method call is made without options that may control performance-sensitive features, enhance the call by utilizing options like disabling unnecessary validation in release builds to improve performance."}
{"number": 912, "change": "@@ -94,7 +94,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\t    node_type != abnode_type::equipment)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_server_dn(pnode, dn, sizeof(dn));\n-\t\tstrcat(dn, \"/cn=Microsoft Private MDB\");\n+\t\tHX_strlcat(dn, \"/cn=Microsoft Private MDB\", arsizeof(dn));\n \t\tif (NULL == pbuff) {\n \t\t\tpprop->value.pv = ndr_stack_alloc(\n \t\t\t\tNDR_STACK_OUT, strlen(dn) + 1);\n@@ -471,7 +471,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\tif (node_type != abnode_type::person)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_user_info(pnode, USER_STORE_PATH, dn, GX_ARRAY_SIZE(dn));\n-\t\tstrcat(dn, \"/config/portrait.jpg\");\n+\t\tHX_strlcat(dn, \"/config/portrait.jpg\", arsizeof(dn));\n \t\tif (!common_util_load_file(dn, &pprop->value.bin))\n \t\t\treturn ecNotFound;\n \t\treturn ecSuccess;\n", "fix_pattern": "<pattern>: if using strcat to concatenate strings where buffer size is a concern, replace it with a safer alternative such as HX_strlcat which takes the size of the destination buffer to prevent buffer overflows."}
{"number": 914, "change": "@@ -167,9 +167,10 @@ void EPollEngine::DelFd(EventHandler* eh)\n \t\treturn;\n \t}\n \n+\t// Do not initialize epoll_event because for EPOLL_CTL_DEL operations the event is ignored and can be NULL.\n+\t// In kernel versions before 2.6.9, the EPOLL_CTL_DEL operation required a non-NULL pointer in event,\n+\t// even though this argument is ignored. Since Linux 2.6.9, event can be specified as NULL when using EPOLL_CTL_DEL.\n \tstruct epoll_event ev;\n-\tmemset(&ev, 0, sizeof(ev));\n-\tev.data.fd = fd;\n \tint i = epoll_ctl(EngineHandle, EPOLL_CTL_DEL, fd, &ev);\n \n \tif (i < 0)\n", "fix_pattern": "<pattern>: if an epoll_event is being initialized for an EPOLL_CTL_DEL operation, avoid unnecessary initialization with memset or setting its fields, as the event data can be NULL and is ignored in this context."}
{"number": 922, "change": "@@ -460,7 +460,7 @@ float DeserializeFloat(const char *str, const char **outEndStr)\n \t\treturn FLOAT_NAN;\n \tif (MATH_NEXT_WORD_IS(str, \"NaN(\"))\n \t{\n-\t\tMATH_SKIP_WORD(str, \"NaN(\");\n+\t\tstr += strlen(\"NaN(\"); //MATH_SKIP_WORD(str, \"NaN(\");\n \t\tu32 x;\n \t\tint n = sscanf(str, \"%X\", (unsigned int *)&x);\n \t\tif (n != 1)\n", "fix_pattern": "<pattern>: if a specific word is skipped using a function that likely incurs function call overhead, replace the function call with a direct manipulation of the pointer to improve performance by reducing function call overhead."}
{"number": 927, "change": "@@ -28,9 +28,10 @@ void QKlamptDisplay::initializeGL(){\n }\n \n void QKlamptDisplay::paintGL(){\n-  glClear(0);\n   if(gui != NULL)\n     gui->SendGLRender();\n+  else\n+    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n }\n \n \n", "fix_pattern": "<pattern>: if glClear is called without any bitmask during a certain condition (like a clear operation being redundant), then ensure it explicitly clears the color and depth buffers only when necessary by combining the relevant bitmasks in one call."}
{"number": 931, "change": "@@ -1096,7 +1096,7 @@ grLfbWriteRegion( GrBuffer_t dst_buffer,\n       }\n \n       glBindTexture(GL_TEXTURE_2D, default_texture);\n-      glTexImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n+      glTexSubImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n \n       set_copy_shader();\n \n", "fix_pattern": "<pattern>: if a texture is already created and needs to be updated, replace glTexImage2D with glTexSubImage2D to improve performance by avoiding the overhead of reallocating texture memory."}
{"number": 945, "change": "@@ -66,7 +66,7 @@ namespace mapnik\n         if (!png_ptr) return;\n \n         // switch on optimization only if supported\n-#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)\n+#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_MMX_CODE_SUPPORTED)\n         png_uint_32 mask, flags;\n \n         flags = png_get_asm_flags(png_ptr);\n", "fix_pattern": "<pattern>: if an API directive checks for specific library versions or features, ensure that the check is using the correct defined macros for the intended assembly optimizations (i.e., update from PNG_ASSEMBLER_CODE_SUPPORTED to PNG_MMX_CODE_SUPPORTED)."}
{"number": 949, "change": "@@ -155,10 +155,13 @@ inline BOOL Win32uiHostGlue::DynamicApplicationInit(const TCHAR *cmd, const TCHA\n     TCHAR err_buf[256];\n     // It's critical Python is loaded *and initialized* before we load win32ui\n     // as just loading win32ui will cause it to call into Python.\n-    const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n-    for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n-        wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n-        hModCore = LoadLibrary(fname);\n+    hModCore = GetModuleHandle(py_dll);  // Check if Python is already loaded\n+    if (hModCore == NULL) {\n+        const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n+        for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n+            wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n+            hModCore = LoadLibrary(fname);\n+        }\n     }\n     if (hModCore == NULL) {\n         wsprintf(err_buf, _T(\"The application can not locate %s (%d)\\n\"), py_dll, GetLastError());\n", "fix_pattern": "<pattern>: if loading a library using LoadLibrary, first check if the library is already loaded using GetModuleHandle to avoid unnecessary calls to LoadLibrary, which can improve performance by reducing the overhead of multiple library load attempts."}
{"number": 954, "change": "@@ -378,14 +378,8 @@ bool PlVkRenderer::initialize(PDECODER_PARAMETERS params)\n \n     pl_vk_inst_params vkInstParams = pl_vk_inst_default_params;\n     {\n-        bool ok;\n-        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\", &ok);\n-        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\", &ok);\n-#ifdef QT_DEBUG\n-        if (!ok) {\n-            vkInstParams.debug = true;\n-        }\n-#endif\n+        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\");\n+        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\");\n     }\n     vkInstParams.get_proc_addr = (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();\n     vkInstParams.extensions = instanceExtensions.data();\n", "fix_pattern": "<pattern>: if the second parameter of `qEnvironmentVariableIntValue` is not utilized, remove it to avoid unnecessary performance overhead associated with passing an unused pointer."}
{"number": 959, "change": "@@ -38,15 +38,15 @@ void UpdateDetector::versionCheck( Theme *theme )\n     QUrl url(\"http://download.owncloud.com/clientupdater.php\");\n     QString ver = QString(\"%1.%2.%3\").arg(MIRALL_VERSION_MAJOR).arg(MIRALL_VERSION_MINOR).arg(MIRALL_VERSION_MICRO);\n \n-    QString platform = QString::fromLocal8Bit(\"stranger\");\n+    QString platform = QLatin1String(\"stranger\");\n #ifdef Q_OS_LINUX\n-    platform = QString::fromLocal8Bit(\"linux\");\n+    platform = QLatin1String(\"linux\");\n #endif\n #ifdef Q_OS_WIN32\n-    platform = QString::fromLocal8Bit( \"win32\" );\n+    platform = QLatin1String( \"win32\" );\n #endif\n #ifdef Q_OS_MACOS\n-    platform = QString::fromLocal8Bit( \"macos\" );\n+    platform = QLatin1String( \"macos\" );\n #endif\n \n     url.addQueryItem( \"version\", ver );\n", "fix_pattern": "<pattern>: if QString::fromLocal8Bit is used with static strings, replace it with QLatin1String for better performance since QLatin1String is optimized for such use cases in the Qt framework."}
{"number": 963, "change": "@@ -218,8 +218,6 @@ void table_t::stop()\n         time(&start);\n \n         fprintf(stderr, \"Sorting data and creating indexes for %s\\n\", name.c_str());\n-        pgsql_exec_simple(sql_conn, PGRES_COMMAND_OK, (fmt(\"ANALYZE %1%\") % name).str());\n-        fprintf(stderr, \"Analyzing %s finished\\n\", name.c_str());\n \n         // Special handling for empty geometries because geohash chokes on\n         // empty geometries on postgis 1.5.\n", "fix_pattern": "<pattern>: if a call to `pgsql_exec_simple` is immediately followed by a logging statement using `fprintf`, consider using a logging mechanism that combines both actions to reduce overhead from executing two separate functions in tight succession."}
{"number": 965, "change": "@@ -349,9 +349,16 @@ void SDLRenderTarget::blitRenderTarget(RenderTarget *s, int x, int y, int w, int\n \tSDLRenderTarget *src = dynamic_cast<SDLRenderTarget *>(s);\n \tassert(src);\n \n-\t// TODO: evil use of internal SDL api\n+\tSDL_Renderer *renderer = SDL_CreateSoftwareRenderer(surface);\n+\tassert(renderer);\n+\tSDL_Texture *tex = SDL_CreateTextureFromSurface(renderer, src->surface);\n+\tassert(tex);\n+\n \tSDL_Rect r; r.x = x; r.y = y; r.w = w; r.h = h;\n-\tSDL_SoftStretch(src->surface, 0, surface, &r);\n+\tSDL_RenderCopy(renderer, tex, nullptr, &r);\n+\n+\tSDL_DestroyTexture(tex);\n+\tSDL_DestroyRenderer(renderer);\n }\n \n RenderTarget *SDLBackend::newRenderTarget(unsigned int w, unsigned int h) {\n", "fix_pattern": "<pattern>: if the SDL_SoftStretch function is used for scaling surfaces, refactor the code to create a software renderer, create a texture from the source surface, and use SDL_RenderCopy to perform the copy operation, as it can provide better performance through hardware acceleration or more optimized rendering."}
{"number": 969, "change": "@@ -1100,9 +1100,11 @@ void Loader::fillEvaluationObject(const ScopeChain::Ptr &scope, LanguageObject *\n void Loader::fillEvaluationObjectBasics(const ScopeChain::Ptr &scopeChain, LanguageObject *object, EvaluationObject *evaluationObject)\n {\n     // append the property declarations\n-    foreach (const PropertyDeclaration &pd, object->propertyDeclarations)\n-        if (!evaluationObject->scope->declarations.contains(pd.name))\n-            evaluationObject->scope->declarations.insert(pd.name, pd);\n+    foreach (const PropertyDeclaration &pd, object->propertyDeclarations) {\n+        PropertyDeclaration &scopePropertyDeclaration = evaluationObject->scope->declarations[pd.name];\n+        if (!scopePropertyDeclaration.isValid())\n+            scopePropertyDeclaration = pd;\n+    }\n \n     applyFunctions(&m_engine, object, evaluationObject, scopeChain);\n     applyBindings(object, scopeChain);\n", "fix_pattern": "<pattern>: if multiple calls to check for existence and then insert into a map are detected, refactor the code to access the map once and modify the existing value if it is invalid, which reduces the overhead of multiple lookups."}
{"number": 971, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if string join operations are performed with regular char or QString, replace them with QLatin1Char for improved performance when dealing with Latin-1 encoded strings, as it avoids unnecessary conversions."}
{"number": 973, "change": "@@ -1,5 +1,6 @@\n #include \"TextureGL.h\"\n #include <cassert>\n+#include \"utils.h\"\n \n namespace Graphics {\n \n@@ -109,16 +110,18 @@ TextureGL::~TextureGL()\n void TextureGL::Update(const void *data, const vector2f &dataSize, ImageFormat format, ImageType type)\n {\n \tglEnable(m_target);\n+\tglBindTexture(m_target, m_texture);\n \n \tswitch (m_target) {\n \t\tcase GL_TEXTURE_2D:\n-\t\t\tglTexImage2D(m_target, 0, GLTextureFormat(GetDescriptor().format), dataSize.x, dataSize.y, 0, GLImageFormat(format), GLImageType(type), data);\n+\t\t\tglTexSubImage2D(m_target, 0, 0, 0, dataSize.x, dataSize.y, GLImageFormat(format), GLImageType(type), data);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tassert(0);\n \t}\n \n+\tglBindTexture(m_target, 0);\n \tglDisable(m_target);\n }\n \n", "fix_pattern": "<pattern>: if a texture is being created or updated with glTexImage2D, replace it with glBindTexture and glTexSubImage2D to optimize the texture upload process, as the latter can update an existing texture without recreating it, reducing overhead and potentially improving performance."}
{"number": 974, "change": "@@ -32,14 +32,16 @@ bool header_match( const string & env_var_name,\n                    const string & header_name,\n                    const HTTPRequest & saved_response )\n {\n+    const char * const env_value = getenv( env_var_name.c_str() );\n+\n     /* case 1: neither header exists (OK) */\n-    if ( (not getenv( env_var_name.c_str() )) and (not saved_response.has_header( header_name )) ) {\n+    if ( (not env_value) and (not saved_response.has_header( header_name )) ) {\n         return true;\n     }\n \n     /* case 2: headers both exist (OK if values match) */\n-    if ( getenv( env_var_name.c_str() ) and saved_response.has_header( header_name ) ) {\n-        return saved_response.get_header_value( header_name ) == string( getenv( env_var_name.c_str() ) );\n+    if ( env_value and saved_response.has_header( header_name ) ) {\n+        return saved_response.get_header_value( header_name ) == string( env_value );\n     }\n \n     /* case 3: one exists but the other doesn't (failure) */\n", "fix_pattern": "<pattern>: if getenv() is called multiple times with the same variable, store the result in a local variable to avoid redundant calls and improve performance."}
{"number": 977, "change": "@@ -760,10 +760,8 @@ static QRegion scaleRegion(const QRegion &region, qreal factor)\n {\n     if (region.isEmpty() || qFuzzyCompare(factor, qreal(1)))\n         return region;\n-    if (region.rectCount() == 1)\n-        return QRegion(scaleRect(QRectF(region.boundingRect()), factor).toRect());\n     QRegion result;\n-    foreach (const QRect &rect, region.rects())\n+    for (const QRect &rect : region)\n         result += QRectF(QPointF(rect.topLeft()) * factor, QSizeF(rect.size() * factor)).toRect();\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is checking the count of rectangles in a QRegion and then iterating through them, replace the check and foreach with a range-based for loop directly on the QRegion to enhance readability and potentially improve performance by avoiding an extra function call."}
{"number": 979, "change": "@@ -1078,11 +1078,12 @@ void QIcon::addFile(const QString &fileName, const QSize &size, Mode mode, State\n     if (!d) {\n \n         QFileInfo info(fileName);\n-        QIconEngine *engine = iconEngineFromSuffix(fileName, info.suffix());\n+        QString suffix = info.suffix();\n #ifndef QT_NO_MIMETYPE\n-        if (!engine)\n-            engine = iconEngineFromSuffix(fileName, QMimeDatabase().mimeTypeForFile(info).preferredSuffix());\n+        if (suffix.isEmpty())\n+            suffix = QMimeDatabase().mimeTypeForFile(info).preferredSuffix(); // determination from contents\n #endif // !QT_NO_MIMETYPE\n+        QIconEngine *engine = iconEngineFromSuffix(fileName, suffix);\n         d = new QIconPrivate(engine ? engine : new QPixmapIconEngine);\n     }\n \n", "fix_pattern": "<pattern>: if an icon engine is retrieved using a suffix derived from the filename that depends on file info, first check if the suffix is empty and retrieve it conditionally only once, storing it in a variable to avoid redundant calls for the same operation."}
{"number": 984, "change": "@@ -859,9 +859,9 @@ void GLPaintContour::finalize_geometry()\n \n     if (!this->contour_indices.empty()) {\n         glsafe(::glGenBuffers(1, &this->m_contour_EBO_id));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, this->m_contour_EBO_id));\n-        glsafe(::glBufferData(GL_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, 0));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this->m_contour_EBO_id));\n+        glsafe(::glBufferData(GL_ELEMENT_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));\n         this->contour_indices.clear();\n     }\n }\n", "fix_pattern": "<pattern>: if the OpenGL API is being used to bind and buffer a data array, ensure to use the appropriate buffer type that matches the intended usage; replace `GL_ARRAY_BUFFER` with `GL_ELEMENT_ARRAY_BUFFER` when dealing with element indices to enhance performance and correctness."}
{"number": 985, "change": "@@ -172,7 +172,7 @@ QEvdevTouchScreenHandler::QEvdevTouchScreenHandler(const QString &specification,\n {\n     setObjectName(QLatin1String(\"Evdev Touch Handler\"));\n \n-    bool printDeviceInfo = qgetenv(\"QT_QPA_EVDEV_DEBUG\").toInt();\n+    bool printDeviceInfo = qEnvironmentVariableIntValue(\"QT_QPA_EVDEV_DEBUG\");\n \n     // only the first device argument is used for now\n     QString spec = QString::fromLocal8Bit(qgetenv(\"QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS\"));\n", "fix_pattern": "<pattern>: replace the combination of qgetenv and QString::toInt to read an environment variable as an integer directly using qEnvironmentVariableIntValue for improved performance."}
{"number": 986, "change": "@@ -461,7 +461,7 @@ void QPainterPrivate::draw_helper(const QPainterPath &originalPath, DrawOperatio\n     p.drawPath(originalPath);\n \n #ifndef QT_NO_DEBUG\n-    static bool do_fallback_overlay = qgetenv(\"QT_PAINT_FALLBACK_OVERLAY\").size() > 0;\n+    static bool do_fallback_overlay = !qEnvironmentVariableIsEmpty(\"QT_PAINT_FALLBACK_OVERLAY\");\n     if (do_fallback_overlay) {\n         QImage block(8, 8, QImage::Format_ARGB32_Premultiplied);\n         QPainter pt(&block);\n", "fix_pattern": "<pattern>: if checking for the existence of an environment variable using qgetenv and then calling size() on its return is done, replace it with directly using qEnvironmentVariableIsEmpty for better performance and clarity."}
{"number": 988, "change": "@@ -562,9 +562,9 @@ void DapEngine::updateItem(const QString &iname)\n void DapEngine::reexpandItems(const QSet<QString> &inames)\n {\n     QSet<QString> expandedInames = inames;\n-    const QList<QString> &watcherNames = watchHandler()->watcherNames().keys();\n-    for (const QString &inames : watcherNames)\n-        expandedInames.insert(watchHandler()->watcherName(inames));\n+    const auto &watcherNames = watchHandler()->watcherNames();\n+    for (auto it = watcherNames.begin(); it != watcherNames.end(); ++it)\n+        expandedInames.insert(watchHandler()->watcherName(it.key()));\n \n     QList<QString> inamesVector = expandedInames.values();\n     inamesVector.sort();\n", "fix_pattern": "<pattern>: if a QList's keys() method is used to retrieve keys, then refactor the code to operate directly on the QList to reduce unnecessary intermediate copies and improve iterator access for performance."}
{"number": 989, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if the code is using QString to perform string joining and manipulation, replace character literals with QLatin1Char() to optimize performance and reduce overhead in character operations within QString methods."}
{"number": 995, "change": "@@ -2289,21 +2289,12 @@ TClass *TClass::GetBaseClass(const char *classname)\n \n    if (!fClassInfo) return 0;\n \n-   TObjLink *lnk = GetListOfBases() ? fBase->FirstLink() : 0;\n+   // Make sure we deal with possible aliases, we could also have normalized\n+   // the name.\n+   TClass *search = TClass::GetClass(classname);\n \n-   // otherwise look at inheritance tree\n-   while (lnk) {\n-      TClass     *c, *c1;\n-      TBaseClass *base = (TBaseClass*) lnk->GetObject();\n-      c = base->GetClassPointer();\n-      if (c) {\n-         if (strcmp(c->GetName(), classname) == 0) return c;\n-         c1 = c->GetBaseClass(classname);\n-         if (c1) return c1;\n-      }\n-      lnk = lnk->Next();\n-   }\n-   return 0;\n+   if (search) return GetBaseClass(search);\n+   else return 0;\n }\n \n //______________________________________________________________________________\n", "fix_pattern": "<pattern>: instead of iterating through a linked list to find class information, use a direct lookup via TClass::GetClass for better performance and efficiency in accessing the desired base class."}
{"number": 997, "change": "@@ -253,11 +253,6 @@ void OpenGLShaderRenderer::renderCrossair(const Common::Point crossairPosition)\n \t_triangleShader->setUniform(\"useStipple\", false);\n \t_triangleShader->setUniform(\"mvpMatrix\", identity);\n \n-\tglMatrixMode(GL_PROJECTION);\n-\tglLoadIdentity();\n-\tglOrtho(0, _screenW, _screenH, 0, 0, 1);\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglLoadIdentity();\n \tglEnable(GL_BLEND);\n \tglBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ZERO);\n \n", "fix_pattern": "<pattern>: if multiple OpenGL matrix operations are called in a sequence, it's beneficial to group them under a single matrix mode and minimize state changes to improve performance."}
{"number": 1000, "change": "@@ -194,7 +194,7 @@ inline void GlTexture::Upload(\n     GLenum data_format, GLenum data_type\n ) {\n     Bind();\n-    glTexSubImage2D(GL_TEXTURE_2D,0,0,0,width,height,data_format,data_type,data);\n+    glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, data_format, data_type, data);\n     CheckGlDieOnError();\n }\n \n", "fix_pattern": "<pattern>: when updating texture data for the whole texture, use glTexImage2D instead of glTexSubImage2D for improved performance, as the former can handle the entire texture in one call versus modifying sub-regions."}
{"number": 1002, "change": "@@ -32,14 +32,7 @@ GlobeGPS::GlobeGPS(QWidget* parent) : MarbleWidget(parent), loadedDives(0), edit\n \tQStringList list = mtm.mapThemeIds();\n \tQString  subsurfaceDataPath;\n \tQDir marble;\n-\tbool foundGoogleMap = false;\n-\tQ_FOREACH(const QString& theme, list){\n-\t\tif (theme == \"earth/googlesat/googlesat.dgml\"){\n-\t\t\tfoundGoogleMap = true;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tif (!foundGoogleMap) {\n+\tif (!list.contains(\"earth/googlesat/googlesat.dgml\")) {\n \t\tsubsurfaceDataPath = getSubsurfaceDataPath(\"marbledata\");\n \t\tif (subsurfaceDataPath != \"\") {\n \t\t\tMarbleDirs::setMarbleDataPath(subsurfaceDataPath);\n", "fix_pattern": "<pattern>: if a loop is used to check for the existence of an item in a QStringList, replace it with the QStringList::contains() method for better performance and readability."}
{"number": 1007, "change": "@@ -178,12 +178,12 @@ DatabaseCommand_Resolve::fullTextResolve( DatabaseImpl* lib )\n     QList< QPair<int, float> > trackPairs = lib->search( m_query );\n     QList< QPair<int, float> > albumPairs = lib->searchAlbum( m_query, 20 );\n \n+    TomahawkSqlQuery query = lib->newquery();\n+    query.prepare( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = ?\" );\n+\n     foreach ( const scorepair_t& albumPair, albumPairs )\n     {\n-        TomahawkSqlQuery query = lib->newquery();\n-\n-        QString sql = QString( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = %1\" ).arg( albumPair.first );\n-        query.prepare( sql );\n+        query.bindValue( 0, albumPair.first );\n         query.exec();\n \n         QList<Tomahawk::album_ptr> albumList;\n", "fix_pattern": "<pattern>: if constructing a SQL query with QString::arg is used for value substitution, replace it with parameterized queries using bindValue to improve performance and security (prevent SQL injection)."}
{"number": 1010, "change": "@@ -89,9 +89,6 @@ void vw_Start2DMode(GLdouble zNear, GLdouble zFar)\n  */\n void vw_End2DMode()\n {\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglPopMatrix();\n-\n \t// we don't switch to 0 unit, in 2D mode only 0 unit should be used\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n@@ -100,6 +97,7 @@ void vw_End2DMode()\n \tglPopMatrix();\n \n \tglMatrixMode(GL_MODELVIEW);\n+\tglPopMatrix();\n \n \tglPopAttrib();\n }\n", "fix_pattern": "<pattern>: if glMatrixMode(GL_MODELVIEW) is called immediately before glPopMatrix(), it can be removed to avoid unnecessary state changes, as glPopMatrix() resets the matrix without needing to set the mode first."}
{"number": 1018, "change": "@@ -602,12 +602,20 @@ void Database::PurgeExpiredInstances()\n \t\treturn;\n \t}\n \n+\tstd::vector<std::string> instance_ids;\n \tfor (auto row = results.begin(); row != results.end(); ++row) {\n-\t\tquery = StringFormat(\"DELETE FROM instance_list WHERE id=%u\", atoi(row[0]));\n-\t\tQueryDatabase(query);\n-\n-\t\tDeleteInstance(atoi(row[0]));\n+\t\tinstance_ids.emplace_back(row[0]);\n \t}\n+\n+\tstd::string imploded_instance_ids = implode(\",\", instance_ids);\n+\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list_player WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM respawn_times WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM spawn_condition_values WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"UPDATE character_corpses SET is_buried = 1, instance_id = 0 WHERE instance_id IN ({})\", imploded_instance_ids));\n+\n+\t\n }\n \n void Database::SetInstanceDuration(uint16 instance_id, uint32 new_duration)\n", "fix_pattern": "<pattern>: if multiple deletes and an update are performed on the same instance_id, consolidate them into a single query for better performance by using a formatted string that incorporates instance_ids as a comma-separated list. This reduces the number of separate database calls and can improve overall efficiency."}
{"number": 1020, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified before being passed to the JS_DefinePropertyById function, and to simplify the call, set the configurable attribute directly on the descriptor and pass it without individually specifying getter, setter, and attributes. This reduces the overhead of constructing the property descriptor with multiple parameters and improves readability."}
{"number": 1021, "change": "@@ -23,6 +23,7 @@\n #include <map>\n #include <tuple>\n #include <chrono>\n+#include <cassert>\n \n #include \"async_handler.h\"\n #include \"cache.h\"\n@@ -274,13 +275,13 @@ namespace {\n \t\t\treturn LoadDummyBitmap<T>(s.directory, f);\n \t\t}\n \n+#ifndef NDEBUG\n \t\t// Test if the file was requested asynchronously before.\n \t\t// If not the file can't be expected to exist -> bug.\n-\t\tFileRequestAsync* request = AsyncHandler::RequestFile(s.directory, f);\n-\t\tif (!request->IsReady()) {\n-\t\t\tOutput::Debug(\"BUG: File Not Requested: %s/%s\", s.directory, f.c_str());\n-\t\t\treturn BitmapRef();\n-\t\t}\n+\t\t// This test is expensive and turned off in release builds.\n+\t\tauto* req = AsyncHandler::RequestFile(s.directory, f);\n+\t\tassert(req != nullptr && req->IsReady());\n+#endif\n \n \t\tBitmapRef ret = LoadBitmap(s.directory, f, transparent, Bitmap::Flag_ReadOnly | (\n \t\t\t\t\t\t\t\t\t\t T == Material::Chipset? Bitmap::Flag_Chipset:\n", "fix_pattern": "<pattern>: if a check for readiness is performed during debugging, replace the runtime check with an assert to avoid performance overhead in release builds while still ensuring the condition is verified during development."}
{"number": 1029, "change": "@@ -172,7 +172,8 @@ void SignalHistoryModel::onObjectAdded(QObject* object)\n   Q_ASSERT(thread() == QThread::currentThread());\n \n   // blacklist event dispatchers\n-  if (QString(object->metaObject()->className()).startsWith(\"QPAEventDispatcher\"))\n+  if (qstrncmp(object->metaObject()->className(), \"QPAEventDispatcher\", 18) == 0\n+    || qstrncmp(object->metaObject()->className(), \"QGuiEventDispatcher\", 19) == 0)\n     return;\n \n   beginInsertRows(QModelIndex(), m_tracedObjects.size(), m_tracedObjects.size());\n", "fix_pattern": "<pattern>: if a QString method is used to check for a prefix, replace it with qstrncmp for improved performance by avoiding QString overhead, especially in scenarios where only a few characters of comparison are needed."}
{"number": 1040, "change": "@@ -30,7 +30,7 @@\n #include \"vtkIdTypeArray.h\"\n #include \"vtkObjectFactory.h\"\n \n-vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18\");\n+vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18.6.1\");\n vtkStandardNewMacro(vtkDataSetAttributes);\n \n //--------------------------------------------------------------------------\n@@ -1470,16 +1470,16 @@ void vtkDataSetAttributes::CopyData(vtkDataSetAttributes::FieldList& list,\n                                     vtkDataSetAttributes* fromDSA,\n                                     int idx, vtkIdType fromId, vtkIdType toId)\n {\n-  vtkDataArray *fromDA;\n-  vtkDataArray *toDA;\n+  vtkAbstractArray *fromDA;\n+  vtkAbstractArray *toDA;\n   \n   int i;\n   for (i=0; i < list.NumberOfFields; i++)\n     {\n     if ( list.FieldIndices[i] >= 0 )\n       {\n-      toDA = this->GetArray(list.FieldIndices[i]);\n-      fromDA = fromDSA->GetArray(list.DSAIndices[idx][i]);\n+      toDA = this->GetAbstractArray(list.FieldIndices[i]);\n+      fromDA = fromDSA->GetAbstractArray(list.DSAIndices[idx][i]);\n       this->CopyTuple(fromDA, toDA, fromId, toId);\n       }\n     }\n", "fix_pattern": "<pattern>: if a specific API (vtkDataArray*) is replaced by a more generalized one (vtkAbstractArray*), it may indicate a move to more versatile or polymorphic data handling, which can improve performance through more efficient memory management and reduced type-checking overhead when handling datasets."}
{"number": 1041, "change": "@@ -57,7 +57,7 @@ extern \"C\" vtkglX::__GLXextFuncPtr glXGetProcAddressARB(const GLubyte *);\n // GLU is currently not linked in VTK.  We do not support it here.\n #define GLU_SUPPORTED   0\n \n-vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.29\");\n+vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.30\");\n vtkStandardNewMacro(vtkOpenGLExtensionManager);\n \n namespace vtkgl\n@@ -180,7 +180,7 @@ int vtkOpenGLExtensionManager::ExtensionSupported(const char *name)\n   // Workaround for a bug on renderer string=\"Quadro4 900 XGL/AGP/SSE2\"\n   // version string=\"1.5.8 NVIDIA 96.43.01\" or \"1.5.6 NVIDIA 87.56\"\n   // The driver reports it supports 1.5 but the 1.4 core promoted extension\n-  // GL_EXT_blend_func_separate is implemented in software.\n+  // GL_EXT_blend_func_separate is implemented in software (poor performance).\n   // All the NV2x chipsets are probably affected. NV2x chipsets are used\n   // in GeForce4 and Quadro4.\n   // It will make this method return false with \"GL_VERSION_1_4\" and true\n", "fix_pattern": "<pattern>: If a revision macro is updated to reflect a change in performance characteristics (from version 1.29 to 1.30) and includes a comment indicating poor performance related to a feature, then document the revision change alongside a performance note to provide context for why the change is notable."}
{"number": 1043, "change": "@@ -90,7 +90,7 @@ namespace rwe\n \n         glGenerateMipmap(GL_TEXTURE_2D);\n \n-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if the texture magnification filter could impact performance, and a performance improvement can be achieved by changing the filter from GL_LINEAR to GL_NEAREST, then update the parameter to use GL_NEAREST for better performance in scenarios where linear filtering is not necessary."}
{"number": 1052, "change": "@@ -64,7 +64,7 @@\n #define VTK_PV_ANIMATION_GROUP \"animateable\"\n \n vtkStandardNewMacro(vtkPVAnimationManager);\n-vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.47\");\n+vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.48\");\n vtkCxxSetObjectMacro(vtkPVAnimationManager, HorizantalParent, vtkKWWidget);\n vtkCxxSetObjectMacro(vtkPVAnimationManager, VerticalParent, vtkKWWidget);\n //*****************************************************************************\n@@ -205,7 +205,6 @@ void vtkPVAnimationManager::Create(vtkKWApplication* app, const char* )\n \n   this->ActiveTrackSelector->SetParent(\n     this->VAnimationInterface->GetSelectorFrame());\n-  this->ActiveTrackSelector->SetAnimationManager(this);\n   this->ActiveTrackSelector->Create(app, \"-relief flat\");\n   this->Script(\"pack %s -anchor n -side top -expand t -fill both\",\n     this->ActiveTrackSelector->GetWidgetName());\n", "fix_pattern": "<pattern>: if the vtkCxxRevisionMacro is updated to a new version number without changing any other logic or behavior in the code, correctly increment the versioning to reflect updates, indicating a potential change in functionality or fixes within the class."}
{"number": 1056, "change": "@@ -50,22 +50,15 @@ void dirvec_sort(struct dirvec *dv)\n \n struct directory *dirvec_find(const struct dirvec *dv, const char *path)\n {\n-\tchar *base;\n \tint i;\n-\tstruct directory *ret = NULL;\n-\n-\tbase = g_path_get_basename(path);\n \n \tdb_lock();\n \tfor (i = dv->nr; --i >= 0; )\n-\t\tif (!strcmp(directory_get_name(dv->base[i]), base)) {\n-\t\t\tret = dv->base[i];\n-\t\t\tbreak;\n-\t\t}\n+\t\tif (!strcmp(directory_get_name(dv->base[i]), path))\n+\t\t\treturn dv->base[i];\n \tdb_unlock();\n \n-\tg_free(base);\n-\treturn ret;\n+\treturn NULL;\n }\n \n int dirvec_delete(struct dirvec *dv, struct directory *del)\n", "fix_pattern": "<pattern>: if a temporary variable is used to hold the result of g_path_get_basename(path) only for comparison purposes, remove the unnecessary allocation of the temporary variable and directly compare the directory name with the original path instead."}
{"number": 1064, "change": "@@ -58,15 +58,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made to get and set file descriptor flags, combine them to reduce the number of system calls and avoid unnecessary operations when the new flags are equal to the old flags."}
{"number": 1078, "change": "@@ -45,11 +45,18 @@ ErrorOr<int> serenity_main(Main::Arguments arguments)\n \n     TRY(Core::System::pledge(\"stdio rpath exec\"));\n \n-    Vector<String> exec_environment_strings;\n     Vector<StringView> exec_environment;\n-    if (auto* term = getenv(\"TERM\")) {\n-        exec_environment_strings.append(String::formatted(\"TERM={}\", term));\n-        exec_environment.append(exec_environment_strings.last());\n+    for (size_t i = 0; environ[i]; ++i) {\n+        StringView env_view { environ[i] };\n+        auto maybe_needle = env_view.find('=');\n+\n+        if (!maybe_needle.has_value())\n+            continue;\n+\n+        if (env_view.substring_view(0, maybe_needle.value()) != \"TERM\"sv)\n+            continue;\n+\n+        exec_environment.append(env_view);\n     }\n \n     Vector<String> exec_arguments;\n", "fix_pattern": "<pattern>: if the code checks for a specific environment variable using getenv, refactor it to iterate through the `environ` array for potentially better performance and to handle cases where the environment variable may not exist or might be defined differently. This avoids the overhead of a string formatting operation unless necessary."}
{"number": 1082, "change": "@@ -76,7 +76,7 @@ static int newPage(const char *name, int level, int width, int height, int count\n \tglTexImage2D(GL_TEXTURE_2D, level, wz_texture_compression, width, height, 0,\n \t             GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n \tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n+\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if a texture filtering parameter is set using glTexParameteri(), consider switching from GL_LINEAR_MIPMAP_LINEAR to GL_NEAREST_MIPMAP_LINEAR to potentially improve performance due to the reduced computational cost of nearest filtering compared to linear filtering."}
{"number": 1085, "change": "@@ -600,11 +600,8 @@ int iV_DrawFormattedText(const char* String, UDWORD x, UDWORD y, UDWORD Width, U\n \n void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotation)\n {\n-\tGLint matrix_mode = 0;\n-\n \tpie_SetTexturePage(TEXPAGE_FONT);\n \n-\tglGetIntegerv(GL_MATRIX_MODE, &matrix_mode);\n \tglMatrixMode(GL_TEXTURE);\n \tglPushMatrix();\n \tglLoadIdentity();\n@@ -630,7 +627,7 @@ void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotati\n \tglPopMatrix();\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n-\tglMatrixMode(matrix_mode);\n+\tglMatrixMode(GL_MODELVIEW);\n \n \t// Reset the current model view matrix\n \tglLoadIdentity();\n", "fix_pattern": "<pattern>: if retrieving the current matrix mode using glGetIntegerv(GL_MATRIX_MODE, ...) is unnecessary and a specific mode (e.g., GL_MODELVIEW) can be assumed or set directly, replace the call with a direct glMatrixMode(...) invocation to improve performance."}
{"number": 1086, "change": "@@ -76,15 +76,14 @@ void GlLine::draw(float,Camera *) {\n \t\tglLineStipple(factor,pattern);\n \t\tglEnable(GL_LINE_STIPPLE);\n \t}\n-\tglBegin(GL_LINE_STRIP);\n \n-\tfor(unsigned int i=0; i < _points.size(); ++i) {\n-\t\tif (i < _colors.size()) {\n-\t\t\tsetColor(_colors[i]);\n-\t\t}\n-\t\tglVertex3fv((float *)&_points[i]);\n-\t}\n-\tglEnd();\n+\tglEnableClientState(GL_VERTEX_ARRAY);\n+\tglEnableClientState(GL_COLOR_ARRAY);\n+\tglVertexPointer(3, GL_FLOAT, 3 * sizeof(float), &_points[0]);\n+\tglColorPointer(4, GL_UNSIGNED_BYTE, 4 * sizeof(unsigned char), &_colors[0]);\n+\tglDrawArrays(GL_LINE_STRIP, 0, _points.size());\n+\tglDisableClientState(GL_VERTEX_ARRAY);\n+\tglDisableClientState(GL_COLOR_ARRAY);\n \n \tOpenGlConfigManager::getInst().desactivateLineAndPointAntiAliasing();\n \n", "fix_pattern": "<pattern>: if OpenGL drawing commands use `glBegin` and `glEnd` for drawing multiple vertices and colors, refactor the code to use vertex array capabilities, enabling the appropriate client states and using `glDrawArrays` for improved performance and reduced overhead."}
{"number": 1092, "change": "@@ -88,13 +88,18 @@ QVariant DateFilter::doFilter(const QVariant &input, const QVariant &argument,\n                               bool autoescape) const\n {\n   Q_UNUSED(autoescape)\n-  auto d = QDateTime::fromString(getSafeString(input),\n+    QDateTime d;\n+    if (input.type() == QVariant::DateTime) {\n+        d = input.toDateTime();\n+    } else if (input.type() == QVariant::Date) {\n+        d.setDate(input.toDate());\n+    } else {\n #if QT_VERSION < QT_VERSION_CHECK(5, 11, 0)\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss\"));\n #else\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\"));\n #endif\n-  );\n+    }\n \n   auto argString = getSafeString(argument);\n \n", "fix_pattern": "<pattern>: if the input type is checked for QVariant::DateTime or QVariant::Date, avoid calling QDateTime::fromString multiple times and directly use toDateTime() and setDate() methods to improve performance by reducing redundant string conversions."}
{"number": 1103, "change": "@@ -383,8 +383,6 @@ void Renderer::render(uint32_t delta) {\n       const auto& batch = graphics_batches[i];\n       const auto program = batch.depth_shader.gl_program;\n       glUseProgram(program);\n-      glBindVertexArray(batch.gl_depth_vao);\n-\n       glUniformMatrix4fv(glGetUniformLocation(program, \"camera_view\"), 1, GL_FALSE, glm::value_ptr(camera_transform));\n       \n       // FIXME: These copies should happen outside of the render loop\n", "fix_pattern": "<pattern>: if glBindVertexArray is called redundantly, ensure that it's only called when necessary, potentially by checking if the current VAO is different from the one being bound to avoid unnecessary state changes."}
{"number": 1107, "change": "@@ -19,7 +19,7 @@\n  \n      For further information visit http://plib.sourceforge.net\n \n-     $Id: fnt.cc,v 1.1.2.5 2003-12-04 02:12:47 olly Exp $\n+     $Id: fnt.cc,v 1.1.2.6 2004-03-02 12:28:58 olly Exp $\n */\n \n #include \"fnt.h\"\n@@ -177,9 +177,6 @@ fntTexFont::load(const char *fname)\n \t\t (GLvoid *)teximage);\n     delete [] teximage;\n \n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n-\n     glAlphaFunc(GL_GREATER, 0.5f);\n \n     fseek(fd, fpos, SEEK_SET);\n", "fix_pattern": "<pattern>: NA"}
{"number": 1110, "change": "@@ -2459,7 +2459,6 @@ void MainScene(HDC hDC)\n \n         if (Success)\n         {\n-            glFlush();\n             SwapBuffers(hDC);\n         }\n \n", "fix_pattern": "<pattern>: if glFlush() is called without subsequent rendering commands that require completion, consider removing it or consolidating it to reduce unnecessary sync point overhead in OpenGL rendering."}
{"number": 1116, "change": "@@ -517,11 +517,14 @@ void Core::emitRichNotification(const QString &evid, const QString &title, const\n \n bool Core::emitBatteryChargePercentNotification(int currentPercent, int previousPercent, const QString &udi, Core::ChargeNotificationFlags flags)\n {\n-    using namespace Solid;\n-    Device device(udi);\n-    Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+    if (m_peripheralBatteriesPercent.contains(udi)) {\n+        using namespace Solid;\n+        Device device(udi);\n+        Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+        if (!b) {\n+            return false;\n+        }\n \n-    if (b && !b->isPowerSupply()) {\n         // if you leave the device out of reach or it has not been initialized yet\n         // it won't be \"there\" and report 0%, don't show anything in this case\n         if (!b->isPresent() || b->chargePercent() == 0) {\n", "fix_pattern": "<pattern>: if there is a need to check for a specific device's power supply status through an API call that is potentially costly, add a quick lookup check in a map or set to determine if further API usage is necessary, thus avoiding unnecessary calls when the information can be derived from a pre-checked structure."}
{"number": 1118, "change": "@@ -95,9 +95,9 @@ KAboutPerson KAboutPerson::fromJSON(const QJsonObject &obj)\n {\n     const QString name = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Name\"));\n     const QString task = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Task\"));\n-    const QString email = obj[QStringLiteral(\"Email\")].toString();\n-    const QString website = obj[QStringLiteral(\"Website\")].toString();\n-    const QUrl avatarUrl = obj[QStringLiteral(\"AvatarUrl\")].toVariant().toUrl();\n+    const QString email = obj.value(QLatin1String(\"Email\")).toString();\n+    const QString website = obj.value(QLatin1String(\"Website\")).toString();\n+    const QUrl avatarUrl = obj.value(QLatin1String(\"AvatarUrl\")).toVariant().toUrl();\n     return KAboutPerson(name, task, email, website, avatarUrl);\n }\n \n", "fix_pattern": "<pattern>: if accessing keys in a QJsonObject using QStringLiteral results in potential repeated conversions from QString to QByteArray, use QLatin1String instead for improved performance."}
{"number": 1119, "change": "@@ -99,9 +99,7 @@ KNotesApp::KNotesApp()\n {\n     Akonadi::ControlGui::widgetNeedsAkonadi(this);\n \n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n \n     if (KNotesGlobalConfig::self()->autoCreateResourceOnStart()) {\n         NoteShared::LocalResourceCreator *creator = new NoteShared::LocalResourceCreator(this);\n", "fix_pattern": "<pattern>: if checking for an environment variable and its value's emptiness, replace qgetenv and isEmpty with the more direct qEnvironmentVariableIsEmpty for improved performance."}
