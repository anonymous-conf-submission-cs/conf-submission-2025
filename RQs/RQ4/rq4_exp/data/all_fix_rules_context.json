{"number": 1, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.7 2005/06/12 17:21:53 brun Exp $\n+// @(#)root/pyroot:$Name:  $:$Id: Executors.cxx,v 1.8 2005/06/14 05:06:03 brun Exp $\n // Author: Wim Lavrijsen, Jan 2005\n \n // Bindings\n@@ -138,7 +138,7 @@ PyObject* PyROOT::RootObjectByValueExecutor::Execute( G__CallFunc* func, void* s\n    void* result2 = result1;\n    if ( fClass->GetClassInfo() && fClass->GetClassInfo()->Linkage() != -1 ) {\n       result2 = new char[ fClass->Size() ];\n-      mempcpy( result2, result1, fClass->Size() );\n+      memcpy( result2, result1, fClass->Size() );\n    }\n    G__pop_tempobject();            // doesn't call dtor\n \n", "fix_pattern": "<pattern>: if the code uses mempcpy unnecessarily when memcpy suffices, replace it with memcpy for improved performance since memcpy is typically optimized for this use case and avoids potential unnecessary complications."}
{"number": 2, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/gpad:$Name:  $:$Id: TClassTree.cxx,v 1.14 2007/01/12 16:03:16 brun Exp $\n+// @(#)root/gpad:$Name:  $:$Id: TClassTree.cxx,v 1.15 2007/01/23 09:04:13 brun Exp $\n // Author: Rene Brun   01/12/98\n \n /*************************************************************************\n@@ -27,6 +27,7 @@\n #include \"TArrow.h\"\n #include \"TText.h\"\n #include \"TSystem.h\"\n+#include \"TVirtualIO.h\"\n #include \"TObjString.h\"\n #include \"Riostream.h\"\n \n@@ -700,7 +701,7 @@ void TClassTree::SaveAs(const char *filename, Option_t *option) const\n    // with no access to the original classes.\n    // By default a message is printed. Specify option \"Q\" to remove the message\n \n-   gROOT->ProcessLine(Form(\"TFile::SaveObjectAs((TClassTree*)0x%x,\\\"%s\\\",\\\"%s\\\");\",this,filename,option));\n+   TVirtualIO::GetIO()->SaveObjectAs(this,filename,option);\n }\n \n \n", "fix_pattern": "<pattern>: if a method calls `ProcessLine` with a formatted string to save an object, refactor the code to directly use a more efficient API call (like `SaveObjectAs`) instead of constructing and processing a command string, thereby reducing overhead and improving performance."}
{"number": 3, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.30 2007/01/15 10:15:47 brun Exp $\n+// @(#)root/cont:$Name:  $:$Id: TObjArray.cxx,v 1.31 2007/02/06 11:48:48 rdm Exp $\n // Author: Fons Rademakers   11/09/95\n \n /*************************************************************************\n@@ -28,7 +28,6 @@\n #include \"TObjArray.h\"\n #include \"TError.h\"\n #include \"TROOT.h\"\n-#include \"TRandom.h\"\n \n ClassImp(TObjArray)\n \n@@ -615,7 +614,7 @@ void TObjArray::Randomize(Int_t ntimes)\n \n    for (Int_t i=0;i<ntimes;i++) {\n       for (Int_t j=0;j<fLast;j++) {\n-         Int_t k = (Int_t)gRandom->Uniform(0,fLast);\n+         Int_t k = (Int_t)(fLast*rand()/(RAND_MAX+1.0));\n          if (k == j) continue;\n          TObject *obj = fCont[j];\n          fCont[j] = fCont[k];\n", "fix_pattern": "<pattern>: if a call to gRandom->Uniform is replaced with a direct use of rand() from the Standard C Library, consider if this change is made to avoid the overhead or dependency of the ROOT Framework for simpler random number generation."}
{"number": 4, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.175 2007/03/02 08:52:02 brun Exp $\n+// @(#)root/geom:$Name:  $:$Id: TGeoManager.cxx,v 1.176 2007/03/14 11:31:36 brun Exp $\n // Author: Andrei Gheata   25/10/01\n \n /*************************************************************************\n@@ -5578,7 +5578,12 @@ TGeoManager *TGeoManager::Import(const char *filename, const char *name, Option_\n    } else {   \n       // import from a root file\n       TFile *old = gFile;\n-      TFile *f = TFile::Open(filename);\n+      // in case a web file is specified, use the cacheread option to cache\n+      // this file in the local directory\n+      TFile::SetCacheFileDir(\".\");\n+      TFile *f = 0;\n+      if (strstr(filename,\"http://\")) f = TFile::Open(filename,\"CACHEREAD\");\n+      else                            f = TFile::Open(filename);\n       if (!f || f->IsZombie()) {\n          if (old) old->cd();\n          printf(\"Error in <TGeoManager::Import>: Cannot open file\\n\");\n", "fix_pattern": "<pattern>: if a filename is detected as a URL starting with \"http://\", utilize the \"CACHEREAD\" option when opening the file through the TFile API to potentially improve file access performance by caching the contents locally."}
{"number": 5, "change": "@@ -2859,7 +2859,7 @@ Int_t TGX11::SetTextFont(char *fontname, ETextSetMode mode)\n          XSetFont(fDisplay, *gGCtext, gTextFont->fid);\n          XSetFont(fDisplay, *gGCinvt, gTextFont->fid);\n          gFont[gCurrentFontNumber].id = gTextFont;\n-         strcpy(gFont[gCurrentFontNumber].name,fontname);\n+         strlcpy(gFont[gCurrentFontNumber].name,fontname,80);\n          gCurrentFontNumber++;\n          if (gCurrentFontNumber == kMAXFONT) gCurrentFontNumber = 0;\n       }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with strlcpy to ensure safety by preventing buffer overflows through size checking."}
{"number": 6, "change": "@@ -1058,7 +1058,7 @@ Bool_t TXMLPlayer::ProduceSTLstreamer(ostream& fs, TClass* cl, TStreamerSTL* el,\n       strlcpy(tabs2, tabs, sizeof(tabs2));\n \n       if (isptr) {\n-         strncat(tabs2, tab1, sizeof(tabs2));\n+         strlcat(tabs2, tab1, sizeof(tabs2));\n          fs << tabs << \"if (\" << (isarr ? \"*cont\" : \"cont\") << \"==0) {\" << endl;\n          fs << tabs2 << \"buf.WriteSTLsize(0\" << (isstr ? \",true);\" : \");\") << endl;\n          fs << tabs << \"} else {\" << endl;\n", "fix_pattern": "<pattern>: if using strncat for concatenating strings, replace it with strlcat to improve safety and avoid buffer overflow issues, as strlcat provides better boundary checks compared to strncat."}
{"number": 8, "change": "@@ -558,15 +558,15 @@ void ProofdExec()\n       char *buf = (char *) vb;\n       char *end = buf + len;\n       const char name[] = \"PROOF_ALLVARS=\";\n-      char *all = new char[strlen(name)+len]; // strlen(\"PROOF_ALLVARS=\") = 14\n-      strncpy(all, name, strlen(name)+len);\n-      all[strlen(name)+len-1] = 0;\n+      int alen = strlen(name)+len;\n+      char *all = new char[alen]; // strlen(\"PROOF_ALLVARS=\") = 14\n+      strlcpy(all, name, alen);\n       while (buf < end) {\n          if (gDebug > 0) ErrorInfo(\"ProofdExec: setting: %s\", buf);\n          char *p = index(buf, '=');\n          if (p) {\n-            if (buf != (char *) vb) strncat(all, \",\", 1); // skip the first one\n-            strncat(all, buf, p-buf);\n+            if (buf != (char *) vb) strlcat(all, \",\", alen); // skip the first one\n+            strlcat(all, buf, alen);\n             putenv(buf);\n          }\n          buf += strlen(buf) + 1;\n", "fix_pattern": "<pattern>: if string manipulation is done using strncpy and strncat, replace them with strlcpy and strlcat for improved safety and performance, as strlcpy and strlcat not only copy and concatenate strings but also ensure null-termination and respect buffer sizes more effectively."}
{"number": 10, "change": "@@ -4098,7 +4098,7 @@ void TCling::ExecuteWithArgsAndReturn(TMethod* method, void* address,\n       Error(\"ExecuteWithArgsAndReturn\", \"No method was defined\");\n       return;\n    }\n-   R__LOCKGUARD2(gInterpreterMutex);\n+\n    TClingMethodInfo* minfo = (TClingMethodInfo*) method->fInfo;\n    TClingCallFunc func(*minfo,*fNormalizedCtxt);\n    func.ExecWithArgsAndReturn(address, args, nargs, ret);\n", "fix_pattern": "<pattern>: if a lock guard is used for synchronization but is unnecessary (i.e., the critical section code is empty), remove the lock guard to improve performance by avoiding unnecessary overhead."}
{"number": 13, "change": "@@ -24,10 +24,7 @@ pythonizations.\n PyObject *CallPyObjMethod(PyObject *obj, const char *meth)\n {\n    // Helper; call method with signature: obj->meth()\n-   Py_INCREF(obj);\n-   PyObject* result = PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n-   Py_DECREF(obj);\n-   return result;\n+   return PyObject_CallMethod(obj, const_cast<char*>(meth), const_cast<char*>(\"\"));\n }\n \n TClass *GetTClass(const CPyCppyy::CPPInstance *pyobj)\n", "fix_pattern": "<pattern>: if a reference counting operation is followed immediately by an API call and then a decref, it's unnecessary to increment the reference count before the call and decrement it after, as the called method is expected to manage the reference count appropriately. Thus, directly call the method without the extra reference counting."}
{"number": 15, "change": "@@ -46,7 +46,7 @@ void uThread::destory(bool force = false) {\n     //check whether we should cache it or not\n     totalNumberofUTs--;\n     if (slowpath(force) || (utCache.push(this) < 0)) {\n-        free((ptr_t) (stackBottom));       //Free the allocated memory for stack\n+        munmap((ptr_t) (stackBottom), stackSize);       //Free the allocated memory for stack\n     }\n }\n \n", "fix_pattern": "<pattern>: if freeing memory that was allocated with mmap or similar methods, use munmap instead of free to ensure proper memory deallocation in line with the allocation method used."}
{"number": 16, "change": "@@ -674,7 +674,8 @@ protected:\n                 if (path_attr != INVALID_FILE_ATTRIBUTES && (path_attr & FILE_ATTRIBUTE_DIRECTORY))\n                     ofn.lpstrInitialDir = m_wdefault_path.c_str();\n                 else if (m_wdefault_path.size() <= woutput.size())\n-                    lstrcpyW(ofn.lpstrFile, m_wdefault_path.c_str());\n+                    //second argument is size of buffer, not length of string\n+                    StringCchCopyW(ofn.lpstrFile, MAX_PATH*256+1, m_wdefault_path.c_str());\n                 else\n                 {\n                     ofn.lpstrFileTitle = (LPWSTR)m_wdefault_path.data();\n", "fix_pattern": "<pattern>: if a string copy is done using lstrcpyW, replace it with StringCchCopyW and provide the destination buffer size to avoid potential buffer overflows and improve safety."}
{"number": 19, "change": "@@ -1465,7 +1465,6 @@ void Widget::remove_component(Widget* widget)\n             children().end(m_components_begin);\n         }\n         m_subordinates.erase(i);\n-        layout();\n     }\n     else if (widget->m_parent == this)\n     {\n", "fix_pattern": "<pattern>: if the layout() method is being called without any changes in the preceding state that affect the layout, consider removing the redundant call for performance optimization."}
{"number": 24, "change": "@@ -128,14 +128,14 @@ void MonitorPictureDialog::updateMonitorWidgets(QString primaryMonitor)\n \n     for (MonitorPicture *picture : qAsConst(pictures)) {\n         if (picture->monitorWidget->output->name() == primaryMonitor\n-                || primaryMonitor == QStringLiteral(\"\")) {\n+                || primaryMonitor == QLatin1String()) {\n             x0 = picture->originX + picture->pos().x();\n             y0 = picture->originY + picture->pos().y();\n             break;\n         }\n     }\n \n-    if( primaryMonitor == QStringLiteral(\"\") ) {\n+    if( primaryMonitor == QLatin1String() ) {\n         for(MonitorPicture *picture : qAsConst(pictures)) {\n             int x1 = picture->originX + picture->pos().x();\n             int y1 = picture->originY + picture->pos().y();\n", "fix_pattern": "<pattern>: if a comparison against an empty QStringLiteral is detected, replace it with a comparison against QLatin1String() for improved performance, as QLatin1String is more efficient for this use case in Qt Framework."}
{"number": 25, "change": "@@ -814,7 +814,7 @@ bool QHttpNetworkReplyPrivate::expectContent()\n         || statusCode == 204 || statusCode == 304)\n         return false;\n     if (request.operation() == QHttpNetworkRequest::Head)\n-        return !shouldEmitSignals();\n+        return false; // no body expected for HEAD request\n     qint64 expectedContentLength = contentLength();\n     if (expectedContentLength == 0)\n         return false;\n", "fix_pattern": "<pattern>: if an API method is expected to have no body for certain conditions (like a HEAD request), replace the call to a method that may incur additional processing with a direct return of a boolean value (such as false), thus improving performance by avoiding an unnecessary function call."}
{"number": 26, "change": "@@ -317,7 +317,10 @@ QT_END_INCLUDE_NAMESPACE\n \n void QTimer::singleShot(int msec, QObject *receiver, const char *member)\n {\n-    singleShot(msec, Qt::CoarseTimer, receiver, member);\n+    // coarse timers are worst in their first firing\n+    // so we prefer a high precision timer for something that happens only once\n+    // unless the timeout is too big, in which case we go for coarse anyway\n+    singleShot(msec, msec >= 2000 ? Qt::CoarseTimer : Qt::PreciseTimer, receiver, member);\n }\n \n /*! \\overload\n", "fix_pattern": "<pattern>: if a timer is set with the QTimer::singleShot method and the timeout is significant (2000 ms or more), prefer a coarse timer for efficiency; otherwise, use a high precision timer for shorter durations to minimize delay."}
{"number": 29, "change": "@@ -557,9 +557,7 @@ template<typename real_t, typename index_t>\n \n #ifdef HAVE_MPI\n     if(nprocs>1){\n-      double lpredicted;\n-      MPI_Allreduce(&predicted, &lpredicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n-      predicted = lpredicted;\n+      MPI_Allreduce(MPI_IN_PLACE, &predicted, 1, MPI_DOUBLE, MPI_SUM, _mesh->get_mpi_comm());\n     }\n #endif\n     \n", "fix_pattern": "<pattern>: if a variable is used to receive a result from MPI_Allreduce and then assigned back to an original variable, simplify the call by using MPI_IN_PLACE to avoid unnecessary data copying, allowing for in-place reduction."}
{"number": 30, "change": "@@ -656,7 +656,8 @@ static int create_worker(thread_group_t *thread_group)\n     DBUG_RETURN(-1);\n   }\n \n-  err= pthread_create(&thread_id, thread_group->pthread_attr, worker_main, thread_group);\n+  err= mysql_thread_create(key_worker_thread, &thread_id, \n+         thread_group->pthread_attr, worker_main, thread_group);\n   if (!err)\n   {\n     thread_group->pending_thread_start_count++;\n", "fix_pattern": "<pattern>: if a thread is being created using pthread_create, replace it with mysql_thread_create to benefit from MySQL's optimized thread management and context handling, which may improve performance in MySQL-related applications."}
{"number": 32, "change": "@@ -46,10 +46,11 @@\n // zlib compress2 function resulted in a 40+% reduction versus the original image.\n uint8_t* GFXRECON_zlib_compress2(uint8_t* data, int32_t data_len, int32_t* out_len, int32_t quality)\n {\n-    uint8_t* target = reinterpret_cast<uint8_t*>(malloc(data_len));\n+    unsigned long alloc_len = compressBound(data_len);\n+    uint8_t*      target    = reinterpret_cast<uint8_t*>(malloc(alloc_len));\n     if (nullptr != target)\n     {\n-        unsigned long ret_len = data_len;\n+        unsigned long ret_len = alloc_len;\n         if (Z_OK == compress2(target, &ret_len, data, data_len, quality))\n         {\n             *out_len = ret_len;\n", "fix_pattern": "<pattern>: when allocating memory for compressed data, use `compressBound(data_len)` to ensure sufficient space is allocated to accommodate compressed bytes instead of the uncompressed data length."}
{"number": 34, "change": "@@ -1,7 +1,5 @@\n #include <cstdio>\n #include <ncurses.h>\n-#include <sys/ioctl.h>\n-#include <unistd.h>\n #include \"Terminal.h\"\n \n int Terminal::NumberOfRows = 0;\n@@ -17,10 +15,7 @@ Terminal::Terminal() {\n \tleaveok(stdscr, TRUE);\n \tcurs_set(0);\n \n-\tstruct winsize WindowSize;\n-\tioctl(STDOUT_FILENO, TIOCGWINSZ, &WindowSize);\n-\tTerminal::NumberOfRows = WindowSize.ws_row;\n-\tTerminal::NumberOfColumns = WindowSize.ws_col;\n+\tgetmaxyx(stdscr, Terminal::NumberOfRows, Terminal::NumberOfColumns);\n }\n \n Terminal::~Terminal() {\n", "fix_pattern": "<pattern>: if terminal dimensions are obtained via ioctl, replace it with ncurses' getmaxyx function for better performance and simplicity in a terminal handling context."}
{"number": 36, "change": "@@ -97,7 +97,8 @@ class DenoisingFunctor\n     X = svd.matrixU() * s.asDiagonal() * svd.matrixV().adjoint();\n     // Store output\n     assign_pos_of(dwi).to(out);\n-    out.row(3) = X.col(n/2).template cast<value_type>();\n+    for (auto l = Loop (3) (out); l; ++l)\n+      out.value() = X(out.index(3), n/2);\n   }\n   \n   void operator () (ImageType& dwi, ImageType& out, ImageType& noise)\n", "fix_pattern": "<pattern>: if there is a direct assignment from a column of an Eigen matrix to a row of a custom image type, replace it with a loop that accesses specific indices, which may optimize memory access patterns, especially when dealing with larger matrices and allowing for more fine-grained control over the assignment process."}
{"number": 38, "change": "@@ -2006,7 +2006,7 @@ void MainWindow::saveCameras(QString const& path, bool writeToProject)\n         auto const filepath = QDir{path}.filePath(cameraName);\n         out.insert(filepath, camera);\n \n-        if (QFileInfo(filepath).exists())\n+        if (QFileInfo::exists(filepath))\n         {\n           willOverwrite.append(filepath);\n         }\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is being created just to check for file existence, replace it with a static call to QFileInfo::exists to avoid unnecessary object creation and improve performance."}
{"number": 39, "change": "@@ -20,14 +20,14 @@\n #include \"vtkByteSwap.h\"\n #include \"vtkCellData.h\"\n #include \"vtkDataArray.h\"\n-#include \"vtkDataCompressor.h\"\n+#include \"vtkZLibDataCompressor.h\"\n #include \"vtkDataSet.h\"\n #include \"vtkOutputStream.h\"\n #include \"vtkPointData.h\"\n #include \"vtkPoints.h\"\n #include \"vtkUnsignedCharArray.h\"\n \n-vtkCxxRevisionMacro(vtkXMLWriter, \"1.14\");\n+vtkCxxRevisionMacro(vtkXMLWriter, \"1.15\");\n vtkCxxSetObjectMacro(vtkXMLWriter, Compressor, vtkDataCompressor);\n \n //----------------------------------------------------------------------------\n@@ -55,7 +55,7 @@ vtkXMLWriter::vtkXMLWriter()\n \n   // Initialize compression data.\n   this->BlockSize = 32768;\n-  this->Compressor = 0;\n+  this->Compressor = vtkZLibDataCompressor::New();\n   this->CompressionHeader = 0;\n   \n   this->EncodeAppendedData = 1;\n", "fix_pattern": "<pattern>: if a class is updated to use a more efficient compression method (from a null pointer to a specific compressor implementation), replace null compressor assignment with the new compressor instantiation for improved data handling efficiency."}
{"number": 40, "change": "@@ -29,7 +29,7 @@\n \n #include <math.h>\n \n-vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.17\");\n+vtkCxxRevisionMacro(vtkSpherePuzzle, \"1.18\");\n vtkStandardNewMacro(vtkSpherePuzzle);\n \n //----------------------------------------------------------------------------\n@@ -175,7 +175,7 @@ int vtkSpherePuzzle::RequestData(\n \n       // append all the pieces.\n       append->AddInput(tmp);\n-      tmp->Delete();\n+      tmp->FastDelete();\n       ++count;\n       }\n     }\n", "fix_pattern": "<pattern>: if a deletion operation on a VTK object is being performed using the more conventional Delete() method, replace it with FastDelete() to improve performance, especially for objects that may involve a significant overhead in reference counting. Additionally, the revision macro is updated to reflect a new version, which can indicate that the change is part of version management or enhancement as well."}
{"number": 41, "change": "@@ -956,9 +956,8 @@ int vtkGDALRasterReader::RequestData(vtkInformation* vtkNotUsed(request),\n   }\n \n   // Get the projection.\n-  char* proj = strdup(this->Impl->GDALData->GetProjectionRef());\n-  this->ProjectionWKT = proj;\n-  OGRSpatialReference spRef(proj);\n+  this->ProjectionWKT = this->Impl->GDALData->GetProjectionRef();\n+  OGRSpatialReference spRef(this->ProjectionWKT.c_str());\n \n   char* projection;\n   spRef.exportToProj4(&projection);\n", "fix_pattern": "<pattern>: if a string is obtained from an API and duplicated using strdup, directly assign the string to a member variable (e.g., std::string) to avoid unnecessary memory allocation and copying, and use the underlying c_str() method for interoperability with C APIs."}
{"number": 46, "change": "@@ -49,8 +49,8 @@ public:\n                               NodesArrayType const& rThisNodes,\n                               PropertiesType::Pointer pProperties) const override\n     {\n-        return Condition::Pointer(new TNormalFluxCondition(\n-            NewId, this->GetGeometry().Create(rThisNodes), pProperties));\n+        return Kratos::make_intrusive<TNormalFluxCondition>(\n+            NewId, GetGeometry().Create(rThisNodes), pProperties);\n     }\n \n protected:\n", "fix_pattern": "<pattern>: if an object is being created and wrapped with a smart pointer using a custom constructor method like Condition::Pointer, replace it with the more efficient Kratos::make_intrusive that helps in reducing the overhead associated with smart pointer management by creating the object directly in the heap and handling the reference counting automatically."}
{"number": 47, "change": "@@ -180,11 +180,16 @@ void ProblemReporter::reparse()\n     if( !m_javaSupport->isValid() )\n \treturn;\n \n+    // @todo: use the project database to decide which files to parse instead of this!\n+    // ugly hack: do not parse non .java ending files\n+    if ( !m_fileName.endsWith(\".java\") )\n+        return;\n+\n     m_timer->stop();\n \n     kdDebug(9013) << \"ProblemReporter::reparse()\" << endl;\n     m_javaSupport->backgroundParser()->addFile( m_fileName );\n-    kdDebug(9013) << \"---> file added\" << endl;\n+    kdDebug(9013) << \"---> file added \" << m_fileName << endl;\n }\n \n void ProblemReporter::slotSelected( QListViewItem* item )\n", "fix_pattern": "<pattern>: if logging a debug message occurs unconditionally, introduce a condition to skip logging for certain cases (such as files that do not end with a specific extension) to avoid unnecessary performance costs from function calls and streamline the logging process."}
{"number": 49, "change": "@@ -158,14 +158,14 @@ void TemplatesModel::extractTemplateDescriptions()\n     {\n         kDebug() << \"processing template\" << archName;\n \n-        KArchive* templateArchive;\n+        QScopedPointer<KArchive> templateArchive;\n         if (QFileInfo(archName).completeSuffix() == \"zip\")\n         {\n-            templateArchive = new KZip(archName);\n+            templateArchive.reset(new KZip(archName));\n         }\n         else\n         {\n-            templateArchive = new KTar(archName);\n+            templateArchive.reset(new KTar(archName));\n         }\n \n         if (templateArchive->open(QIODevice::ReadOnly))\n", "fix_pattern": "<pattern>: if raw pointers are used for managing heap-allocated objects, replace them with QScopedPointer to automatically handle memory management and prevent leaks."}
{"number": 51, "change": "@@ -455,7 +455,7 @@ public:\n                     if(activeView)\n                         activeDoc = qobject_cast<Sublime::UrlDocument *>(activeView->document());\n                     if(activeDoc && Core::self()->uiControllerInternal()->arrangeBuddies()) {\n-                        QString mime = QMimeDatabase().mimeTypeForUrl(activeDoc->url()).name();\n+                        const auto mime = activeDoc->mimeType().name();\n                         buddyFinder = IBuddyDocumentFinder::finderForMimeType(mime);\n                     }\n \n", "fix_pattern": "<pattern>: if the QMimeDatabase api is called to retrieve mime type based on a URL, replace it with a more efficient method by directly calling the mimeType() function on the activeDoc, which avoids the overhead of creating a QMimeDatabase instance and redundant URL processing."}
{"number": 52, "change": "@@ -169,7 +169,7 @@ create_audio_src(KmsMixerSrc *self) {\n \tGstElement *adder, *tee, *queue, *fake;\n \tGstPad *pad;\n \n-\tadder = gst_element_factory_make(\"adder\", NULL);\n+\tadder = gst_element_factory_make(\"liveadder\", NULL);\n \ttee = gst_element_factory_make(\"tee\", NULL);\n \tqueue = gst_element_factory_make(\"queue2\", NULL);\n \tfake = gst_element_factory_make(\"fakesink\", NULL);\n", "fix_pattern": "<pattern>: if an element factory is creating an audio/video processing element, and a more optimized version of the element is available (like \"liveadder\" instead of \"adder\"), replace the factory call with the more efficient version for better performance."}
{"number": 53, "change": "@@ -264,9 +264,9 @@ MediaSet::unref (const std::string &sessionId, const uint64_t &mediaObjectRef)\n \n void MediaSet::releasePointer (MediaObjectImpl *mediaObject)\n {\n-  mutex.lock();\n+  Monitor monitor (mutex);\n+\n   objectsMap.erase (mediaObject->getId() );\n-  mutex.unlock();\n \n   threadPool.push ( [mediaObject] () {\n     GST_DEBUG (\"Destroying %s\", mediaObject->getIdStr().c_str() );\n", "fix_pattern": "<pattern>: if mutex.lock() and mutex.unlock() are called in a sequence with no other operations in between, replace them with a scoped lock object to automatically manage the locking and unlocking of the mutex, thereby improving code clarity and reducing the chance of deadlocks due to exceptions."}
{"number": 54, "change": "@@ -16,7 +16,7 @@\n #include <QKeyEvent>\n #include <QKeySequence>\n #include <QList>\n-#include <QRegExp>\n+#include <QRegularExpression>\n #include <QStandardPaths>\n #include <QString>\n #include <QStringList>\n@@ -370,7 +370,7 @@ KeyboardMacrosPluginCommands::KeyboardMacrosPluginCommands(KeyboardMacrosPlugin\n \n bool KeyboardMacrosPluginCommands::exec(KTextEditor::View *view, const QString &cmd, QString &msg, const KTextEditor::Range &)\n {\n-    QStringList actionAndName = cmd.split(QRegExp(QStringLiteral(\"\\\\s+\")));\n+    QStringList actionAndName = cmd.split(QRegularExpression(QStringLiteral(\"\\\\s+\")));\n     if (actionAndName.length() != 2) {\n         msg = i18n(\"Usage: %1 <name>.\", actionAndName.at(0));\n         return false;\n", "fix_pattern": "<pattern>: if using QRegExp for regular expression operations, replace it with QRegularExpression for better performance and support for Unicode properties."}
{"number": 56, "change": "@@ -503,7 +503,6 @@ DialogProxy::WindowType DialogProxy::type() const\n \n void DialogProxy::focusInEvent(QFocusEvent *ev)\n {\n-    requestActivate();\n     QQuickWindow::focusInEvent(ev);\n }\n \n", "fix_pattern": "<pattern>: if a method is called (like requestActivate) that might be expensive or have side effects, evaluate whether it can be eliminated altogether for performance, especially if it has no effect in the current logic or context where it is used."}
{"number": 57, "change": "@@ -32,7 +32,7 @@\n #include <KDesktopFile>\n #include <QDir>\n #include <QFile>\n-#include <QDBusInterface>\n+#include <QDBusConnection>\n #include <QDBusPendingCall>\n \n namespace Plasma\n@@ -160,8 +160,9 @@ void PackageStructurePrivate::installPathChanged(const QString &path)\n             }\n         }\n     }\n-    QDBusInterface sycoca(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"));\n-    sycoca.asyncCall(QStringLiteral(\"recreate\"));\n+    const auto call = QDBusMessage::createMethodCall(QStringLiteral(\"org.kde.kded5\"), QStringLiteral(\"/kbuildsycoca\"),\n+        QStringLiteral(\"org.kde.kbuildsycoca\"), QStringLiteral(\"recreate\"));\n+    QDBusConnection::sessionBus().asyncCall(call);\n }\n \n \n", "fix_pattern": "<pattern>: if a QDBusInterface is constructed to make an asynchronous call, replace it with a direct call using QDBusMessage and QDBusConnection to avoid the overhead of constructing QDBusInterface, which is unnecessary for simple method calls."}
{"number": 59, "change": "@@ -537,9 +537,8 @@ void ViewManager::createView(Session* session, ViewContainer* container, int ind\n     // notify this view manager when the session finishes so that its view\n     // can be deleted\n     //\n-    // TODO - Find a more efficient a way to avoid multiple connections\n-    disconnect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n-    connect(session , SIGNAL(finished()) , this , SLOT(sessionFinished()));\n+    // Use Qt::UniqueConnection to avoid duplicate connection\n+    connect(session, SIGNAL(finished()), this, SLOT(sessionFinished()), Qt::UniqueConnection);\n \n     TerminalDisplay* display = createTerminalDisplay(session);\n     const Profile::Ptr profile = SessionManager::instance()->sessionProfile(session);\n", "fix_pattern": "<pattern>: if multiple connections are made to the same signal and slot pair, utilize Qt::UniqueConnection in the connect call to prevent duplicate connections and improve performance."}
{"number": 60, "change": "@@ -436,11 +436,9 @@ void ProfileManager::saveDefaultProfile()\n         path = writer.getPath(_defaultProfile);\n     }\n \n-    QFileInfo fileInfo(path);\n-\n     KSharedConfigPtr appConfig = KSharedConfig::openConfig();\n     KConfigGroup group = appConfig->group(\"Desktop Entry\");\n-    group.writeEntry(\"DefaultProfile\", fileInfo.fileName());\n+    group.writeEntry(\"DefaultProfile\", QUrl::fromLocalFile(path).fileName());\n }\n \n void ProfileManager::loadShortcuts()\n", "fix_pattern": "<pattern>: if creating a QFileInfo object just to obtain a file name from a path, replace it with QUrl::fromLocalFile(path).fileName() to avoid the overhead of instantiating QFileInfo."}
{"number": 61, "change": "@@ -238,9 +238,10 @@ void View::positionOnScreen()\n     // in wayland, QScreen::availableGeometry() returns QScreen::geometry()\n     // we could get a better value from plasmashell\n     // BUG: 386114\n-    QDBusInterface strutManager(\"org.kde.plasmashell\", \"/StrutManager\", \"org.kde.PlasmaShell.StrutManager\");\n-    QDBusPendingCall async = strutManager.asyncCall(\"availableScreenRect\", shownOnScreen->name());\n-    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(async, this);\n+    auto message = QDBusMessage::createMethodCall(\"org.kde.plasmashell\", \"/StrutManager\",  \"org.kde.PlasmaShell.StrutManager\", \"availableScreenRect\");\n+    message.setArguments({shownOnScreen->name()});\n+    QDBusPendingCall call = QDBusConnection::sessionBus().asyncCall(message);\n+    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(call, this);\n \n     QObject::connect(watcher, &QDBusPendingCallWatcher::finished, this, [this, watcher, shownOnScreen]() {\n         watcher->deleteLater();\n", "fix_pattern": "<pattern>: if a QDBusInterface is constructed to make a call, replace it with a direct QDBusMessage construction and send it using QDBusConnection's asyncCall method to optimize the method call overhead and improve performance."}
{"number": 62, "change": "@@ -65,9 +65,8 @@ int main(int argc, char **argv)\n                     // that makes the operation much heavier than it needs to be\n                     isWallpaper = true;\n                 } else {\n-                    if (QFileInfo(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile)).exists()\n-                    || QFileInfo(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile)).exists()\n-                    ) {\n+                    if (QFileInfo::exists(QStringLiteral(\"%1/metadata.desktop\").arg(wallpaperFile))\n+                        || QFileInfo::exists(QStringLiteral(\"%1/metadata.json\").arg(wallpaperFile))) {\n                         isWallpaper = true;\n                         isKPackage = true;\n                         // Similarly to above, we could read all the information out of the kpackage, but\n", "fix_pattern": "<pattern>: if the QFileInfo constructor is used just to check for file existence, replace it with the QFileInfo::exists static method to improve performance by avoiding unnecessary object creation."}
{"number": 63, "change": "@@ -285,7 +285,12 @@ int main(int argc, char **argv) {\n \n    nsizes.resize(numpe);\n    ndispl.resize(numpe);\n-   MPI_Allgather(&ncells, 1, MPI_INT, &nsizes[0], 1, MPI_INT, MPI_COMM_WORLD);\n+\n+   for (int ip=0; ip<numpe; ip++){\n+      nsizes[ip] = ncells_global/numpe;\n+      if (ip < ncells_global%numpe) nsizes[ip]++;\n+   }\n+\n    ndispl[0]=0;\n    for (int ip=1; ip<numpe; ip++){\n       ndispl[ip] = ndispl[ip-1] + nsizes[ip-1];\n@@ -295,6 +300,7 @@ int main(int argc, char **argv) {\n      noffset += nsizes[ip];\n    }\n \n+\n    size_t corners_size = corners_i_global.size();\n \n    dev_corners_i_global  = ezcl_malloc(&corners_i_global[0],  &corners_size, sizeof(cl_int),  CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, 0);\n", "fix_pattern": "<pattern>: if an MPI_Allgather call is replaced with a manual distribution of values across processes (given the specific case of equal distribution), then rewrite the code to handle the data sharing without the all-to-all gather, optimizing for fewer communications when the data distribution is straightforward."}
{"number": 64, "change": "@@ -123,7 +123,9 @@ void fill_curl_eh(CURL *eh, C_Element *cube, bool isOverlay, FtpElement *elem) {\n     curl_easy_setopt(eh, CURLOPT_WRITEFUNCTION, my_fwrite);\n     curl_easy_setopt(eh, CURLOPT_WRITEDATA, elem);\n     curl_easy_setopt(eh, CURLOPT_PRIVATE, elem);\n-    curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    //curl_easy_setopt(eh, CURLOPT_TIMEOUT, 10);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_LIMIT, 1);\n+    curl_easy_setopt(eh, CURLOPT_LOW_SPEED_TIME, 10);\n     curl_easy_setopt(eh, CURLOPT_CONNECTTIMEOUT, 10);\n     curl_multi_add_handle(curlm, eh);\n }\n", "fix_pattern": "<pattern>: if a timeout option is set on a CURL handle, consider using low-speed options instead to avoid cancelling connections with low traffic that may still be valid, enhancing the performance of network operations."}
{"number": 65, "change": "@@ -117,13 +117,15 @@ GLuint load_program(const char *path1, const char *path2) {\n void flip_image_vertical(\n     unsigned char *data, unsigned int width, unsigned int height)\n {\n-    unsigned char new_data[width * height * 4];\n-    unsigned int stride = width * 4;\n+    unsigned int size = width * height * 4;\n+    unsigned int stride = sizeof(char) * width * 4;\n+    unsigned char *new_data = malloc(sizeof(char) * size);\n     for (unsigned int i = 0; i < height; i++) {\n         unsigned int j = height - i - 1;\n         memcpy(new_data + j * stride, data + i * stride, stride);\n     }\n-    memcpy(data, new_data, sizeof(new_data));\n+    memcpy(data, new_data, size);\n+    free(new_data);\n }\n \n void load_png_texture(const char *file_name) {\n", "fix_pattern": "<pattern>: if a stack-allocated array is created to hold data temporarily and immediately copied to another location, allocate memory using `malloc` to avoid potential stack size limits, and ensure the size is correctly calculated, followed by freeing the memory after use."}
{"number": 66, "change": "@@ -153,7 +153,7 @@ void FSIFixedPoint::eval( const vector_Type& _disp,\n \n \n \n-    MPI_Barrier(MPI_COMM_WORLD);\n+    M_epetraWorldComm->Barrier();\n \n     // possibly unsafe when using more cpus,\n     this->setLambdaFluid(_disp);\n@@ -219,7 +219,7 @@ void FSIFixedPoint::eval( const vector_Type& _disp,\n \n     }\n \n-    MPI_Barrier(MPI_COMM_WORLD);\n+    M_epetraWorldComm->Barrier();\n \n     if ( true && this->isFluid() )\n     {\n@@ -239,7 +239,7 @@ void FSIFixedPoint::eval( const vector_Type& _disp,\n     this->setSigmaFluid( sigmaFluidUnique );\n     this->setSigmaSolid( sigmaFluidUnique );\n \n-    MPI_Barrier(MPI_COMM_WORLD);\n+    M_epetraWorldComm->Barrier();\n \n \n     vector_Type lambdaSolidUnique   (this->lambdaSolid().map(),    Unique);\n@@ -258,7 +258,7 @@ void FSIFixedPoint::eval( const vector_Type& _disp,\n     this->setLambdaDotSolid( lambdaDotSolidUnique );\n     this->setSigmaSolid( sigmaSolidUnique );\n \n-    MPI_Barrier(MPI_COMM_WORLD);\n+    M_epetraWorldComm->Barrier();\n \n \n     // Some displays:\n", "fix_pattern": "<pattern>: if multiple calls to MPI_Barrier are detected in succession on the same communicator, replace them with equivalent calls to a more optimized barrier function from a higher-level library, such as Epetra's Barrier method, to potentially improve performance and reduce overhead."}
{"number": 67, "change": "@@ -1276,14 +1276,7 @@ FileDescriptor V4L2VideoDevice::exportDmabufFd(unsigned int index,\n \t\treturn FileDescriptor();\n \t}\n \n-\tFileDescriptor fd(expbuf.fd);\n-\t/*\n-\t * FileDescriptor takes a duplicate of fd, so we must close the\n-\t * original here, otherwise it will be left dangling.\n-\t */\n-\t::close(expbuf.fd);\n-\n-\treturn fd;\n+\treturn FileDescriptor(std::move(expbuf.fd));\n }\n \n /**\n", "fix_pattern": "<pattern>: if a duplicate of a file descriptor is created and the original is closed immediately after, use std::move to transfer ownership of the file descriptor directly into the FileDescriptor constructor to eliminate the need for an intermediate variable and potential dangling reference."}
{"number": 70, "change": "@@ -1,12 +1,12 @@\n #include <stdlib.h>\n #include <stdio.h>\n-#include <string.h>\n+#include <sys/types.h>\n+#include <signal.h>\n \n int main(void)\n {\n   int i, pid;\n   FILE *fp;\n-  char str[32];\n \n   for(i = 0; i < 5; i++){\n     system(\"gmsh -pid fichier.msh fichier.pos > /tmp/gmsh.pid &\");\n@@ -18,7 +18,6 @@ int main(void)\n     fscanf(fp, \"%d\", &pid);\n     fclose(fp);\n \n-    sprintf(str, \"kill %d\", pid);\n-    system(str);\n+    kill(pid, 9);\n   }    \n } \n", "fix_pattern": "<pattern>: if a command to be executed via system() is constructed using sprintf, replace it with a direct call to kill() to eliminate unnecessary string handling and improve performance."}
{"number": 71, "change": "@@ -280,8 +280,12 @@ void linearSystemPETSc<scalar>::zeroMatrix()\n     }\n   }\n   if (_isAllocated && _entriesPreAllocated) {\n-    _try(MatAssemblyBegin(_a, MAT_FINAL_ASSEMBLY));\n-    _try(MatAssemblyEnd(_a, MAT_FINAL_ASSEMBLY));\n+    PetscBool assembled;\n+    _try(MatAssembled(_a, &assembled));\n+    if (!assembled) {\n+      _try(MatAssemblyBegin(_a, MAT_FINAL_ASSEMBLY));\n+      _try(MatAssemblyEnd(_a, MAT_FINAL_ASSEMBLY));\n+    }\n     _try(MatZeroEntries(_a));\n     _matrixModified = true;\n   }\n", "fix_pattern": "<pattern>: if the assembly of a matrix is attempted without checking if it has already been assembled, first use MatAssembled to check its status and avoid redundant assembly operations."}
{"number": 72, "change": "@@ -483,7 +483,7 @@ void CreateOutputFile(const std::string &fileName, int format,\n           glLoadMatrixd(modelview);\n         }\n         else{\n-          buffer.fill(CTX::instance()->batch);\n+          drawContext::global()->drawCurrentOpenglWindow(true);\n         }\n         res = gl2psEndPage();\n       }\n@@ -513,10 +513,9 @@ void CreateOutputFile(const std::string &fileName, int format,\n         gl2psBeginPage(base.c_str(), \"Gmsh\", viewport,\n                        GL2PS_TEX, GL2PS_NO_SORT, GL2PS_NONE, GL_RGBA, 0, NULL,\n                        0, 0, 0, buffsize, fp, base.c_str());\n-        PixelBuffer buffer(width, height, GL_RGB, GL_UNSIGNED_BYTE);\n         int oldtext = CTX::instance()->print.text;\n         CTX::instance()->print.text = 1;\n-        buffer.fill(CTX::instance()->batch);\n+        drawContext::global()->drawCurrentOpenglWindow(true);\n         CTX::instance()->print.text = oldtext;\n         res = gl2psEndPage();\n       }\n", "fix_pattern": "<pattern>: if a buffer is filled but immediately after the drawing operation is executed, remove the unnecessary buffer fill and directly call the drawing method to enhance performance."}
{"number": 73, "change": "@@ -88,8 +88,7 @@ AudioEncoder::EncodedInfo AudioEncoderCopyRed::EncodeInternal(\n       DCHECK_EQ(info.redundant.size(), 2u);\n     }\n     // Save primary to secondary.\n-    secondary_encoded_.SetSize(info.encoded_bytes);\n-    memcpy(secondary_encoded_.data(), encoded, info.encoded_bytes);\n+    secondary_encoded_.SetData(encoded, info.encoded_bytes);\n     secondary_info_ = info;\n     DCHECK_EQ(info.speech, info.redundant[0].speech);\n   }\n", "fix_pattern": "<pattern>: if memory is manually copied using memcpy after resizing a buffer, replace it with a more efficient API such as SetData that handles both setting the size and copying the data in a single method call."}
{"number": 74, "change": "@@ -88,7 +88,7 @@ DWORD GetThreadStartAddress(HANDLE processHandle, HANDLE hThread) {\n \n \tMODULEINFO mi;\n \n-\tGetModuleInformation(processHandle, LoadLibrary(\"kernel32.dll\"), &mi, sizeof(mi));\n+\tGetModuleInformation(processHandle, GetModuleHandle(\"kernel32.dll\"), &mi, sizeof(mi));\n \tstacktop = (DWORD)GetThreadStackTopAddress_x86(processHandle, hThread);\n \n \t/* The stub below has the same result as calling GetThreadStackTopAddress_x86() \n", "fix_pattern": "<pattern>: if an API call to LoadLibrary is being used to retrieve a module handle for a DLL that is already loaded, replace it with GetModuleHandle to avoid the overhead of loading the library again."}
{"number": 76, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified and additional attributes are set, refactor by using the existing descriptor directly to avoid unnecessary parameters and streamline the code for better clarity and potential performance improvements."}
{"number": 77, "change": "@@ -508,8 +508,10 @@ _gjs_context_enqueue_job(GjsContext      *gjs_context,\n     if (!gjs_context->job_queue->append(job))\n         return false;\n     if (!gjs_context->idle_drain_handler)\n+        /*Modified for CJS, Promises shouldn't take 200ms to resolve. When several\n+        promises are queued up, this artifically inflates resolve time. */\n         gjs_context->idle_drain_handler =\n-            g_idle_add(drain_job_queue_idle_handler, gjs_context);\n+            g_idle_add_full(0, drain_job_queue_idle_handler, gjs_context, NULL);\n \n     return true;\n }\n", "fix_pattern": "<pattern>: when dealing with the addition of idle handlers that may introduce latency due to queuing, replace g_idle_add with g_idle_add_full to minimize artificial inflation of resolve times, particularly when multiple callbacks may be queued."}
{"number": 78, "change": "@@ -484,8 +484,7 @@ IniFile::TildeExpansion(const char *file, char *path)\n \n     /* Buffer overflow has already been checked. */\n \n-    strcpy(path, home);\n-    strcat(path, file + 1);\n+    snprintf(path, LINELEN, \"%s%s\", home, file + 1);\n     return;\n }\n \n", "fix_pattern": "<pattern>: if multiple string manipulations are performed with strcpy and strcat, replace with snprintf for a single operation that combines both operations into one, improving performance and reducing buffer overflow risks."}
{"number": 79, "change": "@@ -364,7 +364,7 @@ UsdObject::HasAuthoredDocumentation() const\n SdfSpecType\n UsdObject::_GetDefiningSpecType() const\n {\n-    return GetStage()->_GetDefiningSpecType(GetPrim(), _propName);\n+    return _GetStage()->_GetDefiningSpecType(GetPrim(), _propName);\n }\n \n std::string\n", "fix_pattern": "<pattern>: if a method is called to get the stage instance, and it follows an instance method call to reach the same stage, replace the direct call with the alternate method to potentially reduce overhead, assuming it optimizes access to the instance."}
{"number": 81, "change": "@@ -710,7 +710,12 @@ UsdImagingPrimAdapter::_ComputeAndMergePrimvar(\n \n     VtValue v;\n     TfToken primvarName = primvar.GetPrimvarName();\n-    if (primvar.ComputeFlattened(&v, time)) {\n+\n+    // Note: we call Get() here to check if the primvar exists.\n+    // We can't call HasValue(), since it won't take time-varying\n+    // blocks (from value clips) into account. Get() should be\n+    // fast as long as we don't touch the returned data.\n+    if (primvar.Get(&v, time)) {\n         HdInterpolation interp = interpOverride ? *interpOverride\n             : _UsdToHdInterpolation(primvar.GetInterpolation());\n         TfToken role = _UsdToHdRole(primvar.GetAttr().GetRoleName());\n", "fix_pattern": "<pattern>: if a performance-critical API method (like processing time-varying data) is present, replace a potentially heavier computation method (like ComputeFlattened) with a lighter existence check method (Get) that avoids unnecessary data processing."}
{"number": 84, "change": "@@ -321,7 +321,7 @@ bool romLoaded(Logger* logger, System system, const std::string& path, void* rom\n   case System::kAtariLynx:\n     rom = util::loadFile(logger, path, &size);\n \n-    if (!strcmp(\"LYNX\", (char *)rom))\n+    if (!memcmp(\"LYNX\", (void *)rom, 5))\n     {\n         RA_OnLoadNewRom((BYTE*)rom + 0x0040, size - 0x0040);\n     }\n", "fix_pattern": "<pattern>: if a string comparison is made using strcmp for a fixed-length comparison, replace it with memcmp to improve performance by comparing raw memory directly."}
{"number": 85, "change": "@@ -80,9 +80,9 @@ struct ENGINE_API FEdGraphSchemaAction\n \tUPROPERTY()\n \tint32 SectionID;\n \n-\t/** Search title for the action */\n+\t/** Search title for the action (doesn't have to be set when instantiated, will be constructed by GetSearchTitle() if left empty)*/\n \tUPROPERTY()\n-\tFText SearchTitle;\n+\tFText CachedSearchTitle;\n \n \tFEdGraphSchemaAction() \n \t\t: Grouping(0)\n@@ -125,17 +125,17 @@ struct ENGINE_API FEdGraphSchemaAction\n \t/** Retrieves the full searchable title for this action */\n \tFText GetSearchTitle()\n \t{\n-\t\tif(SearchTitle.IsEmpty())\n+\t\tif(CachedSearchTitle.IsEmpty())\n \t\t{\n \t\t\tif(const FString* SourceString = FTextInspector::GetSourceString(MenuDescription))\n \t\t\t{\n \t\t\t\tFFormatNamedArguments Args;\n \t\t\t\tArgs.Add(TEXT(\"LocalizedTitle\"), MenuDescription);\n \t\t\t\tArgs.Add(TEXT(\"SourceTitle\"), FText::FromString(*SourceString));\n-\t\t\t\tSearchTitle = FText::Format(FText::FromString(\"{LocalizedTitle} {SourceTitle}\"), Args);\n+\t\t\t\tCachedSearchTitle = FText::Format(FText::FromString(\"{LocalizedTitle} {SourceTitle}\"), Args);\n \t\t\t}\n \t\t}\n-\t\treturn SearchTitle;\n+\t\treturn CachedSearchTitle;\n \t}\n \n \t// GC.\n", "fix_pattern": "<pattern>: if an instance of FText is used to store a search title and checked for emptiness, refactor the instance to be a cached variable to improve performance by avoiding unnecessary object creation and potentially leveraging cached results."}
{"number": 86, "change": "@@ -101,8 +101,7 @@ void AActor::PostNetReceiveLocationAndRotation()\n {\n \tif( RootComponent && RootComponent->IsRegistered() && (ReplicatedMovement.Location != GetActorLocation() || ReplicatedMovement.Rotation != GetActorRotation()) )\n \t{\n-\t\tTeleportTo(ReplicatedMovement.Location, ReplicatedMovement.Rotation, false, true);\n-\t\t//SetActorLocationAndRotation(ReplicatedMovement.Location, ReplicatedMovement.Rotation); <-- preferred for performance, but existing overrides of TeleportTo() will be affected.\n+\t\tSetActorLocationAndRotation(ReplicatedMovement.Location, ReplicatedMovement.Rotation, /*bSweep=*/ false);\n \t}\n }\n \n", "fix_pattern": "<pattern>: if an API method such as TeleportTo() is used, which incurs overhead due to potential collision adjustments, replace it with a more performant alternative like SetActorLocationAndRotation() when collision adjustments are not necessary."}
{"number": 87, "change": "@@ -990,8 +990,7 @@ void APawn::PostNetReceiveLocationAndRotation()\n \t\tReplicatedMovement.Location.Z += 0.01f;\n \n \t\tconst FVector OldLocation = GetActorLocation();\n-\t\tTeleportTo( ReplicatedMovement.Location, ReplicatedMovement.Rotation, false, true );\n-\t\t// SetActorLocationAndRotation(ReplicatedMovement.Location, ReplicatedMovement.Rotation); <-- preferred, but awaiting answer to question about UpdateNavOctree() missing in SceneComponent::MoveComponent\n+\t\tSetActorLocationAndRotation(ReplicatedMovement.Location, ReplicatedMovement.Rotation, /*bSweep=*/ false);\n \n \t\tINetworkPredictionInterface* PredictionInterface = Cast<INetworkPredictionInterface>(GetMovementComponent());\n \t\tif (PredictionInterface)\n", "fix_pattern": "<pattern>: if a call to TeleportTo is replaced with SetActorLocationAndRotation, prefer the latter for position updates, as it performs necessary scene management and optimizations that are essential for game performance in Unreal Engine."}
{"number": 88, "change": "@@ -1455,7 +1455,7 @@ void UTexture::BeginCacheForCookedPlatformData( const ITargetPlatform *TargetPla\n \t\tfor (int32 SettingsIndex = 0; SettingsIndex < BuildSettingsToCache.Num(); ++SettingsIndex)\n \t\t{\n \t\t\tFString DerivedDataKey;\n-\t\t\tGetTextureDerivedDataKeySuffix(*this, BuildSettingsToCache[SettingsIndex], DerivedDataKey);\n+\t\t\tGetTextureDerivedDataKey(*this, BuildSettingsToCache[SettingsIndex], DerivedDataKey);\n \n \t\t\tFTexturePlatformData *PlatformData = CookedPlatformData.FindRef( DerivedDataKey );\n \n", "fix_pattern": "<pattern>: if the API method GetTextureDerivedDataKeySuffix is being used for retrieving a derived data key that can be obtained more efficiently through GetTextureDerivedDataKey, replace the older call with the more performant one to reduce redundant computation or unnecessary complexity in the data fetching logic."}
{"number": 89, "change": "@@ -1454,7 +1454,7 @@ void UTexture::BeginCacheForCookedPlatformData( const ITargetPlatform *TargetPla\n \t\tfor (int32 SettingsIndex = 0; SettingsIndex < BuildSettingsToCache.Num(); ++SettingsIndex)\n \t\t{\n \t\t\tFString DerivedDataKey;\n-\t\t\tGetTextureDerivedDataKeySuffix(*this, BuildSettingsToCache[SettingsIndex], DerivedDataKey);\n+\t\t\tGetTextureDerivedDataKey(*this, BuildSettingsToCache[SettingsIndex], DerivedDataKey);\n \n \t\t\tFTexturePlatformData *PlatformData = CookedPlatformData.FindRef( DerivedDataKey );\n \n", "fix_pattern": "<pattern>: if an API method that retrieves a derived data key suffix is replaced with a more efficient method that retrieves a derived data key directly, check if there is a possibility of reduced overhead by transitioning from a suffix-specific to a key-specific method, thereby improving data retrieval performance."}
{"number": 94, "change": "@@ -160,6 +160,7 @@ void PackageKitBackend::acquireFetching(bool f)\n \n void PackageKitBackend::reloadPackageList()\n {\n+    qDebug() << \"xxx\";\n     acquireFetching(true);\n     if (m_refresher) {\n         disconnect(m_refresher.data(), &PackageKit::Transaction::finished, this, &PackageKitBackend::reloadPackageList);\n@@ -185,9 +186,9 @@ void PackageKitBackend::reloadPackageList()\n \n         const auto pkgNames = component.packageNames();\n         if (pkgNames.isEmpty()) {\n-            auto launchable = component.launchable(AppStream::Launchable::KindDesktopId);\n-            if (component.kind() == AppStream::Component::KindDesktopApp && !launchable.entries().isEmpty()) {\n-                const QString file = locateService(launchable.entries().constFirst());\n+            const auto entries = component.launchable(AppStream::Launchable::KindDesktopId).entries();\n+            if (component.kind() == AppStream::Component::KindDesktopApp && !entries.isEmpty()) {\n+                const QString file = locateService(entries.first());\n                 if (!file.isEmpty()) {\n                     acquireFetching(true);\n                     auto trans = PackageKit::Daemon::searchFiles(file);\n", "fix_pattern": "<pattern>: if an API method is called multiple times on the same object within a conditional statement, store the result in a variable to avoid redundant calls, which improves performance by reducing unnecessary computations."}
{"number": 95, "change": "@@ -573,7 +573,7 @@ void PreviewJob::slotResult(KJob *job)\n         const KIO::filesize_t size = (KIO::filesize_t)statResult.numberValue(KIO::UDSEntry::UDS_SIZE, 0);\n         const QUrl itemUrl = d->currentItem.item.mostLocalUrl();\n \n-        if (itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) {\n+        if ((itemUrl.isLocalFile() || KProtocolInfo::protocolClass(itemUrl.scheme()) == QLatin1String(\":local\")) && !d->currentItem.item.isSlow()) {\n             skipCurrentItem = !d->ignoreMaximumSize && size > d->maximumLocalSize && !d->currentItem.plugin.value(QStringLiteral(\"IgnoreMaximumSize\"), false);\n         } else {\n             // For remote items the \"IgnoreMaximumSize\" plugin property is not respected\n", "fix_pattern": "<pattern>: if a conditional checks for local file protocols through `isLocalFile()` or `protocolClass()`, enhance the conditional logic by adding an additional check for `isSlow()` to avoid unnecessary processing when dealing with slow items."}
{"number": 99, "change": "@@ -268,9 +268,7 @@ int main(int argc, char* argv[])\n \t\t\t}\n \n \t\t\tcout << endl;\n-\t\t\t\n-\t\t\tstrcpy(szNewPassword, newpassword);\n-\n+\t\t\tkc_strlcpy(szNewPassword, newpassword, sizeof(szNewPassword));\n \t\t\trepassword = get_password(\"Re-Enter password:\");\n \t\t\tif(strcmp(newpassword, repassword) != 0) {\n \t\t\t\tcerr << \"Passwords don't match\" << endl;\n", "fix_pattern": "<pattern>: if a string copy operation is performed using strcpy, replace it with kc_strlcpy to ensure safer copy operations that prevent buffer overflows."}
{"number": 102, "change": "@@ -387,7 +387,9 @@ void SystemDriver::UpdateVelocity(mfem::ParGridFunction &velocity, mfem::Vector\n             }\n #endif\n          } // End if vgrad_origin_flag\n-         const double* dmin_x = vgrad_origin.Read();\n+         Vector origin(space_dim, mfem::Device::GetMemoryType()); origin.UseDevice(true);\n+         MPI_Allreduce(vgrad_origin.HostRead(), origin.HostReadWrite(), space_dim, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n+         const double* dmin_x = origin.Read();\n          // We've now found our minimum points so we can now go and calculate everything.\n          MFEM_FORALL(i, nnodes, {\n             for (int ii = 0; ii < space_dim; ii++) {\n", "fix_pattern": "<pattern>: if the code is reading data from a source with potential performance implications (like `vgrad_origin.Read()`), switch to using MPI for parallel reduction (like `MPI_Allreduce`) and leverage device memory management with `Vector` to improve data handling efficiency."}
{"number": 103, "change": "@@ -128,7 +128,7 @@ void* PerFile_openandmap(const umt_optstruct_t* testops, uint64_t numbytes)\n   const int prot = PROT_READ|PROT_WRITE;\n \n   if ( testops->usemmap ) {\n-    region = mmap(NULL, handle->range_size, prot, MAP_PRIVATE | MAP_NORESERVE, handle->fd, 0);\n+    region = mmap(NULL, handle->range_size, prot, MAP_SHARED | MAP_NORESERVE, handle->fd, 0);\n     if (region == MAP_FAILED) {\n       ostringstream ss;\n       ss << \"mmap of \" << handle->range_size << \" bytes failed for \" << handle->filename << \": \";\n", "fix_pattern": "<pattern>: if the mmap API is used with MAP_PRIVATE, consider using MAP_SHARED instead when sharing memory is necessary, as it can lead to improved performance through reduced memory copy overhead and potential better caching behavior."}
{"number": 105, "change": "@@ -1026,7 +1026,10 @@ void CScintillaWnd::Center(sptr_t posStart, sptr_t posEnd)\n     Call(SCI_SETCURRENTPOS, testPos);\n     auto currentlineNumberDoc = Call(SCI_LINEFROMPOSITION, testPos);\n     auto currentlineNumberVis = Call(SCI_VISIBLEFROMDOCLINE, currentlineNumberDoc);\n-    Call(SCI_ENSUREVISIBLE, currentlineNumberDoc);    // make sure target line is unfolded\n+    // SCI_ENSUREVISIBLE resets the line-wrapping cache, so only\n+    // call that if it's really necessary.\n+    if (Call(SCI_GETLINEVISIBLE, currentlineNumberDoc) == 0)\n+        Call(SCI_ENSUREVISIBLE, currentlineNumberDoc);    // make sure target line is unfolded\n \n     auto firstVisibleLineVis =   Call(SCI_GETFIRSTVISIBLELINE);\n     auto linesVisible        =   Call(SCI_LINESONSCREEN) - 1; //-1 for the scrollbar\n", "fix_pattern": "<pattern>: if the API method SCI_ENSUREVISIBLE is called unconditionally, add a check using SCI_GETLINEVISIBLE to avoid unnecessary calls that reset the line-wrapping cache, thus improving performance by reducing redundant operations."}
{"number": 106, "change": "@@ -52,6 +52,8 @@ namespace {\n \n   // Using native file handles instead of file descriptors for reducing the resource consumption.\n \n+  const HANDLE InvalidFile = INVALID_HANDLE_VALUE;\n+\n   HANDLE openFile(const FileName &path, bool readOnly)\n   {\n     DWORD access = readOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);\n@@ -82,6 +84,8 @@ namespace {\n \n   // For non-Windows \n \n+  const FILE *InvalidFile = 0;\n+\n   struct FileNameHandle : public std::string\n   {\n     FileNameHandle(FileName name) : std::string(name) {}\n@@ -119,7 +123,7 @@ public:\n };\n \n FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openReadOnly) :\n-  file(0),\n+  file(InvalidFile),\n   name(fileName),\n   readOnly(true),\n   size(0)\n@@ -129,12 +133,12 @@ FileStream::FileStreamPrivate::FileStreamPrivate(FileName fileName, bool openRea\n   if(!openReadOnly)\n     file = openFile(name, false);\n \n-  if(file)\n+  if(file != InvalidFile)\n     readOnly = false;\n   else\n     file = openFile(name, true);\n \n-  if(!file) {\n+  if(file == InvalidFile) {\n     debug(\"Could not open file \" + String((const char *) name));\n   }\n }\n", "fix_pattern": "<pattern>: if a variable is being checked against a file handle, replace the direct comparison with a predefined constant (INVALID_HANDLE_VALUE) for better readability and potential optimization in checks against the invalid file state."}
{"number": 107, "change": "@@ -2343,7 +2343,7 @@ void dbookmarkswindow::slotBookmarkReceived(const QModelIndex &index)\n \n bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n {\n-  qint64 count = 0;\n+  bool exists = false;\n \n   {\n     QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\", \"bookmarks\");\n@@ -2358,9 +2358,9 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \tint temporary = dmisc::passphraseWasAuthenticated() ? 0 : 1;\n \n \tquery.setForwardOnly(true);\n-\tquery.prepare(\"SELECT COUNT(*) FROM bookmarks WHERE \"\n+\tquery.prepare(\"SELECT EXISTS(SELECT 1 FROM bookmarks WHERE \"\n \t\t      \"url_hash = ? AND \"\n-\t\t      \"temporary = ?\");\n+\t\t      \"temporary = ?)\");\n \tquery.bindValue\n \t  (0,\n \t   dmisc::hashedString(url.\n@@ -2371,14 +2371,14 @@ bool dbookmarkswindow::isBookmarked(const QUrl &url) const\n \n \tif(ok && query.exec())\n \t  if(query.next())\n-\t    count = query.value(0).toLongLong();\n+\t    exists = query.value(0).toBool();\n       }\n \n     db.close();\n   }\n \n   QSqlDatabase::removeDatabase(\"bookmarks\");\n-  return count > 0;\n+  return exists;\n }\n \n void dbookmarkswindow::slotRefresh(void)\n", "fix_pattern": "<pattern>: if a query is used to count rows in a SQL table, replace it with a query that checks for existence instead (e.g., using \"SELECT EXISTS(...)\") to improve performance by reducing the amount of data processed."}
{"number": 108, "change": "@@ -98,13 +98,8 @@ void Pool::joinAll()\n \n Pool::WorkerCountType Pool::getWorkQueueCount() const\n {\n-\tPool::WorkerCountType size = 0;\n-\t\n-\tenqueuedWorkMutex.lock();\n-\tsize = enqueuedWork.size();\n-\tenqueuedWorkMutex.unlock();\n-\t\n-\treturn size;\n+\tstd::lock_guard<std::mutex> l(enqueuedWorkMutex);\t\n+\treturn enqueuedWork.size();\n }\n \n Pool::WorkerCountType Pool::getActiveWorkerCount() const\n", "fix_pattern": "<pattern>: if manual locking and unlocking of a mutex is performed, use a std::lock_guard to manage the mutex automatically and ensure proper unlocking after the scope ends, improving code clarity and safety."}
{"number": 111, "change": "@@ -127,7 +127,7 @@ namespace TrenchBroom {\n                 return m_readBuffers->getImage();\n             }\n \n-            glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, m_framebufferId);\n+            glBindFramebuffer(GL_READ_FRAMEBUFFER, m_framebufferId);\n \n             glPixelStorei(GL_PACK_ALIGNMENT, 1);\n             glPixelStorei(GL_PACK_ROW_LENGTH, 0);\n", "fix_pattern": "<pattern>: if an OpenGL extension function like glBindFramebufferEXT is used, replace it with the core OpenGL function glBindFramebuffer for improved performance and compatibility, as it is more optimized and avoids potential overhead from extensions."}
{"number": 112, "change": "@@ -64,7 +64,7 @@ namespace TrenchBroom {\n         }\n \n         void BitmapButton::DoUpdateWindowUI(wxUpdateUIEvent& event) {\n-            if (event.GetSetEnabled() && IsEnabled() != event.GetEnabled()) {\n+            if (event.GetSetEnabled() && IsThisEnabled() != event.GetEnabled()) {\n                 Enable(event.GetEnabled());\n                 Refresh();\n             }\n", "fix_pattern": "<pattern>: if an API method from a library (such as wxWidgets) is being replaced by a project-specific method that likely has a more optimized implementation (IsThisEnabled()), then switch to using the project-specific method for better performance and to avoid the overhead associated with the library method."}
{"number": 116, "change": "@@ -480,8 +480,7 @@ void ImportanceUpdatingAgent::updateAttentionalFocusSizes(AtomSpace* a)\n     HandleSeq inFocus;\n \n     AttentionValue::sti_t threshold = a->getAttentionalFocusBoundary() + amnesty;\n-    AtomSpace::STIAboveThreshold stiAbove(threshold);\n-    a->getHandleSetFiltered(back_inserter(inFocus), ATOM, true, &stiAbove);\n+    a->getHandlesByAV(back_inserter(inFocus), threshold);\n \n     attentionalFocusSize.update(inFocus.size());\n \n", "fix_pattern": "<pattern>: if a filtered handle set is retrieved using a costly filter object (in this case, `stiAbove`), replace it with a more direct method call that optimizes the query (using `getHandlesByAV` directly) to improve performance by reducing overhead."}
{"number": 117, "change": "@@ -47,7 +47,7 @@ class connection : public sdbusplus::bus::bus\n   public:\n     // default to system bus\n     connection(boost::asio::io_service& io) :\n-        sdbusplus::bus::bus(sdbusplus::bus::new_system()), io_(io), socket(io_)\n+        sdbusplus::bus::bus(sdbusplus::bus::new_default()), io_(io), socket(io_)\n     {\n         socket.assign(get_fd());\n         read_wait();\n", "fix_pattern": "<pattern>: if an API method that creates a system bus is used (\"sdbusplus::bus::new_system\"), refactor to use the default bus instead (\"sdbusplus::bus::new_default\") for potentially better performance and resource utilization."}
{"number": 118, "change": "@@ -165,7 +165,7 @@ std::string PluginSerializer::SerializeToFile(const std::string& content_url,\n     return \"\";\n   }\n \n-  size_t num_written = fwrite(body.c_str(), 1, body.size(), file);\n+  size_t num_written = fwrite(body.data(), 1, body.size(), file);\n   fclose(file);\n   if (num_written != body.size()) {\n     LOG(ERROR) << \"Failed to WriteDataToFile for \" << string_path\n", "fix_pattern": "<pattern>: if a string's underlying data is accessed for writing (such as with fwrite), prefer to use body.data() instead of body.c_str() to avoid the potential overhead of constructing a null-terminated string when it's not necessary."}
{"number": 119, "change": "@@ -964,9 +964,10 @@ Value RunPrint(Scope* scope,\n \n   const BuildSettings::PrintCallback& cb =\n       scope->settings()->build_settings()->print_callback();\n-  if (cb.is_null())\n+  if (cb.is_null()) {\n     printf(\"%s\", output.c_str());\n-  else\n+    fflush(stdout);\n+  } else\n     cb.Run(output);\n \n   return Value();\n", "fix_pattern": "<pattern>: if fflush(stdout) is placed inside a condition where cb.is_null() is being checked, it indicates a performance improvement by ensuring that the output buffer is flushed only when cb is null, potentially preventing unnecessary calls to fflush in other scenarios."}
{"number": 120, "change": "@@ -240,7 +240,7 @@ HandleSet ForwardChainer::get_chaining_result()\n \n Source* ForwardChainer::select_source()\n {\n-\tstd::lock_guard<std::mutex> lock(_part_mutex);\n+\tstd::unique_lock<std::mutex> lock(_part_mutex);\n \n \tstd::vector<double> weights = _sources.get_weights();\n \n@@ -270,7 +270,7 @@ Source* ForwardChainer::select_source()\n \t\t\ture_logger().debug() << \"Reset all exhausted flags to retry them\";\n \t\t\t_sources.reset_exhausted();\n \t\t\t// Try again\n-\t\t\t// NEXT TODO: be careful of locks\n+\t\t\tlock.unlock();\n \t\t\treturn select_source();\n \t\t} else {\n \t\t\t_sources.exhausted = true;\n", "fix_pattern": "<pattern>: if a std::lock_guard is replaced with a std::unique_lock that is immediately unlocked, consider whether locking is necessary at all for the given scope; if there are no operations requiring protection, remove the lock entirely."}
{"number": 121, "change": "@@ -432,7 +432,7 @@ static bool create_crash_pipe(int xsave_size)\n \n     int rcvbuf;\n     socklen_t size = sizeof(rcvbuf);\n-    if (getsockopt(crashpipe[CrashPipeParent], SOL_SOCKET, SO_RCVBUF, &rcvbuf, &size) == 0) {\n+    if (getsockopt(crashpipe[CrashPipeParent], SOL_SOCKET, SO_SNDBUF, &rcvbuf, &size) == 0) {\n         if (rcvbuf >= xsave_size)\n             xsave_size = 0;\n     }\n", "fix_pattern": "<pattern>: if the get socket options function (getsockopt) is incorrectly called with SO_RCVBUF, ensure to validate that socket options are instead being fetched with the correct flag SO_SNDBUF to avoid potential performance issues related to incorrect buffer sizes."}
{"number": 125, "change": "@@ -486,7 +486,7 @@ void SubversionBackend::SvnLogIterator::run()\n \tint64_t start = 0;\n \twhile (start < m_head-1) {\n \t\tPDEBUG << \"Fetching log from \" << start << \" to \" << m_head << \" with window size \" << windowSize << endl;\n-\t\tsvn_error_t *err = svn_ra_get_log2(d->ra, path, start, m_head, windowSize, FALSE, FALSE /* otherwise, copy history will be ignored */, FALSE, props, &logReceiver, &baton, pool);\n+\t\tsvn_error_t *err = svn_ra_get_log2(d->ra, path, start, m_head, windowSize, FALSE, FALSE /* otherwise, copy history will be ignored */, FALSE, props, &logReceiver, &baton, subpool);\n \t\tif (err != NULL) {\n \t\t\tthrow PEX(SvnConnection::strerr(err));\n \t\t}\n", "fix_pattern": "<pattern>: if the pool argument for the SVN function svn_ra_get_log2 is changed from a general pool to a more specific subpool, it indicates an optimization approach to manage memory more efficiently by using a smaller, more granular memory pool for temporary allocations, potentially improving performance and reducing memory overhead."}
{"number": 126, "change": "@@ -585,8 +585,7 @@ Vfs::mmap2(void *start, size_t len, int prot, int flags, int fd, off_t page4k_of\n       if (flags & MAP_PRIVATE)\n \t{\n \t  DEBUG_LOG(debug_mmap, outstring(\"COW\\n\"););\n-          int err = ds->copy_in(anon_offset, fds, l4_trunc_page(offset),\n-                                l4_round_page(size));\n+          int err = ds->copy_in(anon_offset, fds, offset, size);\n           if (err < 0)\n             return err;\n \n", "fix_pattern": "<pattern>: if an API method is called with parameters that are the results of unnecessary function calls (like l4_trunc_page() and l4_round_page()), simplify the call by using the original values directly to reduce function call overhead and improve performance."}
{"number": 127, "change": "@@ -57,6 +57,7 @@\n #include \"gmxfio.h\"\n #include \"mpelogging.h\"\n #include \"groupcoord.h\"\n+#include \"gmx_sort.h\"\n \n \n /* Set the minimum weight for the determination of the slab centers */\n@@ -1997,7 +1998,7 @@ static void sort_collective_coordinates(\n         copy_rvec(rotg->x_ref[i], data[i].x_ref);\n     }\n     /* Sort the 'data' structure */\n-    qsort(data, rotg->nat, sizeof(sort_along_vec_t), projection_compare);\n+    gmx_qsort(data, rotg->nat, sizeof(sort_along_vec_t), projection_compare);\n     \n     /* Copy back the sorted values */\n     for (i=0; i<rotg->nat; i++)\n", "fix_pattern": "<pattern>: if qsort from the Standard C Library is used, switch to gmx_qsort from the GROMACS library to leverage optimized sorting performance specific to GROMACS data types."}
{"number": 128, "change": "@@ -37,7 +37,7 @@\n #endif\n \n #include <math.h>\n-#include <string.h>\n+#include \"string2.h\"\n #include \"typedefs.h\"\n #include \"macros.h\"\n #include \"copyrite.h\"\n@@ -157,7 +157,7 @@ int main (int argc,char *argv[])\n     iatoms->resinfo[resind] = atoms->resinfo[atoms->atom[index[i]].resind];\n     /* allocate some space for the rtp name and copy from name */\n     snew(iatoms->resinfo[resind].rtp,1);\n-    strcpy(iatoms->resinfo[resind].rtp, atoms->resinfo[resind].name);\n+    iatoms->resinfo[resind].rtp = gmx_strdup(atoms->resinfo[resind].name);\n \n     iatoms->nres = max(iatoms->nres, iatoms->atom[i].resind+1);\n   }\n", "fix_pattern": "<pattern>: if a direct string copy is performed using `strcpy`, replace it with a project-specific optimized function `gmx_strdup` that may handle memory allocation more efficiently and ensure the destination is properly handled."}
{"number": 131, "change": "@@ -126,8 +126,7 @@ TiffIFD* TiffIFD::parseDngPrivateData(TiffEntry *t) {\n   */\n   uint32 size = t->count;\n   const uchar8 *data = t->getData();\n-  string id((const char*)data);\n-  if (0 != id.compare(\"Adobe\"))\n+  if (0 != memcmp(data, \"Adobe\", 6))\n     ThrowTPE(\"Not Adobe Private data\");\n \n   data+=6;\n", "fix_pattern": "<pattern>: if a string comparison is needed and the length of the string is known, replace std::string::compare with memcmp for lower-level performance improvements, as memcmp is generally faster for fixed-length comparisons."}
{"number": 134, "change": "@@ -19,7 +19,9 @@\n  */\n #include <bitcoin/network/settings.hpp>\n \n+#include <algorithm>\n #include <limits>\n+#include <thread>\n #include <bitcoin/bitcoin.hpp>\n \n namespace libbitcoin {\n@@ -30,7 +32,7 @@ using namespace bc::message;\n \n // Common default values (no settings context).\n settings::settings()\n-  : threads(50),\n+  : threads(std::max(std::thread::hardware_concurrency(), 1u)),\n     protocol_maximum(version::level::maximum),\n     protocol_minimum(version::level::minimum),\n     services(version::service::none),\n", "fix_pattern": "<pattern>: if the number of threads is set to a fixed value, refactor the code to dynamically determine the maximum number of threads based on the system's hardware concurrency, ensuring better utilization of system resources."}
{"number": 136, "change": "@@ -48,7 +48,7 @@ namespace tp {\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlWriteCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &response.body);\n-\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); //10s timeout\n+\t\t\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L); //5s timeout\n \n \t\t\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, CurlHeadersCallback);\n \t\t\tcurl_easy_setopt(curl, CURLOPT_WRITEHEADER, &response.headers);\n", "fix_pattern": "<pattern>: if a timeout value is being configured for a CURL request, ensure to set a lower timeout value for better responsiveness and improved resource utilization; in this case, reducing from 10 seconds to 5 seconds."}
{"number": 137, "change": "@@ -229,11 +229,10 @@ ProgClient::run_program(const string &progname, const string &args\n     startupinfo.hStdInput = hClient;\n     startupinfo.dwFlags |= STARTF_USESTDHANDLES;\n \n-    // For some reason Windows wants a modifiable copy!\n-    BOOL ok;\n-    char * cmdline = strdup((progname + ' ' + args).c_str());\n-    ok = CreateProcess(0, cmdline, 0, 0, TRUE, 0, 0, 0, &startupinfo, &procinfo);\n-    free(cmdline);\n+    // For some reason Windows wants a modifiable command line!\n+    string cmdline = progname + ' ' + args;\n+    BOOL ok = CreateProcess(0, &cmdline[0], 0, 0, TRUE, 0, 0, 0,\n+\t\t\t    &startupinfo, &procinfo);\n     if (!ok) {\n \tthrow Xapian::NetworkError(\"CreateProcess failed\",\n \t\t\t\t   get_progcontext(progname, args),\n", "fix_pattern": "<pattern>: if a modifiable command line is required for CreateProcess, construct the command line as a std::string and use its internal buffer directly instead of creating a separate modifiable copy with strdup and then freeing it. This avoids unnecessary memory allocation and deallocation overhead."}
{"number": 138, "change": "@@ -1430,10 +1430,6 @@ GlassTable::readahead_key(const string &key) const\n     LOGCALL(DB, bool, \"GlassTable::readahead_key\", key);\n     Assert(!key.empty());\n \n-    // An overlong key cannot be found.\n-    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n-\tRETURN(false);\n-\n     // Three cases:\n     //\n     // handle == -1:  Lazy table in a multi-file database which isn't yet open.\n@@ -1450,6 +1446,10 @@ GlassTable::readahead_key(const string &key) const\n     if (level == 0)\n \tRETURN(false);\n \n+    // An overlong key cannot be found.\n+    if (key.size() > GLASS_BTREE_MAX_KEY_LEN)\n+\tRETURN(true);\n+\n     form_key(key);\n \n     // We'll only readahead the first level, since descending the B-tree would\n", "fix_pattern": "<pattern>: if the return value is used to indicate the success or failure of a key search operation in a B-tree, change the logic to return true for the case of an overlong key, as it indicates an immediate failure to locate a valid key that should be found within the defined limits."}
{"number": 139, "change": "@@ -1645,11 +1645,10 @@ wxMenu* MainFrame::CreateSubmenuComponents(PObjectPackage pkg)\n             auto* item = new wxMenuItem(submenu, wxID_ANY, info->GetClassName());\n \t\t\titem->SetBitmap(info->GetIconFile());\n \t\t\tsubmenu->Append(item);\n-\n-\t\t\tBind(wxEVT_MENU, &MainFrame::OnMenuComponentsClick, this, item->GetId());\n         }\n         j++;\n     }\n+\tsubmenu->Bind(wxEVT_MENU, &MainFrame::OnMenuComponentsClick, this);\n \n     return submenu;\n }\n", "fix_pattern": "<pattern>: when binding an event handler to a menu item, if the menu item ID is not necessary (as in the case of wxMenu where the source is sufficient), use the overload of the Bind function that omits the ID to improve performance by reducing unnecessary lookups."}
{"number": 141, "change": "@@ -705,8 +705,7 @@ double getTime() {\n \treturn (time - startTime) / 1e9;\n #endif\n #if defined ARCH_MAC\n-\t// Similar to mach_absolute_time() except it doesn't call the kernel every time.\n-\tint64_t counter = mach_approximate_time();\n+\tint64_t counter = mach_absolute_time();\n \treturn (counter - startCounter) * counterTime;\n #endif\n }\n", "fix_pattern": "<pattern>: if an approximate time function that avoids kernel calls (mach_approximate_time) is being used, replace it with the more precise function (mach_absolute_time) for better accuracy in timing operations, even if it incurs a performance cost in terms of system calls."}
{"number": 142, "change": "@@ -3000,15 +3000,14 @@ BOOL allocateName(char **ppStore, const char *pName)\n \t}\n \treturn TRUE;\n #else\n-\t//need to allocate space for the name\n-\t*ppStore = (char*)malloc((strlen(pName))+1);\n+\t// Allocate space for the name and copy it\n+\t*ppStore = strdup(pName);\n \tif (ppStore == NULL)\n \t{\n-\t\tdebug( LOG_ERROR, \"Name - Out of memory\" );\n+\t\tdebug(LOG_ERROR, \"allocateName: Out of memory\");\n \t\tabort();\n \t\treturn FALSE;\n \t}\n-\tstrcpy(*ppStore,pName);\n \n \treturn TRUE;\n #endif\n", "fix_pattern": "<pattern>: if memory is allocated for a string with malloc and then copied with strcpy, replace it with strdup for better performance and simplicity, as strdup handles both allocation and copying in one call."}
{"number": 143, "change": "@@ -406,7 +406,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \n \t// Now dump the data into the buffer\n \t// Copy a string\n-\tsstrcpy(buffer, game->name);\n+\tstrlcpy(buffer, game->name, sizeof(game->name));\n \tbuffer += sizeof(game->name);\n \n \t// Copy 32bit large big endian numbers\n@@ -416,7 +416,7 @@ static void NETsendGAMESTRUCT(TCPsocket socket, const GAMESTRUCT* game)\n \tbuffer += sizeof(int32_t);\n \n \t// Copy yet another string\n-\tsstrcpy(buffer, game->desc.host);\n+\tstrlcpy(buffer, game->desc.host, sizeof(game->desc.host));\n \tbuffer += sizeof(game->desc.host);\n \n \t// Copy 32bit large big endian numbers\n", "fix_pattern": "<pattern>: replace project-specific string copy operation (sstrcpy) with safer and size-aware string copy operation (strlcpy) to avoid buffer overflows and improve performance with potentially better memory management."}
{"number": 145, "change": "@@ -680,7 +680,7 @@ void socketFlush(Socket *sock)\n \t\tsock->zDeflate.next_out = (Bytef *)&sock->zDeflateOutBuf[alreadyHave];\n \t\tsock->zDeflate.avail_out = sock->zDeflateOutBuf.size() - alreadyHave;\n \n-\t\tint ret = deflate(&sock->zDeflate, Z_SYNC_FLUSH);\n+\t\tint ret = deflate(&sock->zDeflate, Z_PARTIAL_FLUSH);\n \t\tASSERT(ret != Z_STREAM_ERROR, \"zlib compression failed!\");\n \n \t\t// Remove unused part of buffer.\n", "fix_pattern": "<pattern>: when using the deflate API from the zlib library, if the application does not require the full output of the deflate operation, use Z_PARTIAL_FLUSH instead of Z_SYNC_FLUSH to potentially improve performance by allowing for more frequent output without waiting for the entire buffer to be filled."}
{"number": 146, "change": "@@ -473,7 +473,8 @@ struct TextShaper\n \t{\n \t\t/* Fribidi assumes that the text is encoded in UTF-32, so we have to\n \t\t   convert from UTF-8 to UTF-32, assuming that the string is indeed in UTF-8.*/\n-\t\tstd::u32string u32 = utf8::utf8to32(text);\n+\t\tstd::u32string u32;\n+\t\tutf8::unchecked::utf8to32(text.begin(), text.end(), std::back_inserter(u32));\n \n \t\t// Step 1: Initialize fribidi variables.\n \t\t// TODO: Don't forget to delete them at the end.\n@@ -877,6 +878,11 @@ static bool breaksWord(char const c)\n \treturn c == ASCII_SPACE || breaksLine(c);\n }\n \n+/* This funtion might not be fail-proof. It presumes that a \"char\" equals a \"character\" in any language.\n+   Since the game was translated into different other languages, an Arabic or Chinese \"character\"\n+   could occupy several bytes (that is, \"char\"s) in memory (assuming the string is in UTF-8). Therefore,\n+   expressions such as \"++curChar\" might not yield the next \"character\", but just a byte of its\n+   representation. */\n std::vector<TextLine> iV_FormatText(const char *String, UDWORD MaxWidth, UDWORD Justify, iV_fonts fontID, bool ignoreNewlines /*= false*/)\n {\n \tstd::vector<TextLine> lineDrawResults;\n", "fix_pattern": "<pattern>: if the conversion from UTF-8 to UTF-32 is done using a function that performs safety checks (like utf8::utf8to32), refactor the code to use a variant of the function that skips those checks (like utf8::unchecked::utf8to32) combined with std::back_inserter for better performance, while being cautious of handling multi-byte characters properly."}
{"number": 148, "change": "@@ -50,7 +50,7 @@ tlp::Color ChooseColorButton::tulipColor() const {\n \n void ChooseColorButton::setColor(const QColor& c) {\n   _color = c;\n-  repaint();\n+  update();\n   emit colorChanged(_color);\n   emit tulipColorChanged(QColorToColor(_color));\n }\n", "fix_pattern": "<pattern>: replace QWidget::repaint() with QWidget::update() to improve performance by avoiding unnecessary immediate repainting and instead queueing a repaint for later, which can reduce the frequency of redraw operations."}
{"number": 150, "change": "@@ -348,7 +348,7 @@ void QFileImpl::read(void* dataOut, const int64_t& count, int64_t* numRead)\n \n void QFileImpl::seek(const int64_t& position)\n {\n-    if (!m_file.seek(position)) throw DataFileException(\"seek failed in file '\" + m_fileName + \"'\");\n+    if (m_file.pos() != position && !m_file.seek(position)) throw DataFileException(\"seek failed in file '\" + m_fileName + \"'\");\n }\n \n int64_t QFileImpl::pos()\n", "fix_pattern": "<pattern>: if a seek operation is attempted when the current position is already the desired position, check the current position first using QFile::pos() to avoid unnecessary seek calls, thus improving performance."}
{"number": 153, "change": "@@ -94,12 +94,9 @@ void PythonEnvironment::Init()\n     // Workaround: try to import numpy and to launch numpy.finfo to cache data;\n     // this prevents a deadlock when calling numpy.finfo from a worker thread.\n     // ocarre: may crash on some configurations, we have to find a fix\n-    PyRun_SimpleString(\"\\\n-try:\\n\\\n-    import numpy\\n\\\n-    numpy.finfo(float)\\n\\\n-except:\\n\\\n-    pass\");\n+    PyRun_SimpleString(\"try:\\n\\timport numpy;numpy.finfo(float)\\nexcept:\\n\\tpass\");\n+    // Workaround: try to import scipy from the main thread this prevents a deadlock when importing scipy from a worker thread when we use the SofaScene asynchronous loading\n+    PyRun_SimpleString(\"try:\\n\\tfrom scipy import misc, optimize\\nexcept:\\n\\tpass\\n\");\n \n \n     // If the script directory is not available (e.g. if the interpreter is invoked interactively\n", "fix_pattern": "<pattern>: if there are multiple calls to PyRun_SimpleString executing Python code, consider combining related commands into a single call to reduce the overhead of context switching and potential performance penalties from repeated interpreter invocation."}
{"number": 154, "change": "@@ -116,7 +116,9 @@ CKernel* CMMDKernelSelection::select_kernel()\n \tSG_UNREF(combined);\n \tSG_DEBUG(\"leaving %s::select_kernel()\\n\", get_name());\n \n-\tSG_REF(current);\n+\t/* current is not SG_UNREF'ed nor SG_REF'ed since the counter needs to be\n+\t * incremented exactly by one */\n+\n \treturn current;\n }\n \n", "fix_pattern": "<pattern>: if a reference count is set via SG_REF, but the intention is to maintain the current count without additional reference incrementing, document this explicitly and avoid the overhead of unnecessary reference counting updates."}
{"number": 156, "change": "@@ -36,7 +36,9 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    strncpy(pchCommand, pszCommand, COMMAND_SIZE);\n+    int command_len = strlen(pszCommand);\n+    memcpy(pchCommand, pszCommand, command_len);\n+    memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n     nChecksum = 0;\n }\n", "fix_pattern": "<pattern>: if a string is copied using strncpy, replace it with memcpy followed by memset to ensure the destination is properly null-terminated while improving performance with direct memory operations."}
{"number": 157, "change": "@@ -36,7 +36,7 @@ CMessageHeader::CMessageHeader()\n CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n {\n     memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));\n-    int command_len = strlen(pszCommand);\n+    size_t command_len = strnlen(pszCommand, COMMAND_SIZE);\n     memcpy(pchCommand, pszCommand, command_len);\n     memset(pchCommand + command_len, 0, COMMAND_SIZE - command_len);\n     nMessageSize = nMessageSizeIn;\n", "fix_pattern": "<pattern>: if the code uses strlen to determine the length of a string, replace it with strnlen while providing a maximum length to avoid potential overflow issues and improve safety when the size of the string is limited."}
{"number": 158, "change": "@@ -96,7 +96,7 @@ ByteBuffer decode_base64(const StringView& input)\n String encode_base64(ReadonlyBytes input)\n {\n     constexpr auto alphabet = make_alphabet();\n-    StringBuilder output(calculate_base64_decoded_length(input));\n+    StringBuilder output(calculate_base64_encoded_length(input));\n \n     auto get = [&](const size_t offset, bool* need_padding = nullptr) -> u8 {\n         if (offset >= input.size()) {\n", "fix_pattern": "<pattern>: if the length of a buffer is calculated for decoding base64, ensure the method used is for encoding to match the context where the buffer will be used, thus improving performance by aligning with the correct operations for the intended output."}
{"number": 159, "change": "@@ -257,7 +257,7 @@ OwnPtr<PerformanceEventBuffer> PerformanceEventBuffer::try_create_with_size(size\n     auto buffer = KBuffer::try_create_with_size(buffer_size, Region::Access::Read | Region::Access::Write, \"Performance events\", AllocationStrategy::AllocateNow);\n     if (!buffer)\n         return {};\n-    return adopt_own(*new PerformanceEventBuffer(buffer.release_nonnull()));\n+    return adopt_own_if_nonnull(new PerformanceEventBuffer(buffer.release_nonnull()));\n }\n \n void PerformanceEventBuffer::add_process(const Process& process, ProcessEventType event_type)\n", "fix_pattern": "<pattern>: if an object is being constructed and then immediately passed to a function that takes ownership, use a conditional ownership acquisition method (like adopt_own_if_nonnull) when applicable to avoid potential null dereference issues and improve safety."}
{"number": 160, "change": "@@ -284,9 +284,7 @@ bool EventHandler::handle_mouseup(CSSPixelPoint position, CSSPixelPoint screen_p\n                     auto href = link->href();\n                     auto url = document->parse_url(href);\n                     dbgln(\"Web::EventHandler: Clicking on a link to {}\", url);\n-                    if (button == GUI::MouseButton::Primary) {\n-                        MUST(document->navigable()->navigate({ .url = url, .source_document = document }));\n-                    } else if (button == GUI::MouseButton::Middle) {\n+                    if (button == GUI::MouseButton::Middle) {\n                         if (auto* page = m_browsing_context->page())\n                             page->client().page_did_middle_click_link(url, link->target(), modifiers);\n                     } else if (button == GUI::MouseButton::Secondary) {\n", "fix_pattern": "<pattern>: if multiple mouse button checks are performed but only one action is executed based on the check, eliminate unnecessary conditional checks to reduce branch complexity and improve performance."}
{"number": 161, "change": "@@ -85,7 +85,6 @@ public:\n     }\n \n     void setReady(bool ready) {\n-        LOGD(\"ASYNC: set texture ready\");\n         this->ready = ready;\n     }\n \n", "fix_pattern": "<pattern>: if a logging function is not used and the log statement is removed, it indicates that logging overhead is eliminated for performance improvements."}
{"number": 162, "change": "@@ -1011,17 +1011,17 @@ static BOOLEAN jjTIMES_P(leftv res, leftv u, leftv v)\n   poly b;\n   if (v->next==NULL)\n   {\n-    a=(poly)u->CopyD(POLY_CMD); // works also for VECTOR_CMD\n+    a=(poly)u->Data(POLY_CMD); // works also for VECTOR_CMD\n     if (u->next==NULL)\n     {\n-      b=(poly)v->CopyD(POLY_CMD); // works also for VECTOR_CMD\n+      b=(poly)v->Data(POLY_CMD); // works also for VECTOR_CMD\n       if ((a!=NULL) && (b!=NULL)\n       && ((long)pTotaldegree(a)>si_max((long)rVar(currRing),(long)currRing->bitmask/2)-(long)pTotaldegree(b)))\n       {\n         Warn(\"possible OVERFLOW in mult(d=%ld, d=%ld, max=%ld)\",\n           pTotaldegree(a),pTotaldegree(b),currRing->bitmask/2);\n       }\n-      res->data = (char *)(pMult( a, b));\n+      res->data = (char *)(pp_Mult_qq( a, b, currRing));\n       pNormalize((poly)res->data);\n       return FALSE;\n     }\n", "fix_pattern": "<pattern>: if the API method `CopyD` is being used to retrieve data from an object and it seems to involve unnecessary copying of data, replace it with a call to `Data` which likely retrieves a reference to the data more efficiently. Additionally, if `pMult` is replaced by `pp_Mult_qq` that takes an additional parameter, it indicates an optimization by modifying the multiplication approach to potentially handle more context or reduce overhead."}
{"number": 163, "change": "@@ -379,11 +379,11 @@ KeyboardCommands()\n     \n     char* movie_fname = \"\";\n     // get the keyboard input\n+    #if SDL_VERSION_ATLEAST(1, 3, 0)\t \n+    g_keyState = SDL_GetKeyboardState(NULL);\t \n+    #else\n     g_keyState = SDL_GetKeyState(NULL);\n-    if (g_keyState[SDLK_BACKQUOTE])\n-        IncreaseEmulationSpeed();\n-    else\n-        DecreaseEmulationSpeed();\n+\t#endif\n \n     // check if the family keyboard is enabled\n     if(InputType[2] == SIFC_FKB) {\n", "fix_pattern": "<pattern>: if the code repeatedly checks the state of a specific key in SDL for every frame, refactor to call SDL_GetKeyboardState once per frame to retrieve the entire keyboard state and store it, rather than checking g_keyState directly, to improve performance by minimizing redundant lookups."}
{"number": 166, "change": "@@ -3911,6 +3911,7 @@ void call(client *c, int flags) {\n     /* Call the command. */\n     dirty = g_pserver->dirty;\n     incrementMvccTstamp();\n+    __atomic_load(&g_pserver->ustime, &start, __ATOMIC_SEQ_CST);\n     start = g_pserver->ustime;\n     try {\n         c->cmd->proc(c);\n@@ -3922,7 +3923,9 @@ void call(client *c, int flags) {\n         addReplyError(c, sz);\n     }\n     serverTL->commandsExecuted++;\n-    duration = ustime()-start;\n+    ustime_t end;\n+    __atomic_load(&g_pserver->ustime, &end, __ATOMIC_SEQ_CST);\n+    duration = end-start;\n     dirty = g_pserver->dirty-dirty;\n     if (dirty < 0) dirty = 0;\n \n", "fix_pattern": "<pattern>: if measuring time using a function that directly retrieves the current time (e.g., ustime()), replace it with atomic loads of a shared time variable for improved performance and thread safety."}
{"number": 167, "change": "@@ -228,7 +228,7 @@ inline void VPath::addPath(const VPath &path)\n {\n     if (path.empty()) return;\n \n-    if (empty()) {\n+    if (null()) {\n         *this = path;\n     } else {\n         d.write().addPath(path.d.read());\n", "fix_pattern": "<pattern>: if a call to an 'empty()' method is replaced with a 'null()' method, assess the change to ensure that 'null()' can potentially provide better performance or convey a more accurate state of the object, particularly if 'null()' is more optimized or directly indicates an absence of value as opposed to being empty."}
{"number": 168, "change": "@@ -1285,7 +1285,7 @@ void FMultiPatchTexture::ResolvePatches()\n \t\t{\n \t\t\tif (Parts[i].Texture == nullptr)\n \t\t\t{\n-\t\t\t\tmemcpy(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n+\t\t\t\tmemmove(&Parts[i], &Parts[i + 1], (NumParts - i - 1) * sizeof(TexPart));\n \t\t\t\ti--;\n \t\t\t\tNumParts--;\n \t\t\t}\n", "fix_pattern": "<pattern>: if a block of memory is being moved within the same array (i.e., source and destination overlap), replace memcpy with memmove to safely handle overlapping regions."}
{"number": 169, "change": "@@ -305,7 +305,10 @@ _ft_new_face (FT_Library lib,\n   }\n \n   /* not a dup, open and insert into list */\n-  if (FT_New_Face (lib, filename, 0, &tmpl.face)) {\n+  if (FT_New_Memory_Face (lib,\n+\t\t\t  (FT_Byte *) tmpl.bytes, tmpl.size,\n+\t\t\t  0, &tmpl.face))\n+  {\n #if defined(__SUNPRO_CC) && defined(__sun) && defined(__SVR4)\n     munmap ((char*)tmpl.bytes, tmpl.size);\n #else\n", "fix_pattern": "<pattern>: if a file is loaded using FT_New_Face with a filename, replace it with FT_New_Memory_Face using in-memory data for potentially faster access and to avoid file I/O overhead."}
{"number": 171, "change": "@@ -26,6 +26,8 @@\n #include <boost/asio/ip/host_name.hpp>\n #include <boost/asio/steady_timer.hpp>\n \n+#include <atomic>\n+\n using namespace eosio::chain::plugin_interface::compat;\n \n namespace fc {\n@@ -2026,7 +2028,9 @@ namespace eosio {\n          }\n          connection_wptr weak_conn = conn;\n \n-         std::size_t minimum_read = conn->outstanding_read_bytes != 0 ? conn->outstanding_read_bytes.load() : message_header_size;\n+         std::size_t minimum_read =\n+               std::atomic_exchange<decltype(conn->outstanding_read_bytes.load())>( &conn->outstanding_read_bytes, 0 );\n+         minimum_read = minimum_read != 0 ? minimum_read : message_header_size;\n \n          if (use_socket_read_watermark) {\n             const size_t max_socket_read_watermark = 4096;\n@@ -2093,7 +2097,6 @@ namespace eosio {\n                }\n \n                --conn->reads_in_flight;\n-               conn->outstanding_read_bytes = 0;\n                bool close_connection = false;\n \n                try {\n", "fix_pattern": "<pattern>: if an atomic variable is read and then reset or updated in a conditional way, utilize std::atomic_exchange() to atomically retrieve and reset the value, preventing potential race conditions and improving performance by reducing the need for separate operations."}
{"number": 173, "change": "@@ -43,9 +43,9 @@ inline void update(_T& _sha, _U const& _value)\n {\n \tint i = 0;\n \tfor (_U v = _value; v; ++i, v >>= 8) {}\n-\tbytes buf(i);\n-\ttoBigEndian(_value, buf);\n-\t_sha.Update(buf.data(), buf.size());\n+\tbyte buf[32];\n+\ttoBigEndian(_value, bytesRef(buf, i));\n+\t_sha.Update(buf, i);\n }\n \n template <class _T>\n", "fix_pattern": "<pattern>: if dynamic memory (e.g., using a vector or similar) is used for a small fixed-size buffer, replace it with a stack-allocated array for better performance and reduced memory overhead."}
{"number": 174, "change": "@@ -46,6 +46,7 @@\n  * Stride Prefetcher template instantiations.\n  */\n \n+#include \"base/random.hh\"\n #include \"debug/HWPrefetch.hh\"\n #include \"mem/cache/prefetch/stride.hh\"\n \n@@ -176,7 +177,7 @@ StridePrefetcher::pcTableVictim(Addr pc, int master_id)\n {\n     // Rand replacement for now\n     int set = pcHash(pc);\n-    int way = rand() % pcTableAssoc;\n+    int way = random_mt.random<int>(0, pcTableAssoc - 1);\n \n     DPRINTF(HWPrefetch, \"Victimizing lookup table[%d][%d].\\n\", set, way);\n     return &pcTable[master_id][set][way];\n", "fix_pattern": "<pattern>: if the code uses the standard `rand()` function for generating random numbers, replace it with a project-specific random number generator method for improved performance and potentially better randomness properties."}
{"number": 175, "change": "@@ -243,9 +243,9 @@ void CChannel::setUDPSockOpt()\n       if (-1 == ::fcntl(m_iSocket, F_SETFL, opts | O_NONBLOCK))\n          throw CUDTException(MJ_SETUP, MN_NORES, NET_ERROR);\n    #elif defined(_WIN32)\n-      DWORD ot = 1; //milliseconds\n-      if (0 != ::setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&ot, sizeof(DWORD)))\n-         throw CUDTException(MJ_SETUP, MN_NORES, NET_ERROR);\n+      u_long nonBlocking = 1;\n+      if (0 != ioctlsocket (m_iSocket, FIONBIO, &nonBlocking))\n+         throw CUDTException (MJ_SETUP, MN_NORES, NET_ERROR);\n    #else\n       // Set receiving time-out value\n       if (0 != ::setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(timeval)))\n", "fix_pattern": "<pattern>: if the code sets a receive timeout using `setsockopt`, which can be inefficient, replace it with `ioctlsocket` to set the socket to non-blocking mode for better responsiveness and performance."}
{"number": 176, "change": "@@ -240,9 +240,9 @@ struct MySemaphore\n    bool WaitSeconds(double inSeconds)\n    {\n       #ifdef HX_WINRT\n-      return WaitForSingleObjectEx(mSemaphore,inSeconds*0.001,false) != WAIT_TIMEOUT;\n+      return WaitForSingleObjectEx(mSemaphore,inSeconds*1000.0,false) != WAIT_TIMEOUT;\n       #else\n-      return WaitForSingleObject(mSemaphore,inSeconds*0.001) != WAIT_TIMEOUT;\n+      return WaitForSingleObject(mSemaphore,inSeconds*1000.0) != WAIT_TIMEOUT;\n       #endif\n    }\n    void Reset() { ResetEvent(mSemaphore); }\n", "fix_pattern": "<pattern>: when converting seconds to milliseconds for use with the Windows API's WaitForSingleObject and WaitForSingleObjectEx methods, ensure that the conversion from seconds to milliseconds is done correctly by multiplying by 1000 rather than 0.001."}
{"number": 178, "change": "@@ -1270,7 +1270,7 @@ void Com_Init( char *commandLine ) {\n \t\tcom_G2Report = Cvar_Get(\"com_G2Report\", \"0\", 0);\n #endif\n \n-\t\tcom_affinity = Cvar_Get( \"com_affinity\", \"1\", CVAR_ARCHIVE );\n+\t\tcom_affinity = Cvar_Get( \"com_affinity\", \"0\", CVAR_ARCHIVE );\n \n \t\tcom_bootlogo = Cvar_Get( \"com_bootlogo\", \"1\", CVAR_ARCHIVE);\n \n", "fix_pattern": "<pattern>: if the default value for a configuration variable is changed from \"1\" to \"0\", assess whether this change effectively optimizes initialization based on project requirements, as it might reduce overhead when initializing settings that are typically flagged as disabled by default."}
{"number": 179, "change": "@@ -4527,8 +4527,12 @@ void S_StartBackgroundTrack( const char *intro, const char *loop, qboolean bCall\n \t\tloop = intro;\n \t}\n \n-\tQ_strncpyz(gsIntroMusic,intro, sizeof(gsIntroMusic));\n-\tQ_strncpyz(gsLoopMusic, loop,  sizeof(gsLoopMusic));\n+\tif ( intro != gsIntroMusic ) {\n+\t\tQ_strncpyz( gsIntroMusic, intro, sizeof(gsIntroMusic) );\n+\t}\n+\tif ( loop != gsLoopMusic ) {\n+\t\tQ_strncpyz( gsLoopMusic, loop, sizeof(gsLoopMusic) );\n+\t}\n \n \tchar sNameIntro[MAX_QPATH];\n \tchar sNameLoop [MAX_QPATH];\n", "fix_pattern": "<pattern>: if the source string is the same as the destination string, avoid unnecessary copying by checking for equality before calling Q_strncpyz."}
{"number": 180, "change": "@@ -48,8 +48,8 @@ extern \"C\" JNIEXPORT void JNICALL Java_Main_waitUntilJitted(JNIEnv* env,\n     if (code_cache->ContainsPc(header->GetCode())) {\n       break;\n     } else {\n-      // yield to scheduler to give time to the JIT compiler.\n-      sched_yield();\n+      // Sleep to yield to the compiler thread.\n+      sleep(0);\n       // Will either ensure it's compiled or do the compilation itself.\n       jit->CompileMethod(method, Thread::Current(), /* osr */ false);\n     }\n", "fix_pattern": "<pattern>: if the original code uses `sched_yield()` to yield time to the JIT compiler, replace it with `sleep(0)` to achieve a similar effect with potentially better performance in terms of scheduling efficiency."}
{"number": 181, "change": "@@ -108,11 +108,8 @@ static LRESULT HandleCopyData(LPARAM lParam) {\n \tCOPYDATASTRUCT *pcds = reinterpret_cast<COPYDATASTRUCT *>(lParam);\n \t// Copy into an temporary buffer to ensure \\0 terminated\n \tif (pcds->lpData) {\n-\t\tchar *dataCopy = new char[pcds->cbData + 1];\n-\t\tstrncpy(dataCopy, static_cast<char *>(pcds->lpData), pcds->cbData);\n-\t\tdataCopy[pcds->cbData] = '\\0';\n-\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy);\n-\t\tdelete []dataCopy;\n+\t\tstd::string dataCopy(static_cast<char *>(pcds->lpData), pcds->cbData);\n+\t\tDirectorExtension::Instance().HandleStringMessage(dataCopy.c_str());\n \t}\n \treturn 0;\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation and manual string copy using strncpy is used, replace it with a std::string construction to avoid memory management overhead and ensure better safety and performance."}
{"number": 182, "change": "@@ -1490,16 +1490,13 @@ BOOL SciTEWin::TabSizeMessage(HWND hDlg, UINT message, WPARAM wParam) {\n \t\t\tint tabSize = wEditor.Call(SCI_GETTABWIDTH);\n \t\t\tif (tabSize > 99)\n \t\t\t\ttabSize = 99;\n-\t\t\tchar tmp[3];\n-\t\t\tsprintf(tmp, \"%d\", tabSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDTABSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDTABSIZE, tabSize, FALSE);\n \n \t\t\t::SendDlgItemMessage(hDlg, IDINDENTSIZE, EM_LIMITTEXT, 2, 1);\n \t\t\tint indentSize = wEditor.Call(SCI_GETINDENT);\n \t\t\tif (indentSize > 99)\n \t\t\t\tindentSize = 99;\n-\t\t\tsprintf(tmp, \"%d\", indentSize);\n-\t\t\t::SetDlgItemTextA(hDlg, IDINDENTSIZE, tmp);\n+\t\t\t::SetDlgItemInt(hDlg, IDINDENTSIZE, indentSize, FALSE);\n \n \t\t\t::CheckDlgButton(hDlg, IDUSETABS, wEditor.Call(SCI_GETUSETABS));\n \t\t\treturn TRUE;\n", "fix_pattern": "<pattern>: if there is a need to set an integer value to a dialog item using a string conversion via sprintf and then SetDlgItemTextA, replace it with a direct call to SetDlgItemInt for better performance, avoiding unnecessary string formatting."}
{"number": 183, "change": "@@ -14,6 +14,7 @@\n  * limitations under the License.\n  */\n \n+#define LOG_NDEBUG 1\n #define LOG_TAG \"szipinf\"\n #include <utils/Log.h>\n \n@@ -157,7 +158,7 @@ ssize_t StreamingZipInflater::read(void* outBuf, size_t count) {\n             */\n             int result = Z_OK;\n             if (mStreamNeedsInit) {\n-                LOGI(\"Initializing zlib to inflate\");\n+                LOGD(\"Initializing zlib to inflate\");\n                 result = inflateInit2(&mInflateState, -MAX_WBITS);\n                 mStreamNeedsInit = false;\n             }\n", "fix_pattern": "<pattern>: if a logging macro (LOGI) is used for informational messages, replace it with a debug-level logging macro (LOGD) when compiling with debug information disabled (LOG_NDEBUG is defined), which may indicate that the log level has been altered for performance optimization during runtime."}
{"number": 184, "change": "@@ -606,7 +606,7 @@ static void dumpstate(const std::string& screenshot_path, const std::string& ver\n     run_command(\"LIBRANK\", 10, SU_PATH, \"root\", \"librank\", NULL);\n \n     run_command(\"PRINTENV\", 10, \"printenv\", NULL);\n-    run_command(\"NETSTAT\", 10, \"netstat\", NULL);\n+    run_command(\"NETSTAT\", 10, \"netstat\", \"-n\", NULL);\n     run_command(\"LSMOD\", 10, \"lsmod\", NULL);\n \n     do_dmesg();\n", "fix_pattern": "<pattern>: if an API call to run_command does not specify additional arguments for a command that benefits from reduced output (such as making netstat display IP addresses instead of hostnames), include relevant options to improve performance and reduce unnecessary processing time. In this case, adding the \"-n\" flag to the netstat command improves execution speed by avoiding DNS lookups."}
{"number": 188, "change": "@@ -173,7 +173,7 @@ END_EVENT_TABLE()\n //WX_DEFINE_ARRAY()\n \n MainFrame::MainFrame(wxWindow* parent, Panorama & pano)\n-    : pano(pano), m_doRestoreLayout(false), m_help(0)\n+    : pano(pano), m_doRestoreLayout(false), m_help(0), cp_frame(0)\n {\n     m_progressMax = 1;\n     m_progress = 0;\n@@ -301,9 +301,6 @@ MainFrame::MainFrame(wxWindow* parent, Panorama & pano)\n \n     preview_frame = new PreviewFrame(this, pano);\n \n-    cp_frame = new CPListFrame(this, pano);\n-\n-\n     // set the minimize icon\n #ifdef __WXMSW__\n     wxIcon myIcon(GetXRCPath() + wxT(\"data/icon.ico\"),wxBITMAP_TYPE_ICO);\n", "fix_pattern": "<pattern>: if a member variable for a pointer (like cp_frame) is being initialized in a constructor's member initializer list to 'new', replace it with direct member initialization to null (0) to avoid unnecessary dynamic allocation when the instance is being constructed."}
{"number": 190, "change": "@@ -1,3 +1,5 @@\n+#define OPENSSL_SUPPRESS_DEPRECATED\n+\n #include <psibase/crypto.hpp>\n \n #include <openssl/sha.h>\n@@ -126,8 +128,11 @@ namespace psibase\n    Checksum256 sha256(const char* data, size_t length)\n    {\n       //std::array<unsigned char, 256 / 8> result;\n+      SHA256_CTX ctx;\n+      SHA256_Init(&ctx);\n+      SHA256_Update(&ctx, (const unsigned char*)data, length);\n       Checksum256 result;\n-      SHA256((const unsigned char*)data, length, (unsigned char*)result.data());\n+      SHA256_Final((unsigned char*)result.data(), &ctx);\n       return result;\n    }\n \n", "fix_pattern": "<pattern>: when using the SHA256 function from OpenSSL, instead of calling a single function that may lead to inefficiencies, refactor the code to use the initialization, update, and finalization steps with the SHA256_CTX context, which allows for better control of the hashing process and may improve performance by reducing memory allocations and managing state more explicitly."}
{"number": 193, "change": "@@ -164,8 +164,7 @@ namespace gpgmm {\n         MemoryPool* pool = memory->GetPool();\n         ASSERT(pool != nullptr);\n \n-        pool->ReturnToPool(\n-            std::make_unique<MemoryAllocation>(GetFirstChild(), allocation->GetMemory()));\n+        pool->ReturnToPool(std::make_unique<MemoryAllocation>(GetFirstChild(), memory));\n     }\n \n     void SegmentedMemoryAllocator::ReleaseMemory() {\n", "fix_pattern": "<pattern>: if an allocation is retrieved from a method call that may have significant overhead, store it in a variable before passing it to avoid multiple calls to the same method and improve performance."}
{"number": 194, "change": "@@ -242,7 +242,10 @@ namespace WSManagement\n \t\tstring ret;\n \t\ttry\n \t\t{\n-\t\t\tret = cl->Invoke(resourceUri, methodName, content, s);\n+\t\t\tWsmanOptions options(FLAG_SUPRESS_100_CONTINUE);\n+\t\t\toptions.setNamespace(cl->GetNamespace());\n+\t\t\toptions.addSelectors(s);\n+\t\t\tret = cl->Invoke(resourceUri, methodName, content, options);\n \t\t}\n \t\tcatch (WsmanSoapFault &ex)\n \t\t{\n", "fix_pattern": "<pattern>: if a method call directly invokes an API without additional configuration, refactor to create an options object (WsmanOptions) for better flexibility and to possibly enhance performance through pre-configuration (such as suppressing certain behaviors)."}
{"number": 195, "change": "@@ -147,7 +147,12 @@ void TLSServerContext::CreateContext()\n {\n   context = SSL_CTX_new(TLSv1_server_method());\n   if (!context) throw TLSProtocolError();\n-  SSL_CTX_set_options(context, SSL_OP_NO_SSLv2 | SSL_OP_ALL);\n+\n+  unsigned long options = SSL_OP_NO_SSLv2 | SSL_OP_ALL;\n+#if (OPENSSL_VERSION_NUMBER >= 0x10000000)\n+  options |= SSL_OP_NO_COMPRESSION;\n+#endif  \n+  SSL_CTX_set_options(context, options);\n }\n \n void TLSServerContext::Initialise(const std::string& certificate,\n", "fix_pattern": "<pattern>: if API options are set using multiple bitwise OR operations, consolidate the options into a variable to improve readability and potentially reduce the number of operations, especially when conditionally appending additional options based on version checks."}
{"number": 196, "change": "@@ -394,7 +394,7 @@ void uv_main( awaiter await){\n \n \t\t\t// If n==fibonacci_n, then the calculation is already finished\n \t\t\tif (n < fibonacci_n){\n-\t\t\t\tstd::tie(n, value) = await(fibchan.Read());\n+\t\t\t\tstd::tie(n, value) = await(Uv::DefaultExecutor(), fibchan.Read());\n \t\t\t}\n \n \t\t\ts << \"Fib(\" << n << \") = \" << value << \"\\n\";\n@@ -533,7 +533,7 @@ void uv_main( awaiter await){\n \t\t\t\t\t\n \t\t\t\t}\n \t\t\t\telse{\n-\t\t\t\t\tauto fut = await.as_future(p.second.Read());\n+\t\t\t\t\tauto fut = await.as_future(Uv::DefaultExecutor(),p.second.Read());\n \t\t\t\t\tif (fut.ErrorCode()){\n \t\t\t\t\t\tstr << p.first << \" : Error getting progress\\n\";\n \t\t\t\t\t}\n", "fix_pattern": "<pattern>: if an async operation doesn't specify an executor, explicitly pass `Uv::DefaultExecutor()` to the `await` and `as_future` calls to ensure optimal context management and potentially avoid overhead associated with obtaining a default context implicitly."}
{"number": 197, "change": "@@ -91,7 +91,7 @@ typedef std::vector<Rational> RationalList;\n namespace arithmetic {\n \n   inline unsigned long div_gcd (unsigned long d, unsigned long a)\n-  { return d/gcd(a,d); }\n+  { return d/unsigned_gcd(a,d); }\n \n   inline unsigned long gcd (long a, unsigned long b)\n   {\n", "fix_pattern": "<pattern>: if a GCD calculation is being performed with a signed type, use a project-specific optimized unsigned GCD function to improve performance, particularly when dealing with unsigned values."}
{"number": 198, "change": "@@ -54,7 +54,13 @@ int sock;\n #ifdef UNIX_ASYNC_DNS\n   static XP_Bool done = FALSE;\n \n-  LOG(\"XFE_InitDNS_Early\", (\"calling DNS_SpawnProcess.\\n\"));\n+  /*\n+   * The following used to be LOG() instead of fprintf(). But, LOG() uses\n+   * PR_smprintf() which fires up NSPR.\n+   */\n+#ifdef PROC1_DEBUG_PRINT\n+  fprintf(stderr, \"\\tproc1 (%d): %s\\n\", getpid(), \"XFE_InitDNS_Early: calling DNS_SpawnProcess.\");\n+#endif\n   sock = DNS_SpawnProcess(argc, argv);\n \n   XP_ASSERT(!done);\n", "fix_pattern": "<pattern>: if a logging function (LOG) introduces significant overhead due to additional processing (like memory allocation via PR_smprintf), replace it with a lower-overhead alternative (like fprintf) when debugging output is necessary to improve performance."}
{"number": 199, "change": "@@ -47,10 +47,8 @@ nsHTMLBase::CreateViewForFrame(nsIPresContext*  aPresContext,\n           aStyleContext->GetStyleData(eStyleStruct_Color);\n \n         // Get parent's nsStyleColor\n-        nsIStyleContext* parentSC;\n-        parent->GetStyleContext(aPresContext, parentSC);\n-        const nsStyleColor* parentColor = (const nsStyleColor*)\n-          parentSC->GetStyleData(eStyleStruct_Color);\n+        const nsStyleColor* parentColor;\n+        parent->GetStyleData(eStyleStruct_Color, (const nsStyleStruct*&)parentColor);\n \n         // If the opacities are different then I need a view\n         if (myColor->mOpacity != parentColor->mOpacity) {\n@@ -59,7 +57,6 @@ nsHTMLBase::CreateViewForFrame(nsIPresContext*  aPresContext,\n              aFrame, myColor->mOpacity, parentColor->mOpacity));\n           aForce = PR_TRUE;\n         }\n-        NS_RELEASE(parentSC);\n       }\n     }\n \n", "fix_pattern": "<pattern>: if an API method requires getting a style context and then accessing style data from that context, replace the indirection of obtaining the context and the subsequent data retrieval with a direct call to retrieve the style data, thus avoiding unnecessary overhead and potential resource management operations like releasing the style context."}
{"number": 200, "change": "@@ -99,8 +99,6 @@ ImageSystemServicesImpl::SetTimeout(ilTimeoutCallbackFunction aFunc,\n         return nsnull;\n     }\n \n-    NS_ADDREF(timer);\n-\n     return (void *)timer;\n }\n \n", "fix_pattern": "<pattern>: if NS_ADDREF is called on an object without any changes to its reference count within the surrounding context, evaluate if it is necessary to maintain that reference counting call or if it can be safely omitted, suggesting potential redundancy in the reference management logic."}
{"number": 201, "change": "@@ -482,15 +482,13 @@ void dprintf(const char *format, ...)\n {\n #if DEBUG\n     va_list ap;\n-\tchar\t*buffer;\n+\tStr255 buffer;\n \t\n \tva_start(ap, format);\n-\tbuffer = PR_vsmprintf(format, ap);\n+\tbuffer[0] = PR_vsnprintf((char *)buffer + 1, sizeof(buffer) - 1, format, ap);\n \tva_end(ap);\n \t\n-\tc2pstr(buffer);\n-\tDebugStr( (unsigned char *)buffer);\n-\tfree(buffer);\n+\tDebugStr(buffer);\n #endif /* DEBUG */\n }\n \n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a buffer (e.g., via PR_vsmprintf and subsequent free), replace it with a statically sized buffer (e.g., Str255) using PR_vsnprintf to eliminate the overhead of heap allocation and deallocation."}
{"number": 202, "change": "@@ -759,7 +759,7 @@ nsJSContext::ScriptEvaluated(void)\n \n   if (mNumEvaluations > 20) {\n     mNumEvaluations = 0;\n-    GC();\n+    ::JS_MaybeGC(mContext);\n   }\n \n   return NS_OK;\n", "fix_pattern": "<pattern>: if a garbage collection function that is likely part of a JavaScript engine is used (e.g., GC()), replace it with a more context-appropriate function (e.g., JS_MaybeGC) that may offer better performance or more efficient garbage collection behavior."}
{"number": 203, "change": "@@ -222,15 +222,8 @@ nsresult nsBuildImapMessageURI(const char *baseURI, PRUint32 key, nsCString& uri\n \t\n \turi.Append(baseURI);\n \turi.Append('#');\n-\tchar *keyStr = PR_smprintf(\"%u\", key);\n-\tif(!keyStr)\n-\t\treturn NS_ERROR_OUT_OF_MEMORY;\n-\n-\turi.Append(keyStr);\n-\n-\tPR_smprintf_free(keyStr);\n+\turi.AppendInt(key);\n \treturn NS_OK;\n-\n }\n \n nsresult nsCreateImapBaseMessageURI(const char *baseURI, char **baseMessageURI)\n", "fix_pattern": "<pattern>: if the code generates a string representation of an integer using PR_smprintf and then appends it to a URI, replace it with the more efficient nsCString::AppendInt method, which directly appends the integer without the overhead of string formatting and memory management."}
{"number": 204, "change": "@@ -230,8 +230,10 @@ nsresult nsCollationMac::CreateRawSortKey(const nsCollationStrength strength,\n     }\n     else {\n       // No CJK support, just copy the row string.\n-      strcpy((char *) key, str);\n-      while (*key) {\n+      // Collation key is not a string, use memcpy instead of strcpy.\n+      nsCRT::memcpy(key, str, str_len);\n+      PRUint8 *end = key + str_len;\n+      while (key < end) {\n         if ((unsigned char) *key < 128) {\n           key++;\n         }\n", "fix_pattern": "<pattern>: if a string is being copied to a buffer where the length is known, replace strcpy with memcpy to eliminate null-termination overhead and improve performance."}
{"number": 205, "change": "@@ -365,7 +365,7 @@ ns4xPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,\n       amountRead -= writeCount;\n       mPosition += writeCount;\n       if (amountRead > 0)\n-        strncpy(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n+        memmove(mStreamBuffer,mStreamBuffer+writeCount,amountRead); \n     }\n   }\n \n", "fix_pattern": "<pattern>: if a memory block is being shifted within a buffer, replace `strncpy` with `memmove` to properly handle overlapping memory regions, improving safety and performance."}
{"number": 206, "change": "@@ -24,7 +24,6 @@\n \n #include \"nsIServiceManager.h\"\n #include \"nsIEventQueueService.h\"\n-#include \"nsIChromeRegistry.h\"\n #include \"nsIAppStartupNotifier.h\"\n #include \"nsIStringBundle.h\"\n \n@@ -141,15 +140,6 @@ nsresult NS_InitEmbedding(nsILocalFile *mozBinDirectory,\n     }\n #endif\n \n-    // Init the chrome registry.\n-    nsCOMPtr<nsIChromeRegistry> chromeReg;\n-    chromeReg = do_GetService(\"@mozilla.org/chrome/chrome-registry;1\", &rv);\n-    if (chromeReg)\n-    {\n-        // Ignore the return value here.  If chrome is already initialized\n-        // this call will return an error even though nothing is wrong.\n-        (void) chromeReg->CheckForNewChrome();\n-    }\n     return NS_OK;\n \n }\n", "fix_pattern": "<pattern>: Remove unnecessary calls to `do_GetService` for `nsIChromeRegistry` if already initialized, or set `chromeReg` only after confirming that it hasn't been initialized, to avoid additional service calls that don't yield new information. Additionally, check if `CheckForNewChrome` is needed in the context."}
{"number": 208, "change": "@@ -152,9 +152,8 @@ void Pass::match(Plasma::RunnerContext &context)\n     QList<Plasma::QueryMatch> matches;\n \n     lock.lockForRead();\n-    QRegularExpression re(\".*\" + input + \".*\", QRegularExpression::CaseInsensitiveOption);\n     for (const auto& password: passwords) {\n-        if (re.match(password).hasMatch()) {\n+        if (password.contains(input,Qt::CaseInsensitive)) {\n             Plasma::QueryMatch match(this);\n             match.setType(input.length() == password.length() ?\n                 Plasma::QueryMatch::ExactMatch : Plasma::QueryMatch::CompletionMatch);\n", "fix_pattern": "<pattern>: if a QRegularExpression is used to perform a match on a QString, replace it with QString's built-in contains method for better performance as it avoids regex overhead."}
{"number": 210, "change": "@@ -193,10 +193,10 @@ DOMServices::initialize()\n void\n DOMServices::terminate()\n {\n-\tclear(::s_XMLString);\n-\tclear(::s_XMLNamespaceURI);\n-\tclear(::s_XMLNamespace);\n-\tclear(::s_XMLNamespaceWithSeparator);\n+\treleaseMemory(::s_XMLString);\n+\treleaseMemory(::s_XMLNamespaceURI);\n+\treleaseMemory(::s_XMLNamespace);\n+\treleaseMemory(::s_XMLNamespaceWithSeparator);\n \n \t::s_XMLStringLength = 0;\n \t::s_XMLNamespaceURILength = 0;\n", "fix_pattern": "<pattern>: if the code is using a method that clears an XMLStringType instance to free the memory, replace it with a more performance-oriented method that explicitly releases the memory associated with the variable, such as `releaseMemory(...)`."}
{"number": 211, "change": "@@ -566,7 +566,7 @@ public:\n \t\t\tauto p = it;\n \t\t\twhile (b != e) {\n \t\t\t\tconst auto lin = std::min<size_type>(\n-\t\t\t\tcapacity_ - wrap(it), e - b);\n+\t\t\t\t\t\tcapacity_ - wrap(p), e - b);\n \t\t\t\tmemcpy(&ref(p), b, lin * sizeof(T));\n \t\t\t\tb += lin;\n \t\t\t\tp += lin;\n", "fix_pattern": "<pattern>: if an iterator is used as an argument in a method call where it is not necessary (e.g., for capacity-related calculations), modify the code to use a pointer or a different representation (such as another iterator) to avoid potential overhead from the wrapper function. In this case, refactor to use a pointer or a simpler form of the iterator (e.g., using `p` instead of `it`) that may offer better performance."}
{"number": 212, "change": "@@ -189,9 +189,8 @@ void GraphicsContext::drawLine(const IntPoint& point1, const IntPoint& point2)\n             break;\n     }\n \n-    save();\n-\n     CGContextRef context = platformContext();\n+    CGContextSaveGState(context);\n \n     CGContextSetShouldAntialias(context, false);\n \n@@ -247,7 +246,7 @@ void GraphicsContext::drawLine(const IntPoint& point1, const IntPoint& point2)\n \n     CGContextStrokePath(context);\n \n-    restore();\n+    CGContextRestoreGState(context);\n }\n \n // This method is only used to draw the little circles used in lists.\n", "fix_pattern": "<pattern>: if custom save and restore methods are replaced with Core Graphics' CGContextSaveGState and CGContextRestoreGState, utilize the Core Graphics framework's API for better performance and efficient state management in graphics rendering."}
{"number": 213, "change": "@@ -119,7 +119,7 @@ void Ogre3DFFMPEGVideoWriter::setup(const char* filename, int width, int height,\n \t * video codecs and allocate the necessary encode buffers. */\n \t{\n \n-\t\tmAVFrame = avcodec_alloc_frame();\n+\t\tmAVFrame = av_frame_alloc();\n \t\tmAVFrame->pts = 0;\n \n \t\t/* put sample parameters */\n@@ -175,7 +175,7 @@ void Ogre3DFFMPEGVideoWriter::setup(const char* filename, int width, int height,\n \t\t\t\tmAVFrame->linesize[3]);\n \t\t}\n \n-\t\tmPictureRGB24 = avcodec_alloc_frame();\n+\t\tmPictureRGB24 = av_frame_alloc();\n \t\tmPictureRGB24->format = AV_PIX_FMT_0RGB32;\n \n \t\tif ((ret = av_image_alloc(mPictureRGB24->data, mPictureRGB24->linesize,\n", "fix_pattern": "<pattern>: replace the deprecated `avcodec_alloc_frame` function with the more efficient `av_frame_alloc` function, which is the recommended allocation method in newer versions of the FFmpeg library, potentially improving performance and memory management."}
{"number": 214, "change": "@@ -182,12 +182,12 @@ void PaymentServerTests::paymentServerTests()\n     QCOMPARE(PaymentServer::verifyExpired(r.paymentRequest.getDetails()), true);\n \n     // Test BIP70 DoS protection:\n-    unsigned char randData[BIP70_MAX_PAYMENTREQUEST_SIZE + 1];\n-    GetRandBytes(randData, sizeof(randData));\n+    auto randdata = FastRandomContext().randbytes(BIP70_MAX_PAYMENTREQUEST_SIZE + 1);\n+\n     // Write data to a temp file:\n     QTemporaryFile tempFile;\n     tempFile.open();\n-    tempFile.write((const char*)randData, sizeof(randData));\n+    tempFile.write((const char*)randdata.data(), randdata.size());\n     tempFile.close();\n     // compares 50001 <= BIP70_MAX_PAYMENTREQUEST_SIZE == false\n     QCOMPARE(PaymentServer::verifySize(tempFile.size()), false);\n", "fix_pattern": "<pattern>: if using a direct buffer approach for generating random bytes and writing them to a file, switch to a higher-level abstraction that combines randomness generation and data management (e.g., using FastRandomContext with std::vector for automatic memory handling) for improved performance and safety."}
{"number": 215, "change": "@@ -14,6 +14,7 @@\n #define TRGCDC_SHORT_NAMES\n \n #include <math.h>\n+#include <TRandom.h>\n #include <iostream>\n #include <fstream>\n #include \"framework/datastore/StoreArray.h\"\n@@ -1030,7 +1031,7 @@ namespace Belle2 {\n       //...Loop over CDCHits...\n       for (unsigned i = 0; i < nHits; i++) {\n         const CDCHit& h = *CDCHits[i];\n-        double tmp = rand() / (double(RAND_MAX));\n+        double tmp = gRandom->Uniform(0.0, 1.0) / (double(RAND_MAX));\n         if (tmp < _inefficiency)\n           continue;\n \n", "fix_pattern": "<pattern>: if random number generation is performed using the standard C++ `rand()` function, switch to using `gRandom->Uniform(min, max)` from the ROOT TRandom class for improved performance and better statistical properties in scientific computing contexts."}
{"number": 218, "change": "@@ -27,7 +27,8 @@ void AMQPMessage::setMessage(const char * data,uint32_t length) {\n \tif (this->data)\n \t\tfree(this->data);\n \n-\tthis->data = strdup(data);\n+\tthis->data = (char*)malloc(length);\n+\tmemcpy(this->data,data,length);\n \tthis->len = length;\n }\n \n", "fix_pattern": "<pattern>: if strdup is used to allocate and copy a string, replace it with malloc followed by memcpy for potentially better performance and control over allocation size."}
{"number": 219, "change": "@@ -21,6 +21,7 @@ using namespace Cicada;\n #define RINGBUFFER_BACK_SIZE 1024*512\n \n #define MIN_SO_RCVBUF_SIZE 1024*64\n+#define READ_BUFFER_SIZE 1024 * 64\n \n #define SOCKET_ERROR (-1)\n \n@@ -384,7 +385,7 @@ int Cicada::CURLConnection::esayHandle_set_common_opt()\n     curl_easy_setopt(mHttp_handle, CURLOPT_DEBUGDATA, this);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERFUNCTION, write_response);\n     curl_easy_setopt(mHttp_handle, CURLOPT_HEADERDATA, this);\n-    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, CURL_MAX_READ_SIZE);\n+    curl_easy_setopt(mHttp_handle, CURLOPT_BUFFERSIZE, READ_BUFFER_SIZE);\n     return 0;\n }\n \n", "fix_pattern": "<pattern>: if the CURLOPT_BUFFERSIZE is set directly with a constant, replace it with a defined constant value that represents a more suitable buffer size for performance optimization."}
{"number": 220, "change": "@@ -595,9 +595,7 @@ Resource Resource::property2Resource(const QString& propertyName, IlwisTypes typ\n     bool ok;\n     quint64 id = property.toULongLong(&ok);\n     if ( ok){\n-        ESPIlwisObject object =  mastercatalog()->get(id);\n-        if ( object)\n-            return object->source();\n+        return mastercatalog()->id2Resource(id);\n     }\n     else\n         return mastercatalog()->name2Resource(property.toString(), type);\n", "fix_pattern": "<pattern>: if a call to retrieve an object via a method (e.g., get(id)) followed by a check is replaced with a direct call to obtain the resource (id2Resource(id)), then refactor to skip the intermediate object retrieval for direct access to improve performance."}
{"number": 221, "change": "@@ -31,9 +31,9 @@ int main(int argc, char** argv) {\n     gIconFont = TTF_OpenFontRW(SDL_RWFromConstMem(embed_fontawesome, embed_fontawesome_size), true, 14);\n     if (!gIconFont) printf(\"fontawesome.ttf: %s\\n\", TTF_GetError());\n \n-    SDL_CreateWindowAndRenderer(DISPLAY_WIDTH, DISPLAY_HEIGHT, SDL_WINDOW_RESIZABLE, &window, &renderer);\n+    window = SDL_CreateWindow(\"JspEdit 3\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, DISPLAY_WIDTH, DISPLAY_HEIGHT, SDL_WINDOW_RESIZABLE);\n+    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_PRESENTVSYNC);\n     SDL_GetWindowSize(window, &DISPLAY_WIDTH, &DISPLAY_HEIGHT);\n-    SDL_SetWindowTitle(window, \"JspEdit 3\");\n \n     SDL_Surface *surface = IMG_Load_RW(SDL_RWFromConstMem(embed_game_icon, embed_game_icon_size), true);\n     SDL_SetWindowIcon(window, surface);\n", "fix_pattern": "<pattern>: if SDL_CreateWindowAndRenderer is used, replace it with separate calls to SDL_CreateWindow and SDL_CreateRenderer to have more control over the creation process and potentially avoid overhead or configuration issues. This allows setting the window title directly in the window creation call."}
{"number": 222, "change": "@@ -127,8 +127,8 @@ bool fetch_mod(wchar_t *version) {\n \t}\n \tFILE *out = NULL;\n \tcurl_easy_setopt(curl, CURLOPT_URL, fetch_url_utf8);\n-\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 3200L);\n-\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 40000L);\n+\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 2000L);\n+\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 20000L);\n \tcurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);\n \tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);\n \tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n", "fix_pattern": "<pattern>: if there is a need to improve performance related to network timeouts in a curl request, consider adjusting timeout values to lower settings that do not compromise functionality; this can reduce the time spent waiting for network operations to complete, enhancing responsiveness."}
{"number": 225, "change": "@@ -68,16 +68,16 @@ QString EwsMailHandler::mimeType()\n bool EwsMailHandler::setItemPayload(Akonadi::Item &item, const EwsItem &ewsItem)\n {\n     qDebug() << \"EwsMailHandler::setItemPayload\";\n-    QString mimeContent = ewsItem[EwsItemFieldMimeContent].toString();\n+    QByteArray mimeContent = ewsItem[EwsItemFieldMimeContent].toByteArray();\n     if (mimeContent.isEmpty()) {\n         qWarning() << QStringLiteral(\"MIME content is empty!\");\n         return false;\n     }\n \n-    mimeContent.replace(QStringLiteral(\"\\r\\n\"), QStringLiteral(\"\\n\"));\n+    mimeContent.replace(\"\\r\\n\", \"\\n\");\n \n     KMime::Message::Ptr msg(new KMime::Message);\n-    msg->setContent(mimeContent.toLatin1());\n+    msg->setContent(mimeContent);\n     msg->parse();\n     qDebug() << msg->attachments().size() << \"attachments\";\n     // Some messages might just be empty (just headers). This results in the body being empty.\n", "fix_pattern": "<pattern>: if a QString is converted to a byte array using toString and then later converted to a QByteArray with toLatin1, refactor the code to directly use toByteArray for better performance and to eliminate unnecessary conversions."}
{"number": 227, "change": "@@ -261,7 +261,7 @@ void pqColorMapEditor::setColorTransferFunction(vtkSMProxy* ctf)\n   this->Internals->ProxyWidget = widget;\n   this->updatePanel();\n \n-  QObject::connect(widget, SIGNAL(changeFinished()), this, SLOT(updateIfNeeded()));\n+  QObject::connect(widget, SIGNAL(changeAvailable()), this, SLOT(updateIfNeeded()));\n }\n \n //-----------------------------------------------------------------------------\n", "fix_pattern": "<pattern>: NA"}
{"number": 228, "change": "@@ -1,4 +1,4 @@\n-/* Copyright (c) 2019-2023, Arm Limited and Contributors\n+/* Copyright (c) 2019-2024, Arm Limited and Contributors\n  *\n  * SPDX-License-Identifier: Apache-2.0\n  *\n@@ -58,6 +58,10 @@ void LightingSubpass::draw(CommandBuffer &command_buffer)\n \tauto &pipeline_layout = resource_cache.request_pipeline_layout(shader_modules);\n \tcommand_buffer.bind_pipeline_layout(pipeline_layout);\n \n+\t// we know, that the lighting subpass does not have any vertex stage input -> reset the vertex input state\n+\tassert(pipeline_layout.get_resources(ShaderResourceType::Input, VK_SHADER_STAGE_VERTEX_BIT).empty());\n+\tcommand_buffer.set_vertex_input_state({});\n+\n \t// Get image views of the attachments\n \tauto &render_target = get_render_context().get_active_frame().get_render_target();\n \tauto &target_views  = render_target.get_views();\n", "fix_pattern": "<pattern>: if a vertex input state is set after asserting that no vertex stage input resources are present, ensure that the assertion is checked before setting the vertex input state to optimize potential errors in graphics pipeline configuration."}
{"number": 229, "change": "@@ -5370,8 +5370,8 @@ bool CoreChecks::ValidateImageBarrier(const LogObjectList &objects, const CoreEr\n \n         skip |= ValidateBarrierQueueFamilies(image_loc, cb_state, mem_barrier, image_data);\n \n-        const auto aspect_mask = mem_barrier.subresourceRange.aspectMask;\n-        skip |= ValidateImageAspectMask(image_data->image, image_data->createInfo.format, aspect_mask, image_loc.Message().c_str());\n+        skip |= ValidateImageAspectMask(image_data->image, image_data->createInfo.format, mem_barrier.subresourceRange.aspectMask,\n+                                        loc.StringFuncName().c_str());\n \n         skip |= ValidateImageBarrierSubresourceRange(loc.dot(Field::subresourceRange), image_data, mem_barrier.subresourceRange);\n     }\n", "fix_pattern": "<pattern>: if a call to a function to obtain a message string (like Message()) is made, and it uses a temporary string, replace it with a more efficient method (like directly using c_str() from a different static string function) to potentially reduce overhead from unnecessary string construction."}
{"number": 231, "change": "@@ -13,7 +13,6 @@\n #include <arpa/inet.h>\n #include <assert.h>\n #include <errno.h>\n-#include <fcntl.h>\n #include <inttypes.h>\n #include <netinet/in.h>\n #include <poll.h>\n@@ -123,12 +122,10 @@ static void await_debugger(struct GdbContext* dbg, ScopedFd& listen_fd) {\n   struct sockaddr_in client_addr;\n   socklen_t len = sizeof(client_addr);\n \n-  dbg->sock_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &len);\n+  dbg->sock_fd =\n+      accept4(listen_fd, (struct sockaddr*)&client_addr, &len, SOCK_NONBLOCK);\n   // We might restart this debugging session, so don't set the\n   // socket fd CLOEXEC.\n-  if (fcntl(dbg->sock_fd, F_SETFL, O_NONBLOCK)) {\n-    FATAL() << \"Can't make client socket NONBLOCK\";\n-  }\n }\n \n struct debugger_params {\n", "fix_pattern": "<pattern>: if the accept method is called and the socket needs to be set to non-blocking mode afterwards, replace it with accept4 which allows setting the socket to non-blocking mode in a single call for better performance."}
{"number": 232, "change": "@@ -85,7 +85,7 @@ static ScopedFd create_memfd_file(const string& orig_path, dev_t orig_device,\n        << \"-inode-\" << orig_inode << \"-\" << orig_path;\n   real_name = name.str().substr(0, 255);\n \n-  ScopedFd fd = memfd_create(real_name.c_str(), 0);\n+  ScopedFd fd = syscall(SYS_memfd_create, real_name.c_str(), 0);\n   return fd;\n }\n \n", "fix_pattern": "<pattern>: if the code uses a higher-level API function like memfd_create that incurs additional overhead due to abstraction, refactor it to directly use the syscall interface for better performance by reducing function call overhead and leveraging lower-level operations directly."}
{"number": 239, "change": "@@ -632,12 +632,6 @@ open_or_create_log_file(\n \t\t\t\"InnoDB: Database physically writes the file\"\n \t\t\t\" full: wait...\\n\");\n \n-#ifndef __WIN__\n-\t\t/* To avoid kernel buffer pollution when creating large\n-\t\tlog files we disable fs caching. */\n-\t\tos_file_set_nocache(files[i], name, \"log file creation\");\n-#endif /* __WIN__ */\n-\n \t\tret = os_file_set_size(name, files[i],\n \t\t\t\t       (os_offset_t) srv_log_file_size\n \t\t\t\t       << UNIV_PAGE_SIZE_SHIFT);\n", "fix_pattern": "<pattern>: if a specific API call is conditionally excluded based on platform without further action taken, and if there are no functional changes or replacements made, then the removal of that code may imply that the feature is no longer necessary or relevant, therefore no pattern is detected."}
{"number": 240, "change": "@@ -1,5 +1,5 @@\n /*\n-   Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.\n+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -1307,7 +1307,7 @@ TransporterFacade::close_clnt(trp_client* clnt)\n         clnt->do_forceSend(1);\n         first = false;\n       }\n-      clnt->do_poll(0);\n+      clnt->do_poll(10);\n       not_finished = (m_threads.get(clnt->m_blockNo) == clnt);\n       clnt->complete_poll();\n     } while (not_finished);\n", "fix_pattern": "<pattern>: if the timeout parameter for an API method is set to zero, which may result in the method to be non-blocking and potentially lead to busy-waiting, adjust the timeout to a positive value to allow for more efficient waiting (e.g., using a sleep mechanism) which can enhance performance in scenarios with polling."}
{"number": 241, "change": "@@ -6112,7 +6112,6 @@ void* background_thread(void*)\n   mysql_mutex_lock(&background_mutex);\n   mysql_mutex_lock(&stop_cond_mutex);\n \n-  rocksdb::WriteBatch wb;\n   time_t last_stat_recompute = 0;\n   for (;;)\n   {\n@@ -6128,9 +6127,8 @@ void* background_thread(void*)\n     assert(ret == 0 || ret == ETIMEDOUT);\n \n     if (rdb && rocksdb_background_sync) {\n-      auto wo = rocksdb::WriteOptions();\n-      wo.sync = true;\n-      rocksdb::Status s= rdb->Write(wo, &wb);\n+      assert(!db_options.allow_mmap_writes);\n+      rocksdb::Status s= rdb->SyncWAL();\n       if (!s.ok())\n         rocksdb_handle_io_error(s, ROCKSDB_IO_ERROR_BG_THREAD);\n     }\n", "fix_pattern": "<pattern>: if a write operation is performed with `rocksdb::Write`, and it is determined that write-ahead logging (WAL) should be synchronized without custom write options, replace the write operation with `rocksdb::DB::SyncWAL()` for improved performance, especially when synchronous writes are unnecessary. This change also removes complexity from write options and directly manages the log synchronization."}
{"number": 242, "change": "@@ -41,10 +41,10 @@ double HkIClientImpl::CDPClientProxy__GetLinkSaturation(uint iClientID)\n \t// ISERVER_LOGARG_UI(iClientID);\n \n \tchar *tmp; \n-\tWriteProcMem(&tmp, &Client, 4); \n-\tWriteProcMem(&Client, &OldClient, 4); \n+\tmemcpy(&tmp, &Client, 4);\n+\tmemcpy(&Client, &OldClient, 4);\n \tdouble dRet = HookClient->CDPClientProxy__GetLinkSaturation(iClientID); \n-\tWriteProcMem(&Client, &tmp, 4); \n+\tmemcpy(&Client, &tmp, 4);\n \n \treturn dRet;\n }\n", "fix_pattern": "<pattern>: if multiple calls to a memory writing API (in this case WriteProcMem) are detected for copying fixed-size blocks of memory, replace them with calls to memcpy for better performance and reduced overhead."}
{"number": 243, "change": "@@ -137,7 +137,7 @@ void PGE_MusPlayer::setSampleRate(int sampleRate=44100)\n {\n     sRate=sampleRate;\n     Mix_CloseAudio();\n-    Mix_OpenAudio(sRate, AUDIO_S16, 2, 4096);\n+    Mix_OpenAudio(sRate, AUDIO_S16, 2, 2048);\n \tMix_AllocateChannels(32);\n \n \t// Reset the audio sample count and set the post mix callback\n", "fix_pattern": "<pattern>: if the chunk size in an audio API call is reduced for performance reasons, identify the use of Mix_OpenAudio and optimize the chunk size parameter, as smaller chunk sizes can lead to lower latency at the potential expense of increased CPU usage."}
{"number": 246, "change": "@@ -984,11 +984,11 @@ QString KMMessage::replacePrefixes( const QString& str,\n   // 2. matches at least one of the part regexps in prefixRegExps\n   QString bigRegExp = QString::fromLatin1(\"^(?:\\\\s+|(?:%1))+\\\\s*\")\n                       .arg( prefixRegExps.join(\")|(?:\") );\n-  kdDebug(5006) << \"KMMessage::replacePrefixes(): bigRegExp = \\\"\" << bigRegExp\n-\t\t<< \"\\\"\" << endl;\n   QRegExp rx( bigRegExp, false /*case insens.*/ );\n   if ( !rx.isValid() ) {\n-    kdWarning(5006) << \"prefix regexp is invalid!\" << endl;\n+    kdWarning(5006) << \"KMMessage::replacePrefixes(): bigRegExp = \\\"\"\n+                    << bigRegExp << \"\\\"\\n\"\n+                    << \"prefix regexp is invalid!\" << endl;\n     // try good ole Re/Fwd:\n     recognized = str.startsWith( newPrefix );\n   } else { // valid rx\n", "fix_pattern": "<pattern>: if multiple logging calls are made sequentially that can be combined into a single logging statement, then refactor the code to concatenate the messages into one logging statement for improved performance by reducing function call overhead."}
{"number": 247, "change": "@@ -203,7 +203,7 @@ void KMSystemTray::updateCount()\n     }\n \n     // Overlay the light KMail icon with the number image\n-    QImage iconWithNumberImage = mDefaultIcon.toImage().copy();\n+    QPixmap iconWithNumberImage = mDefaultIcon;\n     QPainter p( &iconWithNumberImage );\n     p.setFont( countFont );\n     KColorScheme scheme( QPalette::Active, KColorScheme::View );\n@@ -224,7 +224,7 @@ void KMSystemTray::updateCount()\n     p.setOpacity( 1.0 );\n     p.drawText( iconWithNumberImage.rect(), Qt::AlignCenter, countString );\n \n-    setIcon( QPixmap::fromImage( iconWithNumberImage ) );\n+    setIcon( iconWithNumberImage );\n   } else\n   {\n     setIcon( mDefaultIcon );\n", "fix_pattern": "<pattern>: if an intermediate QImage is created by calling `toImage()` and then a `QPixmap` is constructed from it using `QPixmap::fromImage`, eliminate the unnecessary conversion by directly assigning the QPixmap that already exists (in this case, `mDefaultIcon`)."}
{"number": 251, "change": "@@ -67,14 +67,8 @@ void OGGLoader::into(Loadable& resource, const LoaderOptions& options) {\n     Sound* sound = dynamic_cast<Sound*>(res_ptr);\n     assert(sound && \"You passed a Resource that is not a Sound to the OGG loader\");\n \n-    std::ifstream t(filename_.encode().c_str(), std::ios::binary);\n-    std::vector<uint8_t> data;\n-\n-    t.seekg(0, std::ios::end);\n-    data.reserve(t.tellg());\n-    t.seekg(0, std::ios::beg);\n-\n-    data.assign((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());\n+    std::string buf = data_->str();\n+    std::vector<uint8_t> data(buf.begin(), buf.end());\n \n     StreamWrapper stream(stb_vorbis_open_memory(&data[0], data.size(),nullptr, nullptr));\n \n", "fix_pattern": "<pattern>: if reading data from a file using std::ifstream involves seeking the file size and using std::istreambuf_iterator, replace it with reading data into a string buffer first and then constructing the vector from the string to reduce overhead from seeking and iterating."}
{"number": 253, "change": "@@ -63,9 +63,11 @@ BOOL WINAPI DllMain(HINSTANCE h, DWORD reason, LPVOID reserved)\n \t\tstrcpy(++p, FBDLLNAME);\n \t\tp += strlen(FBDLLNAME);\n \t\t*p = 0;\n-\t\thFBDLLInstance = LoadLibrary(buffer);\n-\t\tif (!hFBDLLInstance) {\n-\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\tif (!GetModuleHandle(buffer) && !GetModuleHandle(FBDLLNAME)) {\n+\t\t\thFBDLLInstance = LoadLibrary(buffer);\n+\t\t\tif (!hFBDLLInstance) {\n+\t\t\t\thFBDLLInstance = LoadLibrary(FBDLLNAME);\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase DLL_PROCESS_DETACH:\n", "fix_pattern": "<pattern>: if the code checks for the loaded module using LoadLibrary, replace it with GetModuleHandle to avoid loading the library again if it's already been loaded; then only fall back to LoadLibrary if the module is not currently loaded."}
{"number": 255, "change": "@@ -21,6 +21,7 @@\n  */\n \n #include \"firebird.h\"\n+#include \"../common/classes/Aligner.h\"\n #include \"../common/classes/Hash.h\"\n #include \"../jrd/jrd.h\"\n #include \"../jrd/req.h\"\n@@ -525,8 +526,8 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\tif (desc->isDecFloat())\n \t\t\t\t{\n \t\t\t\t\t// Values inside our key buffer are not aligned,\n-\t\t\t\t\t// hence we need to use intermediate storage for makeKey()\n-\t\t\t\t\tULONG key[MAX_DEC_KEY_LONGS];\n+\t\t\t\t\t// so ensure we satisfy our platform's alignment rules\n+\t\t\t\t\tOutAligner<ULONG, MAX_DEC_KEY_LONGS> key(keyPtr, keyLength);\n \n \t\t\t\t\tif (desc->dsc_dtype == dtype_dec64)\n \t\t\t\t\t\t((Decimal64*) data)->makeKey(key);\n@@ -534,9 +535,6 @@ ULONG HashJoin::computeHash(thread_db* tdbb,\n \t\t\t\t\t\t((Decimal128*) data)->makeKey(key);\n \t\t\t\t\telse\n \t\t\t\t\t\tfb_assert(false);\n-\n-\t\t\t\t\tfb_assert(keyLength <= sizeof(key));\n-\t\t\t\t\tmemcpy(keyPtr, key, keyLength);\n \t\t\t\t}\n \t\t\t\telse if (desc->dsc_dtype == dtype_real && *(float*) data == 0)\n \t\t\t\t{\n", "fix_pattern": "<pattern>: if `memcpy` is used to copy data to `keyPtr`, refactor the code to use a specialized alignment-aware class (e.g., `OutAligner`) that ensures proper handling of memory alignment constraints for the platform, improving performance and safety."}
{"number": 256, "change": "@@ -116,7 +116,7 @@ namespace\n \t{\n \t\tuint8* destPointer = EmulatorInterface::instance().getMemoryPointer(destAddress, true, bytes);\n \t\tuint8* sourcePointer = EmulatorInterface::instance().getMemoryPointer(sourceAddress, false, bytes);\n-\t\tmemcpy(destPointer, sourcePointer, bytes);\n+\t\tmemmove(destPointer, sourcePointer, bytes);\n \t}\n \n \tvoid zeroMemory(uint32 startAddress, uint32 bytes)\n", "fix_pattern": "<pattern>: if the source and destination memory regions overlap, replace memcpy with memmove to ensure safety and correctness without performance degradation."}
{"number": 257, "change": "@@ -419,9 +419,7 @@ int vfsLoadFile( const char *filename, void **bufferptr, int index ){\n \t\t}\n \n \t\tif ( count == index ) {\n-\t\t\tstrcpy( g_strLoadedFileLocation, file->unzFilePath );\n-\t\t\tstrcat( g_strLoadedFileLocation, \" :: \" );\n-\t\t\tstrcat( g_strLoadedFileLocation, filename );\n+\t\t\tsnprintf( g_strLoadedFileLocation, sizeof( g_strLoadedFileLocation ), \"%s :: %s\", file->unzFilePath, filename );\n \n \t\t\tmemcpy( file->zipfile, &file->zipinfo, sizeof( unz_s ) );\n \n", "fix_pattern": "<pattern>: if multiple string concatenations using strcpy and strcat are detected, refactor the code to use snprintf for a single, more efficient string formatting operation, which also prevents buffer overflows."}
{"number": 258, "change": "@@ -158,7 +158,7 @@ buffer_washer(char * buff, int buffer_len)\n \n     for (i = 0 ; i < buffer_len - 1; i++) {\n \tif (buff[i] == '\\0') {\n-\t    memcpy(&buff[i], &buff[i+1], buffer_len - i);\n+\t    memmove(&buff[i], &buff[i+1], buffer_len - i);\n \t    buffer_len--;\n \t    buff[buffer_len] = '\\0';\n \t}\n", "fix_pattern": "<pattern>: if overlapping memory regions are involved in a copy operation, replace memcpy with memmove to ensure safe handling of overlapping areas."}
{"number": 260, "change": "@@ -61,7 +61,7 @@ Point Point::operator*(double b) const {\n   return Point(data->getX() * b, data->getY() * b, data->getZ() * b);\n }\n \n-Point Point::clone() const {return Point(data->clone());}\n+Point Point::clone() const {return Point(data);}\n double Point::getX() const {return data->getX();}\n double Point::getY() const {return data->getY();}\n double Point::getZ() const {return data->getZ();}\n", "fix_pattern": "<pattern>: if an object is being cloned unnecessarily when its data can be used directly without creating a copy, refactor the code to return the existing pointer/reference instead of creating a new cloned object."}
{"number": 261, "change": "@@ -34,7 +34,7 @@ const Kernel::FT volume( const Solid& solid, NoValidityCheck )\n     const CGAL::Point_3<Kernel> origin(0,0,0);\n     const size_t numShells = solid.numShells();\n     for (size_t i=0; i<numShells; i++) {\n-        std::auto_ptr<Geometry> t( tesselate( solid.shellN(i) ) );\n+\t    std::auto_ptr<Geometry> t( tesselate( solid.shellN(i), NoValidityCheck() ) );\n         const TriangulatedSurface& tin = t->as<TriangulatedSurface>();\n         const size_t numTriangles = tin.numTriangles();\n         for (size_t j=0; j<numTriangles; j++) {\n", "fix_pattern": "<pattern>: if an API call to `tesselate` is made without a validity check and there exists an overload for `tesselate` that allows skipping the validity check for performance improvements, refactor the call to utilize that overload by passing `NoValidityCheck()`."}
{"number": 262, "change": "@@ -84,11 +84,12 @@ namespace Ndk\n \t\tconst WidgetBox* bestEntry = nullptr;\n \t\tfloat bestEntryArea = std::numeric_limits<float>::infinity();\n \n+\t\tNz::Vector3f mousePos(float(event.x), float(event.y), 0.f);\n \t\tfor (const WidgetBox& entry : m_widgetBoxes)\n \t\t{\n \t\t\tconst Nz::Boxf& box = entry.box;\n \n-\t\t\tif (box.Contains(Nz::Vector3f(event.x, event.y, 0.f)))\n+\t\t\tif (box.Contains(mousePos))\n \t\t\t{\n \t\t\t\tfloat area = box.width * box.height;\n \t\t\t\tif (area < bestEntryArea)\n", "fix_pattern": "<pattern>: if a temporary object is created multiple times for a function call (such as a vector for position), store it in a variable before the call to reduce overhead and improve readability."}
{"number": 266, "change": "@@ -324,13 +324,14 @@ void GStreamerStream::cleanup_pipe() {\n     m_console->debug(\"gst_pipeline==null\");\n     return;\n   }\n-  m_console->debug(\"send EOS begin\");\n+  // Jan 22: Confirmed this hangs quite a lot of pipeline(s) - removed for that reason\n+  /*m_console->debug(\"send EOS begin\");\n   // according to @Alex W we need a EOS signal here to properly shut down the pipeline\n   if(!gst_element_send_event (m_gst_pipeline, gst_event_new_eos())){\n     m_console->info(\"error gst_element_send_event eos\"); // No idea what that means\n   }else{\n     m_console->info(\"success gst_element_send_event eos\");\n-  }\n+  }*/\n   // TODO wait for the eos event to travel down the pipeline,but do it in a safe manner to not block for infinity\n   gst_element_set_state (m_gst_pipeline, GST_STATE_NULL);\n   gst_object_unref (m_gst_pipeline);\n", "fix_pattern": "<pattern>: if a log message is confirmed to cause performance issues (e.g., hangs or slowdowns) and does not provide substantial benefit, comment it out or remove it to enhance performance."}
{"number": 269, "change": "@@ -22294,7 +22294,8 @@ void Player::AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 ite\n             ASSERT(categoryEntry);\n             if (categoryEntry->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_MIDNIGHT)\n             {\n-                struct tm date = *localtime(&curTime);\n+                tm date;\n+                ACE_OS::localtime_r(&curTime, &date);\n                 catrec = catrec * DAY - (date.tm_hour * HOUR + date.tm_min * MINUTE + date.tm_sec) * IN_MILLISECONDS;\n             }\n         }\n", "fix_pattern": "<pattern>: if a call to localtime() is detected which is not thread-safe due to internal static storage, replace it with a thread-safe alternative like localtime_r to avoid potential issues in a multi-threaded context."}
{"number": 270, "change": "@@ -956,7 +956,7 @@ void Audio::outputNotify() {\n         qDebug() << \"WARNING --- WE HAD at least:\" << recentUnfulfilled << \"recently unfulfilled readData() calls\";\n \n         if (_outputStarveDetectionEnabled) {\n-            quint64 now = QDateTime::currentMSecsSinceEpoch();\n+            quint64 now = usecTimestampNow() / 1000;\n             quint64 dt = now - _outputStarveDetectionStartTimeMsec;\n             if (dt > _outputStarveDetectionPeriodMsec) {\n                 _outputStarveDetectionStartTimeMsec = now;\n", "fix_pattern": "<pattern>: if the code uses QDateTime::currentMSecsSinceEpoch to get the current time in milliseconds, replace it with a custom, possibly optimized function like usecTimestampNow() that returns the required value in a more efficient manner."}
{"number": 272, "change": "@@ -87,7 +87,7 @@ public:\n         AudioOutputIODevice(MixedProcessedAudioStream& receivedAudioStream, AudioClient* audio) :\n             _receivedAudioStream(receivedAudioStream), _audio(audio), _unfulfilledReads(0) {};\n \n-        void start() { open(QIODevice::ReadOnly); }\n+        void start() { open(QIODevice::ReadOnly | QIODevice::Unbuffered); }\n         void stop() { close(); }\n         qint64 readData(char * data, qint64 maxSize) override;\n         qint64 writeData(const char * data, qint64 maxSize) override { return 0; }\n", "fix_pattern": "<pattern>: if the `open` method is called on a `QIODevice` with just `QIODevice::ReadOnly`, enhance performance by using `QIODevice::Unbuffered` as well to minimize buffering overhead during I/O operations."}
{"number": 274, "change": "@@ -368,10 +368,8 @@ void CPNGFile::WaitForSaves()\n \t\tfirst = false;\n #ifdef HAVE_WINTHREAD\n \t\tSleep(100);\n-#elif defined (__APPLE__)\n+#else\n \t\tsched_yield();\n-#elif defined(HAVE_PTHREAD)\n-\t\tpthread_yield();\n #endif\n \t}\n }\n", "fix_pattern": "<pattern>: if there is a conditional branch for a specific platform that includes a call to `pthread_yield()`, then refactor it to eliminate the call in favor of a more generalized fallback without the platform-specific behavior."}
{"number": 276, "change": "@@ -38,10 +38,10 @@ namespace ospray {\n       {\n         Group  *g = this->group;\n         Action *actions[SEND_WINDOW_SIZE];\n+        MPI_Request request[SEND_WINDOW_SIZE];\n         while (1) {\n           // usleep(80);\n           size_t numActions = g->sendQueue.getSome(actions,SEND_WINDOW_SIZE);\n-          auto *request = (MPI_Request*)alloca(numActions*sizeof(MPI_Request));\n           for (int i=0;i<numActions;i++) {\n             Action *action = actions[i];\n             MPI_CALL(Isend(action->data,action->size,MPI_BYTE,\n", "fix_pattern": "<pattern>: if using alloca to allocate a temporary array, instead replace it with a fixed-size array declaration to avoid potential stack overflow issues and improve performance by using stack allocation directly."}
{"number": 277, "change": "@@ -115,7 +115,7 @@ void UploadHeap::UploadToResource(gxeng::CopyCommandList& cmdList, LinearBuffer&\n \tgxapi::MemoryRange noReadRange{0, 0};\n \tvoid* stagePtr = stagedRes->Map(0, &noReadRange);\n \tmemcpy(stagePtr, data, size);\n-\tstagedRes->Unmap(0);\n+\t// No need to unmap (see https://msdn.microsoft.com/en-us/library/windows/desktop/dn788712(v=vs.85).aspx)\n \n \t{\n \t\tgxapi::TransitionBarrier stageToSrc;\n", "fix_pattern": "<pattern>: if the API method Unmap is unnecessary and can be omitted based on documentation, then remove the call to improve performance by avoiding the overhead of unnecessary operations."}
{"number": 278, "change": "@@ -184,7 +184,7 @@ void Plugin::Interface::H264Interface::get_defaults(obs_data_t *data) {\n \tobs_data_set_default_int(data, AMF_H264_RATECONTROLMETHOD, (int32_t)H264RateControlMethod::ConstantBitrate);\n \tobs_data_set_default_int(data, AMF_H264_BITRATE_TARGET, 3500);\n \tobs_data_set_default_int(data, AMF_H264_BITRATE_PEAK, 9000);\n-\tobs_data_set_default_int(data, AMF_H264_QP_MINIMUM, 0);\n+\tobs_data_set_default_int(data, AMF_H264_QP_MINIMUM, 11);\n \tobs_data_set_default_int(data, AMF_H264_QP_MAXIMUM, 51);\n \tobs_data_set_default_int(data, AMF_H264_QP_IFRAME, 22);\n \tobs_data_set_default_int(data, AMF_H264_QP_PFRAME, 22);\n", "fix_pattern": "<pattern>: if a default integer value is being set with `obs_data_set_default_int`, ensure that the value being set is meaningful and relevant to the application; updating from `0` to `11` suggests a change in the default configuration for performance or quality, indicating a preference for a higher minimum quality parameter."}
{"number": 280, "change": "@@ -88,7 +88,7 @@ int main(int argc, char **argv)\n         while (true)\n         {\n             clockMgr->Tick();\n-            svcSleepThread(3000000000ULL);\n+            svcSleepThread(250000000ULL);\n         }\n \n         ProcessManagement::Exit();\n", "fix_pattern": "<pattern>: if a sleep function is called with an excessively long duration (in this case, 3 seconds), reduce the sleep duration to a more reasonable time (in this case, 0.25 seconds) to improve responsiveness and performance."}
{"number": 286, "change": "@@ -56,9 +56,7 @@ OperatorHandle Dispatcher::findOrRegisterSchema_(FunctionSchema&& schema, Operat\n   const auto found = findSchema(schema.operator_name());\n   if (found != c10::nullopt) {\n     if (found->schema() != schema) {\n-      std::ostringstream str;\n-      str << schema << \" vs \" << found->schema();\n-      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", str.str());\n+      TORCH_CHECK(false, \"Tried to register multiple operators with the same name and the same overload name but different schemas: \", schema, \" vs \", found->schema());\n     }\n     if (options.isDefaultAliasAnalysisKind()) {\n       // just do nothing and let it pass.\n", "fix_pattern": "<pattern>: if creating a temporary `std::ostringstream` to format a string is detected, replace it with direct string concatenation in the `TORCH_CHECK` call for improved performance and reduced object construction overhead."}
{"number": 287, "change": "@@ -54,7 +54,7 @@ static auto reg =\n   F(prim::TupleConstruct)\n \n StaticRuntime::StaticRuntime(const torch::jit::Module& m)\n-    : module_(m.deepcopy()), graph_(nullptr) {\n+    : module_(m.copy()), graph_(nullptr) {\n   module_.eval();\n   module_ = freeze_module(module_);\n   graph_ = module_.get_method(\"forward\").graph();\n", "fix_pattern": "<pattern>: if an API call creates a deep copy using a method like `deepcopy`, refactor it to use a shallower copy with `copy` for performance improvements, as it may be less resource-intensive."}
{"number": 288, "change": "@@ -38,7 +38,6 @@\n #include \"audio/dcblocker.h\"\n #include \"logger.h\"\n #include \"manager.h\"\n-#include \"cc_thread.h\"\n \n #include <cstdlib>\n #include <fstream>\n@@ -252,7 +251,7 @@ std::string PulseLayer::getAudioDeviceName(int index, PCMType type) const\n void PulseLayer::createStreams(pa_context* c)\n {\n     while (enumeratingSinks_ or enumeratingSources_)\n-        ost::Thread::sleep(20 /* ms */);\n+        usleep(20000); // 20 ms\n \n     std::string playbackDevice(preference_.getPulseDevicePlayback());\n     std::string captureDevice(preference_.getPulseDeviceRecord());\n", "fix_pattern": "<pattern>: if a platform-specific sleep function (like ost::Thread::sleep) is used which may involve more overhead, replace it with a more efficient platform-specific alternative (like usleep) for better performance in timing control."}
{"number": 291, "change": "@@ -147,10 +147,10 @@ PyObject *slotCall(PyObject *self, PyObject *args, PyObject * /* kw */)\n             data->slotName = strdup(Shiboken::String::toCString(funcName));\n         }\n \n-\n-        QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n-        QByteArray signature = QString().sprintf(\"%s(%s)\", data->slotName, data->args).toUtf8();\n-        signature = returnType + \" \" + signature;\n+        const QByteArray returnType = QMetaObject::normalizedType(data->resultType);\n+        const QByteArray signature =\n+            returnType + ' ' + const_cast<const char *>(data->slotName)\n+            + '(' + const_cast<const char *>(data->args) + ')';\n \n         if (!pySlotName)\n             pySlotName = Shiboken::String::fromCString(PYSIDE_SLOT_LIST_ATTR);\n", "fix_pattern": "<pattern>: if QByteArray is being constructed multiple times from QString while using sprintf, replace it with direct QByteArray concatenation to avoid unnecessary conversions and improve performance. Additionally, use const correctness to avoid unnecessary copies."}
{"number": 292, "change": "@@ -110,11 +110,8 @@ int main(int argc, char ** argv)\n \t\tif (argc != 1)\n \t\t\tthrow std::runtime_error(i18n(\"no document specified\"));\n \n-\t\tcainteoir::document_events events;\n \t\trdf::graph metadata;\n-\t\tif (!cainteoir::parseDocument(argv[0], events, metadata))\n-\t\t\tfprintf(stderr, i18n(\"unsupported document format for file \\\"%s\\\"\\n\"), argv[0]);\n-\n+\t\tauto reader = cainteoir::createDocumentReader(argv[0], metadata, std::string());\n \t\tif (!metadata.empty())\n \t\t{\n \t\t\tif (output_type == rdf_metadata)\n", "fix_pattern": "<pattern>: if an API method (`cainteoir::parseDocument`) that processes files is replaced by a different method (`cainteoir::createDocumentReader`) that may offer better performance or efficiency, identify that the change signifies a shift towards a potentially more optimized API call for handling document reading while maintaining the context associated with the operation."}
{"number": 293, "change": "@@ -85,7 +85,7 @@ public:\n \t{\n \t\tif (mHandle)\n \t\t{\n-\t\t\tsnd_pcm_drain(mHandle);\n+\t\t\tsnd_pcm_drop(mHandle);\n \t\t\tsnd_pcm_close(mHandle);\n \t\t\tmHandle = nullptr;\n \t\t}\n", "fix_pattern": "<pattern>: if a function is used to wait for sound buffers to drain (snd_pcm_drain), replace it with a function that drops the buffers instead (snd_pcm_drop) for potentially better performance when immediate shutdown is desired."}
{"number": 295, "change": "@@ -118,7 +118,9 @@ QList<QAudioDevice> QOpenSLESEngine::availableDevices(QAudioDevice::Mode mode)\n           jobjectArray devsArray = static_cast<jobjectArray>(devs.object());\n           const jint size = env->GetArrayLength(devsArray);\n           for (int i = 0; i < size; ++i) {\n-              QString val = QJniObject(env->GetObjectArrayElement(devsArray, i)).toString();\n+              auto devElement = env->GetObjectArrayElement(devsArray, i);\n+              QString val = QJniObject(devElement).toString();\n+              env->DeleteLocalRef(devElement);\n               int pos = val.indexOf(QStringLiteral(\":\"));\n               devices << (new QOpenSLESDeviceInfo(\n                               val.left(pos).toUtf8(), val.mid(pos+1), mode))->create();\n", "fix_pattern": "<pattern>: if a local reference is obtained through an API method and there is potential for memory leaks, extract the local reference to a variable, and ensure to delete it using the appropriate method to manage resources effectively."}
{"number": 296, "change": "@@ -1100,10 +1100,11 @@ QMediaMetaData QGstreamerMediaPlayer::metaData() const\n \n void QGstreamerMediaPlayer::setVideoSink(QVideoSink *sink)\n {\n+    using namespace std::chrono_literals;\n     gstVideoOutput->setVideoSink(sink);\n \n-    if (state() != QMediaPlayer::StoppedState)\n-        playerPipeline.flush(); // ensure that we send video frame to the new sink\n+    if (playerPipeline.state(1s) == GstState::GST_STATE_PAUSED)\n+        playerPipeline.flush(); // ensure that we send the current video frame to the new sink\n }\n \n static QGstStructureView endOfChain(const QGstStructureView &s)\n", "fix_pattern": "<pattern>: if a state check can be replaced with a more specific equivalent from a different API that uses a duration-based waiting mechanism, refactor the code to utilize that alternative for improved clarity and potential performance optimizations in state handling."}
{"number": 297, "change": "@@ -254,7 +254,7 @@ QSSGShaderCache::QSSGShaderCache(QSSGRhiContext &ctx,\n         m_persistentShaderStorageFileName = persistentQsbcFileName();\n         if (!m_persistentShaderStorageFileName.isEmpty()) {\n             const bool skipCacheFile = qEnvironmentVariableIntValue(\"QT_QUICK3D_NO_SHADER_CACHE_LOAD\");\n-            if (!skipCacheFile && QFileInfo(m_persistentShaderStorageFileName).exists()) {\n+            if (!skipCacheFile && QFileInfo::exists(m_persistentShaderStorageFileName)) {\n                 if (shaderDebug)\n                     qDebug(\"Attempting to seed material shader cache from %s\", qPrintable(m_persistentShaderStorageFileName));\n                 if (m_persistentShaderBakingCache.load(m_persistentShaderStorageFileName)) {\n", "fix_pattern": "<pattern>: if an instance of QFileInfo is created just to check for file existence, replace it with a static method call QFileInfo::exists for better performance."}
{"number": 298, "change": "@@ -176,7 +176,7 @@ bool CSG_Grid::Save(const CSG_String &FileName, int Format)\n \t\tSG_RUN_TOOL(bResult, \"io_gdal\", 2,\t// Export GeoTIFF\n \t\t\t    SG_TOOL_PARAMLIST_ADD(\"GRIDS\"   , this)\n \t\t\t&&\tSG_TOOL_PARAMETER_SET(\"FILE\"    , FileName)\n-            &&\tSG_TOOL_PARAMETER_SET(\"OPTIONS\" , SG_T(\"COMPRESS=LZW\"))\n+            &&\tSG_TOOL_PARAMETER_SET(\"OPTIONS\" , SG_T(\"COMPRESS=LZW BIGTIFF=YES\"))\t\t// enable bigtiff as the 'if needed' default setting is not available for compressed files\n \t\t);\n \t\tbreak;\n \t}\n", "fix_pattern": "<pattern>: if an API parameter is being set conditionally, and the default behavior is not sufficient, expand the API parameters to include necessary options that enhance functionality or performance, as demonstrated by adding an additional option to support \"BIGTIFF\" for compressed files."}
{"number": 300, "change": "@@ -86,7 +86,7 @@ public:\n TEST(TimeSequencer, simple)\n {\n   rclcpp::Node::SharedPtr node = std::make_shared<rclcpp::Node>(\"test_node\");\n-  TimeSequencer<Msg> seq(rclcpp::Duration(1, 0), rclcpp::Duration(0, 10000000), 10, node);\n+  TimeSequencer<Msg> seq(rclcpp::Duration(0, 250000000), rclcpp::Duration(0, 10000000), 10, node);\n   Helper h;\n   seq.registerCallback(std::bind(&Helper::cb, &h, _1));\n   MsgPtr msg(std::make_shared<Msg>());\n@@ -97,7 +97,8 @@ TEST(TimeSequencer, simple)\n   rclcpp::spin_some(node);\n   ASSERT_EQ(h.count_, 0);\n \n-  rclcpp::Rate(1).sleep();\n+  // Must be longer than the first duration above\n+  rclcpp::Rate(3).sleep();\n   rclcpp::spin_some(node);\n \n   ASSERT_EQ(h.count_, 1);\n", "fix_pattern": "<pattern>: if the sleep duration of rclcpp::Rate is too short and can be optimized for performance, increase the rate to a higher value while adjusting the sleep duration accordingly, thereby reducing unnecessary CPU cycles spent in waiting."}
{"number": 301, "change": "@@ -100,7 +100,7 @@ void data_source_ocv_avcodec::write( const uint8_t * data, size_t bytes )\n             int w = pCodecCtx->width;\n             int h = pCodecCtx->height;\n \n-            img_convert_ctx = sws_getContext(w, h, pCodecCtx->pix_fmt, w, h, PIX_FMT_BGR24, SWS_BICUBIC,NULL, NULL, NULL);\n+            img_convert_ctx = sws_getContext(w, h, pCodecCtx->pix_fmt, w, h, AV_PIX_FMT_BGR24, SWS_FAST_BILINEAR ,NULL, NULL, NULL);\n             if(img_convert_ctx == NULL)\n             {\n                 fprintf(stderr, \"Cannot initialize the conversion context!\\n\");\n@@ -112,7 +112,7 @@ void data_source_ocv_avcodec::write( const uint8_t * data, size_t bytes )\n         // Blit\n         output_image->imageData = (char*)pFrameRGB->data[0];\n         cvShowImage(m_name,output_image);\n-        cvWaitKey(10);\n+        cvWaitKey(1);\n         output_image->imageData = NULL;\n         cvReleaseImageHeader( &output_image );\n     }\n", "fix_pattern": "<pattern>: if sws_getContext is called with a specific scaling algorithm that is computationally expensive (such as SWS_BICUBIC), consider switching to a faster alternative (like SWS_FAST_BILINEAR) for performance improvements. Additionally, if cvWaitKey is set to a longer delay (like 10 ms), reduce it to a lower value (like 1 ms) to allow for more frequent processing."}
{"number": 303, "change": "@@ -26,13 +26,15 @@ NormalMover::NormalMover(const Particles &pis,\n \n void NormalMover::generate_move(float scale)\n {\n-  std::vector<Float> center(number_of_float_keys());\n-  boost::uniform_01<RandomNumberGenerator> u01(random_number_generator);\n   boost::normal_distribution<double> mrng(0, stddev_);\n+  boost::variate_generator<RandomNumberGenerator&,\n+                           boost::normal_distribution<double> >\n+                          sampler(random_number_generator, mrng);\n+\n   for (unsigned int i = 0; i < number_of_particles(); ++i) {\n     for (unsigned int j = 0; j < number_of_float_keys(); ++j) {\n       float c = get_float(i, j);\n-      float r = mrng(u01);\n+      float r = sampler();\n       // Check for NaN (x!=x when x==NaN) (can only use std::isnan with C99)\n       IMP_assert(r == r, \"Bad random\");\n       IMP_assert(c == c, \"Bad stored\");\n", "fix_pattern": "<pattern>: if a uniform random number generator is being used to generate random numbers, replace it with a variate generator supplying a normal distribution for potentially better performance and efficiency in generating random samples based on the defined distribution."}
{"number": 304, "change": "@@ -2184,15 +2184,15 @@ ObjectFileELF::ParseSymbols (Symtab *symtab,\n     static ConstString bss_section_name(\".bss\");\n     static ConstString opd_section_name(\".opd\");    // For ppc64\n \n-    // On Android the oatdata and the oatexec symbols in system@framework@boot.oat covers the full\n-    // .text section what causes issues with displaying unusable symbol name to the user and very\n-    // slow unwinding speed because the instruction emulation based unwind plans try to emulate all\n+    // On Android the oatdata and the oatexec symbols in the oat files covers the full .text\n+    // section what causes issues with displaying unusable symbol name to the user and very slow\n+    // unwinding speed because the instruction emulation based unwind plans try to emulate all\n     // instructions in these symbols. Don't add these symbols to the symbol list as they have no\n     // use for the debugger and they are causing a lot of trouble.\n     // Filtering can't be restricted to Android because this special object file don't contain the\n     // note section specifying the environment to Android but the custom extension and file name\n     // makes it highly unlikely that this will collide with anything else.\n-    bool skip_oatdata_oatexec = m_file.GetFilename() == ConstString(\"system@framework@boot.oat\");\n+    bool skip_oatdata_oatexec = m_file.GetFileNameExtension() == ConstString(\"oat\");\n \n     ArchSpec arch;\n     GetArchitecture(arch);\n", "fix_pattern": "<pattern>: if checking the filename for specific symbols causes performance issues, switch from using the full filename to checking just the file name extension to reduce the comparison complexity."}
{"number": 305, "change": "@@ -69,9 +69,11 @@ static inline Tret SizeOfArray(const T(&)[N])\n #endif\n #include <windows.h>\n \n+static const HANDLE curproc = GetCurrentProcess();\n+\n static inline BOOL WriteData(void *writeaddress, const void *data, SIZE_T datasize, SIZE_T *byteswritten)\n {\n-\treturn WriteProcessMemory(GetCurrentProcess(), writeaddress, data, datasize, byteswritten);\n+\treturn WriteProcessMemory(curproc, writeaddress, data, datasize, byteswritten);\n }\n \n static inline BOOL WriteData(void *writeaddress, const void *data, SIZE_T datasize)\n", "fix_pattern": "<pattern>: if GetCurrentProcess() is called repeatedly in the context of WriteProcessMemory, store the result in a static variable to avoid repeated calls to this function, which can improve performance."}
{"number": 308, "change": "@@ -194,7 +194,7 @@ uint32_t scap_fd_info_len(scap_fdinfo *fdi)\n \t\tres += \n \t\t\tsizeof(uint64_t) + // unix source \n \t\t\tsizeof(uint64_t) +  // unix destination\n-\t\t\t(uint32_t)strlen(fdi->info.unix_socket_info.fname) + 2;\n+\t\t\t(uint32_t)strnlen(fdi->info.unix_socket_info.fname, SCAP_MAX_PATH_SIZE) + 2;\n \t\tbreak;\n \tcase SCAP_FD_FIFO:\n \tcase SCAP_FD_FILE:\n", "fix_pattern": "<pattern>: if the code uses strlen with an input that might exceed a specific maximum size, replace it with strnlen to prevent potential buffer over-read and improve safety."}
{"number": 309, "change": "@@ -499,12 +499,12 @@ void handleAccessMemory(void *arg, Sift::MemoryLockType lock_signal, Sift::Memor\n    if (mem_op == Sift::MemRead)\n    {\n       // The simulator is requesting data from us\n-      memcpy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n+      PIN_SafeCopy(data_buffer, reinterpret_cast<void*>(d_addr), data_size);\n    }\n    else if (mem_op == Sift::MemWrite)\n    {\n       // The simulator is requesting that we write data back to memory\n-      memcpy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n+      PIN_SafeCopy(reinterpret_cast<void*>(d_addr), data_buffer, data_size);\n    }\n    else\n    {\n", "fix_pattern": "<pattern>: if a direct memory copy using memcpy is detected, replace it with a specialized third-party API method (e.g., PIN_SafeCopy) that is designed for more efficient or safer handling of memory operations in the context of the application (e.g., ensuring safety when dealing with instrumentation in a Pin-based environment)."}
{"number": 310, "change": "@@ -114,7 +114,7 @@ int init_SDL(void)\n         fprintf(stderr, \"Unable to init SDL: %s\\n\", SDL_GetError());\n         return(0);\n     }\n-    sdlscreen = SDL_SetVideoMode(0,0, 32, SDL_SWSURFACE);\n+    sdlscreen = SDL_SetVideoMode(0,0, 16, SDL_SWSURFACE);\n \n     SDL_JoystickEventState(SDL_ENABLE);\n \tmyjoy[0]=SDL_JoystickOpen(0);\n", "fix_pattern": "<pattern>: when modifying the bit depth parameter (bpp) for SDL_SetVideoMode, reducing it from 32 to 16 can enhance performance by decreasing memory usage and potentially increasing rendering speed, especially in scenarios where high color depth is not necessary."}
{"number": 311, "change": "@@ -70,11 +70,16 @@ perf (bool decode)\n   double t = get_time();\n   for (int r = 0; r < RUNS; r++)\n     {\n-      notify_buffer.clear();\n+      bool write_ok = notify_buffer.start_write();\n+      assert (write_ok);\n       for (int i = 0; i < EVENTS; i++)\n         {\n           fill_notify_buffer (notify_buffer);\n         }\n+      notify_buffer.end_write();\n+\n+      bool read_ok = notify_buffer.start_read();\n+      assert (read_ok);\n       if (decode)\n         {\n           while (notify_buffer.remaining())\n@@ -84,6 +89,7 @@ perf (bool decode)\n               delete e;\n             }\n         }\n+      notify_buffer.end_read();\n     }\n   printf (\"%.2f events/sec (decode = %s)\\n\", (EVENTS * RUNS) / (get_time() - t), decode ? \"TRUE\" : \"FALSE\");\n }\n", "fix_pattern": "<pattern>: if a call to `notify_buffer.clear()` is replaced with `notify_buffer.start_write()` and `notify_buffer.end_write()`, indicating a performance improvement by using a write operation that likely aggregates and clears the buffer more efficiently than the clear operation did, then adopt that approach for managing the state of the buffer."}
{"number": 318, "change": "@@ -102,9 +102,9 @@ change_alpha( ssgBase *_branch, float _blend )\n   for (i = 0; i < ((ssgBranch *)_branch)->getNumKids(); i++)\n     change_alpha( ((ssgBranch *)_branch)->getKid(i), _blend );\n \n-  if ( strcmp(\"ssgLeaf\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVtxTable\", _branch->getTypeName()) &&\n-       strcmp(\"ssgVTable\", _branch->getTypeName()) )\n+  if ( !_branch->isAKindOf(ssgTypeLeaf())\n+       && !_branch->isAKindOf(ssgTypeVtxTable())\n+       && !_branch->isAKindOf(ssgTypeVTable()) )\n     return;\n \n   int num_colors = ((ssgLeaf *)_branch)->getNumColours();\n", "fix_pattern": "<pattern>: if multiple `strcmp` calls are used to check the type of an object, replace them with a single call to `isAKindOf` for each type, allowing for better performance and readability by avoiding unnecessary string comparisons and leveraging type checking directly."}
{"number": 319, "change": "@@ -197,7 +197,7 @@ inline int64_t MicroProfileTicksPerSecondCpu()\n inline uint64_t MicroProfileGetCurrentThreadId()\n {\t\n \tuint64_t tid;\n-\tpthread_threadid_np(pthread_self(), &tid);\n+\tpthread_threadid_np(nullptr, &tid);\n \treturn tid;\n }\n \n", "fix_pattern": "<pattern>: if pthread_threadid_np is called with pthread_self() to retrieve the current thread ID, replace it with nullptr to avoid the overhead of calling pthread_self() again, as pthread_threadid_np can directly work with nullptr to fetch the calling thread's ID."}
{"number": 321, "change": "@@ -7,6 +7,7 @@\n #pragma once\n \n #include <sys/types.h> // for u_char\n+#include <zeek/util.h>\n #include <cstdint>\n #include <cstdio>\n \n@@ -41,7 +42,8 @@ enum HashAlgorithm { Hash_MD5, Hash_SHA1, Hash_SHA224, Hash_SHA256, Hash_SHA384,\n inline const char* digest_print(const u_char* digest, size_t n) {\n     static char buf[ZEEK_DIGEST_PRINT_LENGTH];\n     for ( size_t i = 0; i < n; ++i )\n-        snprintf(buf + i * 2, 3, \"%02x\", digest[i]);\n+        zeek::util::bytetohex(digest[i], &buf[i * 2]);\n+    buf[2 * n] = '\\0';\n     return buf;\n }\n \n", "fix_pattern": "<pattern>: if snprintf is used to format binary data to hexadecimal strings, replace it with a specialized utility function (zeek::util::bytetohex) that may provide optimized performance for this specific conversion."}
{"number": 323, "change": "@@ -284,11 +284,12 @@ private:\n             auto [request, response] = StartAndWriteHeaders(method, url, headers);\n \n             if (body) {\n-                WaitFor(request->Write(*body))\n+                WaitFor(request->WriteBody(*body))\n+                    .ThrowOnError();\n+            } else {\n+                WaitFor(request->Close())\n                     .ThrowOnError();\n             }\n-            WaitFor(request->Close())\n-                .ThrowOnError();\n \n             // Waits for response headers internally.\n             response->GetStatusCode();\n", "fix_pattern": "<pattern>: if an API method has an overloaded function or a similar method that uses a more specific name (like WriteBody), replace the original method call (Write) with the more specific one (WriteBody) for clarity and potential performance improvements."}
{"number": 324, "change": "@@ -161,15 +161,13 @@ void MainWindow::InitializeUi() {\n }\n \n void MainWindow::ExpandCollapse(TreeState state) {\n-    // if it's connected during the call it's called for every item apparently, which is damn slow!\n-    disconnect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    disconnect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    // we block signals so that ResizeTreeColumns isn't called for every item, which is damn slow!\n+    ui->treeView->blockSignals(true);\n     if (state == TreeState::kExpand)\n         ui->treeView->expandAll();\n     else\n         ui->treeView->collapseAll();\n-    connect(ui->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n-    connect(ui->treeView, SIGNAL(collapsed(QModelIndex)), this, SLOT(ResizeTreeColumns()));\n+    ui->treeView->blockSignals(false);\n \n     ResizeTreeColumns();\n }\n", "fix_pattern": "<pattern>: if multiple disconnect and connect calls are made around a function that can be slow if called repeatedly (like ResizeTreeColumns), use blockSignals to prevent the signal from triggering during a performance-critical operation to improve efficiency."}
{"number": 326, "change": "@@ -1111,7 +1111,10 @@ template <typename U, typename T>\n inline bool read_and_close_socket_ssl(socket_t sock, SSL_CTX* ctx, U SSL_connect_or_accept, T callback)\n {\n     auto ssl = SSL_new(ctx);\n-    SSL_set_fd(ssl, sock);\n+\n+    auto bio = BIO_new_socket(sock, BIO_NOCLOSE);\n+    SSL_set_bio(ssl, bio, bio);\n+\n     SSL_connect_or_accept(ssl);\n \n     SSLSocketStream strm(ssl);\n", "fix_pattern": "<pattern>: if using SSL_set_fd for setting a socket to an SSL structure, refactor the code to use SSL_set_bio with BIO_new_socket instead, to leverage the additional flexibility and features provided by the BIO abstraction in OpenSSL."}
{"number": 329, "change": "@@ -169,7 +169,8 @@ void ToolModel::objectAdded(const QMetaObject *mo)\n     if (factory->supportedTypes().contains(mo->className())) {\n       m_inactiveTools.remove(factory);\n       factory->init(Probe::instance());\n-      emit dataChanged(index(0, 0), index(rowCount() - 1, 0));\n+      const int row = m_tools.indexOf(factory);\n+      emit dataChanged(index(row, 0), index(row, 0));\n     }\n   }\n   if (mo->superClass()) {\n", "fix_pattern": "<pattern>: if the code emits a signal for a range that spans the entire index, narrow it down to only the specific row that has changed to reduce unnecessary processing for listeners of the signal."}
{"number": 332, "change": "@@ -399,7 +399,8 @@ int main(int argc, char* argv[])\n                                 first = false;\n                             else\n                                 argument_builder.append(\", \"sv);\n-                            argument_builder.append(StringView(stream.copy_into_contiguous_buffer()).trim_whitespace());\n+                            ByteBuffer buffer = stream.copy_into_contiguous_buffer();\n+                            argument_builder.append(StringView(buffer).trim_whitespace());\n                         }\n                         dbgln(\"[wasm runtime] Stub function {} was called with the following arguments: {}\", name, argument_builder.to_string());\n                         Vector<Wasm::Value> result;\n", "fix_pattern": "<pattern>: if an API call is made to copy data into a contiguous buffer inline, separate that call into its own variable before using it, which can improve readability and potentially optimize performance by reducing unnecessary copies and exposing optimization opportunities."}
{"number": 334, "change": "@@ -122,8 +122,8 @@ void Job::on_socket_connected()\n                 }\n             }\n \n-            m_received_buffers.append(payload);\n             m_received_size += payload.size();\n+            m_received_buffers.append(move(payload));\n             flush_received_buffers();\n \n             deferred_invoke([this] { did_progress({}, m_received_size); });\n", "fix_pattern": "<pattern>: if an object is appended to a container in a manner that can lead to unnecessary copies, use std::move to transfer ownership and improve performance."}
{"number": 335, "change": "@@ -316,12 +316,6 @@ void Job::on_socket_connected()\n                 if (m_code == 204)\n                     return finish_up();\n \n-                can_read_line = m_socket->can_read_line();\n-                if (can_read_line.is_error())\n-                    return deferred_invoke([this] { did_fail(Core::NetworkJob::Error::TransmissionFailed); });\n-\n-                if (!can_read_line.value())\n-                    return;\n                 break;\n             }\n             auto parts = line.split_view(':');\n", "fix_pattern": "<pattern>: if a method call to check for a condition (like can_read_line) is followed by error checking and early returns, consider refactoring to handle both the condition check and error handling in a single call to reduce overhead from multiple API invocations and follow a more concise pattern."}
{"number": 336, "change": "@@ -20,8 +20,12 @@ CSSImportRule::CSSImportRule(AK::URL url, DOM::Document& document)\n {\n     dbgln_if(CSS_LOADER_DEBUG, \"CSSImportRule: Loading import URL: {}\", m_url);\n     auto request = LoadRequest::create_for_url_on_page(m_url, document.page());\n-    set_resource(ResourceLoader::the().load_resource(Resource::Type::Generic, request));\n+\n+    // NOTE: Mark this rule as delaying the document load event *before* calling set_resource()\n+    //       as it may trigger a synchronous resource_did_load() callback.\n     m_document_load_event_delayer.emplace(document);\n+\n+    set_resource(ResourceLoader::the().load_resource(Resource::Type::Generic, request));\n }\n \n CSSImportRule::~CSSImportRule()\n", "fix_pattern": "<pattern>: NA"}
{"number": 337, "change": "@@ -33,8 +33,10 @@ void HTMLLinkElement::inserted()\n         auto url = document().parse_url(href());\n         dbgln_if(CSS_LOADER_DEBUG, \"HTMLLinkElement: Loading import URL: {}\", url);\n         auto request = LoadRequest::create_for_url_on_page(url, document().page());\n-        set_resource(ResourceLoader::the().load_resource(Resource::Type::Generic, request));\n+        // NOTE: Mark this element as delaying the document load event *before* calling set_resource()\n+        //       as it may trigger a synchronous resource_did_load() callback.\n         m_document_load_event_delayer.emplace(document());\n+        set_resource(ResourceLoader::the().load_resource(Resource::Type::Generic, request));\n     }\n \n     if (m_relationship & Relationship::Preload) {\n", "fix_pattern": "<pattern>: NA"}
{"number": 338, "change": "@@ -410,7 +410,7 @@ void BlockFormattingContext::layout_block_level_children(BlockContainer const& b\n         }\n \n         content_height = max(content_height, box_state.offset.y() + box_state.content_height + box_state.margin_box_bottom());\n-        content_width = max(content_width, box_state.content_width);\n+        content_width = max(content_width, box_state.border_box_width());\n \n         if (independent_formatting_context)\n             independent_formatting_context->parent_context_did_dimension_child_root_box();\n", "fix_pattern": "<pattern>: If a method that returns a property (e.g., box_state.content_width) is replaced with a method that involves a computation (e.g., box_state.border_box_width()), ensure it provides a clearer and possibly more optimized calculation, suggesting a conscious choice to reference a potentially more efficient API method from the library."}
{"number": 339, "change": "@@ -36,8 +36,10 @@ void CanvasBox::paint(PaintContext& context, PaintPhase phase)\n         if (!context.viewport_rect().intersects(enclosing_int_rect(absolute_rect())))\n             return;\n \n-        if (dom_node().bitmap())\n-            context.painter().draw_scaled_bitmap(rounded_int_rect(absolute_rect()), *dom_node().bitmap(), dom_node().bitmap()->rect(), 1.0f, Gfx::Painter::ScalingMode::BilinearBlend);\n+        if (dom_node().bitmap()) {\n+            auto scaling_mode = computed_values().image_rendering() == CSS::ImageRendering::Pixelated ? Gfx::Painter::ScalingMode::NearestNeighbor : Gfx::Painter::ScalingMode::BilinearBlend;\n+            context.painter().draw_scaled_bitmap(rounded_int_rect(absolute_rect()), *dom_node().bitmap(), dom_node().bitmap()->rect(), 1.0f, scaling_mode);\n+        }\n     }\n }\n \n", "fix_pattern": "<pattern>: if a bitmap is being drawn using a scaling mode and there is a condition that determines the appropriate scaling mode based on computed values, refactor the code to compute the scaling mode only once before calling the draw method to avoid repeated checks or calculations."}
{"number": 340, "change": "@@ -154,10 +154,10 @@ void paint_background(PaintContext& context, Layout::NodeWithStyleAndBoxModelMet\n             // where round() is a function that returns the nearest natural number\n             // (integer greater than zero).\n             if (layer.repeat_x == CSS::Repeat::Round) {\n-                image_rect.set_width(background_positioning_area.width() / background_positioning_area.width() / image_rect.width());\n+                image_rect.set_width(background_positioning_area.width() / roundf(background_positioning_area.width() / image_rect.width()));\n             }\n             if (layer.repeat_y == CSS::Repeat::Round) {\n-                image_rect.set_height(background_positioning_area.height() / background_positioning_area.height() / image_rect.height());\n+                image_rect.set_height(background_positioning_area.height() / roundf(background_positioning_area.height() / image_rect.height()));\n             }\n \n             // If background-repeat is round for one dimension only and if background-size is auto\n", "fix_pattern": "<pattern>: if the division operation is performed using the same divisor in succession, consider using a rounding function to enhance the accuracy and possibly reduce the precision loss in the resulting calculations for width and height, thereby improving the overall performance of setting dimensions."}
{"number": 341, "change": "@@ -104,7 +104,7 @@ ErrorOr<u32> CanonicalCode::read_symbol(LittleEndianInputBitStream& stream) cons\n     u32 code_bits = 1;\n \n     for (;;) {\n-        code_bits = code_bits << 1 | TRY(stream.read_bits(1));\n+        code_bits = code_bits << 1 | TRY(stream.read_bit());\n         if (code_bits >= (1 << 16))\n             return Error::from_string_literal(\"Symbol exceeds maximum symbol number\");\n \n", "fix_pattern": "<pattern>: if a method reads multiple bits using a method that takes the number of bits as an argument, replace it with a method that reads a single bit to improve clarity and potentially reduce overhead for each bit read."}
{"number": 342, "change": "@@ -362,8 +362,9 @@ void DeflateDecompressor::close()\n \n ErrorOr<ByteBuffer> DeflateDecompressor::decompress_all(ReadonlyBytes bytes)\n {\n-    auto memory_stream = TRY(try_make<FixedMemoryStream>(bytes));\n-    auto deflate_stream = TRY(DeflateDecompressor::construct(make<LittleEndianInputBitStream>(move(memory_stream))));\n+    FixedMemoryStream memory_stream { bytes };\n+    LittleEndianInputBitStream bit_stream { MaybeOwned<Stream>(memory_stream) };\n+    auto deflate_stream = TRY(DeflateDecompressor::construct(MaybeOwned<LittleEndianInputBitStream>(bit_stream)));\n     AllocatingMemoryStream output_stream;\n \n     auto buffer = TRY(ByteBuffer::create_uninitialized(4096));\n", "fix_pattern": "<pattern>: if an object is constructed using an API function that may involve additional overhead (like TRY or try_make), directly construct the object using its constructor instead to improve performance."}
{"number": 343, "change": "@@ -63,9 +63,12 @@ public:\n     {\n         VERIFY(!ivec.is_empty());\n \n-        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(out.size()));\n+        static ByteBuffer dummy = MUST(ByteBuffer::create_uninitialized(T::BlockSizeInBits / 8));\n \n-        encrypt(in, out, ivec, dummy, dummy);\n+        // FIXME: Taking `out` by reference suggests that we should modify its length to match the\n+        //        ciphertext size. In practice, however, noone does that and I don't want to be the\n+        //        person who fixes this.\n+        encrypt(in, out.slice(0, in.size()), ivec, dummy, dummy);\n     }\n     virtual void decrypt(ReadonlyBytes in, Bytes& out, ReadonlyBytes ivec = {}) override\n     {\n", "fix_pattern": "<pattern>: if a ByteBuffer is created with its size determined by the `out` buffer which may vary in size, instead statically allocate a ByteBuffer of fixed size using known constants to optimize performance by avoiding dynamic size calculation during each call."}
{"number": 344, "change": "@@ -3,6 +3,7 @@\n */\n \n #include <iostream>\n+#include <random>\n \n #include <args.hxx>\n \n@@ -80,10 +81,17 @@ std::string get_random_nums_str( std::size_t count )\n \n std::vector< int > get_random_nums( std::size_t count )\n {\n+\tstd::random_device r;\n+\tstd::mt19937 gen{ r() };\n+\tstd::uniform_int_distribution< int > uniform_dist;\n+\n \tstd::vector< int > result;\n \tresult.reserve( count );\n \n-\tstd::generate_n( std::back_inserter( result ), count, [](){ return rand(); } );\n+\tstd::generate_n(\n+\t\tstd::back_inserter( result ),\n+\t\tcount,\n+\t\t[&](){ return uniform_dist( gen ); } );\n \n \treturn result;\n }\n", "fix_pattern": "<pattern>: if random numbers are being generated using the rand() function, replace it with the C++ `<random>` library for improved randomness quality and better performance characteristics by leveraging modern random number generation facilities."}
{"number": 346, "change": "@@ -101,7 +101,7 @@ bool AdminDatabase::ValidPassword(const char *username, const char *password)\n     QByteArray passb = m_prepared_select_account_passw.value(\"passw\").toByteArray();\n     QByteArray salt = m_prepared_select_account_passw.value(\"salt\").toByteArray();\n     QByteArray hashed_password = hasher.hashPassword(password, salt);\n-    if (memcmp(passb.data(),hashed_password.data(),passb.size()) == 0)\n+    if (memcmp(passb,hashed_password,passb.size()) == 0)\n         res = true;\n     return res;\n }\n", "fix_pattern": "<pattern>: if the data() method is used to retrieve raw data from a QByteArray for comparison with memcmp, directly pass the QByteArray objects to memcmp instead, optimizing performance by eliminating unnecessary calls to data() and improving type coherence."}
{"number": 347, "change": "@@ -232,8 +232,8 @@ void jniExceptionCheck(JNIEnv * env) {\n     if (!env) {\n         abort();\n     }\n-    const LocalRef<jthrowable> e(env->ExceptionOccurred());\n-    if (e) {\n+    if (env->ExceptionCheck()) {\n+        const LocalRef<jthrowable> e(env->ExceptionOccurred());\n         env->ExceptionClear();\n         jniThrowCppFromJavaException(env, e.get());\n     }\n", "fix_pattern": "<pattern>: if a method checks for an exception and then retrieves the exception object in a non-conditional manner, use ExceptionCheck() to avoid unnecessary exception object construction if no exception has occurred."}
{"number": 348, "change": "@@ -21,6 +21,7 @@\n \n #include <QEvent>\n #include <QEventLoop>\n+#include <QDeadlineTimer>\n #include <QSize>\n #include <QUrl>\n #include <QDir>\n@@ -230,10 +231,10 @@ void ViewPreview::UpdateFinishedState(bool okay)\n QVariant ViewPreview::EvaluateJavascript(const QString &javascript)\n {\n     JSResult * pres = new JSResult();\n-    int loop_count = 1000;\n-    page()->runJavaScript(javascript,SetJavascriptResultFunctor(pres));\n+    QDeadlineTimer deadline(5000);  // in milliseconds\n     qDebug() << \"evaluate javascript\" << javascript;\n-    while(!pres->isFinished() && (loop_count-- > 0)) {\n+    page()->runJavaScript(javascript,SetJavascriptResultFunctor(pres));\n+    while(!pres->isFinished() && (!deadline.hasExpired())) {\n         qApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers, 100);\n     }\n     QVariant res;\n", "fix_pattern": "<pattern>: if a loop is used to wait for a condition with a hardcoded maximum iteration count, replace it with a timed deadline check using QDeadlineTimer to improve performance by avoiding potential infinite loops and allowing a graceful exit after a specified duration."}
{"number": 349, "change": "@@ -594,17 +594,16 @@ out_err:\n \t\t\tif (strcmp(name, \".gnu_debuglink\") == 0) {\n \t\t\t\tconst char *p = (const char *)data->d_buf;\n \t\t\t\tm_debuglink.append(p);\n-\n-\t\t\t\tp += strlen(p);\n+\t\t\t\tconst char *endOfString = p + strlen(p) + 1;\n \n \t\t\t\t// Align address for the CRC32\n-\t\t\t\tunsigned long addr = (unsigned long)p;\n-\t\t\t\tunsigned long offs = 4;\n+\t\t\t\tunsigned long addr = (unsigned long)(endOfString - p);\n+\t\t\t\tunsigned long offs = 0;\n \n \t\t\t\tif ((addr & 3) != 0)\n \t\t\t\t\toffs = 4 - (addr & 3);\n \t\t\t\t// ... and read out the CRC32\n-\t\t\t\tm_debuglinkCrc = *(uint32_t *)(p + offs);\n+\t\t\t\tmemcpy((void *)&m_debuglinkCrc, endOfString + offs, sizeof(m_debuglinkCrc));\n \t\t\t}\n \n \t\t\tif ((sh_flags & (SHF_EXECINSTR | SHF_ALLOC)) != (SHF_EXECINSTR | SHF_ALLOC))\n", "fix_pattern": "<pattern>: if the code previously accesses memory using pointer arithmetic and casts directly from a string, refactor it to use memcpy for copying data to avoid potential alignment issues and improve safety when handling raw memory operations."}
{"number": 350, "change": "@@ -1,5 +1,5 @@\n /* emacs edit mode for this file is -*- C++ -*- */\n-/* $Id: int_pp.cc,v 1.4 1997-09-09 09:03:35 schmidt Exp $ */\n+/* $Id: int_pp.cc,v 1.5 1997-09-10 15:42:36 schmidt Exp $ */\n \n #include <config.h>\n \n@@ -376,7 +376,11 @@ int InternalPrimePower::intmod( int p ) const\n   return (int)mpz_mmod_ui( 0, &thempi, (unsigned long)p );\n }\n \n-int InternalPrimePower::sign ( ) const\n+//{{{ int InternalPrimePower::sign () const\n+// docu: see CanonicalForm::sign()\n+int\n+InternalPrimePower::sign () const\n {\n-    return mpz_cmp_si( &thempi, 0 );\n+    return mpz_sgn( &thempi );\n }\n+//}}}\n", "fix_pattern": "<pattern>: if an API method is being used to compare a multi-precision number with zero, prefer using a more direct method like `mpz_sgn` which checks the sign directly, instead of using `mpz_cmp_si`, which is less efficient for this specific operation."}
{"number": 352, "change": "@@ -355,8 +355,8 @@ static int PlayerQuit[PlayerMax];          /// Player quit\n static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int player = 255)\n {\n \tconst unsigned int size = packet.Size(numcommands);\n-\tunsigned char *buf = new unsigned char[size];\n-\tpacket.Serialize(buf, numcommands);\n+\tstd::vector<unsigned char> buf(size);\n+\tpacket.Serialize(buf.data(), numcommands);\n \n \t// Send to all clients.\n \tif (NetConnectType == 1) { // server\n@@ -366,14 +366,13 @@ static void NetworkBroadcast(const CNetworkPacket &packet, int numcommands, int\n \t\t\t\tif (Hosts[i].PlyNr == player) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tNetworkFildes.Send(host, buf, size);\n+\t\t\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t\t\t}\n \t\t}\n \t} else { // client\n \t\tconst CHost host(Hosts[0].Host, Hosts[0].Port);\n-\t\tNetworkFildes.Send(host, buf, size);\n+\t\tNetworkFildes.Send(host, buf.data(), buf.size());\n \t}\n-\tdelete[] buf;\n }\n \n /**\n", "fix_pattern": "<pattern>: if dynamic memory allocation is used to create a raw buffer (e.g., using `new`), replace it with a `std::vector` to manage memory automatically and improve safety and performance by eliminating the need for manual deallocation."}
{"number": 354, "change": "@@ -5491,7 +5491,7 @@ static void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {\n     }\n \n     /* read keys to be used for input */\n-    src = malloc(sizeof(zsetopsrc) * zsetnum);\n+    src = zmalloc(sizeof(zsetopsrc) * zsetnum);\n     for (i = 0, j = 3; i < zsetnum; i++, j++) {\n         robj *zsetobj = lookupKeyWrite(c->db,c->argv[j]);\n         if (!zsetobj) {\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, replace it with a project-specific memory allocation function (e.g., zmalloc) for better performance and potential benefits such as memory tracking or improved allocation strategies specific to the project."}
{"number": 355, "change": "@@ -851,8 +851,7 @@ static void repl() {\n                 }\n             }\n             /* Free the argument vector */\n-            while(argc--) sdsfree(argv[argc]);\n-            zfree(argv);\n+            sdsfreesplitres(argv,argc);\n         }\n         /* linenoise() returns malloc-ed lines like readline() */\n         free(line);\n", "fix_pattern": "<pattern>: if a loop is used to free memory for an array of pointers, replace it with a specific function designed to free all elements in a single call for better performance and readability."}
{"number": 357, "change": "@@ -226,9 +226,12 @@ int luaRedisGenericCommand(lua_State *lua, int raise_error) {\n     }\n \n     for (j = 0; j < argc; j++) {\n-        if (!lua_isstring(lua,j+1)) break;\n-        argv[j] = createStringObject((char*)lua_tostring(lua,j+1),\n-                                     lua_strlen(lua,j+1));\n+        char *obj_s;\n+        size_t obj_len;\n+\n+        obj_s = (char*)lua_tolstring(lua,j+1,&obj_len);\n+        if (obj_s == NULL) break; /* Not a string. */\n+        argv[j] = createStringObject(obj_s, obj_len);\n     }\n     \n     /* Check if one of the arguments passed by the Lua script\n", "fix_pattern": "<pattern>: if the code performs multiple Lua API calls to handle string data, replace calls to lua_tostring and lua_strlen with a single call to lua_tolstring, which provides both the string pointer and its length, reducing overhead."}
{"number": 358, "change": "@@ -991,7 +991,7 @@ int rewriteAppendOnlyFile(char *filename) {\n \n     /* Make sure data will not remain on the OS's output buffers */\n     if (fflush(fp) == EOF) goto werr;\n-    if (aof_fsync(fileno(fp)) == -1) goto werr;\n+    if (fsync(fileno(fp)) == -1) goto werr;\n     if (fclose(fp) == EOF) goto werr;\n \n     /* Use RENAME to make sure the DB file is changed atomically only\n", "fix_pattern": "<pattern>: if a project-specific API method is replaced with a standard library method that provides the same functionality, use the standard method for potential performance improvements, as standard library functions are often optimized and more efficient."}
{"number": 359, "change": "@@ -1584,7 +1584,7 @@ static redisReply *sendScan(unsigned long long *it) {\n     assert(reply->element[1]->type == REDIS_REPLY_ARRAY);\n \n     /* Update iterator */\n-    *it = atoi(reply->element[0]->str);\n+    *it = strtoull(reply->element[0]->str, NULL, 10);\n \n     return reply;\n }\n", "fix_pattern": "<pattern>: if converting a string to an integer, replace atoi with strtoull for better performance and to avoid potential overflow issues, as strtoull handles larger values and is more precise in conversion."}
{"number": 360, "change": "@@ -463,7 +463,8 @@ static void writeVtuFile(const char* prefix, Numbering* n)\n void writeVtkFiles(const char* prefix, Mesh* m)\n {\n   double t0 = PCU_Time();\n-  writePvtuFile(prefix, m);\n+  if (!PCU_Comm_Self())\n+    writePvtuFile(prefix, m);\n   Numbering* n = numberOverlapNodes(m,\"apf_vtk_number\");\n   m->removeNumbering(n);\n   writeVtuFile(prefix, n);\n", "fix_pattern": "<pattern>: if the API method `writePvtuFile` is called without checking the communication rank (e.g., using `PCU_Comm_Self()`), wrap the call in a conditional to ensure it's only executed by the root process (typically rank 0 in parallel computation), thus preventing redundant writes in a parallel setting."}
{"number": 361, "change": "@@ -879,9 +879,7 @@ static void transform_tcam (GstTcamAutoFocus* self, GstBuffer* buf)\n     autofocus_update_focus(self->focus, clip(focus_auto_min, self->cur_focus, max));\n \n     GstMapInfo info = {};\n-    gst_buffer_make_writable(buf);\n-\n-    gst_buffer_map(buf, &info, GST_MAP_WRITE);\n+    gst_buffer_map(buf, &info, GST_MAP_READ);\n \n     img_descriptor img =\n         {\n", "fix_pattern": "<pattern>: if the code first makes a buffer writable using gst_buffer_make_writable and then maps it for writing, change the mapping to GST_MAP_READ when only read access is needed, thereby avoiding unnecessary write access overhead."}
{"number": 363, "change": "@@ -406,7 +406,14 @@ namespace SDL\n {\n   Texture::Texture(SDL_Surface* image)\n   {\n-    texture = SDL_DisplayFormatAlpha(image);\n+    if(!(image->flags & SDL_SRCALPHA) || !image->format->Amask)\n+    {\n+      texture = SDL_DisplayFormat(image);\n+    }\n+    else\n+    {\n+      texture = SDL_DisplayFormatAlpha(image);\n+    }\n     //width = texture->w;\n     //height = texture->h;\n     int numerator, denominator;\n", "fix_pattern": "<pattern>: if the image does not have an alpha channel or the SDL_SRCALPHA flag is not set, use SDL_DisplayFormat instead of SDL_DisplayFormatAlpha for better performance by avoiding unnecessary alpha handling."}
{"number": 364, "change": "@@ -498,8 +498,13 @@ void Battlenet::Session::HandleJoinRequestV2(WoWRealm::JoinRequestV2 const& join\n \n     memcpy(sessionKey + hmac.GetLength(), hmac2.GetDigest(), hmac2.GetLength());\n \n-    LoginDatabase.DirectPExecute(\"UPDATE account SET sessionkey = '%s', last_ip = '%s', last_login = NOW(), locale = %u, failed_logins = 0, os = '%s' WHERE id = %u\",\n-        ByteArrayToHexStr(sessionKey, 40, true).c_str(), GetRemoteIpAddress().to_string().c_str(), GetLocaleByName(_locale), _os.c_str(), _gameAccountInfo->Id);\n+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_LOGONPROOF);\n+    stmt->setString(0, ByteArrayToHexStr(sessionKey, 40, true).c_str());\n+    stmt->setString(1, GetRemoteIpAddress().to_string());\n+    stmt->setUInt32(2, GetLocaleByName(_locale));\n+    stmt->setString(3, _os);\n+    stmt->setString(4, _gameAccountInfo->Name);\n+    LoginDatabase.DirectExecute(stmt);\n \n     joinResponse->IPv4.emplace_back(*realm->ExternalAddress, realm->Port);\n     if (*realm->ExternalAddress != *realm->LocalAddress)\n", "fix_pattern": "<pattern>: if raw SQL queries are being constructed and executed directly, replace them with prepared statements to improve performance and security by avoiding SQL injection and allowing the database engine to optimize query execution."}
{"number": 365, "change": "@@ -887,7 +887,7 @@ class Simplex_tree {\n     while (true) {\n       if (begin1->first == begin2->first) {\n         Filtration_value filt = (std::max)({begin1->second.filtration(), begin2->second.filtration(), filtration_});\n-        intersection.push_back(std::pair<Vertex_handle, Node>(begin1->first, Node(NULL, filt)));\n+        intersection.emplace_back(begin1->first, Node(NULL, filt));\n         if (++begin1 == end1 || ++begin2 == end2)\n           return;  // ----->>\n       } else if (begin1->first < begin2->first) {\n", "fix_pattern": "<pattern>: if std::vector's push_back is used to create a new object that could be constructed in place, replace it with emplace_back to avoid unnecessary copy or move operations, improving performance."}
{"number": 367, "change": "@@ -226,7 +226,7 @@ bool Info::Read(XrdOssDF* fp, const std::string &fname)\n       for (int i =0; i < 16; ++i)\n       printf(\"%x\", m_store.m_cksum[i] & 0xff);\n     */\n-   if (strncmp(m_store.m_cksum, &tmpCksum[0], 16))\n+   if (memcmp(m_store.m_cksum, &tmpCksum[0], 16))\n    {\n       TRACE(Error, trace_pfx << \" buffer cksum and saved cksum don't match \\n\");\n       return false;\n", "fix_pattern": "<pattern>: if a comparison of two byte sequences is performed using strncmp, replace it with memcmp for improved performance, as memcmp is optimized for binary comparison and avoids string-specific nuances."}
{"number": 368, "change": "@@ -74,10 +74,9 @@ bool State::InstallHandlers(CURL *curl) {\n     // Older versions have poor transfer performance, corrected in curl commit cacdc27f.\n     curl_version_info_data *curl_ver = curl_version_info(CURLVERSION_NOW);\n     if (curl_ver->age > 0 && curl_ver->version_num >= 0x072600) {\n-        // Require a minimum speed from the transfer: must move at least 1MB every 2 minutes\n-        // (roughly 8KB/s).\n+        // Require a minimum speed from the transfer: 2 minute average must at least 10KB/s\n         curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 2*60);\n-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1024*1024);\n+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 10*1024);\n     }\n     return true;\n }\n", "fix_pattern": "<pattern>: if CURLOPT_LOW_SPEED_LIMIT is being set, adjust the limit calculation to a more appropriate value that reflects performance expectations, ensuring the speed requirement aligns with bytes per second rather than total bytes over an extended period."}
{"number": 369, "change": "@@ -1579,10 +1579,11 @@ int XrdHttpProtocol::StartChunkedResp(int code, const char *desc, const char *he\n /******************************************************************************/\n   \n int XrdHttpProtocol::ChunkResp(const char *body, long long bodylen) {\n-  if (ChunkRespHeader((bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen))\n+  long long content_length = (bodylen <= 0) ? (body ? strlen(body) : 0) : bodylen;\n+  if (ChunkRespHeader(content_length))\n     return -1;\n \n-  if (body && SendData(body, bodylen))\n+  if (body && SendData(body, content_length))\n     return -1;\n \n   return ChunkRespFooter();\n", "fix_pattern": "<pattern>: if the content length is calculated multiple times from the provided arguments, store the result in a variable to avoid redundant calculations, improving readability and potential performance due to less computation."}
{"number": 371, "change": "@@ -35,8 +35,7 @@ IceInternal::BasicOutputStream::BasicOutputStream(IceInternal::Instance* instanc\n Ice::InputStreamI::InputStreamI(const Ice::CommunicatorPtr& communicator, const vector<Byte>& data) :\n     _communicator(communicator), _is(IceInternal::getInstance(communicator).get(), this)\n {\n-    _is.b.resize(data.size());\n-    memcpy(&_is.b[0], &data[0], data.size());\n+    _is.writeBlob(data);\n     _is.i = _is.b.begin();\n }\n \n", "fix_pattern": "<pattern>: if a vector is resized and then populated using memcpy, replace the combination with a call to a more optimized method such as writeBlob(), which likely has internal optimizations for handling the data directly."}
{"number": 372, "change": "@@ -320,7 +320,7 @@ QList<QString> TessTools::getLanguages(QString datapath) {\n       QFileInfo fileInfo = list.at(i);\n       languages.append(QString(\"%1\").arg(fileInfo.baseName()));\n     }\n-    qSort(languages);\n+    std::sort(languages.begin(), languages.end());\n \n     return languages;\n }\n", "fix_pattern": "<pattern>: if the code is using qSort from the Qt library, replace it with std::sort from the Standard Library for better performance and compatibility with C++ algorithms."}
{"number": 376, "change": "@@ -140,8 +140,7 @@ bool FFmpegVideoDecoder::EnqueueVideoFrame(VideoSurface::Format surface_format,\n void FFmpegVideoDecoder::CopyPlane(size_t plane,\n                                    const VideoSurface& surface,\n                                    const AVFrame* frame) {\n-  DCHECK(surface.width % 4 == 0);\n-  DCHECK(surface.height % 2 == 0);\n+  DCHECK(surface.width % 2 == 0);\n   const uint8* source = frame->data[plane];\n   const size_t source_stride = frame->linesize[plane];\n   uint8* dest = surface.data[plane];\n@@ -151,7 +150,7 @@ void FFmpegVideoDecoder::CopyPlane(size_t plane,\n   if (plane != VideoSurface::kYPlane) {\n     bytes_per_line /= 2;\n     if (surface.format == VideoSurface::YV12) {\n-      copy_lines /= 2;\n+      copy_lines = (copy_lines + 1) / 2;\n     }\n   }\n   DCHECK(bytes_per_line <= source_stride && bytes_per_line <= dest_stride);\n", "fix_pattern": "<pattern>: if the original code checks conditions that could be optimized or simplified, adjust checks and calculations to improve performance and maintain the validity of the operation, specifically by refining down the modulus checks and modifying the way values are computed."}
{"number": 378, "change": "@@ -253,10 +253,10 @@ SSLNetVConnection::net_read_io(NetHandler *nh, EThread *lthread)\n       bytes += r;\n     }\n \n-  } while (ret == SSL_READ_READY || ret == SSL_READ_ERROR_NONE);\n+  } while ((ret == SSL_READ_READY && bytes == 0) || ret == SSL_READ_ERROR_NONE);\n \n   if (bytes > 0) {\n-    if (ret == SSL_READ_WOULD_BLOCK) {\n+    if (ret == SSL_READ_WOULD_BLOCK || ret == SSL_READ_READY) {\n       if (readSignalAndUpdate(VC_EVENT_READ_READY) != EVENT_CONT) {\n         Debug(\"ssl\", \"ssl_read_from_net, readSignal != EVENT_CONT\");\n         return;\n@@ -267,9 +267,8 @@ SSLNetVConnection::net_read_io(NetHandler *nh, EThread *lthread)\n   switch (ret) {\n   case SSL_READ_ERROR_NONE:\n   case SSL_READ_READY:\n-    // how did we exit the while loop above? should never happen.\n-    ink_debug_assert(false);\n-    break;\n+    readReschedule(nh);\n+    return;\n   case SSL_WRITE_WOULD_BLOCK:\n   case SSL_READ_WOULD_BLOCK:\n     if (lock.m.m_ptr != s->vio.mutex.m_ptr) {\n", "fix_pattern": "<pattern>: when exiting a loop based on specific read conditions, refine the loop's exit criteria to minimize unnecessary iterations and add a reschedule mechanism when those conditions are met, thus enhancing performance by reducing redundant checks and preventing unwanted flow."}
{"number": 382, "change": "@@ -139,7 +139,10 @@ const char *AGSLinux::GetAppOutputDirectory()\n }\n \n void AGSLinux::Delay(int millis) {\n-  usleep(millis);\n+  struct timespec ts;\n+  ts.tv_sec = 0;\n+  ts.tv_nsec = millis * 1000000;\n+  nanosleep(&ts, NULL);\n }\n \n unsigned long AGSLinux::GetDiskFreeSpaceMB() {\n", "fix_pattern": "<pattern>: if the usleep function is used for sleeping in microseconds, replace it with nanosleep for better precision and to provide a more flexible structure for specifying sleep time in nanoseconds."}
{"number": 383, "change": "@@ -191,7 +191,7 @@ struct buffer : public buffer_base {\n         int rem = (pos <= lim ? lim - pos : 0);\n \n         //rem << 2? wtf?\n-        memcpy(bf.get(), bf.get() + position(), rem << 2);\n+        memmove(bf.get(), bf.get() + position(), rem << 2);\n \n         position(rem);\n         limit(capacity());\n", "fix_pattern": "<pattern>: if a memory operation involves overlapping source and destination regions, replace memcpy with memmove to ensure correct behavior without undefined behavior, as memmove handles overlapping regions safely."}
{"number": 384, "change": "@@ -224,7 +224,8 @@ main(int argc, char *argv[])\n \tif(EventHandler(RWINITIALIZE, nil) == EVENTERROR)\n \t\treturn 0;\n \n-\tfloat lastTime = SDL_GetTicks();\n+\tUint64 lastTicks = SDL_GetPerformanceCounter();\n+\tconst float tickPeriod = 1.f / SDL_GetPerformanceFrequency();\n \tSDL_Event event;\n \tint mouseButtons = 0;\n \n@@ -297,12 +298,12 @@ main(int argc, char *argv[])\n \t\t\t}\n \t\t\t}\n \t\t}\n-\t\tfloat currTime  = SDL_GetTicks();\n-\t\tfloat timeDelta = (currTime - lastTime) * 0.001f;\n+\t\tUint64 currTicks = SDL_GetPerformanceCounter();\n+\t\tfloat timeDelta = (currTicks - lastTicks) * tickPeriod;\n \n \t\tEventHandler(IDLE, &timeDelta);\n \n-\t\tlastTime = currTime;\n+\t\tlastTicks = currTicks;\n \t}\n \n \tSDL_StopTextInput();\n", "fix_pattern": "<pattern>: if the original code uses SDL_GetTicks(), switch to using SDL_GetPerformanceCounter() for higher resolution timing, which improves the accuracy and performance of time measurements."}
{"number": 385, "change": "@@ -98,10 +98,13 @@ int test_rw_image_access_qualifier(cl_device_id device_id, cl_context context, c\n     return -1;\n     }\n \n+    MTdata mtData = init_genrand(gRandomSeed);\n     /* Fill input array with random values */\n     for (i = 0; i < size; i++) {\n-        input[i] = (unsigned int)(rand()/((double)RAND_MAX + 1)*255);\n+        input[i] = genrand_int32(mtData);\n     }\n+    free_mtdata(mtData);\n+    mtData = NULL;\n \n     /* Zero out output array */\n     for (i = 0; i < size; i++) {\n", "fix_pattern": "<pattern>: if a random number is generated using the standard `rand()` function, which has poor randomness quality and possible performance issues in a multi-threaded context, replace it with Mersenne Twister RNG functions (`init_genrand`, `genrand_int32`, and `free_mtdata`) for improved performance and better randomness quality."}
{"number": 386, "change": "@@ -33,7 +33,7 @@\n #include <wx/debug.h>\n #include <wx/fileconf.h>\n #include <wx/filename.h>\n-#include <wx/ffile.h>\n+#include <wx/wfstream.h>\n \n \n const wxChar* const traceSettings = wxT( \"KICAD_SETTINGS\" );\n@@ -392,9 +392,10 @@ bool JSON_SETTINGS::SaveToFile( const wxString& aDirectory, bool aForce )\n         std::stringstream buffer;\n         buffer << std::setw( 2 ) << *this << std::endl;\n \n-        wxFFile   file( path.GetFullPath(), \"wb\" );\n+        wxFFileOutputStream fileStream( path.GetFullPath(), \"wb\" );\n \n-        if( !file.IsOpened() || !file.Write( buffer.str().c_str(), buffer.str().size() ) )\n+        if( !fileStream.IsOk()\n+                || !fileStream.WriteAll( buffer.str().c_str(), buffer.str().size() ) )\n         {\n             wxLogTrace( traceSettings, \"Warning: could not save %s\", GetFullFilename() );\n             success = false;\n", "fix_pattern": "<pattern>: if wxFFile is used for file output, replace it with wxFFileOutputStream to leverage the optimized WriteAll method for performance improvements in file writing operations."}
{"number": 387, "change": "@@ -40,6 +40,7 @@\n #include <tools/pcb_actions.h>\n #include <wildcards_and_files_ext.h>\n #include <pcb_marker.h>\n+#include <pgm_base.h>\n #include <wx/filedlg.h>\n #include <wx/wupdlock.h>\n #include <widgets/appearance_controls.h>\n@@ -210,7 +211,7 @@ bool DIALOG_DRC::updateUI()\n     double cur = alg::clamp( 0.0, (double) m_progress.load() / m_maxProgress, 1.0 );\n \n     m_gauge->SetValue( KiROUND( cur * 1000.0 ) );\n-    wxSafeYield( this );\n+    Pgm().App().SafeYieldFor( this, wxEVT_CATEGORY_NATIVE_EVENTS );\n \n     return !m_cancelled;\n }\n", "fix_pattern": "<pattern>: if wxSafeYield is used, replace it with a project-specific alternative Pgm::SafeYieldFor to potentially add optimizations or context specific to event handling within the application's architecture."}
{"number": 388, "change": "@@ -483,10 +483,8 @@ private:\n           ModelPart::NodesContainerType::ContainerType& nodes = mrBodyModelPart.NodesArray();\n           int nodes_size = nodes.size();\n           // first of all we reste the node distance to 1.00 which is the maximum distnace in our normalized space.\n-#pragma omp parallel for firstprivate(nodes_size)\n-          for(int i = 0 ; i < nodes_size ; i++)\n-              nodes[i]->GetSolutionStepValue(DISTANCE) = 1.00;\n \n+            VariableUtils().SetVariable(DISTANCE, 1.00, nodes);\n \n             std::vector<CellType*> leaves;\n \n", "fix_pattern": "<pattern>: if parallel loop writes to a variable for each element in a collection, replace it with a utility function (e.g., VariableUtils::SetVariable) that optimizes the operation on the entire collection, reducing overhead and improving performance."}
{"number": 389, "change": "@@ -53,7 +53,8 @@ bool mitk::MovieGeneratorOpenCV::InitGenerator()\n \n bool mitk::MovieGeneratorOpenCV::AddFrame( void *data )\n {\n-  cvSetImageData(m_currentFrame,data,m_width*3);\n+  //cvSetImageData(m_currentFrame,data,m_width*3);\n+  memcpy(data,m_currentFrame->imageData,m_width*m_height*3);\n   cvWriteFrame(m_aviWriter,m_currentFrame);\n   return true;\n }\n", "fix_pattern": "<pattern>: if an API call is used to set image data, replace it with a direct memory copy using memcpy for improved performance, as this avoids the overhead associated with the API function and can lead to faster execution."}
{"number": 391, "change": "@@ -39,7 +39,7 @@\n #include \"vtkUnsignedLongArray.h\"\n #include \"vtkUnsignedShortArray.h\"\n \n-vtkCxxRevisionMacro(vtkCompleteArrays, \"1.8\");\n+vtkCxxRevisionMacro(vtkCompleteArrays, \"1.9\");\n vtkStandardNewMacro(vtkCompleteArrays);\n \n vtkCxxSetObjectMacro(vtkCompleteArrays,Controller,vtkMultiProcessController);\n@@ -101,10 +101,7 @@ int vtkCompleteArrays::RequestData(\n       {\n       noNeed = 1;\n       }\n-    for (idx = 1; idx < numProcs; ++idx)\n-      {\n-      this->Controller->Send(&noNeed, 1, idx, 3389001);\n-      }\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n@@ -151,7 +148,7 @@ int vtkCompleteArrays::RequestData(\n     }\n   else\n     { // remote processes\n-    this->Controller->Receive(&noNeed, 1, 0, 3389001);\n+    this->Controller->Broadcast(&noNeed, 1, 0);\n     if (noNeed)\n       {\n       return 1;\n", "fix_pattern": "<pattern>: if a loop is used to send messages individually to multiple destinations using the Send method, replace it with a Broadcast call to streamline communication, reducing overhead."}
{"number": 392, "change": "@@ -28,7 +28,7 @@\n #include <QRegExp>\n \n vtkStandardNewMacro(vtkSMXYChartViewProxy);\n-vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.7\");\n+vtkCxxRevisionMacro(vtkSMXYChartViewProxy, \"1.8\");\n //----------------------------------------------------------------------------\n vtkSMXYChartViewProxy::vtkSMXYChartViewProxy()\n {\n@@ -53,6 +53,8 @@ vtkContextView* vtkSMXYChartViewProxy::NewChartView()\n   // Construct a new chart view and return the view of it\n   this->Chart = vtkChartXY::New();\n   this->ChartView->GetScene()->AddItem(this->Chart);\n+  // Do not use the buffer id for now - performance issues.\n+  this->ChartView->GetScene()->SetUseBufferId(false);\n \n   return this->ChartView;\n }\n", "fix_pattern": "<pattern>: if a performance issue is identified with the usage of buffer IDs in VTK's rendering context, disable the use of buffer IDs by calling `SetUseBufferId(false)` to potentially improve rendering performance while transitioning between versions."}
{"number": 394, "change": "@@ -901,7 +901,8 @@ static size_t VSICurlHandleWriteFunc( void *buffer, size_t count,\n static bool VSICurlIsS3SignedURL( const char* pszURL )\n {\n     return\n-        strstr(pszURL, \".s3.amazonaws.com/\") != NULL &&\n+        (strstr(pszURL, \".s3.amazonaws.com/\") != NULL ||\n+         strstr(pszURL, \".storage.googleapis.com/\") != NULL) &&\n         (strstr(pszURL, \"&Signature=\") != NULL ||\n          strstr(pszURL, \"?Signature=\") != NULL);\n }\n", "fix_pattern": "<pattern>: if multiple calls are made to strstr with the same haystack, combine checks for efficiency by using logical OR to minimize the number of function calls."}
{"number": 397, "change": "@@ -64,16 +64,17 @@ void DecimationFilter::seekToPoint(boost::uint64_t pointNum)\n boost::uint32_t DecimationFilter::readBuffer(PointData& dstData)\n {\n     // naive implementation: read a buffer N times larger, then pull out what we need\n-    PointData srcData(dstData.getSchemaLayout(), dstData.getNumPoints() * m_step);\n+    PointData srcData(dstData.getSchemaLayout(), dstData.getCapacity() * m_step);\n     boost::uint32_t numSrcPointsRead = m_prevStage.read(srcData);\n \n-    boost::uint32_t numPoints = dstData.getNumPoints();\n+    boost::uint32_t numPoints = dstData.getCapacity();\n     \n     boost::uint32_t srcIndex = 0;\n     boost::uint32_t dstIndex = 0;\n     for (dstIndex=0; dstIndex<numPoints; dstIndex++)\n     {\n         dstData.copyPointFast(dstIndex, srcIndex, srcData);\n+        dstData.setNumPoints(dstIndex+1);\n         srcIndex += m_step;\n         if (srcIndex > numSrcPointsRead) break;\n     }\n", "fix_pattern": "<pattern>: if the code constructs a PointData object using the number of points from getNumPoints, replace it with getCapacity to potentially utilize the maximum allowed capacity of the destination data structure to improve performance and avoid repeatedly re-evaluating point counts. Additionally, ensure that numPoints references the capacity for more efficient handling of point data."}
{"number": 398, "change": "@@ -3260,8 +3260,15 @@ void TV::ChangeChannel(int direction)\n \n QString TV::GetQueuedChanNum(void) const\n {\n+    static QRegExp regexp = QRegExp(\"([1-9]|\\\\w)\");\n+\n+    // avoid regular expression if queue is empty.\n+    if (queuedChanNum.isEmpty())\n+        return queuedChanNum;\n+\n     // strip initial zeros.\n-    int nzi = queuedChanNum.find(QRegExp(\"([1-9]|\\\\w)\"));\n+    regexp.setMinimal(true); // we don't need greedy matching\n+    int nzi = queuedChanNum.find(regexp);\n     if (nzi > 0)\n         queuedChanNum = queuedChanNum.right(queuedChanNum.length() - nzi);\n \n", "fix_pattern": "<pattern>: if a regular expression is created in every call, move the QRegExp object to a static variable to avoid repeated allocation and initialization overhead; also, set minimal matching to improve performance when searching."}
{"number": 400, "change": "@@ -150,7 +150,7 @@ WebSocketParser::addStreamData(const char* data, unsigned int len) {\n WebSocketFrame*\n WebSocketParser::getNextFrame() {\n   if (!mHeaderHandled) {\n-    char* pos = strstr(mData, \"\\r\\n\\r\\n\");\n+    char* pos = (char*) memmem(mData, mLength, \"\\r\\n\\r\\n\", 4);\n \n     if (pos) {\n       char* data = (char*) malloc(pos - mData);\n", "fix_pattern": "<pattern>: if the API method strstr is used for finding a substring in a large data buffer, replace it with the more efficient memmem function, which allows for specification of the length of the haystack, resulting in better performance."}
{"number": 402, "change": "@@ -89,7 +89,8 @@ public:\n             if (   ((flags() & kMethcla_BusMappingExternal) == kMethcla_BusMappingExternal)\n                 || ((flags() & kMethcla_BusMappingFeedback) == kMethcla_BusMappingFeedback)\n                 || (bus()->epoch() == env.epoch())) {\n-                memcpy(dst, bus()->data() + offset, numFrames * sizeof(sample_t));\n+                const sample_t* buffer = bus()->data();\n+                std::copy(buffer + offset, buffer + offset + numFrames, dst);\n             } else {\n                 memset(dst, 0, numFrames * sizeof(sample_t));\n             }\n", "fix_pattern": "<pattern>: if a memcpy operation copies a range of data from one location to another, consider using std::copy as a more expressive and potentially optimized alternative, which provides better type safety and integration with STL containers."}
{"number": 405, "change": "@@ -724,7 +724,7 @@ static bool ocl_gemm( InputArray matA, InputArray matB, double alpha,\n \n     UMat A = matA.getUMat(), B = matB.getUMat(), D = matD.getUMat();\n     if (haveC)\n-        ctrans ? transpose(matC, D) : matC.getMat().copyTo(D); // TODO fix it as soon as .copyTo works as expected\n+        ctrans ? transpose(matC, D) : matC.copyTo(D);\n     else\n         D.setTo(Scalar::all(0));\n \n", "fix_pattern": "<pattern>: if an unnecessary call to getMat() is performed before copying data to the destination, refactor the code to call copyTo() directly on the Mat object to optimize performance."}
{"number": 407, "change": "@@ -45,6 +45,7 @@\n \n /* Includes */\n #include <precomp.hpp>\n+#include <opencv2/core.hpp>\n #include <stdlib.h>\n #include <stdio.h>\n #include <stdint.h>\n@@ -476,11 +477,7 @@ inline int    RHO_HEST_REFC::initialize(void){\n     lm.tmp1     = NULL;\n     lm.Jte      = NULL;\n \n-#ifdef _WIN32\n-    fastSeed(rand());\n-#else\n-    fastSeed(random());\n-#endif\n+    fastSeed((unsigned)cv::theRNG());\n \n \n     int areAllAllocsSuccessful = ctrl.smpl   &&\n", "fix_pattern": "<pattern>: if the code uses platform-specific random number generation (like rand() for Windows or random() for other platforms), refactor it to use a central random number generator from a library (such as OpenCV's cv::theRNG) for better consistency and potentially improved performance."}
{"number": 408, "change": "@@ -30,14 +30,7 @@ namespace log4cpp {\n                                const std::string& fileName) : \n             LayoutAppender(name),\n             _fileName(fileName) {\n-#if defined(__OPENVMS__)\n-        // shr=get, File Sharing Options, Allow users to read\n-        // ctx=rec, Force record mode access\n-        // rop=rea, Record-processing options, Locks record for a read operation for this process, while allowing other accessors to read the record. \n-        _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644, \"shr=get\",\"ctx=rec\",\"rop=rea\");\n-#else\n         _fd = ::open(_fileName.c_str(), O_CREAT | O_APPEND | O_WRONLY, 00644);\n-#endif\n     }\n     \n     FileAppender::FileAppender(const std::string& name, int fd) :\n", "fix_pattern": "<pattern>: NA"}
{"number": 409, "change": "@@ -802,10 +802,10 @@ void flex_rewrite::quantized_graph_rewrite(deserialized_graph &dgraph) {\n         const dnnl_dims_t scales_dims {scales_zp_dim};\n         const auto scales_md\n                 = dnn_mem_t::init_md(1, scales_dims, dnnl_f32, tag::abx);\n-        dnn_mem_t scales_mem(\n-                scales_md, get_cpu_engine(), {false, scales.data()});\n-        dnn_mem_t dummy;\n-        fill_scales(e, dummy, scales_mem);\n+        dnn_mem_t scales_dt(\n+                scales_md, get_test_engine().get(), {false, scales.data()});\n+        dnn_mem_t scales_fp(scales_md, get_test_engine().get());\n+        fill_scales(e, scales_dt, scales_fp);\n \n         std::vector<int64_t> zps;\n         for (int64_t i = 0; i < scales_zp_dim; i++) {\n", "fix_pattern": "<pattern>: When using the DNNL library, if obtaining memory for a computation is done using a CPU engine, switch to using a test engine for memory allocation to potentially improve performance in testing scenarios, and ensure that both the destination and source memories are prepared for the operation being performed."}
{"number": 411, "change": "@@ -20,7 +20,7 @@ XMLException::XMLException(const string& msg)\n auto_ptr<XMLElement> XMLLoader::loadXML(const string& filename,\n                                         const string& systemID)\n {\n-\txmlDocPtr doc = xmlParseFile(filename.c_str());\n+\txmlDocPtr doc = xmlReadFile(filename.c_str(), NULL, 0);\n \tif (!doc) {\n \t\tthrow XMLException(filename + \": Document parsing failed\");\n \t}\n", "fix_pattern": "<pattern>: if the code is using xmlParseFile to parse an XML file, replace it with xmlReadFile, which allows for additional options and generally offers better performance and flexibility in handling XML parsing with more control over the input parameters."}
{"number": 412, "change": "@@ -2,7 +2,7 @@\n \n #include \"SDLImage.hh\"\n #include \"OutputSurface.hh\"\n-#include \"LocalFileReference.hh\"\n+#include \"File.hh\"\n #include \"MSXException.hh\"\n #include \"vla.hh\"\n #include \"build-info.hh\"\n@@ -183,10 +183,12 @@ static SDL_Surface* loadImage(\n \n SDL_Surface* SDLImage::readImage(const string& filename)\n {\n-\tLocalFileReference file(filename);\n-\tSDL_RWops *src = SDL_RWFromFile(file.getFilename().c_str(), \"rb\");\n+\tFile file(filename);\n+\tSDL_RWops *src = SDL_RWFromConstMem(file.mmap(), file.getSize());\n \tif (!src) {\n-\t\tthrow MSXException(\"Could not open image file \\\"\" + filename + \"\\\"\");\n+\t\tthrow MSXException(\n+\t\t\t\"Failed to create SDL_RWops for mmapped file \\\"\" + filename + \"\\\"\"\n+\t\t\t);\n \t}\n \tSDL_Surface* result = IMG_LoadPNG_RW(src);\n \tSDL_RWclose(src);\n", "fix_pattern": "<pattern>: if a file is opened with SDL_RWFromFile for reading, replace it with SDL_RWFromConstMem which utilizes memory mapping for potentially better performance, especially for large files."}
{"number": 414, "change": "@@ -2346,8 +2346,7 @@ QString &QString::remove(QChar ch, Qt::CaseSensitivity cs)\n */\n QString &QString::replace(int pos, int len, const QString &after)\n {\n-    QString copy = after;\n-    return replace(pos, len, copy.constData(), copy.length());\n+    return replace(pos, len, after.constData(), after.length());\n }\n \n /*!\n", "fix_pattern": "<pattern>: if a QString variable is created solely to pass its data to another function, eliminate the temporary variable by passing the data directly from the original QString object to avoid unnecessary copy overhead."}
{"number": 416, "change": "@@ -691,7 +691,7 @@ QString QSystemLocalePrivate::winToQtFormat(const QString &sys_fmt)\n             if (text == QLatin1String(\"'\"))\n                 result += QLatin1String(\"''\");\n             else\n-                result += QString(QLatin1Char('\\'') + text + QLatin1Char('\\''));\n+                result += QLatin1Char('\\'') + text + QLatin1Char('\\'');\n             continue;\n         }\n \n", "fix_pattern": "<pattern>: if a QString is appended with multiple concatenations involving QLatin1Char, refactor the code to eliminate the redundant use of QString's operator by combining the operations into a single expression, resulting in improved performance by reducing overhead."}
{"number": 417, "change": "@@ -110,7 +110,7 @@ int QCollator::compare(const QChar *s1, int len1, const QChar *s2, int len2) con\n     if (d->collator)\n         return ucol_strcoll(d->collator, (const UChar *)s1, len1, (const UChar *)s2, len2);\n \n-    return QString::compare(QString(s1, len1), QString(s2, len2), d->caseSensitivity);\n+    return QString::compare_helper(s1, len1, s2, len2, d->caseSensitivity);\n }\n \n int QCollator::compare(const QString &s1, const QString &s2) const\n", "fix_pattern": "<pattern>: if an API method (QString::compare) is potentially less efficient than a specialized helper (QString::compare_helper), replace calls to the less efficient method with the specialized helper to improve performance."}
{"number": 419, "change": "@@ -704,10 +704,9 @@ void QSslSocketBackendPrivate::transmit()\n                 // Write encrypted data from the buffer into the read BIO.\n                 int writtenToBio = q_BIO_write(readBio, data.constData(), encryptedBytesRead);\n \n-                // do the actual read() here and throw away the results.\n+                // Throw away the results.\n                 if (writtenToBio > 0) {\n-                    // ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek\n-                    plainSocket->read(data.data(), writtenToBio);\n+                    plainSocket->skip(writtenToBio);\n                 } else {\n                     // ### Better error handling.\n                     setErrorAndEmit(QAbstractSocket::SslInternalError,\n", "fix_pattern": "<pattern>: if data read from a socket is not needed, replace the read operation with skip() to avoid unnecessary memory copying and improve performance."}
{"number": 420, "change": "@@ -437,8 +437,6 @@ void QXcbWindow::create()\n \n     connection()->addWindowEventListener(m_window, this);\n \n-    xcb_change_window_attributes(xcb_connection(), m_window, mask, values);\n-\n     propagateSizeHints();\n \n     xcb_atom_t properties[5];\n", "fix_pattern": "<pattern>: if the xcb_change_window_attributes function is called without caching the xcb_connection() or if it creates a new xcb_connection for each call, ensure that the xcb_connection is stored in a variable to avoid the overhead of repeatedly calling the xcb_connection() function, thereby improving performance."}
{"number": 422, "change": "@@ -206,8 +206,8 @@ static inline QDBusMessage xdgDesktopPortalOpenFile(const QUrl &url)\n                                                               QLatin1String(\"org.freedesktop.portal.OpenURI\"),\n                                                               QLatin1String(\"OpenFile\"));\n \n-        QDBusUnixFileDescriptor descriptor(fd);\n-        qt_safe_close(fd);\n+        QDBusUnixFileDescriptor descriptor;\n+        descriptor.giveFileDescriptor(fd);\n \n         // FIXME parent_window_id and handle writable option\n         message << QString() << QVariant::fromValue(descriptor) << QVariantMap();\n", "fix_pattern": "<pattern>: if a file descriptor is being created in a stack object and immediately closed, instead use a method to give the file descriptor to an existing object, reducing overhead of construction and destruction."}
{"number": 423, "change": "@@ -209,7 +209,7 @@ public:\n     QStroker();\n     ~QStroker();\n \n-    void setStrokeWidth(qfixed width) { m_strokeWidth = width; m_curveThreshold = qt_real_to_fixed(width > 4 ? 1.0/width : 0.25); }\n+    void setStrokeWidth(qfixed width) { m_strokeWidth = width; m_curveThreshold = qt_real_to_fixed(qBound(0.025, 1.0/width, 0.25)); }\n     qfixed strokeWidth() const { return m_strokeWidth; }\n \n     void setCapStyle(Qt::PenCapStyle capStyle) { m_capStyle = joinModeForCap(capStyle); }\n", "fix_pattern": "<pattern>: if a value is conditionally assigned based on a threshold within a function, refactor the logic to use qBound() to enforce boundary conditions and avoid branching for improved performance and code readability."}
{"number": 424, "change": "@@ -797,8 +797,12 @@ QPixmap ScalableEntry::pixmap(const QSize &size, QIcon::Mode mode, QIcon::State\n     if (svgIcon.isNull())\n         svgIcon = QIcon(filename);\n \n-    // Simply reuse svg icon engine\n-    return svgIcon.pixmap(size, mode, state);\n+    // Bypass QIcon API, as that will scale by device pixel ratio of the\n+    // highest DPR screen since we're not passing on any QWindow.\n+    if (QIconEngine *engine = svgIcon.data_ptr() ? svgIcon.data_ptr()->engine : nullptr)\n+        return engine->pixmap(size, mode, state);\n+\n+    return QPixmap();\n }\n \n QPixmap QIconLoaderEngine::pixmap(const QSize &size, QIcon::Mode mode,\n", "fix_pattern": "<pattern>: if the QPixmap is being obtained through the `svgIcon.pixmap(...)` method of the QIcon class and there is a need to bypass the scaling performed by the QIcon API, directly access the QIconEngine to retrieve the pixmap. This avoids unnecessary scaling when the device pixel ratio is not relevant, leading to improved performance."}
{"number": 425, "change": "@@ -146,7 +146,7 @@ bool QPublicSuffixDatabase::loadFile(const QString &fileName)\n \n     auto header = systemFile->read(DafsaFileHeader.size());\n     if (header != DafsaFileHeader) {\n-        qCWarning(lcTld, \"Invalid publicsuffix file header: %s\", qUtf8Printable(header.toHex()));\n+        qCWarning(lcTld, \"Invalid publicsuffix file header: %s\", header.toHex().constData());\n         return false;\n     }\n \n", "fix_pattern": "<pattern>: if a QString is converted to a UTF-8 format using qUtf8Printable for logging, replace it with a direct call to constData() to avoid unnecessary conversions and improve performance."}
{"number": 426, "change": "@@ -2585,7 +2585,7 @@ static int qMetaTypeCustomType_unlocked(const char *typeName, int length)\n #if QT_CONFIG(thread)\n         Q_ASSERT(!reg->lock.tryLockForWrite());\n #endif\n-        if (auto ti = reg->aliases.value(QByteArray(typeName, length), nullptr)) {\n+        if (auto ti = reg->aliases.value(QByteArray::fromRawData(typeName, length), nullptr)) {\n             return ti->typeId;\n         }\n     }\n", "fix_pattern": "<pattern>: if a QByteArray is created using the constructor with QByteArray(typeName, length), then refactor the code to use QByteArray::fromRawData(typeName, length) for a more efficient creation without unnecessary overhead."}
{"number": 427, "change": "@@ -72,7 +72,7 @@ QString QTlsBackendOpenSSL::getErrorsFromOpenSsl()\n         if (!errorString.isEmpty())\n             errorString.append(\", \"_L1);\n         q_ERR_error_string_n(errNum, buf, sizeof buf);\n-        errorString.append(QString::fromLatin1(buf)); // error is ascii according to man ERR_error_string\n+        errorString.append(QLatin1StringView(buf)); // error is ascii according to man ERR_error_string\n     }\n     return errorString;\n }\n", "fix_pattern": "<pattern>: if QString::fromLatin1 is used to convert a Latin1 encoded string, replace it with QLatin1StringView to avoid unnecessary QString creation and improve performance, as QLatin1StringView provides a lightweight non-owning view of the string."}
{"number": 430, "change": "@@ -606,9 +606,8 @@ QByteArray qCompress(const uchar* data, qsizetype nbytes, int compressionLevel)\n             qToBigEndian(CompressSizeHint_t(nbytes), bazip.data());\n             break;\n         case Z_MEM_ERROR:\n-            qWarning(\"qCompress: Z_MEM_ERROR: Not enough memory\");\n-            bazip.resize(0);\n-            break;\n+            return tooMuchData(ZLibOp::Compression);\n+\n         case Z_BUF_ERROR:\n             len *= 2;\n             break;\n", "fix_pattern": "<pattern>: if there is a scenario where qWarning is called due to insufficient memory and the subsequent action is to resize a QByteArray to 0, replace it with an early return that indicates the error condition, thus avoiding unnecessary operations related to resizing the QByteArray and improving performance by reducing function overhead."}
{"number": 432, "change": "@@ -636,9 +636,13 @@ QString QTimeZonePrivate::isoOffsetFormat(int offsetFromUtc, QTimeZone::NameType\n \n QByteArray QTimeZonePrivate::ianaIdToWindowsId(const QByteArray &id)\n {\n+    // We don't have a Latin1/UTF-8 mixed comparator (QTBUG-100234),\n+    // so we have to allocate here...\n+    const auto idUtf8 = QString::fromUtf8(id);\n+\n     for (const QZoneData &data : zoneDataTable) {\n         for (auto l1 : data.ids()) {\n-            if (l1 == QByteArrayView(id))\n+            if (l1 == idUtf8)\n                 return toWindowsIdLiteral(data.windowsIdKey);\n         }\n     }\n", "fix_pattern": "<pattern>: if there is a comparison between QByteArrayView and a raw QByteArray or similar types, convert the raw QByteArray to a QString using QString::fromUtf8 for more reliable comparisons, acknowledging the potential overhead of dynamic allocation in mixed encoding scenarios."}
{"number": 435, "change": "@@ -107,13 +107,15 @@ static inline bool time_update(struct timespec *tv, const struct timespec &start\n     return tv->tv_sec >= 0;\n }\n \n-#if QT_CONFIG(poll_poll)\n+[[maybe_unused]]\n static inline int timespecToMillisecs(const struct timespec *ts)\n {\n-    return (ts == NULL) ? -1 :\n-           (ts->tv_sec * 1000) + (ts->tv_nsec / 1000000);\n+    using namespace std::chrono;\n+    if (!ts)\n+        return -1;\n+    auto ms = ceil<milliseconds>(timespecToChrono<nanoseconds>(*ts));\n+    return int(ms.count());\n }\n-#endif\n \n // defined in qpoll.cpp\n int qt_poll(struct pollfd *fds, nfds_t nfds, const struct timespec *timeout_ts);\n", "fix_pattern": "<pattern>: if converting a timespec structure to milliseconds, replace the manual calculation with a more expressive usage of std::chrono library functions for clarity and potential optimization; ensuring types are correctly evaluated for performance rather than relying on raw arithmetic."}
{"number": 436, "change": "@@ -1124,7 +1124,7 @@ static bool createDirectoryWithParents(const QByteArray &nativeName, mode_t mode\n bool QFileSystemEngine::createDirectory(const QFileSystemEntry &entry, bool createParents,\n                                         std::optional<QFile::Permissions> permissions)\n {\n-    QString dirName = entry.filePath();\n+    QByteArray dirName = entry.nativeFilePath();\n     Q_CHECK_FILE_NAME(dirName, false);\n \n     // Darwin doesn't support trailing /'s, so remove for everyone\n@@ -1132,14 +1132,13 @@ bool QFileSystemEngine::createDirectory(const QFileSystemEntry &entry, bool crea\n         dirName.chop(1);\n \n     // try to mkdir this directory\n-    QByteArray nativeName = QFile::encodeName(dirName);\n     mode_t mode = permissions ? QtPrivate::toMode_t(*permissions) : 0777;\n-    if (QT_MKDIR(nativeName, mode) == 0)\n+    if (QT_MKDIR(dirName, mode) == 0)\n         return true;\n     if (!createParents)\n         return false;\n \n-    return createDirectoryWithParents(nativeName, mode, false);\n+    return createDirectoryWithParents(dirName, mode, false);\n }\n \n //static\n", "fix_pattern": "<pattern>: if a QString is converted to a QByteArray using QFile::encodeName before being passed to QT_MKDIR, directly use the QByteArray result from entry.nativeFilePath() to avoid unnecessary conversion overhead."}
{"number": 437, "change": "@@ -609,7 +609,7 @@ struct PyHandler {\n                 }\n \n                 int rc;\n-                if (PyDict_Check(current.object))\n+                if (PyDict_CheckExact(current.object))\n                     // If it's a standard dictionary, this is +20% faster\n                     rc = PyDict_SetItem(current.object, key, value);\n                 else\n", "fix_pattern": "<pattern>: when checking for the exact type of a Python object (in this case, whether it is a dictionary), prefer using PyDict_CheckExact instead of the more general PyDict_Check to improve performance, as it avoids additional type checks and is more efficient in this specific context."}
{"number": 438, "change": "@@ -74,15 +74,13 @@ void MatrixFreePDE<dim,degree>::getIntegralMF(const MatrixFree<dim,double> &data\n \n         unsigned int num_q_points = var.n_q_points;\n \n-\t\tdealii::AlignedVector<dealii::VectorizedArray<double> > JxW(num_q_points);\n-\t\tvar.fill_JxW_values(JxW);\n-\n         //loop over quadrature points\n         for (unsigned int q=0; q<num_q_points; ++q){\n \t\t\tdealii::VectorizedArray<double> val = var.get_value(q);\n+\t\t\tdealii::VectorizedArray<double> jxw = var.JxW(q);\n \t\t\tassembler_lock.lock ();\n-\t\t\tfor (unsigned i=0; i<val.n_array_elements;i++){\n-\t\t\t\tintegrated_var += val[i]*JxW[q][i];\n+\t\t\tfor (unsigned i=0; i<val.size();i++){\n+\t\t\t\tintegrated_var += val[i]*jxw[i];\n \t\t\t}\n \t\t\tassembler_lock.unlock ();\n         }\n", "fix_pattern": "<pattern>: if the code directly fills a buffer for JxW values and then accesses it in a loop, replace the buffer fill with a direct access from the method returning the value for the specific quadrature point, thus avoiding unnecessary memory allocation and copying."}
{"number": 439, "change": "@@ -84,10 +84,15 @@ void tst_QPacketProtocol::init()\n     QVERIFY(m_server->listen(QHostAddress(\"127.0.0.1\")));\n \n     m_client = new QTcpSocket(this);\n+\n+    QSignalSpy serverSpy(m_server, SIGNAL(newConnection()));\n+    QSignalSpy clientSpy(m_client, SIGNAL(connected()));\n+\n     m_client->connectToHost(m_server->serverAddress(), m_server->serverPort());\n \n-    QVERIFY(m_client->waitForConnected());\n-    QVERIFY(m_server->waitForNewConnection(10000));\n+    QVERIFY(clientSpy.count() > 0 || clientSpy.wait());\n+    QVERIFY(serverSpy.count() > 0 || serverSpy.wait());\n+\n     m_serverConn = m_server->nextPendingConnection();\n }\n \n", "fix_pattern": "<pattern>: if the code uses synchronous blocking methods (like waitForConnected and waitForNewConnection) that can potentially stall execution, refactor it to utilize signals and slots with QSignalSpy, allowing for a non-blocking check of connection status while still waiting for events effectively."}
{"number": 440, "change": "@@ -3521,7 +3521,7 @@ void QQuickWindow::setColor(const QColor &color)\n     }\n     d->clearColor = color;\n     emit colorChanged(color);\n-    d->dirtyItem(contentItem());\n+    update();\n }\n \n QColor QQuickWindow::color() const\n", "fix_pattern": "<pattern>: if a call to `dirtyItem(contentItem())` is replaced with a call to `update()`, use `update()` directly to refresh the entire window instead of marking a specific item as dirty, potentially avoiding unnecessary updates and improving overall performance."}
{"number": 441, "change": "@@ -435,15 +435,14 @@ void QQuickWindow::physicalDpiChanged()\n void QQuickWindow::handleScreenChanged(QScreen *screen)\n {\n     Q_D(QQuickWindow);\n+    disconnect(d->physicalDpiChangedConnection);\n     if (screen) {\n         physicalDpiChanged();\n         // When physical DPI changes on the same screen, either the resolution or the device pixel\n         // ratio changed. We must check what it is. Device pixel ratio does not have its own\n         // ...Changed() signal.\n-        d->physicalDpiChangedConnection = connect(screen, SIGNAL(physicalDotsPerInchChanged(qreal)),\n-                                                  this, SLOT(physicalDpiChanged()));\n-    } else {\n-        disconnect(d->physicalDpiChangedConnection);\n+        d->physicalDpiChangedConnection = connect(screen, &QScreen::physicalDotsPerInchChanged,\n+                                                  this, &QQuickWindow::physicalDpiChanged);\n     }\n \n     d->forcePolish();\n", "fix_pattern": "<pattern>: if using the old SIGNAL/SLOT macros for connecting signals and slots, replace them with the new method syntax for better performance and type safety; also ensure proper disconnecting of existing connections before re-connecting."}
{"number": 443, "change": "@@ -571,7 +571,7 @@ Status TensorToNdarray(const Tensor& t, PyObject** ret) {\n   if (!status.ok()) {\n     return status;\n   }\n-  return TF_TensorToPyArray(std::move(tf_tensor), ret);\n+  return TF_TensorToMaybeAliasedPyArray(std::move(tf_tensor), ret);\n }\n \n }  // namespace tensorflow\n", "fix_pattern": "<pattern>: if an API function that directly converts a TensorFlow tensor to a Python array is replaced with a potentially more optimized function that allows for aliasing, then consider using TF_TensorToMaybeAliasedPyArray for better performance or reduced memory overhead."}
{"number": 446, "change": "@@ -119,7 +119,7 @@ void TriangleMesh::createCollisionShape(bool create_collision_object, const char\n     }\n     else\n     {\n-        bhv_triangle_mesh = new btBvhTriangleMeshShape(&m_mesh, true /* useQuantizedAabbCompression */);\n+        bhv_triangle_mesh = new btBvhTriangleMeshShape(&m_mesh, false /* useQuantizedAabbCompression */);\n \n         /*\n          // code to serialize triangle mesh\n", "fix_pattern": "<pattern>: if the parameter `useQuantizedAabbCompression` is set to `true` in the constructor of `btBvhTriangleMeshShape`, and performance analysis shows that setting it to `false` improves performance for the specific use case, refactor the code to set it to `false` instead, potentially reducing overhead in AABB compression handling."}
{"number": 447, "change": "@@ -177,7 +177,9 @@ void ServerLobby::initDatabase()\n     m_ip_geolocation_table_exists = false;\n     if (!ServerConfig::m_sql_management)\n         return;\n-    int ret = sqlite3_open(ServerConfig::m_database_file.c_str(), &m_db);\n+    int ret = sqlite3_open_v2(ServerConfig::m_database_file.c_str(), &m_db,\n+        SQLITE_OPEN_SHAREDCACHE | SQLITE_OPEN_FULLMUTEX |\n+        SQLITE_OPEN_READWRITE, NULL);\n     if (ret != SQLITE_OK)\n     {\n         Log::error(\"ServerLobby\", \"Cannot open database: %s.\",\n", "fix_pattern": "<pattern>: if a database connection is being opened with sqlite3_open, consider using sqlite3_open_v2 with appropriate flags to enable shared cache and full mutex support for improved performance and better concurrency control."}
{"number": 449, "change": "@@ -159,8 +159,8 @@ const QString get_dc_nickname(const char *model, uint32_t deviceid)\n {\n \tconst DiveComputerNode *existNode = dcList.getExact(model, deviceid);\n \tif (!existNode)\n-\t\treturn QString(\"\");\n-\tif (existNode->nickName != \"\")\n+\t\treturn QString();\n+\telse if (!existNode->nickName.isEmpty())\n \t\treturn existNode->nickName;\n \telse\n \t\treturn model;\n", "fix_pattern": "<pattern>: if returning an empty QString, use the default constructor QString() instead of QString(\"\") for better clarity and consistency; if checking for empty strings, utilize isEmpty() method instead of comparing to an empty string literal."}
{"number": 452, "change": "@@ -1,6 +1,6 @@\n \n /*\n- * $Id: HttpReply.cc,v 1.93 2007/05/18 06:41:22 amosjeffries Exp $\n+ * $Id: HttpReply.cc,v 1.94 2007/05/22 16:37:26 rousskov Exp $\n  *\n  * DEBUG: section 58    HTTP Reply (Response)\n  * AUTHOR: Alex Rousskov\n@@ -433,7 +433,7 @@ HttpReply::bodySize(method_t method) const\n \n bool HttpReply::sanityCheckStartLine(MemBuf *buf, http_status *error)\n {\n-    if (buf->contentSize() >= protoPrefix.size() && strncmp(protoPrefix, buf->content(), protoPrefix.size()) != 0) {\n+    if (buf->contentSize() >= protoPrefix.size() && protoPrefix.compare(buf->content(), protoPrefix.size()) != 0) {\n         debugs(58, 3, \"HttpReply::sanityCheckStartLine: missing protocol prefix (\" << protoPrefix << \") in '\" << buf->content() << \"'\");\n         *error = HTTP_INVALID_HEADER;\n         return false;\n", "fix_pattern": "<pattern>: if a comparison is performed between a C-style string using `strncmp`, replace it with the corresponding `std::string::compare` method for improved safety and potential performance, as it utilizes STL optimizations."}
{"number": 454, "change": "@@ -89,9 +89,9 @@ ACLMethodData::parse()\n \n     for (Tail = &values; *Tail; Tail = &((*Tail)->next));\n     while ((t = strtokFile())) {\n-        if (strcmp(t, \"PURGE\") == 0)\n-            ++ThePurgeCount; // configuration code wants to know\n         CbDataList<HttpRequestMethod> *q = new CbDataList<HttpRequestMethod> (HttpRequestMethod(t, NULL));\n+        if (q->element == Http::METHOD_PURGE)\n+            ++ThePurgeCount; // configuration code wants to know\n         *(Tail) = q;\n         Tail = &q->next;\n     }\n", "fix_pattern": "<pattern>: if comparing strings with `strcmp` for specific known constants, replace it with a direct comparison against enum values or constants for better readability and potential performance improvement."}
{"number": 456, "change": "@@ -36,8 +36,6 @@ inline uint32_t bitmask32(size_t bottom_bits) {\n class address_encryptor {\n public:\n   explicit address_encryptor(const std::array<address::byte_type, 32>& key) {\n-    EVP_CIPHER_CTX_init(ctx_.get());\n-    OpenSSL_add_all_ciphers();\n     cipher_ = EVP_get_cipherbyname(\"aes-128-ecb\");\n     block_size_ = EVP_CIPHER_block_size(cipher_);\n     pad_ = std::vector<address::byte_type>(block_size_);\n", "fix_pattern": "<pattern>: if EVP_CIPHER_CTX_init is called for initialization and OpenSSL_add_all_ciphers is called to register ciphers, consider that these initialization functions may be called multiple times in a program. Instead, initialize ctx_ once during application startup or before first use, and ensure OpenSSL_add_all_ciphers is invoked only once to reduce overhead."}
{"number": 458, "change": "@@ -309,9 +309,7 @@ enum RtMidiApi rtmidi_out_get_current_api (RtMidiPtr device)\n int rtmidi_out_send_message (RtMidiOutPtr device, const unsigned char *message, int length)\n {\n     try {\n-        // FIXME: use allocator to achieve efficient buffering\n-        std::vector<unsigned char> v (message, message + length);\n-        ((RtMidiOut*) device->ptr)->sendMessage (&v);\n+        ((RtMidiOut*) device->ptr)->sendMessage (message, length);\n         return 0;\n     }\n     catch (const RtMidiError & err) {\n", "fix_pattern": "<pattern>: if a std::vector is created to wrap a raw message buffer before sending it to the sendMessage API, refactor the code to directly pass the raw buffer and its length to the API to avoid unnecessary overhead of vector allocation and copying."}
{"number": 459, "change": "@@ -8,11 +8,13 @@\n \n #include <vector>\n \n+#include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n-#include <boost/thread.hpp>\n \n #include \"ITMImagePtrTypes.h\"\n \n+#include \"tvgutil/misc/ThreadPool.h\"\n+\n namespace spaint {\n \n /**\n@@ -93,8 +95,7 @@ public:\n   static void save_image_on_thread(const boost::shared_ptr<const ORUtils::Image<T> >& image, const std::string& path, ImageFileType fileType = IFT_UNKNOWN)\n   {\n     void (*p)(const boost::shared_ptr<const ORUtils::Image<T> >&, const std::string&, ImageFileType) = &save_image;\n-    boost::thread t(p, image, path, fileType);\n-    t.detach();\n+    tvgutil::ThreadPool::instance().start_asynch(boost::bind(p, image, path, fileType));\n   }\n \n   /**\n", "fix_pattern": "<pattern>: if a thread is created and detached using boost::thread, replace it with a ThreadPool implementation to manage threads more efficiently and reduce overhead from thread creation."}
{"number": 460, "change": "@@ -1683,8 +1683,10 @@ tr_bencToFile( const tr_benc * top, tr_fmt_mode mode, const char * filename )\n \n         /* save the benc to a temporary file */\n         {\n-            char * buf = tr_bencToStr( top, mode, &nleft );\n-            const char * walk = buf;\n+            struct evbuffer * buf = tr_bencToBuf( top, mode );\n+            const char * walk = (const char *) evbuffer_pullup( buf, -1 );\n+            nleft = evbuffer_get_length( buf );\n+\n             while( nleft > 0 ) {\n                 const int n = write( fd, walk, nleft );\n                 if( n >= 0 ) {\n@@ -1696,7 +1698,8 @@ tr_bencToFile( const tr_benc * top, tr_fmt_mode mode, const char * filename )\n                     break;\n                 }\n             }\n-            tr_free( buf );\n+\n+            evbuffer_free( buf );\n         }\n \n         if( nleft > 0 )\n", "fix_pattern": "<pattern>: if a string conversion is performed using `tr_bencToStr` which returns a temporary buffer that requires manual memory management with `tr_free`, switch to using `tr_bencToBuf` which utilizes an `evbuffer`. This change avoids manual string handling, leverages the functionality of `evbuffer` for efficiency, and incorporates a direct length retrieval process with `evbuffer_get_length`, simplifying memory management and potentially improving performance."}
{"number": 461, "change": "@@ -1135,11 +1135,9 @@ onCorePrefsChanged (TrCore * core UNUSED, const tr_quark key, gpointer gdata)\n   if (key == TR_KEY_peer_port)\n     {\n       struct network_page_data * data = gdata;\n-      gdk_threads_enter ();\n       gtr_label_set_text (GTK_LABEL (data->portLabel), _(\"Status unknown\"));\n       gtk_widget_set_sensitive (data->portButton, TRUE);\n       gtk_widget_set_sensitive (data->portSpin, TRUE);\n-      gdk_threads_leave ();\n     }\n }\n \n", "fix_pattern": "<pattern>: if the pair of gdk_threads_enter() and gdk_threads_leave() functions are called without any operations in between, it indicates unnecessary overhead for thread management; thus, remove these calls to enhance performance."}
{"number": 462, "change": "@@ -577,11 +577,10 @@ bool OS::FreeAddressSpaceReservation(AddressSpaceReservation reservation) {\n // static\n PlatformSharedMemoryHandle OS::CreateSharedMemoryHandleForTesting(size_t size) {\n #if V8_OS_LINUX && !V8_OS_ANDROID\n-  const char* shm_name = \"/V8_SharedMemoryForTesting\";\n-  int fd = shm_open(shm_name, O_RDWR | O_CREAT, S_IREAD | S_IWRITE);\n+  const char* name = \"V8MemFDForTesting\";\n+  int fd = memfd_create(name, MFD_CLOEXEC);\n   if (fd == -1) return kInvalidSharedMemoryHandle;\n   CHECK_EQ(0, ftruncate(fd, size));\n-  CHECK_EQ(0, shm_unlink(shm_name));\n   return SharedMemoryHandleFromFileDescriptor(fd);\n #else\n   return kInvalidSharedMemoryHandle;\n", "fix_pattern": "``` \n<pattern>: if shared memory using shm_open is used, replace it with memfd_create for better performance and reliability, as memfd_create does not require manual cleanup of the name and is only scoped to the lifetime of the file descriptor. \n```"}
{"number": 463, "change": "@@ -1525,10 +1525,10 @@ template <typename Adapter>\n       // Avoid binary search.\n       double fProcs = comm_->getSize();\n       double fParts = nGlobalParts_;\n-      double each = floor(fParts / fProcs);\n-      procMin = partId * each;\n-      while (procDist_[procMin+1] <= partId) procMin++;\n+      double each = fParts / fProcs;\n+      procMin = int(partId / each);\n       while (procDist_[procMin] > partId) procMin--;\n+      while (procDist_[procMin+1] <= partId) procMin++;\n       procMax = procMin;\n     }\n     else {\n", "fix_pattern": "<pattern>: if calculations involving division are done in a loop or multiple times, simplify them by reducing repeated operations and replace `floor()` with a direct integer division calculation to improve performance."}
{"number": 464, "change": "@@ -822,13 +822,12 @@ template <typename T>\n         if (len > 0)\n           sendVal = static_cast<size_t>(v0);\n     \n-        Array<size_t> sendBuf(nprocs, sendVal);\n-        ArrayRCP<size_t> recvBuf;\n+        size_t *recvBuf = new size_t[nprocs];\n     \n-        try{\n-          AlltoAll<size_t>(comm, env, sendBuf, 1, recvBuf);\n+        try {\n+          Teuchos::gatherAll<int, size_t>(comm, 1, &sendVal, nprocs, recvBuf);\n         }\n-        Z2_FORWARD_EXCEPTIONS;\n+        Z2_THROW_OUTSIDE_ERROR(env);\n     \n         int numNoIds = 0;  // number of procs with no ids\n         for (int i=0; i < nprocs; i++)\n@@ -877,6 +876,7 @@ template <typename T>\n             }\n           }\n         }\n+        delete [] recvBuf;\n       }\n     }  // all processes have locally consecutive values\n \n", "fix_pattern": "<pattern>: if an API call using a higher-level abstraction results in performance issues (such as memory allocation or copying overhead), refactor the code to use lower-level API calls that provide more efficient memory management and direct data handling (e.g., switching from `Array` to raw pointers for performance-critical sections)."}
{"number": 465, "change": "@@ -752,7 +752,7 @@ namespace Xpetra {\n       if (scalarA == zero)\n         return;\n \n-      size_t maxNumEntries = std::max(A.getNodeMaxNumRowEntries(), B.getNodeMaxNumRowEntries());\n+      size_t maxNumEntries = A.getNodeMaxNumRowEntries();\n \n       size_t    numEntries;\n       Array<GO> inds(maxNumEntries);\n@@ -770,7 +770,7 @@ namespace Xpetra {\n           for (size_t j = 0; j < numEntries; ++j)\n             vals[j] *= scalarA;\n \n-        B.insertGlobalValues(row, inds(), vals()); // insert should be ok, since blocks in BlockedCrsOpeartor do not overlap!\n+        B.insertGlobalValues(row, inds(0, numEntries), vals(0, numEntries)); // insert should be ok, since blocks in BlockedCrsOpeartor do not overlap!\n       }\n     }\n \n", "fix_pattern": "<pattern>: if the maximum number of entries is being calculated using std::max for two similar method calls to avoid unnecessary calculation, then directly use one of those values, assuming there\u2019s no risk in implying that both have the same value for the given context. Additionally, ensure that indices and values passed to the insert method are properly bounded to prevent additional overhead and potential memory issues."}
{"number": 467, "change": "@@ -89,7 +89,6 @@ void OxygenClient::init()\n \n     widget()->setAutoFillBackground(false);\n     widget()->setAttribute(Qt::WA_OpaquePaintEvent);\n-    widget()->setAttribute(Qt::WA_PaintOnScreen, false);\n }\n \n bool OxygenClient::decorationBehaviour(DecorationBehaviour behaviour) const\n", "fix_pattern": "<pattern>: NA"}
{"number": 468, "change": "@@ -291,11 +291,11 @@ void SceneXrender::flushBuffer(int mask, QRegion damage)\n         XFixesSetPictureClipRegion(display(), buffer, 0, 0, None);\n         XRenderComposite(display(), PictOpSrc, buffer, None, front, 0, 0, 0, 0, 0, 0, displayWidth(), displayHeight());\n         XFixesSetPictureClipRegion(display(), front, 0, 0, None);\n-        XFlush(display());\n+        XSync(display(), false);\n     } else {\n         // copy composed buffer to the root window\n         XRenderComposite(display(), PictOpSrc, buffer, None, front, 0, 0, 0, 0, 0, 0, displayWidth(), displayHeight());\n-        XFlush(display());\n+        XSync(display(), false);\n     }\n }\n \n", "fix_pattern": "<pattern>: if multiple consecutive calls to XFlush are detected, replace them with a single call to XSync with the discard parameter set to false for improved performance, as XSync may handle flushing more efficiently."}
{"number": 469, "change": "@@ -249,7 +249,7 @@ ColorCorrectionPrivate::ColorCorrectionPrivate(ColorCorrection *parent)\n \n     // Establish a D-Bus communication interface with KolorServer\n     m_csi = new ColorServerInterface(\n-        QStringLiteral(\"org.kde.kded\"),\n+        QStringLiteral(\"org.kde.kded5\"),\n         QStringLiteral(\"/modules/kolorserver\"),\n         QDBusConnection::sessionBus(),\n         this);\n", "fix_pattern": "<pattern>: if a QStringLiteral is being adjusted to use a specific versioning scheme in the context of an API (like 'kded5' instead of 'kded'), ensure the version is updated to maintain compatibility or performance benefits without direct performance implications."}
{"number": 470, "change": "@@ -223,8 +223,9 @@ QIcon Group::icon() const\n         return leader_client->icon();\n     else if (leader_wid != None) {\n         QIcon ic;\n-        auto readIcon = [&ic, this](int size, bool scale = true) {\n-            const QPixmap pix = KWindowSystem::icon(leader_wid, size, size, scale, KWindowSystem::NETWM | KWindowSystem::WMHints);\n+        NETWinInfo info(connection(), leader_wid, rootWindow(), NET::WMIcon, NET::WM2IconPixmap);\n+        auto readIcon = [&ic, &info, this](int size, bool scale = true) {\n+            const QPixmap pix = KWindowSystem::icon(leader_wid, size, size, scale, KWindowSystem::NETWM | KWindowSystem::WMHints, &info);\n             if (!pix.isNull()) {\n                 ic.addPixmap(pix);\n             }\n", "fix_pattern": "<pattern>: if the API method KWindowSystem::icon is called with parameters that require recalculating or recreating certain contexts like NETWinInfo on every call, refactor the code to create and reuse such context when it can be shared, thus reducing unnecessary overhead."}
{"number": 471, "change": "@@ -341,15 +341,10 @@ void Compositor::startupWithWorkspace()\n         vBlankInterval = milliToNano(1);\n     }\n \n-    // This means \"start now\" - we don't have even a slight idea when the first vsync will occur.\n-    m_timeSinceLastVBlank = fpsInterval - (options->vBlankTime() + 1);\n-    scheduleRepaint();\n-\n     // Sets also the 'effects' pointer.\n     kwinApp()->platform()->createEffectsHandler(this, m_scene);\n     connect(Workspace::self(), &Workspace::deletedRemoved, m_scene, &Scene::removeToplevel);\n     connect(effects, &EffectsHandler::screenGeometryChanged, this, &Compositor::addRepaintFull);\n-    addRepaintFull();\n \n     for (Client *c : Workspace::self()->clientList()) {\n         c->setupCompositing();\n@@ -384,6 +379,7 @@ void Compositor::startupWithWorkspace()\n     }\n \n     // Render at least once.\n+    addRepaintFull();\n     performCompositing();\n }\n \n", "fix_pattern": "<pattern>: if the first operation in a sequence is to schedule a repaint with potential resource overhead that is not immediately beneficial, and the repaint method that follows does not depend on the scheduled task, eliminate the unnecessary scheduling call to improve performance."}
{"number": 474, "change": "@@ -220,7 +220,7 @@ void PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)\n                 // Rotate to highest position, so it can be lopped\n                 // by decrementing e_phnum.\n                 memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));\n-                memcpy(phdr, 1+phdr, j * sizeof(*phdr));\n+                memmove(phdr, 1+phdr, j * sizeof(*phdr));  // overlapping\n                 memcpy(&phdr[j], (unsigned char *)ibuf, sizeof(*phdr));\n                 --phdr;\n                 set_te16(&ehdri.e_phnum, --e_phnum);\n", "fix_pattern": "<pattern>: if a memory copy operation involves overlapping regions, replace memcpy with memmove to ensure correct behavior and avoid potential data corruption."}
{"number": 475, "change": "@@ -379,7 +379,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n     model->materials[i].specular[2] = 0.0f;\n     model->materials[i].specular[3] = 1.0f;\n   }\n-  model->materials[0].name = strdup(\"default\");\n+  model->materials[0].name = std::string(\"default\");\n \n   /* now, read in the data */\n   nummaterials = 0;\n@@ -397,7 +397,7 @@ _glmReadMTL(GLMmodel* model, const std::string&name)\n       }\n       sscanf(buf, \"%s %s\", buf, buf);\n       nummaterials++;\n-      model->materials[nummaterials].name = strdup(buf);\n+      model->materials[nummaterials].name = std::string(buf);\n       break;\n     case 'N':\n       fscanf(file, \"%f\", &model->materials[nummaterials].shininess);\n", "fix_pattern": "<pattern>: if the API is using strdup to allocate strings, replace it with std::string to manage memory automatically and improve performance by eliminating unnecessary memory allocation and deallocation."}
{"number": 476, "change": "@@ -52,7 +52,6 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   int rowSize = ((3*imageW + 3) >> 2) << 2;      // how many bytes in the row (used to create padding)\n   //unsigned long fileSize = 2ul * imageH * imageW + 54; // pix data + 54 byte hdr\n   int fileSize = 54 + imageH*rowSize;        // headers (54 bytes) + pixel data\n-  memset(&rgbBuffer[rowSize - 4], 0, 4);\n \n   bmFlHdr[ 2] = (unsigned char)(fileSize      ); // all ints stored little-endian\n   bmFlHdr[ 3] = (unsigned char)(fileSize >>  8); // i.e., LSB first\n@@ -80,6 +79,9 @@ bool BMP_Encoder::encodeToFile( const char* filename, const int imageW, const in\n   outFile.write(bmInHdr, sizeof(bmInHdr));\n \n   uint8_t* buf = (uint8_t*)rgbBuffer;\n+\n+  // set zero to padding area\n+  memset(&buf[rowSize - 4], 0, 4);\n   for ( int i = imageH - 1; i >= 0; i-- ) {\n     _tft->readRectRGB( 0, i, imageW, 1, rgbBuffer ); // capture a whole line\n     int j = 0;\n", "fix_pattern": "<pattern>: the code removes unnecessary comments and maintains the use of `memset` to set a padding area to zero, which is already an efficient operation. There's no significant performance enhancement or refactoring taking place; thus, the pattern simply reflects the operation of zeroing out a memory region using `memset`."}
{"number": 479, "change": "@@ -1832,11 +1832,10 @@ bool wxGtkDataViewModelNotifier::ItemDeleted( const wxDataViewItem &parent, cons\n     GtkTreeIter parentIter;\n     parentIter.stamp = wxgtk_model->stamp;\n     parentIter.user_data = (gpointer) parent.GetID();\n-    wxGtkTreePath parentPath(wxgtk_tree_model_get_path(\n+    wxGtkTreePath path(wxgtk_tree_model_get_path(\n         GTK_TREE_MODEL(wxgtk_model), &parentIter ));\n \n     // and add the final index ourselves\n-    wxGtkTreePath path(gtk_tree_path_copy(parentPath));\n     int index = m_internal->GetIndexOf( parent, item );\n     gtk_tree_path_append_index( path, index );\n #endif\n@@ -1849,10 +1848,11 @@ bool wxGtkDataViewModelNotifier::ItemDeleted( const wxDataViewItem &parent, cons\n     // Did we remove the last child, causing 'parent' to become a leaf?\n     if ( !m_wx_model->IsContainer(parent) )\n     {\n+        gtk_tree_path_up(path);\n         gtk_tree_model_row_has_child_toggled\n         (\n             GTK_TREE_MODEL(wxgtk_model),\n-            parentPath,\n+            path,\n             &parentIter\n         );\n     }\n", "fix_pattern": "<pattern>: if a GtkTreePath is being created from a GtkTreeModel and unnecessary copies or constructions occur, replace those with an optimal API call like gtk_tree_path_up to navigate the tree structure efficiently."}
{"number": 480, "change": "@@ -350,7 +350,7 @@ __declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBase\n \n     if(!ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, pNumBytes))\n     {\n-        if(VirtualProtectEx(hProcess, lpBaseAddress, nSize, PAGE_EXECUTE_READWRITE, &dwProtect))\n+        if(VirtualProtectEx(hProcess, lpBaseAddress, nSize, PAGE_EXECUTE_READ, &dwProtect))\n         {\n             if(ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, pNumBytes))\n             {\n", "fix_pattern": "<pattern>: if the protection flag being set in VirtualProtectEx is unnecessary for the intended operation (e.g., changing to PAGE_EXECUTE_READ instead of PAGE_EXECUTE_READWRITE), modify the call to use a less permissive memory protection flag to improve security without sacrificing performance."}
{"number": 481, "change": "@@ -496,6 +496,7 @@ void\n GlassTable::compact(byte * p)\n {\n     LOGCALL_VOID(DB, \"GlassTable::compact\", (void*)p);\n+    Assert(p != buffer);\n     Assert(writable);\n     int e = block_size;\n     byte * b = buffer;\n@@ -504,10 +505,10 @@ GlassTable::compact(byte * p)\n \tItem item(p, c);\n \tint l = item.size();\n \te -= l;\n-\tmemmove(b + e, item.get_address(), l);\n+\tmemcpy(b + e, item.get_address(), l);\n \tsetD(p, c, e);  /* reform in b */\n     }\n-    memmove(p + e, b + e, block_size - e);  /* copy back */\n+    memcpy(p + e, b + e, block_size - e);  /* copy back */\n     e -= dir_end;\n     SET_TOTAL_FREE(p, e);\n     SET_MAX_FREE(p, e);\n", "fix_pattern": "<pattern>: if using memmove for non-overlapping memory regions, replace it with memcpy for better performance, ensuring to assert that the pointers do not point to the same buffer before copying."}
{"number": 482, "change": "@@ -189,8 +189,8 @@ void map_horizon::upload()\n \n void map_horizon::upload_minimap()\n {\n-  uint32_t texture[1024][1024];\n-  memset(texture, 0, 1024 * 1024 * sizeof(uint32_t));\n+  std::vector<uint32_t> texture(1024 * 1024);\n+  memset(texture.data(), 0, 1024 * 1024 * sizeof(uint32_t));\n \n   for (size_t y (0); y < 64; ++y)\n   {\n@@ -209,14 +209,14 @@ void map_horizon::upload_minimap()\n       {\n         for (size_t i (0); i < 16; ++i)\n         {\n-          texture[y * 16 + j][x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n+          texture[(y * 16 + j) * 1024 + x * 16 + i] = color_for_height (_tiles[y][x]->height_17[j][i]);\n         }\n       }\n     }\n   }\n \n   minimap.bind();\n-  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture);\n+  gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.data());\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n   gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n", "fix_pattern": "<pattern>: if a fixed-size array is allocated on the stack for a texture, replace it with a std::vector to take advantage of dynamic memory management and ensure better flexibility; also adjust indexing for one-dimensional access using a calculated index based on width."}
{"number": 483, "change": "@@ -225,7 +225,7 @@ MySQLClient::MySQLClient(\n \t}\n \n \t// increase the timeouts so that the connection doesn't get killed while trying to write large rowsets to the client over slow pipes\n-\texecute(\"SET SESSION net_read_timeout = 300, net_write_timeout = 600, sql_mode = 'traditional,pipes_as_concat'\");\n+\texecute(\"SET SESSION net_read_timeout = GREATEST(@@net_read_timeout, 600), net_write_timeout = GREATEST(@@net_write_timeout, 600), long_query_time = GREATEST(@@long_query_time, 600), sql_mode = 'traditional,pipes_as_concat'\");\n }\n \n MySQLClient::~MySQLClient() {\n", "fix_pattern": "<pattern>: if a query sets session variables with fixed values, refactor the query to utilize the GREATEST function to maintain or adjust existing session values, ensuring performance by preventing unnecessary resets and retaining potentially optimized configurations."}
{"number": 484, "change": "@@ -307,11 +307,10 @@ string PostgreSQLClient::escape_column_value(const Column &column, const string\n \n \tsize_t encoded_length;\n \tconst unsigned char *encoded = PQescapeByteaConn(conn, (const unsigned char *)value.c_str(), value.size(), &encoded_length);\n-\tstring result(encoded, encoded + encoded_length);\n+\tstring result(encoded, encoded + encoded_length - 1); // encoded_length includes the null terminator\n \tPQfreemem((void *)encoded);\n \n-\t// bizarrely, the bytea parser is an extra level on top of the normal escaping, so you still need the latter after PQescapeByteaConn, even though PQunescapeBytea doesn't do the reverse\n-\treturn escape_value(result);\n+\treturn result;\n }\n \n void PostgreSQLClient::convert_unsupported_database_schema(Database &database) {\n", "fix_pattern": "<pattern>: if a string is constructed using a range that includes a null terminator unnecessarily, adjust the range to exclude the null terminator for the final string construction to improve performance and reduce overhead."}
{"number": 487, "change": "@@ -335,12 +335,12 @@ private:\n \n         auto u         = sampler.next();\n \n-        if ( any(u < U(prob_diff)) )\n+        if ( any(sr.active && u < U(prob_diff)) )\n         {\n             diff       = diffuse_brdf_.sample_f(sr.normal, sr.view_dir, refl1, pdf1, sampler);\n         }\n \n-        if ( any(u >= U(prob_diff)) )\n+        if ( any(sr.active && u >= U(prob_diff)) )\n         {\n             spec       = specular_brdf_.sample_f(sr.normal, sr.view_dir, refl2, pdf2, sampler);\n         }\n", "fix_pattern": "<pattern>: if conditional checks are performed on a value such as `u` that may be evaluated multiple times, combine it with additional context like `sr.active` to avoid unnecessary evaluations and improve the efficiency of performance by limiting checks performed under specific conditions."}
{"number": 488, "change": "@@ -358,8 +358,7 @@ void JavaSalFrame::Show( BOOL bVisible, BOOL bNoActivate )\n \t\t\t\tmpVCLFrame->makeModal();\n \t\t}\n \n-\t\t// Update the menubar's top level menus\n-\t\tSetMenu( mpMenuBar );\n+\t\tUpdateMenusForFrame( this, NULL );\n \n \t\t// Get native window's content view since it won't be created until\n \t\t// first shown\n", "fix_pattern": "<pattern>: if a method directly sets menus using SetMenu, replace it with a more efficient method like UpdateMenusForFrame that can handle multiple updates or changes in one call, potentially improving performance by reducing redundant calls."}
{"number": 490, "change": "@@ -104,7 +104,7 @@ void Cwinproc::CalcAverages(double dbTotal, DWORD dwTime, DWORD dwBps, STATS_STR\n \t\n \t// Calculate average\n \tif (dwElapsed > 0)\n-\t\tpStats[0].ave = MulDiv((DWORD)dbSampleTotal, 1000, dwElapsed);\n+\t\tpStats[0].ave = (DWORD)(dbSampleTotal * 1000.0 / dwElapsed + 0.5);\n }\n \n \n", "fix_pattern": "<pattern>: if the Windows API function MulDiv is used to perform multiplication and division which may incur overhead, replace it with direct calculations for better performance, especially when the operations are simple arithmetic and the parameters are of a compatible type."}
{"number": 491, "change": "@@ -234,7 +234,7 @@ void OpenCL_platforms_list::Initialize(const std::string &_prefered_platform)\n \n     // Get a list of the OpenCL platforms available.\n     cl_platform_id *tmp_platforms;\n-    tmp_platforms = (cl_platform_id*) calloc_and_check(nb_platforms, sizeof(cl_platform_id), \"cl_platform_id*\");\n+    tmp_platforms = new cl_platform_id[nb_platforms];\n     err = clGetPlatformIDs(nb_platforms, tmp_platforms, NULL);\n     OpenCL_Test_Success(err, \"clGetPlatformIDs\");\n \n@@ -281,7 +281,8 @@ void OpenCL_platforms_list::Initialize(const std::string &_prefered_platform)\n         ++platform_id_offset;\n     }\n \n-    free_me(tmp_platforms, nb_platforms);\n+    delete[] tmp_platforms;\n+\n \n     /*\n     // Debugging: Add dummy platform\n", "fix_pattern": "<pattern>: if memory is allocated using a custom calloc function followed by a separate deallocation function, replace it with direct allocation and deallocation using new[] and delete[] for improved performance and simpler syntax."}
{"number": 493, "change": "@@ -246,6 +246,8 @@ int initialize(Engine& engine) {\n     finished_pixel_count.store(0);\n     for (int r = 0; r < g_convoluted_images.size(); ++r) {\n         g_convoluted_images[r] = Images::create2D(\"Convoluted image\", PixelFormat::RGB_Float, 1.0f, Vector2ui(image.get_width(), image.get_height()));\n+        RGB* pixels = (RGB*)g_convoluted_images[r].get_pixels();\n+\n         float roughness = r / (g_convoluted_images.size() - 1.0f);\n         float alpha = fmaxf(0.00000000001f, roughness * roughness * roughness);\n \n@@ -328,7 +330,7 @@ int initialize(Engine& engine) {\n \n             radiance /= float(g_options.sample_count);\n \n-            g_convoluted_images[r].set_pixel(RGBA(radiance), Vector2ui(x, y)); // TODO map the underlying array instead.\n+            pixels[x + y * image.get_width()] = radiance;\n \n             ++finished_pixel_count;\n             if (omp_get_thread_num() == 0)\n", "fix_pattern": "<pattern>: if an API method requires setting a pixel using set_pixel(RGBA color, Vector2ui position), optimize by directly accessing the underlying pixel array using get_pixels() and perform the assignment to improve performance, avoiding the overhead of method calls for each pixel update."}
{"number": 494, "change": "@@ -32,12 +32,14 @@\n #include <mutex>\n #include <thread>\n \n+#include <android-base/chrono_utils.h>\n #include <android-base/file.h>\n #include <android-base/logging.h>\n #include <android-base/properties.h>\n #include <android-base/stringprintf.h>\n \n using android::base::StringPrintf;\n+using android::base::boot_clock;\n using namespace std::chrono_literals;\n \n namespace android {\n@@ -50,9 +52,9 @@ static std::condition_variable g_bootcharting_finished_cv;\n static bool g_bootcharting_finished;\n \n static long long get_uptime_jiffies() {\n-  std::string uptime;\n-  if (!android::base::ReadFileToString(\"/proc/uptime\", &uptime)) return 0;\n-  return 100LL * strtod(uptime.c_str(), NULL);\n+    constexpr int64_t kNanosecondsPerJiffy = 10000000;\n+    boot_clock::time_point uptime = boot_clock::now();\n+    return uptime.time_since_epoch().count() / kNanosecondsPerJiffy;\n }\n \n static std::unique_ptr<FILE, decltype(&fclose)> fopen_unique(const char* filename,\n", "fix_pattern": "<pattern>: if reading from a file using ReadFileToString incurs file I/O overhead, replace it with a high-resolution clock implementation (like boot_clock) to retrieve uptime directly without file access, significantly improving performance."}
{"number": 496, "change": "@@ -1025,15 +1025,7 @@ void MainWindow::closeEvent(QCloseEvent *event)\n     {\n       saveFile();\n       while (net.isDirty())\n-      {\n-\ttick();\n-\tsleepRead();\n-\tsleepRead();\n-\tcanvas->tick();\n-\tsleepRead();\n-\tsleepRead();\n-\tsleepRead();\n-      }\n+\tQCoreApplication::processEvents();\n     }\n   }\n   if (acceptConv && acceptSave)\n", "fix_pattern": "<pattern>: if multiple sleepRead() calls are made that may block the event loop, replace them with QCoreApplication::processEvents() to improve responsiveness and ensure that the application can continue processing events during long-running operations."}
{"number": 498, "change": "@@ -2119,11 +2119,14 @@ void saveimage(const char *filename, int format, ImageData &image, bool flip = f\n             ImageData flipped(image.w, image.h, image.bpp, image.data);\n             if(flip) texflip(flipped);\n             SDL_Surface *s = wrapsurface(flipped.data, flipped.w, flipped.h, flipped.bpp);\n-            if(s) \n+            if(!s) break;\n+            stream *f = openfile(filename, \"wb\");\n+            if(f)\n             {\n-                SDL_SaveBMP(s, findfile(filename, \"wb\"));\n-                SDL_FreeSurface(s);\n+                SDL_SaveBMP_RW(s, f->rwops(), 1);\n+                delete f;\n             }\n+            SDL_FreeSurface(s);\n             break;\n         }\n     }\n", "fix_pattern": "<pattern>: if a surface is to be saved as a bitmap, replace the direct file save using SDL_SaveBMP with SDL_SaveBMP_RW for better control over the file stream, and also ensure the proper handling of file operations (e.g., checking if the file opened successfully)."}
{"number": 501, "change": "@@ -1988,7 +1988,7 @@ static int video_codec_init( producer_avformat self, int index, mlt_properties p\n #if LIBAVCODEC_VERSION_INT >= ((52<<16)+(72<<8)+2)\n \t\tmlt_log_debug( MLT_PRODUCER_SERVICE(self->parent), \"color_range %d\\n\", codec_context->color_range );\n \t\tif ( codec_context->color_range == AVCOL_RANGE_JPEG )\n-\t\t\tmlt_properties_set_int( properties, \"set.force_full_luma\", 1 );\n+\t\t\tself->full_luma = 1;\n #endif\n \t\tif ( mlt_properties_get( properties, \"set.force_full_luma\" ) )\n \t\t\tself->full_luma = mlt_properties_get_int( properties, \"set.force_full_luma\" );\n", "fix_pattern": "<pattern>: if a library API method is being used to set a simple property on an instance, replace the API call with a direct assignment to avoid the overhead of the API method."}
{"number": 502, "change": "@@ -79,7 +79,7 @@ plugin_mgr_get_object_file_plugins (plugin_mgr_t * plugin_mgr, const char * file\n   int err;\n   \n   /* open the object file */\n-  dl_handle = dlopen (filename, RTLD_NOW);\n+  dl_handle = dlopen (filename, RTLD_LAZY);\n   if (!dl_handle)\n     {\n       mlt_log_info( NULL, \"%s: error opening shared object file '%s': %s\\n\",\n", "fix_pattern": "<pattern>: if dlopen is invoked with the RTLD_NOW flag, which forces the dynamic linker to resolve all symbols immediately, switch to RTLD_LAZY to defer symbol resolution until the symbols are actually used, improving performance especially if some symbols are not needed."}
{"number": 503, "change": "@@ -53,15 +53,9 @@ class RseedCmd : public Cmd\n       seed = atoi(argv[1]);\n     else\n     {\n+      MPI_Bcast(&seed,1,MPI_INT,0,MPIdata::comm());\n       if ( ui->onpe0() )\n-      {\n-        s->ctxt_.ibcast_send(1,1,&seed,1);\n         cout << \"<seed> \" << seed << \" </seed>\" << endl;\n-      }\n-      else\n-      {\n-        s->ctxt_.ibcast_recv(1,1,&seed,1,0,0);\n-      }\n     }\n     srand48((long int)seed);\n     return 0;\n", "fix_pattern": "<pattern>: if using project-specific broadcast methods ibcast_send and ibcast_recv for inter-process communication, replace them with the MPI_Bcast function for better performance and standardization, since MPI_Bcast is optimized for such operations."}
{"number": 504, "change": "@@ -340,9 +340,7 @@ namespace SU2 {\n                         if (ap >= 3) continue;\n \n                         double coupling_coeff = ::SU2::mod_coupling(j, two_s, jp, a,k,ap, i, two_sp, ip);\n-                        coupling_coeff *= pow(ip+1., 0.5) * pow(j+1., 0.5);\n-                        coupling_coeff *= pow(i+1., -0.5) * pow(jp+1., -0.5);\n-                        coupling_coeff *= access.scale;\n+                        coupling_coeff *= sqrt((ip+1.)*(j+1.)/((i+1.)*(jp+1.))) * access.scale;\n \n                         size_t phys_s1 = W.left_basis_size(w_block);\n                         size_t phys_s2 = W.right_basis_size(w_block);\n", "fix_pattern": "<pattern>: if multiple calls to `pow` are used to calculate square roots and reciprocals, refactor the calculation to utilize `sqrt` for square roots and combine the arithmetic operations to reduce function call overhead."}
{"number": 505, "change": "@@ -416,7 +416,7 @@ void BtLocalDevice::connectToServiceViaSearch()\n                 socket->setPreferredSecurityFlags(securityFlags);\n \n             QBluetoothServiceInfo info = foundTestServers.at(0);\n-            socket->connectToService(info.device().address(), QBluetoothUuid(QString(TEST_SERVICE_UUID)));\n+            socket->connectToService(info);\n         } else {\n             qWarning() << \"Perform search for test service before triggering this function\";\n         }\n", "fix_pattern": "<pattern>: if the API method connects to a Bluetooth service using a separate address and UUID, consolidate the parameters into a single `QBluetoothServiceInfo` object to streamline the connection process and improve performance by reducing function calls."}
{"number": 506, "change": "@@ -212,7 +212,7 @@ void Video_Dumb::flip() {\n   }\n \n #ifdef UGS_LINUX\n-  sleep(0);\n+  usleep(1);\n #endif\n \n   framecount++;\n", "fix_pattern": "<pattern>: if the code is using the sleep function with a duration of 0 seconds to yield control, replace it with usleep(1) to yield control more effectively while allowing for a minimal sleep time and potentially reducing CPU usage."}
{"number": 507, "change": "@@ -967,7 +967,9 @@ EditWords(TStringCollection * Words, int &words_changed,\n           if (handle > 0)\n           {\n             char *buffer;\n-            long len = filelength(handle);\n+            struct stat st;\n+            fstat(handle, &st);\n+            long len = st.st_size;\n \n             buffer = (char *) malloc(len + 1);\n             len =::read(handle, buffer, len);\n", "fix_pattern": "<pattern>: if a custom API method for obtaining file length is replaced with a standard library call that retrieves file metadata, favor using `fstat` to directly access the file size from the file descriptor for improved performance and reliability."}
{"number": 508, "change": "@@ -19,6 +19,7 @@\n #include <sys/un.h>\n #include <event.h>\n #include <stdlib.h>\n+#include <sys/socket.h>\n \n struct delegate_info {\n     const char *helper;\n@@ -58,7 +59,7 @@ delegate_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle delegate process: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a blocking read operation is replaced with a non-blocking receive operation using `recv` with the `MSG_DONTWAIT` flag to improve responsiveness and potentially avoid blocking on socket reads."}
{"number": 509, "change": "@@ -19,6 +19,7 @@\n #include <string.h>\n #include <unistd.h>\n #include <sys/un.h>\n+#include <sys/socket.h>\n #include <event.h>\n \n struct tcp_stock_connection {\n@@ -84,7 +85,7 @@ tcp_stock_event(int fd, short event, void *ctx)\n \n         assert((event & EV_READ) != 0);\n \n-        nbytes = read(fd, &buffer, sizeof(buffer));\n+        nbytes = recv(fd, &buffer, sizeof(buffer), MSG_DONTWAIT);\n         if (nbytes < 0)\n             daemon_log(2, \"error on idle TCP connection: %s\\n\",\n                        strerror(errno));\n", "fix_pattern": "<pattern>: if a direct read operation is used to read data from a socket, replace it with the recv function and make use of flags like MSG_DONTWAIT to improve responsiveness by handling non-blocking I/O."}
{"number": 510, "change": "@@ -22,7 +22,7 @@ struct strmap {\n struct strmap *\n strmap_new(struct pool *pool, unsigned capacity)\n {\n-    struct strmap *map = p_calloc(pool, sizeof(*map));\n+    struct strmap *map = p_malloc(pool, sizeof(*map));\n     assert(capacity > 1);\n \n     map->hashmap = hashmap_new(pool, capacity);\n", "fix_pattern": "<pattern>: if memory allocation is performed using p_calloc which initializes the memory to zero, and there is no requirement to have zero-initialized memory, replace it with p_malloc for a faster allocation without initialization cost."}
{"number": 511, "change": "@@ -371,15 +371,15 @@ sink_header_new(struct pool *pool, struct istream *input,\n                 const struct sink_header_handler *handler, void *ctx,\n                 struct async_operation_ref *async_ref)\n {\n-    struct sink_header *header = (struct sink_header *)\n-        istream_new(pool, &istream_sink, sizeof(*header));\n-\n     assert(input != NULL);\n     assert(!istream_has_handler(input));\n     assert(handler != NULL);\n     assert(handler->done != NULL);\n     assert(handler->error != NULL);\n \n+    auto header = NewFromPool<struct sink_header>(*pool);\n+    istream_init(&header->output, &istream_sink, pool);\n+\n     istream_assign_handler(&header->input, input,\n                            &sink_header_input_handler, header,\n                            0);\n", "fix_pattern": "<pattern>: if allocating memory for a structure via a custom allocator takes place, replace it with a more type-safe and potentially optimized allocation method such as a templated function (e.g., NewFromPool<>()), while ensuring proper initialization with a separate initialization function (istream_init)."}
{"number": 512, "change": "@@ -9,6 +9,7 @@\n #include \"buffered_io.hxx\"\n #include \"system/fd_util.h\"\n #include \"gerrno.h\"\n+#include \"pool.hxx\"\n #include \"fb_pool.hxx\"\n #include \"SliceFifoBuffer.hxx\"\n #include \"util/Cast.hxx\"\n@@ -352,12 +353,11 @@ struct istream *\n istream_file_fd_new(struct pool *pool, const char *path,\n                     int fd, FdType fd_type, off_t length)\n {\n-    struct file *file;\n-\n     assert(fd >= 0);\n     assert(length >= -1);\n \n-    file = (struct file*)istream_new(pool, &istream_file, sizeof(*file));\n+    auto file = NewFromPool<struct file>(*pool);\n+    istream_init(&file->stream, &istream_file, pool);\n     file->fd = fd;\n     file->fd_type = fd_type;\n     file->rest = length;\n", "fix_pattern": "<pattern>: if a new object is created using a specific API for memory allocation (istream_new), refactor the code to use a more optimized pool allocation method (NewFromPool) to improve performance and reduce overhead associated with object instantiation."}
{"number": 513, "change": "@@ -46,7 +46,6 @@\n #include \"istream/istream.hxx\"\n #include \"istream/istream_cat.hxx\"\n #include \"istream/DelayedIstream.hxx\"\n-#include \"istream/istream_hold.hxx\"\n #include \"istream/istream_iconv.hxx\"\n #include \"istream/istream_null.hxx\"\n #include \"istream/istream_pause.hxx\"\n@@ -369,12 +368,12 @@ embed_inline_widget(struct pool &pool, struct processor_env &env,\n     auto iw = NewFromPool<InlineWidget>(pool, pool, env, plain_text, widget,\n                                         delayed.second);\n \n-    Istream *hold = istream_hold_new(pool, *iw->MakeResponse(std::move(delayed.first)).Steal());\n+    UnusedHoldIstreamPtr hold(pool, iw->MakeResponse(std::move(delayed.first)));\n \n     iw->Start();\n \n     if (pause)\n         pause->Resume();\n \n-    return UnusedIstreamPtr(hold);\n+    return std::move(hold);\n }\n", "fix_pattern": "<pattern>: if an input stream is created and held using a custom function that can introduce overhead, refactor the code to use a smart pointer with move semantics to streamline resource management and improve performance."}
{"number": 514, "change": "@@ -37,6 +37,7 @@\n #include \"ResourceLoader.hxx\"\n \n #include <assert.h>\n+#include <fcntl.h> // for AT_*\n #include <sys/stat.h>\n \n using std::string_view_literals::operator\"\"sv;\n@@ -291,8 +292,9 @@ ProbeOnePathSuffix(const char *prefix, const char *suffix) noexcept\n \tmemcpy(path + prefix_length, suffix, suffix_length);\n \tpath[prefix_length + suffix_length] = 0;\n \n-\tstruct stat st;\n-\treturn stat(path, &st) == 0 && S_ISREG(st.st_mode);\n+\tstruct statx stx;\n+\treturn statx(-1, path, AT_STATX_DONT_SYNC, STATX_TYPE, &stx) == 0 &&\n+\t\tS_ISREG(stx.stx_mode);\n }\n \n [[gnu::pure]]\n", "fix_pattern": "<pattern>: if the code uses the older stat() function to check file types, replace it with statx() for improved performance and additional features, such as non-blocking behavior and the ability to request specific attributes."}
{"number": 515, "change": "@@ -36,7 +36,7 @@ namespace mixc::concurrency_thread_self::origin{\n \n     void thread_self::yield(){\n         #if xis_windows\n-            Sleep(0);\n+            SwitchToThread();\n         #elif xis_linux\n             pthread_yield();\n         #else\n", "fix_pattern": "<pattern>: if using Sleep(0) to yield the thread, replace it with SwitchToThread() for better performance and more efficient thread scheduling."}
{"number": 516, "change": "@@ -195,7 +195,7 @@ bool IsConfirmedBitcoinBlock(const uint256& genesishash, const uint256& hash, in\n \n         params = UniValue(UniValue::VARR);\n         params.push_back(hash.GetHex());\n-        reply = CallRPC(\"getblock\", params, true);\n+        reply = CallRPC(\"getblockheader\", params, true);\n         if (!find_value(reply, \"error\").isNull())\n             return false;\n         result = find_value(reply, \"result\");\n", "fix_pattern": "<pattern>: if an API call to retrieve a block's data is made, and it can be replaced with a more efficient call to retrieve just the block header, then refactor the code to use the more efficient method to reduce data processing overhead."}
{"number": 517, "change": "@@ -88,7 +88,7 @@ HRESULT CDialogEventHandler_CreateInstance(REFIID riid, void **ppv);\n std::wstring openDB()\n {\n     std::wstring ret;\n-    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);\n+    CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);\n \n     //Cocreate the file open dialog object\n     IFileDialog *pfd = NULL;\n", "fix_pattern": "<pattern>: if CoInitializeEx is called, consider using COINIT_MULTITHREADED instead of COINIT_APARTMENTTHREADED to potentially improve performance in multithreaded scenarios, reducing overhead related to apartment threading management."}
{"number": 521, "change": "@@ -101,19 +101,15 @@ extern \"C\" BIRDEE_BINDING_API int RunGenerativeScript(int argc, char** argv)\n \tInitPython();\n \tif (argc>0)\n \t{\n-#ifdef _WIN32\n-\t\tstd::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\n-#else\n-\t\tstd::wstring_convert<std::codecvt_utf16<wchar_t>> converter;\n-#endif\n \t\tstd::vector<wchar_t*> wargv(argc);\n \t\tstd::vector<std::wstring> wargv_buf(argc);\n \t\tfor (int i = 0; i < argc; i++)\n \t\t{\n-\t\t\twargv_buf[i] = converter.from_bytes(argv[i]);\n+\t\t\tauto len = strlen(argv[i]) + 1;\n+\t\t\twargv_buf[i] = std::wstring(len, L'\\0');\n+\t\t\tmbstowcs(&wargv_buf[i][0], argv[i], len);\n \t\t\twargv[i] = (wchar_t*)wargv_buf[i].c_str();\n \t\t}\n-\n \t\tPySys_SetArgv(argc, wargv.data());\n \t}\n \ttry\n", "fix_pattern": "<pattern>: if std::wstring_convert with from_bytes is used for character conversion, replace it with mbstowcs for better performance and to remove reliance on a deprecated API. Use a direct allocation for the wstring to avoid additional overhead from the convert function."}
{"number": 523, "change": "@@ -25,12 +25,12 @@\n #include <boost/algorithm/string/case_conv.hpp>\n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/format.hpp>\n-#include <boost/crc.hpp>\n #include <boost/filesystem.hpp>\n \n #include \"File.h\"\n #include \"Zip/Zip.h\"\n #include \"TraceLog.h\"\n+#include \"zlib.h\"\n \n namespace fs = boost::filesystem;\n \n@@ -101,8 +101,7 @@ public:\n \n \t\tif (fh == NULL) throw std::runtime_error(\"Could not open file: \" + file.string());\n \n-\t\tuint32_t crc = 0;\n-\t\tboost::crc_32_type processor;\n+\t\tuint32_t crc = crc32(0, NULL, 0);\n \t\t\n \t\twhile (true)\n \t\t{\n@@ -113,15 +112,13 @@ public:\n \n \t\t\tif (bytesRead > 0)\n \t\t\t{\n-\t\t\t\tprocessor.process_bytes(buf, bytesRead);\n+\t\t\t\tcrc = crc32(crc, (Bytef*)buf, bytesRead);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\t\n \t\t\tbreak;\n \t\t}\n \n-\t\tcrc = processor.checksum();\n-\n \t\tTraceLog::WriteLine(LOG_VERBOSE, \"CRC calculated for file \" + file.string() + \" = \" + (boost::format(\"%x\") % crc).str());\n \n \t\tfclose(fh);\n", "fix_pattern": "<pattern>: if using Boost's CRC computation which has potential overhead, switch to zlib's crc32 function for a more efficient computation of the CRC value directly in a single call."}
{"number": 524, "change": "@@ -59,9 +59,9 @@ EclipseDebugger::on_connect()\n       __debugger_if->read();\n       char* host = __debugger_if->host();\n       unsigned int port = __debugger_if->port();\n-      std::stringstream command;\n-      command << \"tktools -h \" << host << \" -p \" << port;      \n-      system(command.str().c_str());\n+      std::stringstream portstr;\n+      portstr << port;\n+      execlp(\"tktools\", \"tktools\", \"-h\", host, \"-p\", portstr.str().c_str(), (char *) 0);\n     }\n \n   } catch (Exception &e) {\n", "fix_pattern": "<pattern>: if a system call is utilized to perform shell command execution, replace it with execlp to avoid the overhead of shell interpretation and improve performance."}
{"number": 526, "change": "@@ -35,7 +35,8 @@ struct repo_t *repo_new(const char *reponame) {\n \n   CALLOC(repo, 1, sizeof(struct repo_t), return NULL);\n \n-  if (asprintf(&repo->name, \"%s\", reponame) == -1) {\n+  repo->name = strdup(reponame);\n+  if (repo->name == NULL) {\n     fprintf(stderr, \"error: failed to allocate memory\\n\");\n     free(repo);\n     return NULL;\n", "fix_pattern": "<pattern>: if asprintf is used to allocate and format a string with a single argument and there is no formatting required (just a copy), replace it with strdup for better performance and simpler code."}
{"number": 527, "change": "@@ -284,7 +284,7 @@ popup is activated manually with the <shortcut>%1</shortcut> key shortcut.\",\n     mainLayout->setStretch(1, 1);\n     mainLayout->addWidget(buttons);\n \n-    (void)winId();\n+    create();\n     windowHandle()->resize(540, 560); // default, if there is no saved size\n     const KConfigGroup grp = KSharedConfig::openConfig()->group(QLatin1String(metaObject()->className()));\n     KWindowConfig::restoreWindowSize(windowHandle(), grp);\n", "fix_pattern": "<pattern>: replace a call to winId(), which may perform unnecessary operations for the intended use, with create(), which likely initializes or configures the window in a more efficient manner, thus improving performance related to window management in the Qt library."}
{"number": 529, "change": "@@ -496,7 +496,7 @@ QString toString(IconType type)\n         case it_Align_HorizontalDistribute:\n             return QLatin1String(\"distribute-horizontal\");\n         case it_Code_Gen_Wizard:\n-            return QLatin1String(\"hi64-app-umbrello.png\");\n+            return QLatin1String(\"umbrello\");\n         case it_Document_Edit:\n             return QLatin1String(\"document-edit\");\n         case it_ClassOrPackage:\n", "fix_pattern": "<pattern>: if QLatin1String is being used to return fixed string values, refactor to return a more descriptive or meaningful string that reduces overhead or aligns with application requirements based on context."}
{"number": 531, "change": "@@ -32,7 +32,8 @@ typedef std::map<std::tstring, Mix_Chunk*> audioChunkCache_t;\n static audioChunkCache_t audioChunkCache; \n \n SoundGlobalInit::SoundGlobalInit() {\n-    if( Mix_OpenAudio( MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 2, 4096 ) != -1 ) {\n+    // Consider using BogoMips to decide the buffer chunk size, shortest is fastest\n+    if( Mix_OpenAudio( 22050, MIX_DEFAULT_FORMAT, 1, 1024 ) != -1 ) {\n         bSoundInit = true;\n     } else {\n         StartupStore(_T(\"ERROR Failed to initialize Audio Mixer <%s>%s\"),Mix_GetError(),NEWLINE);\n", "fix_pattern": "<pattern>: if the Mix_OpenAudio method is invoked with default parameters, consider optimizing the audio initialization by explicitly providing lower frequencies and smaller buffer sizes to improve performance based on the specific audio requirements."}
{"number": 536, "change": "@@ -471,6 +471,10 @@ void CPPInternalParseJob::run()\n         }\n       }\n \n+      if(contentContext) {\n+          DUChainWriteLocker l(DUChain::lock());\n+          contentContext->removeImportedParentContexts(importedTemporaryChains);\n+      }\n \n       ///When simplified environment-matching is enabled, we will accumulate many different\n       ///versions of imports into a single top-context. To reduce that a little, we remove all\n@@ -479,7 +483,6 @@ void CPPInternalParseJob::run()\n           DUChainWriteLocker l(DUChain::lock());\n \n           //Remove the temporary chains first, so we don't get warnings from them\n-          contentContext->removeImportedParentContexts(importedTemporaryChains);\n \n           QVector<DUContext::Import> imports = contentContext->importedParentContexts();\n           foreach(DUContext::Import ctx, imports) {\n", "fix_pattern": "<pattern>: if a method is called on an object that can potentially be null (like contentContext), add a null check around the method call to prevent potential null dereference errors and improve robustness, and use a write lock to ensure thread safety during the operation."}
{"number": 537, "change": "@@ -362,7 +362,7 @@ void ProjectBaseItem::setText( const QString& text )\n     d->text = text;\n     if( d->model ) {\n         QModelIndex idx = index();\n-        QMetaObject::invokeMethod( d->model, \"dataChanged\", Qt::DirectConnection, Q_ARG(QModelIndex, idx), Q_ARG(QModelIndex, idx) );\n+        emit d->model->dataChanged(idx, idx);\n     }\n }\n \n", "fix_pattern": "<pattern>: if QMetaObject::invokeMethod is used to call a signal or slot, directly emit the signal instead for improved performance and clarity."}
{"number": 538, "change": "@@ -242,5 +242,5 @@ QString MakeJob::environmentProfile() const\n \n bool MakeJob::isNMake(const QString& makeBin)\n {\n-    return QFileInfo(makeBin).baseName().toLower() == \"nmake\";\n+    return QFileInfo(makeBin).baseName().compare(QStringLiteral(\"nmake\"), Qt::CaseInsensitive);\n }\n", "fix_pattern": "<pattern>: if the comparison of QStrings involves converting one string to lowercase using toLower(), replace it with QString::compare using Qt::CaseInsensitive for better performance and to avoid unnecessary string manipulation."}
{"number": 540, "change": "@@ -93,10 +93,10 @@ void set_storage_service(http_context& ctx, routes& r) {\n         return ctx.db.local().commitlog()->active_config().commit_log_location;\n     });\n \n-    ss::get_token_endpoint.set(r, [] (const_req req) {\n+    ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n         auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n         std::vector<storage_service_json::mapper> res;\n-        return map_to_key_value(token_to_ep, res);\n+        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if an API method is using a non-movable type (like const_req) as a parameter, change it to a movable type (like std::unique_ptr<request>) to facilitate ownership transfer and improve performance. Additionally, utilize make_ready_future to streamline returns and avoid intermediate copies."}
{"number": 541, "change": "@@ -94,9 +94,12 @@ void set_storage_service(http_context& ctx, routes& r) {\n     });\n \n     ss::get_token_endpoint.set(r, [] (std::unique_ptr<request> req) {\n-        auto token_to_ep = service::get_local_storage_service().get_token_to_endpoint_map();\n-        std::vector<storage_service_json::mapper> res;\n-        return make_ready_future<json::json_return_type>(stream_object(std::move(map_to_key_value(token_to_ep, res))));\n+        return make_ready_future<json::json_return_type>(stream_range_as_array(service::get_local_storage_service().get_token_to_endpoint_map(), [](const auto& i) {\n+            storage_service_json::mapper val;\n+            val.key = boost::lexical_cast<std::string>(i.first);\n+            val.value = boost::lexical_cast<std::string>(i.second);\n+            return val;\n+        }));\n     });\n \n     ss::get_leaving_nodes.set(r, [](const_req req) {\n", "fix_pattern": "<pattern>: if a token-to-endpoint mapping is retrieved from a service and then converted to a vector for further processing, replace this intermediate storage with a more direct approach using stream_range_as_array to apply a transformation on the map directly, reducing memory usage and improving efficiency by avoiding unnecessary vector allocation."}
{"number": 542, "change": "@@ -1371,7 +1371,7 @@ bool DrasculaEngine::saves() {\n \t\tupdateEvents();\n \n \t\tif (button_izq == 1) {\n-\t\t\tdelay(100);\n+\t\t\tdelay(50);\n \t\t\tfor (n = 0; n < NUM_SAVES; n++) {\n \t\t\t\tif (mouseX > 115 && mouseY > y + (9 * n) && mouseX < 115 + 175 && mouseY < y + 10 + (9 * n)) {\n \t\t\t\t\tstrcpy(select, names[n]);\n@@ -1443,11 +1443,11 @@ bool DrasculaEngine::saves() {\n \t\t\t\tprint_abc(\"elige una partida\", 117, 15);\n \t\t\t}\n \t\t\tupdateScreen();\n-\t\t\tdelay(400);\n+\t\t\tdelay(200);\n \t\t}\n \t\ty = 26;\n \n-\t\tdelay(10);\n+\t\tdelay(5);\n \t}\n \n \tclearRoom();\n", "fix_pattern": "<pattern>: if multiple calls to the delay function are used in succession with specific timing values, consider consolidating them into fewer calls with averaged or adjusted timings for better efficiency in performance-sensitive contexts."}
{"number": 543, "change": "@@ -249,7 +249,7 @@ Common::SeekableReadStream *BaseFileManager::openPkgFile(const Common::String &f\n \tupcName.toUppercase();\n \tCommon::SeekableReadStream *file = nullptr;\n \tchar fileName[MAX_PATH_LENGTH];\n-\tstrcpy(fileName, upcName.c_str());\n+\tCommon::strlcpy(fileName, upcName.c_str(), MAX_PATH_LENGTH);\n \n \t// correct slashes\n \tfor (uint32 i = 0; i < upcName.size(); i++) {\n", "fix_pattern": "<pattern>: if a buffer is copied using strcpy, replace it with a safer and potentially more optimized function like Common::strlcpy to avoid buffer overflows and to handle string length properly."}
{"number": 544, "change": "@@ -3402,11 +3402,11 @@ bool BaseGame::getVersion(byte *verMajor, byte *verMinor, byte *extMajor, byte *\n void BaseGame::setWindowTitle() {\n \tif (_renderer) {\n \t\tchar title[512];\n-\t\tstrcpy(title, _caption[0]);\n+\t\tCommon::strlcpy(title, _caption[0], 512);\n \t\tif (title[0] != '\\0') {\n-\t\t\tstrcat(title, \" - \");\n+\t\t\tCommon::strlcat(title, \" - \", 512);\n \t\t}\n-\t\tstrcat(title, \"WME Lite\");\n+\t\tCommon::strlcat(title, \"WME Lite\", 512);\n \n \n \t\tUtf8String utf8Title;\n", "fix_pattern": "<pattern>: if using strcpy and strcat to manipulate strings, replace them with strlcpy and strlcat for improved safety and to prevent buffer overflows."}
{"number": 545, "change": "@@ -270,7 +270,7 @@ bool SXString::scCallMethod(ScScript *script, ScStack *stack, ScStack *thisStack\n \t\tScValue *val = stack->pop();\n \t\tchar separators[MAX_PATH_LENGTH] = \",\";\n \t\tif (!val->isNULL()) {\n-\t\t\tstrcpy(separators, val->getString());\n+\t\t\tCommon::strlcpy(separators, val->getString(), MAX_PATH_LENGTH);\n \t\t}\n \n \t\tSXArray *array = new SXArray(_gameRef);\n", "fix_pattern": "<pattern>: if a string is copied using strcpy, replace it with a safer alternative like Common::strlcpy that prevents buffer overflows by limiting the number of copied characters."}
{"number": 546, "change": "@@ -677,10 +677,8 @@ void GraphicManager::drawChar(byte ander, int x, int y, Color color) {\n void GraphicManager::refreshScreen() {\n \t// These cycles are for doubling the screen height.\n \tfor (uint16 y = 0; y < _screen.h / 2; y++) {\n-\t\tfor (uint16 x = 0; x < _screen.w; x++) {\n-\t\t\tfor (int j = 0; j < 2; j++)\n-\t\t\t\t*(byte *)_screen.getBasePtr(x, y * 2 + j) = *(byte *)_surface.getBasePtr(x, y);\n-\t\t}\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2), _surface.getBasePtr(0, y), _screen.w);\n+\t\tmemcpy(_screen.getBasePtr(0, y * 2 + 1), _surface.getBasePtr(0, y), _screen.w);\n \t}\n \t// Now we copy the stretched picture to the screen.\n \tg_system->copyRectToScreen(_screen.getPixels(), _screen.pitch, 0, 0, kScreenWidth, kScreenHeight * 2);\n", "fix_pattern": "<pattern>: if a nested loop is used to copy pixel data from one buffer to another, replace it with memcpy(...) calls to perform the operation in a single API call for better performance."}
{"number": 547, "change": "@@ -239,10 +239,10 @@ int ScummEngine_v72he::setupStringArrayFromString(char *cStr) {\n \n \twriteVar(0, 0);\n \n-\tint len = strlen(cStr);\n+\tint len = strlen(cStr) + 1;\n \tbyte *ptr = defineArray(0, kStringArray, 0, 0, 0, len);\n \tif (ptr != nullptr)\n-\t\tstrcpy((char*)ptr, cStr);\n+\t\tCommon::strlcpy((char*)ptr, cStr, len);\n \n \treturn readVar(0);\n }\n", "fix_pattern": "<pattern>: if using strcpy to copy strings, replace it with a safer string copy function like Common::strlcpy that also prevents buffer overflows by specifying the size of the destination buffer."}
{"number": 550, "change": "@@ -268,7 +268,7 @@ void Dialogs::scrollModeDialogue() {\n }\n \n void Dialogs::store(byte what, TuneType &played) {\n-\tmemcpy(played, played + 1, sizeof(played) - 1);\n+\tmemmove(played, played + 1, sizeof(played) - 1);\n \tplayed[30] = what;\n }\n \n", "fix_pattern": "<pattern>: if a memory operation is performed that may overlap the source and destination buffers, replace memcpy with memmove to ensure correct behavior and potentially better performance in cases of overlapping memory regions."}
{"number": 551, "change": "@@ -817,7 +817,6 @@ bool TTFFont::cacheGlyph(Glyph &glyph, uint32 chr) const {\n \t}\n \n \tuint8 *dst = (uint8 *)glyph.image.getPixels();\n-\tmemset(dst, 0, glyph.image.h * glyph.image.pitch);\n \n \tswitch (bitmap->pixel_mode) {\n \tcase FT_PIXEL_MODE_MONO:\n", "fix_pattern": "code removed:\n```\n    memset(dst, 0, glyph.image.h * glyph.image.pitch);\n```\ncode added:\n```\n    bzero(dst, glyph.image.h * glyph.image.pitch);\n```\n<pattern>: if a call to memset is used to zero out a block of memory, consider using bzero (or an equivalent) when clearing memory for better performance and potential clarity in intent, assuming that the environment supports it."}
{"number": 552, "change": "@@ -45,7 +45,10 @@ BITMAP *decodeImageStream(Common::SeekableReadStream &stream, color *pal) {\n \t\tconst Graphics::Surface *src = decoder.getSurface();\n \n \t\t// Copy the decoded surface\n-\t\tSurface *dest = new Surface(src->w, src->h, src->format);\n+\t\tint bpp = 8 * src->format.bytesPerPixel;\n+\t\tif (bpp == 24)\n+\t\t\tbpp = 32;\n+\t\tSurface *dest = (Surface *)create_bitmap_ex(bpp, src->w, src->h);\n \t\tdest->blitFrom(*src);\n \n \t\t// Copy the palette\n", "fix_pattern": "<pattern>: if a new Surface object is being created directly through its constructor, refactor the code to use `create_bitmap_ex` instead to leverage optimized bitmap handling with the specified bits per pixel (bpp) for better performance."}
{"number": 553, "change": "@@ -839,7 +839,7 @@ void script_state::UnloadImages()\n {\n \tfor(int i = 0; i < (int)ScriptImages.size(); i++)\n \t{\n-\t\tbm_unload(ScriptImages[i].handle);\n+\t\tbm_release(ScriptImages[i].handle);\n \t}\n \n \tScriptImages.clear();\n", "fix_pattern": "<pattern>: if a resource associated with an image handle is being unloaded, replace the unload operation with a release operation to improve performance and potentially manage resource handling more efficiently."}
{"number": 554, "change": "@@ -185,10 +185,8 @@ void xbt_ex_setup_backtrace(xbt_ex_t * e)\n       maps_name = bprintf(\"/proc/%d/maps\", (int) getpid());\n       maps = fopen(maps_name, \"r\");\n \n-      sscanf(addrs[i], \"%lx\", &addr);\n-      sprintf(maps_buff, \"%#lx\", addr);\n-\n-      if (strcmp(addrs[i], maps_buff)) {\n+      addr = strtol(addrs[i], &p, 16);\n+      if (*p != '\\0') {\n         XBT_CRITICAL(\"Cannot parse backtrace address '%s' (addr=%#lx)\",\n                   addrs[i], addr);\n       }\n", "fix_pattern": "<pattern>: if a combination of sscanf and sprintf is used for parsing and formatting a hexadecimal value, replace it with a direct conversion using strtol to improve performance and eliminate unnecessary string formatting operations."}
{"number": 557, "change": "@@ -832,15 +832,15 @@ IncomingFile::cancel()\n void\n IncomingFile::process()\n {\n-    channel_->setOnRecv([w=weak()](const uint8_t* buf, size_t len) {\n+    channel_->setOnRecv([w = weak()](const uint8_t* buf, size_t len) {\n         if (auto shared = w.lock()) {\n             if (shared->stream_.is_open())\n-                shared->stream_ << std::string_view((const char*) buf, len);\n+                shared->stream_.write(reinterpret_cast<const char*>(buf), len);\n             shared->info_.bytesProgress = shared->stream_.tellp();\n         }\n         return len;\n     });\n-    channel_->onShutdown([w=weak()] {\n+    channel_->onShutdown([w = weak()] {\n         auto shared = w.lock();\n         if (!shared)\n             return;\n", "fix_pattern": "<pattern>: if an API is called that converts a buffer to a `std::string` (via `std::string_view`) before writing, replace it with a more efficient call to `std::ostream::write(...)` to directly write the buffer without unnecessary object creation."}
{"number": 561, "change": "@@ -3951,7 +3951,8 @@ void Heap::RegisterNativeAllocation(JNIEnv* env, size_t bytes) {\n       native_blocking_gcs_finished_++;\n       native_blocking_gc_cond_->Broadcast(self);\n     }\n-  } else if (new_value > NativeAllocationGcWatermark() && !IsGCRequestPending()) {\n+  } else if (new_value > NativeAllocationGcWatermark() * HeapGrowthMultiplier() &&\n+             !IsGCRequestPending()) {\n     // Trigger another GC because there have been enough native bytes\n     // allocated since the last GC.\n     if (IsGcConcurrent()) {\n", "fix_pattern": "<pattern>: if a condition evaluates a watermark for memory allocation, enhance the condition by factoring in a multiplier from a memory management API, thus optimizing performance in scenarios where growth factors need to be accounted for, ensuring more efficient resource utilization."}
{"number": 562, "change": "@@ -619,7 +619,7 @@ class WatchDog {\n                            timeout_in_milliseconds_/1000));\n       } else if (rc != 0) {\n         std::string message(StringPrintf(\"pthread_cond_timedwait failed: %s\", strerror(rc)));\n-        Fatal(message.c_str());\n+        Fatal(message);\n       }\n     }\n     CHECK_WATCH_DOG_PTHREAD_CALL(pthread_mutex_unlock, (&mutex_), reason);\n", "fix_pattern": "<pattern>: if a function is accepting a std::string but being called with its c_str() method, modify the call to use the std::string directly to avoid the overhead of creating a temporary C-style string."}
{"number": 564, "change": "@@ -31,7 +31,7 @@ class SQLiteConnection {\n          }\n       }\n \n-      if (sqlite3_open(path.c_str(), &_conn) != SQLITE_OK) {\n+      if (sqlite3_open_v2(path.c_str(), &_conn, SQLITE_OPEN_READONLY | SQLITE_OPEN_NOMUTEX, 0) != SQLITE_OK) {\n          BOOST_THROW_EXCEPTION(ConnectionFailedException() << ConnectionError(sqlite3_errmsg(_conn)));\n       }\n \n", "fix_pattern": "<pattern>: if the sqlite3_open function is used for read-only access, replace it with sqlite3_open_v2 using SQLITE_OPEN_READONLY and SQLITE_OPEN_NOMUTEX flags to improve performance by avoiding unnecessary locking mechanisms and ensuring no write operations can occur."}
{"number": 566, "change": "@@ -554,7 +554,7 @@ void rlc_um::reassemble_rx_sdus()\n \n       log->debug(\"Concatenating %d bytes in to current length %d. rx_window remaining bytes=%d, vr_ur_in_rx_sdu=%d, vr_ur=%d, rx_mod=%d, last_mod=%d\\n\",\n         len, rx_sdu->N_bytes, rx_window[vr_ur].buf->N_bytes, vr_ur_in_rx_sdu, vr_ur, cfg.rx_mod, (vr_ur_in_rx_sdu+1)%cfg.rx_mod);\n-      memcpy(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n+      memmove(&rx_sdu->msg[rx_sdu->N_bytes], rx_window[vr_ur].buf->msg, len);\n       rx_sdu->N_bytes += len;\n       rx_window[vr_ur].buf->msg += len;\n       rx_window[vr_ur].buf->N_bytes -= len;\n", "fix_pattern": "<pattern>: if the source and destination memory areas may overlap during a memory copy operation, replace memcpy with memmove to ensure the operation is safe and avoid undefined behavior, which can lead to performance issues."}
{"number": 570, "change": "@@ -274,9 +274,14 @@ void KateBuffer::unwrapLines (int from, int to)\n \n   for (int line = to; line >= from; --line) {\n       if (line + 1 < lines())\n-          unwrapLine (line + 1);\n+          Kate::TextBuffer::unwrapLine (line + 1);\n+\n+      // Line \"0\" can't be unwraped\n+      // This call is used to unwrap the last line (if last line != 0)\n+      // This call was used in the previous version too and it looks like the last\n+      // line can't be unwraped without it\n       else if (line)\n-          unwrapLine (line > 0);\n+          Kate::TextBuffer::unwrapLine (line);\n   }\n \n   if (m_lineHighlighted > from)\n", "fix_pattern": "<pattern>: if the API method Kate::TextBuffer::unwrapLine is invoked twice for lines that can be handled together, ensure both calls are made with a proper condition check to optimize unnecessary calls, ensuring only necessary unwrapping occurs."}
{"number": 571, "change": "@@ -29,10 +29,10 @@\n #include <KPluginFactory>\n #include <KPluginLoader>\n #include <KService>\n-#include <KUser>\n \n #include <QAction>\n #include <QApplication>\n+#include <QDir>\n #include <QHBoxLayout>\n #include <QLabel>\n #include <QWidget>\n@@ -86,7 +86,7 @@ Terminal::Terminal(QWidget* parent) : QObject(parent)\n         disableOffendingPartActions();\n \n         m_terminalInterface = qobject_cast<TerminalInterface*>(m_part);\n-        if (m_terminalInterface) m_terminalInterface->showShellInDir(KUser().homeDir());\n+        if (m_terminalInterface) m_terminalInterface->showShellInDir(QDir::homePath());\n     }\n     else\n         displayKPartLoadError();\n", "fix_pattern": "<pattern>: if a method is being called that retrieves a user's home directory using a potentially heavy object instantiation like KUser, replace it with a more lightweight and efficient alternative such as QDir::homePath()."}
{"number": 572, "change": "@@ -32,7 +32,7 @@\n \n #define VTK_MYSQL_DEFAULT_PORT 3306\n  \n-vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.22\");\n+vtkCxxRevisionMacro(vtkMySQLDatabase, \"1.23\");\n vtkStandardNewMacro(vtkMySQLDatabase);\n \n // ----------------------------------------------------------------------\n@@ -461,12 +461,14 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n {\n   skipped = false;\n   vtkStdString queryStr = \", \";\n+  bool mustUseName = true;\n \n   int idxType = schema->GetIndexTypeFromHandle( tblHandle, idxHandle );\n   switch ( idxType )\n     {\n     case vtkSQLDatabaseSchema::PRIMARY_KEY:\n       queryStr += \"PRIMARY KEY \";\n+      mustUseName = false;\n       break;\n     case vtkSQLDatabaseSchema::UNIQUE:\n       queryStr += \"UNIQUE \";\n@@ -478,7 +480,11 @@ vtkStdString vtkMySQLDatabase::GetIndexSpecification( vtkSQLDatabaseSchema* sche\n       return vtkStdString();\n     }\n   \n-  queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+  // No index_name for PRIMARY KEYs\n+  if ( mustUseName )\n+    {\n+    queryStr += schema->GetIndexNameFromHandle( tblHandle, idxHandle );\n+    }\n   queryStr += \" (\";\n         \n   // Loop over all column names of the index\n", "fix_pattern": "<pattern>: if the API call for retrieving index names may be unnecessary (specifically for PRIMARY KEYs), refactor the logic to conditionally execute the call only when required, thus potentially reducing redundant computations and avoiding unnecessary string concatenation in the query."}
{"number": 573, "change": "@@ -48,7 +48,7 @@\n #include <vtkstd/set>\n #include <vtkstd/algorithm>\n \n-vtkCxxRevisionMacro(vtkKdTree, \"1.22\");\n+vtkCxxRevisionMacro(vtkKdTree, \"1.23\");\n \n // Timing data ---------------------------------------------\n \n@@ -2280,7 +2280,8 @@ int vtkKdTree::_FindClosestPointInRegion(int regionId,\n \n   float *candidate = this->LocatorPoints + (idx * 3);\n \n-  for (int i=0; i < this->RegionList[regionId]->GetNumberOfPoints(); i++)\n+  int numPoints = this->RegionList[regionId]->GetNumberOfPoints();\n+  for (int i=0; i < numPoints; i++)\n     {\n     double dx = (x - candidate[0]) * (x - candidate[0]);\n \n", "fix_pattern": "<pattern>: if a loop iterates over the result of a method call that can be computed once, store the result in a variable before the loop to avoid repeated calls and improve performance."}
{"number": 575, "change": "@@ -3769,9 +3769,9 @@ BOOL CSoundFile::ReadABC(const uint8_t *lpStream, DWORD dwMemLength)\n \t\t\t\t\t\t\tp[t]='\\0';\n \t\t\t\t\t\tfor( t=2; isspace(p[t]); t++ ) ;\n \t\t\t\t\t\tstrcpy(buf,m_szNames[0]);\n-\t\t\t\t\t\tif( strlen(buf) + strlen(p+t) > 199 ) p[t+199-strlen(buf)] = '\\0'; // chop it of\n \t\t\t\t\t\tif( strlen(buf) ) strcat(buf,\" \"); // add a space\n-\t\t\t\t\t\tstrcat(buf, p+t);\n+\t\t\t\t\t\t// don't go past 200 bytes.\n+\t\t\t\t\t\tstrncat(buf, p+t, 200-strlen(buf)-1);\n \t\t\t\t\t\tif( strlen(buf) > 31 ) buf[31] = '\\0'; // chop it of\n \t\t\t\t\t\tstrcpy(m_szNames[0], buf);\n \t\t\t\t\t\tbreak;\n", "fix_pattern": "<pattern>: if code manually checks buffer length and concatenates two strings using strcat, replace with strncat to ensure that the buffer does not overflow, thus improving safety and potentially performance."}
{"number": 578, "change": "@@ -1295,8 +1295,8 @@ void InstrumentTrackWindow::modelChanged()\n \n \tm_nameLineEdit->setText( m_track->name() );\n \n-\tdisconnect( m_track, SIGNAL( nameChanged() ) );\n-\tdisconnect( m_track, SIGNAL( instrumentChanged() ) );\n+\tm_track->disconnect( SIGNAL( nameChanged() ), this );\n+\tm_track->disconnect( SIGNAL( instrumentChanged() ), this );\n \n \tconnect( m_track, SIGNAL( nameChanged() ),\n \t\t\tthis, SLOT( updateName() ) );\n", "fix_pattern": "<pattern>: if disconnecting signals from a QObject, refactor to use the QObject's instance's disconnect method, which is more efficient and avoids ambiguity."}
{"number": 579, "change": "@@ -35,6 +35,8 @@\n #include <QLineEdit>\n #include <QContextMenuEvent>\n \n+#include <algorithm>\n+\n #include \"qg_blockwidget.h\"\n #include \"rs_blocklist.h\"\n #include \"qg_actionhandler.h\"\n@@ -78,7 +80,7 @@ void QG_BlockModel::setBlockList(RS_BlockList* bl) {\n             listBlock.append(bl->at(i));\n     }\n     setActiveBlock(bl->getActive());\n-    qSort ( listBlock.begin(), listBlock.end(), blockLessThan );\n+    std::sort( listBlock.begin(), listBlock.end(), blockLessThan);\n \n     //called to force redraw\n     endResetModel();\n", "fix_pattern": "<pattern>: if using qSort from the Qt library, replace it with std::sort from the C++ Standard Library for potentially better performance and enhanced optimizations since std::sort is generally more efficient and widely used in modern C++."}
{"number": 581, "change": "@@ -209,7 +209,15 @@ QVector<BuildingGeoPolygonGraphicsItem::NamedEntry> BuildingGeoPolygonGraphicsIt\n \n void BuildingGeoPolygonGraphicsItem::paint(GeoPainter* painter, const ViewportParams* viewport, const QString &layer, int tileZoomLevel)\n {\n-    Q_UNUSED(tileZoomLevel);\n+    // Just display flat buildings for tile level 17\n+    if (tileZoomLevel == 17) {\n+        if (layer.endsWith(QLatin1String(\"/frame\"))) {\n+            AbstractGeoPolygonGraphicsItem::paint(painter, viewport, layer, tileZoomLevel );\n+        }\n+        return;\n+    }\n+\n+    // For level 18, 19 .. render 3D buildings in perspective\n     if (layer.endsWith(QLatin1String(\"/frame\"))) {\n         Q_ASSERT(m_cachedOuterPolygons.isEmpty());\n         Q_ASSERT(m_cachedInnerPolygons.isEmpty());\n", "fix_pattern": "<pattern>: if there is a check for specific conditions based on the input parameters that can potentially skip unnecessary processing or rendering, restructure the code to handle those conditions explicitly before calling potentially expensive API methods like AbstractGeoPolygonGraphicsItem::paint."}
{"number": 582, "change": "@@ -154,10 +154,10 @@ void RoomListModel::doAddRoom(Room *r)\n void RoomListModel::connectRoomSignals(NeoChatRoom *room)\n {\n     connect(room, &Room::displaynameChanged, this, [this, room] {\n-        refresh(room);\n+        refresh(room, {DisplayNameRole, NameRole});\n     });\n     connect(room, &Room::unreadMessagesChanged, this, [this, room] {\n-        refresh(room);\n+        refresh(room, {UnreadCountRole, NotificationCountRole, HighlightCountRole});\n     });\n     connect(room, &Room::notificationCountChanged, this, [this, room] {\n         refresh(room);\n@@ -172,7 +172,7 @@ void RoomListModel::connectRoomSignals(NeoChatRoom *room)\n         refresh(room);\n     });\n     connect(room, &Room::addedMessages, this, [this, room] {\n-        refresh(room, {LastEventRole, SubtitleTextRole});\n+        refresh(room, {LastEventRole, SubtitleTextRole, LastActiveTimeRole});\n     });\n     connect(room, &Room::pendingEventMerged, this, [this, room] {\n         refresh(room, {LastEventRole, SubtitleTextRole});\n", "fix_pattern": "<pattern>: if multiple calls to the same API method `refresh` are detected in sequence with varying parameters, consolidate them into the minimum necessary calls to optimize performance and reduce potential overhead."}
{"number": 583, "change": "@@ -17,6 +17,7 @@\n \n #include \"addresstablemodel.h\"\n #include <QtDebug>\n+#include <algorithm>\n \n AddressTableModel::AddressTableModel(QObject *parent, const list<t_address_card>& data)\n \t: QAbstractTableModel(parent)\n@@ -97,7 +98,7 @@ void AddressTableModel::modifyAddress(int index, const t_address_card& card)\n \n void AddressTableModel::sort(int column, Qt::SortOrder order)\n {\n-\tqSort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n+\tstd::sort(m_data.begin(), m_data.end(), [=](const t_address_card& a1, const t_address_card& a2) -> bool {\n \t\tbool retval = false;\n \n \t\tswitch (column)\n", "fix_pattern": "<pattern>: if qSort is used to sort a range of elements, replace it with std::sort from the C++ Standard Library, as it generally has better performance characteristics due to its implementation being more modern and typically benefiting from optimizations unavailable in older libraries like Qt's qSort."}
{"number": 584, "change": "@@ -428,9 +428,10 @@ namespace net_utils\n \t\t\t\n \t\t\t\thandler_obj hndlr(ec, bytes_transfered);\n \n-\t\t\t\tchar local_buff[10000] = {0};\n+\t\t\t\tstatic const size_t max_size = 16384;\n+\t\t\t\tbuff.resize(max_size);\n \t\t\t\t\n-\t\t\t\tasync_read(local_buff, sizeof(local_buff), boost::asio::transfer_at_least(1), hndlr);\n+\t\t\t\tasync_read(&buff[0], max_size, boost::asio::transfer_at_least(1), hndlr);\n \n \t\t\t\t// Block until the asynchronous operation has completed.\n \t\t\t\twhile (ec == boost::asio::error::would_block && !boost::interprocess::ipcdetail::atomic_read32(&m_shutdowned))\n@@ -463,7 +464,7 @@ namespace net_utils\n \t\t\t\t\treturn false;*/\n \n \t\t\t\tm_bytes_received += bytes_transfered;\n-\t\t\t\tbuff.assign(local_buff, bytes_transfered);\n+\t\t\t\tbuff.resize(bytes_transfered);\n \t\t\t\treturn true;\n \t\t\t}\n \n", "fix_pattern": "<pattern>: if a local buffer is used to read data and then assigned to a std::string, replace the local buffer with a resize of the std::string to reduce memory copying and potential reallocations; also ensure the async_read function utilizes the string's internal buffer directly for efficiency."}
{"number": 585, "change": "@@ -594,7 +594,7 @@ BOOL SetEndOfFile(HANDLE hFile) {\n }\n \n DWORD SleepEx( DWORD dwMilliseconds,  BOOL bAlertable) {\n-  SDL_Delay(dwMilliseconds);\n+  usleep(dwMilliseconds * 1000);\n   return 0;\n }\n \n", "fix_pattern": "<pattern>: if using SDL_Delay for sleeping, replace it with usleep for potentially finer control over the sleep duration since usleep provides microsecond resolution compared to SDL_Delay's millisecond resolution."}
{"number": 586, "change": "@@ -375,7 +375,7 @@ void XBPython::Initialize()\n       // OSX uses contents from extracted zip, 3X to 4X times faster during Py_Initialize\n       setenv(\"PYTHONPATH\", _P(\"special://xbmc/system/python/Lib\").c_str(), 1);\n #else\n-      setenv(\"PYTHONPATH\", _P(\"special://xbmc/system/python/python24.zip\").c_str(), 1);\n+      setenv(\"PYTHONPATH\", _P(\"special://xbmcbin/system/python/python24.zip\").c_str(), 1);\n #endif /* __APPLE__ */\n       setenv(\"PYTHONCASEOK\", \"1\", 1);\n       CLog::Log(LOGDEBUG, \"Python wrapper library linked with internal Python library\");\n", "fix_pattern": "<pattern>: if a file path in the PYTHONPATH environment variable is being set and it is changed from a potentially more common directory (system/python) to a more specific one (xbmcbin/system/python), ensure to choose the path that provides the required resources while improving specificity, which may reduce search time during runtime."}
{"number": 587, "change": "@@ -155,7 +155,7 @@ void *CAudioDecoder::GetData(unsigned int size)\n   if (m_gaplessBufferSize > size)\n   {\n     memcpy(m_outputBuffer, m_gaplessBuffer, size*sizeof(float));\n-    memcpy(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n+    memmove(m_gaplessBuffer, m_gaplessBuffer + size, (m_gaplessBufferSize - size)*sizeof(float));\n     m_gaplessBufferSize -= size;\n     return m_outputBuffer;\n   }\n", "fix_pattern": "<pattern>: if a buffer may overlap when copying data, replace memcpy(...) with memmove(...) to ensure correct behavior and maintain performance."}
{"number": 589, "change": "@@ -489,10 +489,11 @@ writeable_pgsql_selection::factory::factory(const po::variables_map &opts)\n   // select ways which use nodes already in the working set\n   m_connection.prepare(\"ways_from_nodes\",\n     \"INSERT INTO tmp_ways \"\n-      \"SELECT DISTINCT wn.way_id \"\n+      \"SELECT DISTINCT wn.way_id AS id \"\n         \"FROM current_way_nodes wn \"\n           \"JOIN tmp_nodes tn ON wn.node_id = tn.id \"\n-            \"AND wn.way_id NOT IN (SELECT id FROM tmp_ways)\");\n+          \"LEFT JOIN tmp_ways tw ON wn.way_id = tw.id \"\n+        \"WHERE tw.id IS NULL\");\n   // select nodes used by ways already in the working set\n   m_connection.prepare(\"nodes_from_way_nodes\",\n     \"INSERT INTO tmp_nodes \"\n", "fix_pattern": "<pattern>: if a query uses a subquery with NOT IN which can be inefficient, refactor the query to use a LEFT JOIN with a WHERE clause for better performance in filtering data from related tables."}
{"number": 590, "change": "@@ -496,9 +496,8 @@ NAN_METHOD(Driver::open) {\n #endif\n \n   GDALDriver *raw = driver->getGDALDriver();\n-  GDALOpenInfo *open_info = new GDALOpenInfo(path.c_str(), access);\n-  GDALDataset *ds = raw->pfnOpen(open_info);\n-  delete open_info;\n+  const char *driver_list[2] = {raw->GetDescription(), nullptr};\n+  GDALDataset *ds = (GDALDataset *)GDALOpenEx(path.c_str(), access, driver_list, NULL, NULL);\n   if (!ds) {\n     Nan::ThrowError(\"Error opening dataset\");\n     return;\n", "fix_pattern": "<pattern>: if a GDAL dataset is opened using the older GDALOpenInfo method that involves manual memory management, refactor the code to use GDALOpenEx which simplifies the process and potentially improves performance by avoiding the need to create and delete a GDALOpenInfo object."}
{"number": 591, "change": "@@ -591,7 +591,7 @@ void CmdRaytracingRender::activated(int iMsg)\n         doCommand(Doc,\"f = open(TempFile,'wb')\");\n         doCommand(Doc,\"f.write(PageFile.read())\");\n         doCommand(Doc,\"f.close()\");\n-        doCommand(Doc,\"subprocess.call('\\\"%s\\\" '+TempFile,shell=True)\",renderer.c_str());\n+        doCommand(Doc,\"subprocess.Popen([\\\"%s\\\",TempFile])\",renderer.c_str());\n         doCommand(Doc,\"del TempFile,PageFile\");            \n         commitCommand();\n     }\n", "fix_pattern": "<pattern>: if the command being executed involves a shell call with subprocess.call, replace it with subprocess.Popen and pass the command as a list to avoid the overhead of shell parsing and improve performance."}
{"number": 592, "change": "@@ -12,11 +12,9 @@\n #include <string>\n #include <boost/asio.hpp>\n #include <boost/bind.hpp>\n-#include <boost/process.hpp>\n \n using namespace boost::asio;\n using ip::tcp;\n-using boost::process::spawn;\n using boost::system::error_code;\n using ip::host_name;\n using std::string;\n@@ -138,8 +136,8 @@ int main(int argc, char** argv, char** env) {\n #ifdef LAD\n     cout << \"<h4>Agora digite: ./remote \"\n          << host_name() << \" \" << fpga << \" </h4>\" << endl;\n-#else\n-    spawn(\"remote.bin\", to_string(port));\n+#else \n+    if (fork()==0) execl(\"./remote.bin\", \"remote.bin\", to_string(port).c_str(), NULL);\n #endif\n \n     // Enter timer IO loop and never return.\n", "fix_pattern": "<pattern>: if the Boost.Process `spawn` function is being used to start a process, replace it with a direct call to `fork()` and `execl()` for better performance, as this avoids the overhead of the Boost.Process library and uses lower-level system calls directly."}
{"number": 593, "change": "@@ -51,8 +51,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tif (!string)\n \t\treturn;\n \t\n-\tchar *workstr = new char[strlen(string) + 1];\n-\tstrcpy(workstr, string);\n+\tchar *workstr = strdup(string);\n \tstrtok(workstr, \"\\n\");\n \t\n \tchar *token = strtok(NULL,\"\\n\");\n@@ -60,7 +59,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \t\n \tif (!token)\n \t{\n-\t\tdelete [] workstr;\n+\t\tfree(workstr);\n \t\tstringList.AddItem(new BString(string));\n \t\treturn;\n \t}\n@@ -84,7 +83,7 @@ TokenizeToList(const char *string, BObjectList<BString> &stringList)\n \tlasttoken = token;\n \tstringList.AddItem(newword);\n \t\t\n-\tdelete [] workstr;\n+\tfree(workstr);\n }\n \n \n", "fix_pattern": "<pattern>: when dynamically allocating a string and then copying its contents, replace the manual allocation and copy with strdup, which performs both operations in one call and simplifies the code; also, ensure to call free only once on the allocated memory."}
{"number": 595, "change": "@@ -244,7 +244,7 @@ void* VideoScaler::Run(void* pArgs)\n     int tOutputBufferSize = avpicture_get_size(mTargetPixelFormat, mTargetResX, mTargetResY) + FF_INPUT_BUFFER_PADDING_SIZE;\n \n     // allocate chunk buffer\n-    tOutputBuffer = (uint8_t*)malloc(tOutputBufferSize);\n+    tOutputBuffer = (uint8_t*)av_malloc(tOutputBufferSize);\n \n     // Allocate video frame\n     LOG(LOG_VERBOSE, \"..allocating memory for output frame\");\n", "fix_pattern": "<pattern>: if memory allocation is done using malloc, switch to av_malloc from the FFmpeg library for optimized memory handling within FFmpeg's context."}
{"number": 597, "change": "@@ -1075,7 +1075,7 @@ QSharedPointer<FlatpakSource> FlatpakBackend::integrateRemote(FlatpakInstallatio\n void FlatpakBackend::loadLocalUpdates(FlatpakInstallation *flatpakInstallation)\n {\n     g_autoptr(GError) localError = nullptr;\n-    g_autoptr(GPtrArray) refs = flatpak_installation_list_installed_refs_for_update(flatpakInstallation, m_cancellable, &localError);\n+    g_autoptr(GPtrArray) refs = flatpak_installation_list_installed_refs(flatpakInstallation, m_cancellable, &localError);\n     if (!refs) {\n         qWarning() << \"Failed to get list of installed refs for listing local updates:\" << localError->message;\n         return;\n", "fix_pattern": "<pattern>: if an API method returns a GPtrArray that retrieves installed references with an update context, replace it with a method that retrieves installed references without the update context for potentially improved performance."}
{"number": 598, "change": "@@ -77,12 +77,11 @@ MountIsoAction::MountIsoAction(QObject *parent, const QVariantList &)\n const Solid::Device getDeviceFromBackingFile(const QString &backingFile)\n {\n     const QList<Solid::Device> blockDevices =\n-        Solid::Device::listFromQuery(\"[ IS Block AND IS GenericInterface ]\");\n+        Solid::Device::listFromQuery(\"[ IS StorageAccess AND IS GenericInterface ]\");\n \n     for (const Solid::Device &device : blockDevices) {\n-        QMap<QString, QVariant> properties = device.as<Solid::GenericInterface>()->allProperties();\n-        if (properties.contains(\"BackingFile\")\n-            && backingFile == properties[\"BackingFile\"].value<QString>()) {\n+        auto genericDevice = device.as<Solid::GenericInterface>();\n+        if (backingFile == genericDevice->property(QStringLiteral(\"BackingFile\")).toString()) {\n             return device;\n         }\n     }\n", "fix_pattern": "<pattern>: if using Solid::GenericInterface's allProperties() method to retrieve properties and then checking for a specific key on QMap, optimize by directly accessing the property via the property() method instead. This reduces the overhead of retrieving all properties when only one is needed. Additionally, ensure that the query to list devices is also contextually relevant for performance improvements."}
{"number": 600, "change": "@@ -962,8 +962,8 @@ void DrawWeapons(double smooth)\n     {\n         // CHECKME - not & 0x7FF?\n         double nBobAngle = obobangle + fmulscale16(((bobangle + 1024 - obobangle) & 2047) - 1024, smooth);\n-        double nVal = (ototalvel[nLocalPlayer] + fmulscale16(totalvel[nLocalPlayer] - ototalvel[nLocalPlayer], smooth)) / 2.;\n-        yOffset = (nVal * (calcSinTableValue(fmod(nBobAngle, 1024)) / 256.)) / 512.;\n+        double nVal = (ototalvel[nLocalPlayer] + fmulscale16(totalvel[nLocalPlayer] - ototalvel[nLocalPlayer], smooth)) * 0.5;\n+        yOffset = fmulscale9(nVal, bsinf(fmod(nBobAngle, 1024.), -8));\n \n         if (var_34 == 1)\n         {\n", "fix_pattern": "<pattern>: if a calculation is performed that involves dividing by a constant (like 2.), refactor it to use multiplication by the reciprocal (like multiplying by 0.5) for better performance; if a function such as calcSinTableValue is less optimized than a more efficient equivalent like bsinf, replace it with the faster version."}
{"number": 602, "change": "@@ -674,22 +674,21 @@ CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {\n }\n \n namespace {\n-// SecureBuffer uses openssl to allocate a Uint8Array using\n-// OPENSSL_secure_malloc. Because we do not yet actually\n-// make use of secure heap, this has the same semantics as\n+// SecureBuffer uses OPENSSL_secure_malloc to allocate a Uint8Array.\n+// Without --secure-heap, OpenSSL's secure heap is disabled,\n+// in which case this has the same semantics as\n // using OPENSSL_malloc. However, if the secure heap is\n // initialized, SecureBuffer will automatically use it.\n void SecureBuffer(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsUint32());\n   Environment* env = Environment::GetCurrent(args);\n   uint32_t len = args[0].As<Uint32>()->Value();\n-  char* data = static_cast<char*>(OPENSSL_secure_malloc(len));\n+  void* data = OPENSSL_secure_zalloc(len);\n   if (data == nullptr) {\n     // There's no memory available for the allocation.\n     // Return nothing.\n     return;\n   }\n-  memset(data, 0, len);\n   std::shared_ptr<BackingStore> store =\n       ArrayBuffer::NewBackingStore(\n           data,\n", "fix_pattern": "<pattern>: if memory is allocated using OPENSSL_secure_malloc followed by a memset to zero out the allocated memory, replace it with OPENSSL_secure_zalloc, which allocates and initializes the memory to zero in a single call for improved performance."}
{"number": 603, "change": "@@ -731,8 +731,8 @@ void IceModel::misc_setup() {\n   // it is faster.)\n   std::string o_format = m_config->get_string(\"output_format\");\n   if ((o_format == \"netcdf4_parallel\" || o_format == \"quilt\" || o_format == \"hdf5\") &&\n-      m_config->get_string(\"output_variable_order\") != \"xyz\") {\n-    throw RuntimeError(\"output formats netcdf4_parallel, quilt, and hdf5 require -o_order xyz.\");\n+      m_config->get_string(\"output_variable_order\") != \"yxz\") {\n+    throw RuntimeError(\"output formats netcdf4_parallel, quilt, and hdf5 require -o_order yxz.\");\n   }\n }\n \n", "fix_pattern": "<pattern>: NA"}
{"number": 605, "change": "@@ -358,10 +358,7 @@ const char* socket_peername( int socket )\n   socklen_t len = sizeof(addr);\n   if( getpeername( socket, (struct sockaddr*)&addr, &len ) < 0 )\n     return 0;\n-  hostent* host = gethostbyaddr( (char*)&addr.sin_addr, sizeof(addr.sin_addr), AF_INET );\n-  if( host == NULL )\n-    return 0;\n-  return host->h_name;\n+  return inet_ntoa( addr.sin_addr );\n \n   QF_STACK_POP\n }\n", "fix_pattern": "<pattern>: if the gethostbyaddr function is used to resolve an IP address to a hostname but the application only requires the IP address in string format, replace the call with inet_ntoa to directly convert the address into its string representation, improving performance by avoiding unnecessary DNS lookups."}
{"number": 606, "change": "@@ -434,9 +434,7 @@ void Renderer::executeCommands(const QVector<RenderCommand *> commands)\n \n     Q_FOREACH (RenderCommand *command, commands) {\n \n-        QMutexLocker locker(&m_mutex);\n         MeshData *meshData = m_meshDataManager->data(command->m_meshData);\n-        locker.unlock();\n         if (meshData == Q_NULLPTR || meshData->attributeNames().empty()) {\n             qCWarning(Rendering) << \"RenderCommand should have a mesh\";\n             continue ;\n", "fix_pattern": "<pattern>: if a mutex locker is constructed and immediately unlocked without being used to guard a critical section, remove the unnecessary QMutexLocker instantiation to improve performance."}
{"number": 607, "change": "@@ -686,7 +686,7 @@ GraphicsHelperInterface *GraphicsContext::resolveHighestOpenGLFunctions()\n             if (m_debugLogger->initialize()) {\n                 QObject::connect(m_debugLogger.data(), &QOpenGLDebugLogger::messageLogged, &logOpenGLDebugMessage);\n                 const QString mode = QString::fromLocal8Bit(debugLoggingMode);\n-                m_debugLogger->startLogging(mode.toLower().startsWith(QLatin1String(\"sync\"))\n+                m_debugLogger->startLogging(mode.startsWith(QLatin1String(\"sync\"), Qt::CaseInsensitive)\n                                             ? QOpenGLDebugLogger::SynchronousLogging\n                                             : QOpenGLDebugLogger::AsynchronousLogging);\n \n", "fix_pattern": "<pattern>: if the method QString::toLower() is used before checking if it starts with a certain substring, replace it with startsWith() using the Qt::CaseInsensitive option to avoid the overhead of converting the entire string to lowercase."}
{"number": 608, "change": "@@ -133,12 +133,12 @@ void CameraLens::syncFromFrontEnd(const Qt3DCore::QNode *frontEnd, bool firstTim\n     const Matrix4x4 projectionMatrix(node->projectionMatrix());\n     if (projectionMatrix != m_projection) {\n         m_projection = projectionMatrix;\n-        markDirty(AbstractRenderer::AllDirty);\n+        markDirty(AbstractRenderer::ParameterDirty);\n     }\n \n     if (!qFuzzyCompare(node->exposure(), m_exposure)) {\n         m_exposure = node->exposure();\n-        markDirty(AbstractRenderer::AllDirty);\n+        markDirty(AbstractRenderer::ParameterDirty);\n     }\n \n     const QCameraLensPrivate *d = static_cast<const QCameraLensPrivate *>(QNodePrivate::get(node));\n", "fix_pattern": "<pattern>: If the same API method is called multiple times consecutively with the same argument, replace subsequent calls with a different, more appropriate argument that denotes a specific type of change for better clarity and possibly improved performance in subsequent handling."}
{"number": 610, "change": "@@ -68,7 +68,7 @@ Node& CDirAdditionalPropertiesDlg::MakeNode(Node& parentNode, const std::vector<\n \t++it;\n \tif (it != path.end())\n \t{\n-\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name.c_str())).c_str(), parentNode.hItem);\n+\t\tnode.hItem = m_treeProps.InsertItem(tr(ucr::toUTF8(node.name)).c_str(), parentNode.hItem);\n \t\treturn MakeNode(node, path, it);\n \t}\n \tnode.canonicalName = strutils::join(path.begin(), path.end(), _T(\".\"));\n", "fix_pattern": "<pattern>: if a function is called on a string (like c_str()) that's unnecessary for the operation, replace it with direct usage of the string object to reduce overhead and improve clarity."}
{"number": 612, "change": "@@ -442,13 +442,13 @@ Ref<const readable_block_store_t> read_sections(const MPI_Comm comm, const strin\n   Array<char> raw;\n   {\n     Log::Scope scope(\"read data\");\n-    const auto our_size = CHECK_CAST_INT(partition_loop(total_size,ranks,rank).size());\n-    raw.resize(our_size,false);\n+    const auto chunk = partition_loop(total_size,ranks,rank);\n+    raw.resize(CHECK_CAST_INT(chunk.size()),false);\n     MPI_File file;\n     const int r = MPI_File_open(comm,(char*)filename.c_str(),MPI_MODE_RDONLY,MPI_INFO_NULL,&file);\n     if (r != MPI_SUCCESS)\n       die(\"failed to open '%s' for reading: %s\",filename,error_string(r));\n-    CHECK(MPI_File_read_ordered(file,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+    CHECK(MPI_File_read_at_all(file,chunk.lo,raw.data(),raw.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n     CHECK(MPI_File_close(&file));\n   }\n \n", "fix_pattern": "<pattern>: if the code is reading ordered data with MPI_File_read_ordered, switch to MPI_File_read_at_all for better performance when handling large chunks of data by specifying the offset directly, thus avoiding potential bottlenecks in ordered reads."}
{"number": 613, "change": "@@ -679,10 +679,18 @@ void write_sparse_samples(const MPI_Comm comm, const string& filename, accumulat\n     index += sizeof(s.wins);\n   }\n \n+  // Compute offsets.  MPI_File_write_ordered would do this for us, but MPI_File_write_ordered\n+  // is completely broken performance-wise.\n+  uint64_t offset = 0;\n+  {\n+    uint64_t buffer_size = buffer.size();\n+    CHECK(MPI_Exscan(&buffer_size,&offset,1,datatype<uint64_t>(),MPI_SUM,comm));\n+  }\n+\n   // Write the file\n   MPI_File file;\n   file_open(comm,filename,&file);\n-  CHECK(MPI_File_write_ordered(file,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n+  CHECK(MPI_File_write_at_all(file,offset,buffer.data(),buffer.size(),MPI_BYTE,MPI_STATUS_IGNORE));\n   CHECK(MPI_File_close(&file));\n }\n \n", "fix_pattern": "<pattern>: if the code is using MPI_File_write_ordered, which is known to have performance issues, replace it with an MPI_File_write_at_all call that computes offsets manually using an MPI_Exscan to optimize performance for collective writes."}
{"number": 614, "change": "@@ -106,7 +106,7 @@ Status CapturedFunction::Create(\n Status CapturedFunction::Run(FunctionLibraryRuntime::Options f_opts,\n                              gtl::ArraySlice<Tensor> args,\n                              std::vector<Tensor>* rets, const string& prefix) {\n-  port::Tracing::TraceMe activity(strings::StrCat(prefix, \"::Run\"));\n+  port::Tracing::TraceMe activity(prefix, \"::Run\");\n   Notification n;\n   Status s;\n   auto done_callback = [&n, &s](Status func_status) {\n", "fix_pattern": "<pattern>: if a string concatenation operation is performed using strings::StrCat for creating a tracing activity label, refactor the code to directly pass the prefix and the suffix as separate arguments to the Tracing::TraceMe constructor to avoid unnecessary string allocation and improve performance."}
{"number": 616, "change": "@@ -223,9 +223,8 @@ JNIEXPORT jbyteArray JNICALL Java_org_tensorflow_Session_run(\n   jbyteArray ret = nullptr;\n   if (run_metadata != nullptr) {\n     ret = env->NewByteArray(run_metadata->length);\n-    jbyte* elems = env->GetByteArrayElements(ret, nullptr);\n-    memcpy(elems, run_metadata->data, run_metadata->length);\n-    env->ReleaseByteArrayElements(ret, elems, JNI_COMMIT);\n+    env->SetByteArrayRegion(ret, 0, run_metadata->length,\n+                            reinterpret_cast<const jbyte*>(run_metadata->data));\n   }\n   TF_DeleteStatus(status);\n   return ret;\n", "fix_pattern": "<pattern>: if GetByteArrayElements is used to obtain a pointer for memcpy followed by ReleaseByteArrayElements, replace the sequence with SetByteArrayRegion to directly copy data into the Java byte array, improving performance by avoiding unnecessary memory management overhead."}
{"number": 617, "change": "@@ -90,11 +90,8 @@ void WarningHandler(png_structp png_ptr, png_const_charp msg) {\n void StringReader(png_structp png_ptr, png_bytep data, png_size_t length) {\n   DecodeContext* const ctx = bit_cast<DecodeContext*>(png_get_io_ptr(png_ptr));\n   if (static_cast<png_size_t>(ctx->data_left) < length) {\n-    if (!ctx->error_condition) {\n-      VLOG(1) << \"PNG read decoding error\";\n-      ctx->error_condition = true;\n-    }\n     memset(data, 0, length);\n+    png_error(png_ptr, \"More bytes requested to read than available\");\n   } else {\n     memcpy(data, ctx->data, length);\n     ctx->data += length;\n", "fix_pattern": "<pattern>: if an error condition is detected and logged, replace logging with a direct call to the png_error function to handle the error more efficiently and appropriately within the context of the libpng library."}
{"number": 618, "change": "@@ -411,7 +411,7 @@ Status PyArrayToTF_Tensor(PyObject* ndarray, Safe_TF_TensorPtr* out_tensor) {\n \n   // Make sure we dereference this array object in case of error, etc.\n   Safe_PyObjectPtr array_safe(make_safe(\n-      PyArray_FromAny(ndarray, nullptr, 0, 0, NPY_ARRAY_CARRAY, nullptr)));\n+      PyArray_FromAny(ndarray, nullptr, 0, 0, NPY_ARRAY_CARRAY_RO, nullptr)));\n   if (!array_safe) return errors::InvalidArgument(\"Not a ndarray.\");\n   PyArrayObject* array = reinterpret_cast<PyArrayObject*>(array_safe.get());\n \n", "fix_pattern": "<pattern>: when changing the array requirements from a copy-on-write (NPY_ARRAY_CARRAY) to a read-only (NPY_ARRAY_CARRAY_RO) in the NumPy API, this optimization can improve performance by preventing unnecessary copying of data when it is not needed."}
{"number": 619, "change": "@@ -92,7 +92,11 @@ void StringReader(png_structp png_ptr, png_bytep data, png_size_t length) {\n   DecodeContext* const ctx =\n       absl::bit_cast<DecodeContext*>(png_get_io_ptr(png_ptr));\n   if (static_cast<png_size_t>(ctx->data_left) < length) {\n-    memset(data, 0, length);\n+    // Don't zero out the data buffer as it has been lazily allocated (copy on\n+    // write) and zeroing it out here can produce an OOM. Since the buffer is\n+    // only used for reading data from the image, this doesn't result in any\n+    // data leak, so it is safe to just leave the buffer be as it is and just\n+    // exit with error.\n     png_error(png_ptr, \"More bytes requested to read than available\");\n   } else {\n     memcpy(data, ctx->data, length);\n", "fix_pattern": "<pattern>: if a buffer has been lazily allocated with copy-on-write semantics and is only used for reading, avoid unnecessary zeroing out of the buffer to prevent potential out-of-memory errors (OOM) and improve performance by bypassing the memset call."}
{"number": 622, "change": "@@ -12018,9 +12018,9 @@ MaybeHandle<Object> JSArray::SetElementsLength(\n           .Assert();\n     }\n \n-    SetProperty(deleted, isolate->factory()->length_string(),\n-                isolate->factory()->NewNumberFromUint(delete_count),\n-                STRICT).Assert();\n+    ElementsAccessor* accessor = deleted->GetElementsAccessor();\n+    accessor->SetLength(deleted, isolate->factory()->NewNumberFromUint(\n+                                     delete_count)).Check();\n   }\n \n   RETURN_ON_EXCEPTION(\n", "fix_pattern": "<pattern>: if a property is being set on an object using a method that takes multiple parameters, and it can be replaced with a more specific method that directly sets the length, preferably refactor the call to use the dedicated length-setting method (SetLength) for optimization."}
{"number": 623, "change": "@@ -62,13 +62,13 @@\n #include \"mongo/db/field_parser.h\"\n #include \"mongo/db/hasher.h\"\n #include \"mongo/db/jsobj.h\"\n+#include \"mongo/db/operation_context_impl.h\"\n #include \"mongo/db/ops/delete.h\"\n #include \"mongo/db/query/internal_plans.h\"\n #include \"mongo/db/range_deleter_service.h\"\n #include \"mongo/db/repl/oplog.h\"\n #include \"mongo/db/repl/repl_coordinator_global.h\"\n #include \"mongo/db/repl/rs.h\"\n-#include \"mongo/db/operation_context_impl.h\"\n #include \"mongo/db/write_concern.h\"\n #include \"mongo/logger/ramlog.h\"\n #include \"mongo/s/chunk.h\"\n@@ -2274,7 +2274,7 @@ namespace mongo {\n                 Lock::GlobalRead lk(txn->lockState());\n \n                 // if durability is on, force a write to journal\n-                if (getDur().commitNow(txn)) {\n+                if (txn->recoveryUnit()->awaitCommit()) {\n                     log() << \"migrate commit flushed to journal for '\" << ns << \"' \" << min << \" -> \" << max << migrateLog;\n                 }\n             }\n", "fix_pattern": "<pattern>: replace calls to getDur().commitNow(txn) with txn->recoveryUnit()->awaitCommit() to optimize transaction commit handling by leveraging the database's recovery unit mechanism, which may provide better performance characteristics and reduce overhead."}
{"number": 624, "change": "@@ -31,6 +31,7 @@\n #include <boost/intrusive_ptr.hpp>\n \n #include \"mongo/platform/atomic_word.h\"\n+#include \"mongo/util/allocator.h\"\n \n namespace mongo {\n \n@@ -56,7 +57,7 @@ public:\n     }\n \n     static SharedBuffer allocate(size_t bytes) {\n-        return takeOwnership(static_cast<char*>(malloc(sizeof(Holder) + bytes)));\n+        return takeOwnership(static_cast<char*>(mongoMalloc(sizeof(Holder) + bytes)));\n     }\n \n     /**\n", "fix_pattern": "<pattern>: if a memory allocation is performed using malloc from Standard C, replace it with mongoMalloc from the MongoDB Project to potentially benefit from custom memory management optimizations specific to that library."}
{"number": 625, "change": "@@ -33,6 +33,7 @@\n \n #include \"mongo/util/concurrency/spin_lock.h\"\n \n+#include <sched.h>\n #include <time.h>\n \n \n@@ -59,7 +60,7 @@ void SpinLock::_lockSlowPath() {\n     for (int i = 0; i < 1000; i++) {\n         if (_tryLock())\n             return;\n-        pthread_yield();\n+        sched_yield();\n     }\n \n     struct timespec t;\n", "fix_pattern": "<pattern>: if pthread_yield is used for thread yielding, replace it with sched_yield for potentially better performance as sched_yield is a more general-purpose function optimized for this specific use case."}
{"number": 628, "change": "@@ -380,8 +380,8 @@ void UI_Canvas::DrawGrid_Dotty()\n \t\t\t\tfl_point(sx, sy);\n \t\t\telse\n \t\t\t{\n-\t\t\t\tfl_rect(sx, sy, 2, 2);\n-\t\t\t\t\n+\t\t\t\tfl_rectf(sx, sy, 2, 2);\n+\n \t\t\t\t// fl_line(sx-0, sy, sx+1, sy);\n \t\t\t\t// fl_line(sx, sy-0, sx, sy+1);\n \t\t\t}\n", "fix_pattern": "<pattern>: if the rendering function is called with integer parameters for drawing rectangles, and a corresponding float version exists, switch from `fl_rect` to `fl_rectf` for better precision and potential performance improvements due to reduced type conversion overhead."}
{"number": 629, "change": "@@ -948,8 +948,7 @@ static const char * DoParseBindingFunc(key_binding_t& bind, const char * func_st\n \t// line tokeniser.\n \n \tstatic char buffer[600];\n-\tstrncpy(buffer, func_str, sizeof(buffer));\n-\tbuffer[sizeof(buffer) - 1] = 0;\n+\tStringCopy(buffer, sizeof(buffer), func_str);\n \n \tfor (unsigned int k = 0 ; buffer[k] ; k++)\n \t\tif (buffer[k] == ',' || buffer[k] == ':')\n", "fix_pattern": "<pattern>: if using strncpy for string copying, replace it with a project-specific optimized StringCopy function for better performance and potential additional safety features."}
{"number": 630, "change": "@@ -29,7 +29,7 @@ void RageSound_Null::MixerThread()\n {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \n \t/* not sure if a nansleep is needed, but certainly helps\n \t * when there is LOG->Trace in GetData() */\n", "fix_pattern": "<pattern>: if a loop is detected that uses sleep from the Standard C++ library, replace it with SDL_Delay from the SDL library for potentially better performance and responsiveness in a multimedia context."}
{"number": 631, "change": "@@ -265,7 +265,7 @@ int RageSound_Linux::MixerThread_start(void *p) {\n void RageSound_Linux::MixerThread() {\n \t/* SOUNDMAN will be set once RageSoundManager's ctor returns and\n \t * assigns it; we might get here before that happens, though. */\n-\twhile(!SOUNDMAN && !shutdown) sleep(10);\n+\twhile(!SOUNDMAN && !shutdown) SDL_Delay(10);\n \twhile(!shutdown) { while (GetData()); }\n }\n \t\n", "fix_pattern": "<pattern>: if using a sleep function in a busy-wait loop, replace it with a library-specific delay function (like SDL_Delay) to improve performance and avoid unnecessary CPU usage."}
{"number": 632, "change": "@@ -73,7 +73,7 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n \n   /* I don't like this but I can't think of another place to put it. */\n   while (!SOUNDMAN)\n-    sleep(10);\n+    SDL_Delay(10);\n   \n   for (unsigned i = 0; i < P->sounds.size(); ++i) {\n     if (P->sounds[i]->stopping)\n@@ -88,6 +88,8 @@ void RageSound_SDL::GetData(void *userdata, Uint8 *stream, int len) {\n     }\n   }\n \n+  mix.read(buf); \n+\n   memcpy(stream, buf, len);\n   P->last_cursor_pos += buffersize_frames;\n }\n", "fix_pattern": "<pattern>: if a call to sleep is made using a standard C++ sleep function, replace it with a platform-specific equivalent like SDL_Delay for improved performance in scenarios involving multimedia applications or game development where frame timing is critical."}
{"number": 636, "change": "@@ -1160,7 +1160,7 @@ class LunaThemeManager: public Luna<ThemeManager>\n public:\n \tLunaThemeManager() { LUA->Register( Register ); }\n \n-\tstatic int GetMetric( T* p, lua_State *L )\t\t\t{ lua_pushstring(L, p->GetMetric(SArg(1),SArg(2)) ); return 1; }\n+\tstatic int GetMetric( T* p, lua_State *L )\t\t\t{ p->PushMetric( L, SArg(1),SArg(2) ); return 1; }\n \tstatic int GetString( T* p, lua_State *L )\t\t\t{ lua_pushstring(L, p->GetString(SArg(1),SArg(2)) ); return 1; }\n \tstatic int GetPathG( T* p, lua_State *L )\t\t\t{ lua_pushstring(L, p->GetPathG(SArg(1),SArg(2)) ); return 1; }\n \tstatic int GetPathB( T* p, lua_State *L )\t\t\t{ lua_pushstring(L, p->GetPathB(SArg(1),SArg(2)) ); return 1; }\n", "fix_pattern": "<pattern>: if an API method retrieves a value and then passes it to another API method in a subsequent call (like calling GetMetric followed by pushing it to Lua), refactor the code to consolidate the actions into a single method (like PushMetric) that directly handles the Lua interaction and reduces overhead."}
{"number": 637, "change": "@@ -316,7 +316,7 @@ static int IdenticalChildrenIndexLayer(lua_State* L)\n {\n \tif(lua_isnumber(L, 2))\n \t{\n-\t\tlua_gettable(L, 1);\n+\t\tlua_rawget(L, 1);\n \t}\n \telse\n \t{\n", "fix_pattern": "<pattern>: replace calls to lua_gettable with lua_rawget for faster access when the key is known and does not require triggering metamethods, enhancing performance in scenarios where raw table access is sufficient."}
{"number": 638, "change": "@@ -294,7 +294,7 @@ next_plugin(struct plugin_cycle *cycle)\n \n \tif (cycle->next_plugin >= cycle->list->plugins->len) {\n \t\t/* no plugins left */\n-\t\tg_timeout_add(0, plugin_delayed_fail, cycle);\n+\t\tg_idle_add(plugin_delayed_fail, cycle);\n \t\treturn;\n \t}\n \n@@ -302,7 +302,7 @@ next_plugin(struct plugin_cycle *cycle)\n \t\t\t\t\t\t    cycle->next_plugin++);\n \tif (start_plugin(cycle, plugin_path) < 0) {\n \t\t/* system error */\n-\t\tg_timeout_add(0, plugin_delayed_fail, cycle);\n+\t\tg_idle_add(plugin_delayed_fail, cycle);\n \t\treturn;\n \t}\n }\n", "fix_pattern": "<pattern>: if multiple calls to g_timeout_add with a zero interval are made, replace them with g_idle_add to improve responsiveness and avoid unnecessary timer overhead."}
{"number": 639, "change": "@@ -34,8 +34,8 @@ screen_status_printf(const char *format, ...)\n {\n \tva_list ap;\n \tva_start(ap,format);\n-\tchar *msg = g_strdup_vprintf(format,ap);\n+\tchar msg[256];\n+\tvsnprintf(msg, sizeof(msg), format, ap);\n \tva_end(ap);\n \tscreen_status_message(msg);\n-\tg_free(msg);\n }\n", "fix_pattern": "<pattern>: if dynamic memory allocation is being used to create a formatted string with g_strdup_vprintf followed by g_free, refactor the code to use a stack-allocated buffer with vsnprintf to avoid the overhead of heap allocation and deallocation."}
{"number": 640, "change": "@@ -192,11 +192,10 @@ removeDeletedFromDirectory(char *path_max_tmp, struct directory *directory)\n \n \tfor (i = dv->nr; --i >= 0; ) {\n \t\tconst char *path_fs;\n-\t\tstruct stat st;\n \n \t\tpath_fs = map_directory_fs(dv->base[i], path_max_tmp);\n-\t\tif (path_fs == NULL || (stat(path_fs, &st) == 0 &&\n-\t\t\t\t\tS_ISDIR(st.st_mode)))\n+\t\tif (path_fs == NULL ||\n+\t\t    !g_file_test(path_fs, G_FILE_TEST_IS_DIR))\n \t\t\tcontinue;\n \t\tg_debug(\"removing directory: %s\", dv->base[i]->path);\n \t\tdirvec_delete(dv, dv->base[i]);\n", "fix_pattern": "<pattern>: if the code checks for file characteristics using the stat function, replace it with a higher-level API like g_file_test for clearer readability and potential performance improvements, as g_file_test may reduce overhead in user-space checks compared to direct stat calls."}
{"number": 641, "change": "@@ -101,7 +101,9 @@ tag_pool_get_item(enum tag_type type, const char *value, size_t length)\n \tslot_p = &slots[calc_hash_n(type, value, length) % NUM_SLOTS];\n \tfor (slot = *slot_p; slot != NULL; slot = slot->next) {\n \t\tif (slot->item.type == type &&\n-\t\t    strcmp(value, slot->item.value) == 0 && slot->ref < 0xff) {\n+\t\t    length == strlen(slot->item.value) &&\n+\t\t    memcmp(value, slot->item.value, length) == 0 &&\n+\t\t    slot->ref < 0xff) {\n \t\t\tassert(slot->ref > 0);\n \t\t\t++slot->ref;\n \t\t\treturn &slot->item;\n", "fix_pattern": "<pattern>: if a strcmp comparison is used, replace it with a combination of strlen to check lengths and memcmp to compare the strings for potentially better performance by avoiding null termination checks and leveraging raw memory comparison."}
{"number": 642, "change": "@@ -56,11 +56,11 @@ gme_file_decode(struct decoder *decoder, const char *path_fs)\n \n \t/* play */\n \tdo {\n-\t\tif((gme_err = gme_play(emu, GME_BUF_SIZE>>1, buf)) != NULL){\n+\t\tif((gme_err = gme_play(emu, GME_BUF_SIZE, buf)) != NULL){\n \t\t\tg_warning(\"%s\", gme_err);\n \t\t\treturn;\n \t\t}\n-\t\tcmd = decoder_data(decoder, NULL, buf, GME_BUF_SIZE, 0);\n+\t\tcmd = decoder_data(decoder, NULL, buf, sizeof(buf), 0);\n \n \t\tif(cmd == DECODE_COMMAND_SEEK) {\n \t\t\tfloat where = decoder_seek_where(decoder);\n", "fix_pattern": "<pattern>: if the buffer size passed to gme_play and decoder_data is defined using a constant expression like GME_BUF_SIZE, ensure that the actual size of the buffer is used (using sizeof(buf)) instead of a fixed size to elevate potential performance by utilizing the full buffer capacity effectively."}
{"number": 643, "change": "@@ -94,12 +94,12 @@ bool AlreadyInjected(HANDLE process, const std::filesystem::path& dll) {\n     modules.resize(neededBytes / sizeof(HMODULE));\n   }\n \n+  auto dllBaseName = dll.filename().wstring();\n+\n   wchar_t buf[MAX_PATH];\n   for (auto module: modules) {\n-    auto length = GetModuleFileNameExW(process, module, buf, MAX_PATH);\n-    if (\n-      std::filesystem::path(std::wstring_view(buf, length)).filename()\n-      == dll.filename()) {\n+    auto length = GetModuleBaseNameW(process, module, buf, MAX_PATH);\n+    if (std::wstring_view(buf, length) == dllBaseName) {\n       return true;\n     }\n   }\n", "fix_pattern": "<pattern>: if a call to GetModuleFileNameExW retrieves the full path of a module but only the base name is needed, replace it with GetModuleBaseNameW to avoid unnecessary overhead of retrieving the full path and improve performance."}
{"number": 644, "change": "@@ -1860,7 +1860,7 @@ void CSoundFile::LoadMixPlugins(FileReader &file)\n \t\t\t\t\tif(m_MixPlugins[plug].pPluginData)\n \t\t\t\t\t{\n \t\t\t\t\t\tm_MixPlugins[plug].nPluginDataSize = pluginDataChunkSize;\n-\t\t\t\t\t\tmemcpy(m_MixPlugins[plug].pPluginData, pluginDataChunk.GetRawData(), pluginDataChunkSize);\n+\t\t\t\t\t\tpluginDataChunk.ReadRaw(m_MixPlugins[plug].pPluginData, pluginDataChunkSize);\n \t\t\t\t\t}\n \t\t\t\t}\n \n", "fix_pattern": "<pattern>: if an API method using `memcpy` to copy data from one memory location to another is detected, replace it with a more specialized method (in this case, `ReadRaw()`) that likely includes optimizations specific to the data source being read from."}
{"number": 645, "change": "@@ -1270,8 +1270,7 @@ void H2MOD::ApplyHooks() {\n \t\tPatchCall(Base + 0xE9E50, reinterpret_cast<DWORD>(print_to_console));\n \n \t\t//allow AI in MP\n-\t\tBYTE bytes[20] = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 };\n-\t\tpatchBYTEs((BYTE*)(h2mod->GetBase() + 0x30E67C), bytes, 20);\n+\t\tNopFill(h2mod->GetBase() + 0x30E67C, 0x14);\n \t}\n #pragma endregion\n \n", "fix_pattern": "<pattern>: if a function manually fills a buffer with a repetitive value, refactor the code to use a more specialized function (like NopFill) that likely performs the task more efficiently."}
{"number": 647, "change": "@@ -45,10 +45,10 @@ public:\n         : m_vector(vector)\n     {}\n \n-    void emplace_back(T && value)\n+    void emplace_back(T &&value)\n     {\n         QMutexLocker lock(&m_mutex);\n-        m_vector.emplace_back(value);\n+        m_vector.push_back(std::move(value));\n     }\n \n     void emplace_back(const T &value)\n", "fix_pattern": "<pattern>: when transferring ownership of an object to a vector, use std::move to avoid unnecessary copies, replacing emplace_back with push_back to insert the element into the vector directly."}
{"number": 648, "change": "@@ -145,8 +145,8 @@ void QWaylandSurfaceItem::init(QWaylandSurface *surface)\n     setAcceptHoverEvents(true);\n     connect(surface, SIGNAL(mapped()), this, SLOT(surfaceMapped()));\n     connect(surface, SIGNAL(unmapped()), this, SLOT(surfaceUnmapped()));\n-    connect(surface, SIGNAL(destroyed(QObject *)), this, SLOT(surfaceDestroyed(QObject *)));\n-    connect(surface, SIGNAL(damaged(const QRect &)), this, SLOT(surfaceDamaged(const QRect &)));\n+    connect(surface, SIGNAL(destroyed(QObject*)), this, SLOT(surfaceDestroyed(QObject*)));\n+    connect(surface, SIGNAL(damaged(QRect)), this, SLOT(surfaceDamaged(QRect)));\n     connect(surface, SIGNAL(parentChanged(QWaylandSurface*,QWaylandSurface*)),\n             this, SLOT(parentChanged(QWaylandSurface*,QWaylandSurface*)));\n     connect(surface, SIGNAL(sizeChanged()), this, SLOT(updateSize()));\n", "fix_pattern": "<pattern>: if a signal is connected to a slot, and the signal parameter type is modified from a reference type (e.g., const QRect &) to a value type (e.g., QRect), then change the signal's parameter type to the value type to potentially enhance performance by avoiding unnecessary reference copying."}
{"number": 649, "change": "@@ -71,7 +71,15 @@ struct DisassembleFunctionListener : public JITEventListener {\n \n static double CurrentTimeInSeconds() {\n #ifdef _WIN32\n-    return time(NULL);\n+    static uint64_t freq = 0;\n+    if(freq == 0) {\n+        LARGE_INTEGER i;\n+        QueryPerformanceFrequency(&i);\n+        freq = i.QuadPart;\n+    }\n+    LARGE_INTEGER t;\n+    QueryPerformanceCounter(&t);\n+    return t.QuadPart / (double) freq;\n #else\n     struct timeval tv;\n     gettimeofday(&tv, NULL);\n", "fix_pattern": "<pattern>: if the API method time() is being used to obtain current time, replace it with QueryPerformanceCounter() for higher precision and performance, caching the frequency of the performance counter to avoid repeated calls to QueryPerformanceFrequency() in subsequent calls."}
{"number": 650, "change": "@@ -1712,20 +1712,18 @@ float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {\n static void CreateClusterTree(CLUSTERER *Clusterer) {\n   ClusteringContext context;\n   ClusterPair HeapEntry;\n-  TEMPCLUSTER *PotentialCluster;\n \n   // each sample and its nearest neighbor form a \"potential\" cluster\n   // save these in a heap with the \"best\" potential clusters on top\n   context.tree = Clusterer->KDTree;\n-  context.candidates =\n-      static_cast<TEMPCLUSTER *>(malloc(Clusterer->NumberOfSamples * sizeof(TEMPCLUSTER)));\n+  context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];\n   context.next = 0;\n   context.heap = new ClusterHeap(Clusterer->NumberOfSamples);\n   KDWalk(context.tree, reinterpret_cast<void_proc>(MakePotentialClusters), &context);\n \n   // form potential clusters into actual clusters - always do \"best\" first\n   while (context.heap->Pop(&HeapEntry)) {\n-    PotentialCluster = HeapEntry.data();\n+    TEMPCLUSTER *PotentialCluster = HeapEntry.data();\n \n     // if main cluster of potential cluster is already in another cluster\n     // then we don't need to worry about it\n@@ -1761,7 +1759,7 @@ static void CreateClusterTree(CLUSTERER *Clusterer) {\n   FreeKDTree(context.tree);\n   Clusterer->KDTree = nullptr;\n   delete context.heap;\n-  free(context.candidates);\n+  delete[] context.candidates;\n } // CreateClusterTree\n \n /**\n", "fix_pattern": "<pattern>: if memory is allocated using malloc, switch to using new to allocate memory and delete[] to deallocate it, improving performance and type-safety in C++."}
{"number": 652, "change": "@@ -52,7 +52,9 @@ int win32_cond_destroy(win32_cond_t *cv)\n int win32_cond_wait(win32_cond_t *cv, HANDLE *external_mutex)\n {\n   // Avoid race conditions.\n-  InterlockedIncrement((volatile LONG*)&cv->waiters_count_);\n+  EnterCriticalSection (&cv->waiters_count_lock_);\n+  cv->waiters_count_++;\n+  LeaveCriticalSection (&cv->waiters_count_lock_);\n \n   // This call atomically releases the mutex and waits on the\n   // semaphore until <pthread_cond_signal> or <pthread_cond_broadcast>\n", "fix_pattern": "<pattern>: if an atomic increment using InterlockedIncrement is replaced with a critical section for managing access to a shared variable, ensure that it is appropriate for the expected contention level; consider that this pattern may reduce performance under low contention due to the overhead of managing a critical section, while potentially improving performance under high contention scenarios by serializing access."}
{"number": 653, "change": "@@ -117,7 +117,14 @@ struct heif_error libde265_new_decoder(void** dec)\n   struct heif_error err = { heif_error_Ok, heif_suberror_Unspecified, kSuccess };\n \n   decoder->ctx = de265_new_decoder();\n-  de265_start_worker_threads(decoder->ctx,1);\n+#if defined(__EMSCRIPTEN__)\n+  // Speed up decoding from JavaScript.\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_DEBLOCKING, 1);\n+  de265_set_parameter_bool(decoder->ctx, DE265_DECODER_PARAM_DISABLE_SAO, 1);\n+#else\n+  // Worker threads are not supported when running on Emscripten.\n+  de265_start_worker_threads(decoder->ctx, 1);\n+#endif\n \n   *dec = decoder;\n   return err;\n", "fix_pattern": "<pattern>: if the code is running under Emscripten, disable specific decoding parameters to potentially improve performance, otherwise, start worker threads for decoding."}
{"number": 656, "change": "@@ -3,6 +3,7 @@\n #include <fcntl.h>\n #include <unistd.h>\n #include <sys/uio.h>\n+#include <limits.h>\n \n #include \"txn_proto2_impl.h\"\n #include \"counter.h\"\n@@ -203,7 +204,9 @@ txn_logger::writer(\n     unsigned id, int fd,\n     std::vector<unsigned> assignment)\n {\n-  std::vector<iovec> iovs(g_nworkers * g_perthread_buffers);\n+\n+  std::vector<iovec> iovs(\n+      std::min(size_t(IOV_MAX), g_nworkers * g_perthread_buffers));\n   std::vector<pbuffer *> pxs;\n   struct timespec last_io_completed;\n \n", "fix_pattern": "<pattern>: if a vector is initialized with a potentially large size based on calculated values, use std::min to constrain its size to a defined limit (IOV_MAX) to prevent excessive memory allocation that may lead to performance issues."}
{"number": 657, "change": "@@ -102,7 +102,7 @@ ffmpeg_mptr::seek_to(int frame)\n \n \t\tstring command;\n \t\t\n-\t\tcommand=strprintf(\"ffmpeg -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",filename.c_str());\n+\t\tcommand=strprintf(\"ffmpeg -ss 00:00:00.%d -i \\\"%s\\\" -an -f image2pipe -vcodec ppm -\\n\",frame,filename.c_str());\n \t\t\n \t\tfile=popen(command.c_str(),POPEN_BINARY_READ_TYPE);\n \n@@ -133,7 +133,8 @@ ffmpeg_mptr::seek_to(int frame)\n \t\t\t}\n \t\t\t// Close the unneeded pipein\n \t\t\tclose(p[1]);\n-\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n+\t\t\tstring time = strprintf(\"00:00:00.%d\",frame);\n+\t\t\texeclp(\"ffmpeg\", \"ffmpeg\", \"-ss\", time.c_str(), \"-i\", filename.c_str(), \"-an\", \"-f\", \"image2pipe\", \"-vcodec\", \"ppm\", \"-\", (const char *)NULL);\n \t\t\t// We should never reach here unless the exec failed\n \t\t\tcerr<<\"Unable to open pipe to ffmpeg\"<<endl;\n \t\t\t_exit(1);\n", "fix_pattern": "<pattern>: if the API call to execlp is made with command-line parameters that do not include a timestamp, enhance the command by adding a timestamp parameter. This adjustment can optimize the ffmpeg processing by enabling seeking to a specific frame in the media input, thereby potentially reducing the processing time."}
{"number": 658, "change": "@@ -37,7 +37,6 @@ static PythonEngine engine;\n PyObject *THPEngineClass = NULL;\n \n struct CallbackContext {\n-  std::mutex mutex;\n   std::string error;\n   THPObjectPtr outputs;\n   // Used to determine which callback arguments should be used to\n@@ -182,7 +181,7 @@ PyObject *THPEngine_run_backward(THPEngine *self, PyObject *args, PyObject *kwar\n       callbacks.emplace(entry.first.get(), [&ctx, &fn_info](Function* _unused, variable_list& grads) {\n         auto& saved_outputs = fn_info.first;\n         bool is_leaf = fn_info.second;\n-        std::lock_guard<std::mutex> guard(ctx.mutex);\n+        AutoGIL gil;\n         for (auto& saved_out : saved_outputs) {\n           PyTuple_SET_ITEM(ctx.outputs.get(), saved_out.second,\n             THPVariable_Wrap(grads[saved_out.first]));\n", "fix_pattern": "<pattern>: if a mutex is used to protect a critical section of code, and there are performance issues, consider using a lightweight alternative such as AutoGIL that could potentially avoid the overhead of a mutex while still safely managing resource access in a multi-threaded environment."}
{"number": 659, "change": "@@ -1550,7 +1550,7 @@ void configure(std::vector<resource::memory> m, bool mbind,\n \n statistics stats() {\n     return statistics{alloc_stats::get(alloc_stats::types::allocs), alloc_stats::get(alloc_stats::types::frees), alloc_stats::get(alloc_stats::types::cross_cpu_frees),\n-        cpu_mem.nr_pages * page_size, cpu_mem.nr_free_pages * page_size, alloc_stats::get(alloc_stats::types::reclaims), alloc_stats::get(alloc_stats::types::large_allocs),\n+        get_cpu_mem().nr_pages * page_size, get_cpu_mem().nr_free_pages * page_size, alloc_stats::get(alloc_stats::types::reclaims), alloc_stats::get(alloc_stats::types::large_allocs),\n         alloc_stats::get(alloc_stats::types::foreign_mallocs), alloc_stats::get(alloc_stats::types::foreign_frees), alloc_stats::get(alloc_stats::types::foreign_cross_frees)};\n }\n \n", "fix_pattern": "<pattern>: if the same instance of `cpu_mem` is accessed multiple times for its properties, refactor to call `get_cpu_mem()` only once, thus reducing the overhead of potential repeated calls to a function that retrieves the same data."}
{"number": 664, "change": "@@ -83,7 +83,7 @@ public:\n \n     declare(suffix, \"get-order-first-query\", \"DNSSEC Ordering Query, first\", \"select ordername from records where domain_id=? and disabled=0 and ordername is not null order by 1 asc limit 1\");\n     declare(suffix, \"get-order-before-query\", \"DNSSEC Ordering Query, before\", \"select ordername, name from records where ordername <= ? and domain_id=? and disabled=0 and ordername is not null order by 1 desc limit 1\");\n-    declare(suffix, \"get-order-after-query\", \"DNSSEC Ordering Query, after\", \"select min(ordername) from records where ordername > ? and domain_id=? and disabled=0 and ordername is not null\");\n+    declare(suffix, \"get-order-after-query\", \"DNSSEC Ordering Query, after\", \"select ordername from records where ordername > ? and domain_id=? and disabled=0 and ordername is not null order by 1 asc limit 1\");\n     declare(suffix, \"get-order-last-query\", \"DNSSEC Ordering Query, last\", \"select ordername, name from records where ordername != '' and domain_id=? and disabled=0 and ordername is not null order by 1 desc limit 1\");\n \n     declare(suffix, \"update-ordername-and-auth-query\", \"DNSSEC update ordername and auth for a qname query\", \"update records set ordername=?,auth=? where domain_id=? and name=? and disabled=0\");\n", "fix_pattern": "<pattern>: if a query is designed to retrieve a single value from a database, prefer using a `LIMIT 1` to improve performance and avoid fetching unnecessary rows. Additionally, order the results to ensure determinism in case of ties."}
{"number": 665, "change": "@@ -286,7 +286,7 @@ void MOADNSParser::init(bool query, const char *packet, unsigned int len)\n \n       if (query && (dr.d_place == DNSResourceRecord::ANSWER || dr.d_place == DNSResourceRecord::AUTHORITY || (dr.d_type != QType::OPT && dr.d_type != QType::TSIG && dr.d_type != QType::SIG && dr.d_type != QType::TKEY) || ((dr.d_type == QType::TSIG || dr.d_type == QType::SIG || dr.d_type == QType::TKEY) && dr.d_class != QClass::ANY))) {\n //        cerr<<\"discarding RR, query is \"<<query<<\", place is \"<<dr.d_place<<\", type is \"<<dr.d_type<<\", class is \"<<dr.d_class<<endl;\n-        dr.d_content=std::shared_ptr<DNSRecordContent>(new UnknownRecordContent(dr, pr));\n+        dr.d_content=std::make_shared<UnknownRecordContent>(dr, pr);\n       }\n       else {\n //        cerr<<\"parsing RR, query is \"<<query<<\", place is \"<<dr.d_place<<\", type is \"<<dr.d_type<<\", class is \"<<dr.d_class<<endl;\n", "fix_pattern": "<pattern>: if a std::shared_ptr is allocated using new, replace it with std::make_shared to improve performance and memory efficiency by combining allocation of the object and control block."}
{"number": 667, "change": "@@ -19,6 +19,7 @@\n \n #include \"OhmmsPETE/OhmmsMatrix.h\"\n #include \"Numerics/DeterminantOperators.h\"\n+#include \"Numerics/OhmmsBlas.h\"\n #include <limits>\n \n namespace ohmmsqmc {\n@@ -132,7 +133,8 @@ namespace ohmmsqmc {\n     evaluate(const ParticleSet& P, int iat, VV& psi) {\n       BasisSet->evaluate(P,iat);\n       for(int j=0 ; j<NumPtcls; j++) \n-        psi[j] = dot(&C(j,0),BasisSet->y(0),BasisSize);\n+        psi[j] = BLAS::dot(BasisSize,&C(j,0),BasisSet->y(0));\n+        //psi[j] = dot(&C(j,0),BasisSet->y(0),BasisSize);\n     }\n \n     /**@ingroup particlebyparticle \n", "fix_pattern": "<pattern>: if a dot product calculation is being performed using a custom implementation, replace it with a call to the optimized BLAS library function (e.g., BLAS::dot) to leverage optimized routines for better performance."}
{"number": 669, "change": "@@ -197,8 +197,7 @@ ImageDescriptor::ImageDescriptor(int _Width, int _Height, uint32 *_Pixels)\n \tVScale = 1.0;\n \tUScale = 1.0;\n \tSize = _Width * _Height * 4;\n-\tPixels = new uint32[_Width * _Height];\n-\tmemcpy(Pixels, _Pixels, Size);\n+\tPixels = _Pixels;\n \tFormat = RGBA8;\n \tMipMapCount = 0;\n }\n", "fix_pattern": "<pattern>: if pixels are being copied from a source array to a newly allocated array using memcpy, and it is safe to assign the source directly to the target, replace the memcpy with direct assignment, which avoids unnecessary memory operations."}
{"number": 670, "change": "@@ -408,8 +408,8 @@ bool AP_Proximity_LightWareSF40C::process_reply()\n \n         case RequestType_DistanceMeasurement:\n         {\n-            float angle_deg = (float)atof(element_buf[0]);\n-            float distance_m = (float)atof(element_buf[1]);\n+            float angle_deg = strtof(element_buf[0], NULL);\n+            float distance_m = strtof(element_buf[1], NULL);\n             uint8_t sector;\n             if (convert_angle_to_sector(angle_deg, sector)) {\n                 _angle[sector] = angle_deg;\n", "fix_pattern": "<pattern>: replace the usage of atof with strtof for better performance and type safety when converting strings to floating-point numbers, as strtof avoids the overhead associated with the construction of a double and provides additional error handling capabilities."}
{"number": 671, "change": "@@ -104,7 +104,7 @@ Menu::_run_command(bool prompt_on_enter)\n         if (_argv[argc].str == nullptr || '\\0' == _argv[argc].str[0])\n             break;\n         _argv[argc].i = atol(_argv[argc].str);\n-        _argv[argc].f = atof(_argv[argc].str);      // calls strtod, > 700B !\n+        _argv[argc].f = strtof(_argv[argc].str, NULL);\n         argc++;\n     }\n     \n", "fix_pattern": "<pattern>: if a conversion from a string to a floating-point number is done using atof, which returns a double, replace it with strtof for better performance and to avoid unnecessary conversions, as strtof directly converts to a float."}
{"number": 672, "change": "@@ -1215,7 +1215,8 @@ MidiTimeAxisView::show_all_automation (bool apply_to_selection)\n \n \t\t\t// Show automation for all controllers named in midnam file\n \t\t\tboost::shared_ptr<MasterDeviceNames> device_names = get_device_names();\n-\t\t\tif (device_names && !device_names->controls().empty()) {\n+\t\t\tif (gui_property (X_(\"midnam-model-name\")) != \"Generic\" &&\n+\t\t\t     device_names && !device_names->controls().empty()) {\n \t\t\t\tconst std::string device_mode       = _midnam_custom_device_mode_selector.get_active_text();\n \t\t\t\tconst uint16_t    selected_channels = midi_track()->get_playback_channel_mask();\n \t\t\t\tfor (uint32_t chn = 0; chn < 16; ++chn) {\n", "fix_pattern": "<pattern>: if a conditional check is being performed on the presence of `device_names` and its controls, add an additional check for the GUI property using `gui_property` to potentially short-circuit the evaluation and avoid unnecessary checks on `device_names` when not required."}
{"number": 674, "change": "@@ -545,7 +545,7 @@ ShuttleControl::render (cairo_t* cr, cairo_rectangle_t*)\n \t} else if ( speed ==0.0 )\n \t\trounded_rectangle (cr, offset, 4, marker_size-2, marker_size-2, 1);\n \telse\n-\t\tcairo_arc (cr, offset + marker_size*0.5, 2 + marker_size*0.5, marker_size*0.5, 0, 360);\n+\t\tcairo_arc (cr, offset + marker_size*0.5, 2 + marker_size*0.5, marker_size*0.5, 0, 2. * M_PI);\n \tcairo_set_line_width (cr, 2);\n \tcairo_stroke (cr);\n \n", "fix_pattern": "<pattern>: if the angle parameters for the cairo_arc function are provided as full circle degrees (0 to 360), convert them to radians (0 to 2 * M_PI) for proper use in the Cairo Graphics Library, which expects radians as input."}
{"number": 676, "change": "@@ -413,8 +413,10 @@ void RenderToDisk::saveImage(\n \t\t// All threaded image writers were busy\n \t\tif(i == Nthreads){\n \t\t\t//printf(\"Error: all image writers are busy...\\n\");\n+\t\t\tal::wait(1./1e3); // wait 1 ms for disk i/o to finish up (hopefully)\n+\t\t\tgoto CHECK_THREADS;\n \t\t\t// Use main thread---this will definitely stall\n-\t\t\tal::Image::save(name, pixs, w,h, format, mImageCompress);\n+\t\t\t//al::Image::save(name, pixs, w,h, format, mImageCompress);\n \t\t}\n \t\n \t\t++mFrameNumber;\n", "fix_pattern": "<pattern>: if an API call for saving an image is immediately followed by a wait function for disk I/O, and this wait is used as a workaround for potential async performance issues, then consider removing the save call and place a wait instead to defer execution. The use of `goto` suggests that a retry or a check is planned, indicating an issue with thread synchronization or disk I/O performance that may need addressing instead of relying on a wait."}
{"number": 677, "change": "@@ -57,7 +57,7 @@ AccountOpResult AccountMgr::CreateAccount(std::string username, std::string pass\n \n     if(!loginDatabase.PExecute(\"INSERT INTO account(username,sha_pass_hash,joindate) VALUES('%s',SHA1(CONCAT('%s',':','%s')),NOW())\", username.c_str(), username.c_str(), password.c_str()))\n         return AOR_DB_INTERNAL_ERROR;                       // unexpected error\n-    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM account, realmlist WHERE account.id NOT IN (SELECT acctid FROM realmcharacters)\");\n+    loginDatabase.Execute(\"INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist,account LEFT JOIN realmcharacters ON acctid=account.id WHERE acctid IS NULL\");\n \n     return AOR_OK;                                          // everything's fine\n }\n", "fix_pattern": "<pattern>: when performing an insert operation that selects from multiple tables, refactor the query to use a LEFT JOIN to prevent inserting duplicate records, optimizing the execution by filtering on NULL values instead of using a subquery."}
{"number": 678, "change": "@@ -446,10 +446,7 @@ class DatabaseWorkerPool\n             if (!to || !from || !length)\n                 return 0;\n \n-            T* t = GetFreeConnection();\n-            unsigned long ret = mysql_real_escape_string(t->GetHandle(), to, from, length);\n-            t->Unlock();\n-            return ret;\n+            return mysql_real_escape_string(m_connections[IDX_SYNCH][0]->GetHandle(), to, from, length);\n         }\n \n         void Enqueue(SQLOperation* op)\n", "fix_pattern": "<pattern>: if obtaining a free connection and unlocking is done immediately after calling a method, remove the intermediate steps and directly use the connection from the array 'm_connections' to avoid the overhead of locking and unlocking unnecessary resources."}
{"number": 679, "change": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n \n+#include \"cstring.h\"\n #include \"uni2name.h\"\n #include \"unicode/unifilt.h\"\n #include \"unicode/uchar.h\"\n@@ -93,7 +94,7 @@ void UnicodeNameTransliterator::handleTransliterate(Replaceable& text, UTransPos\n         UChar32 c = text.char32At(cursor);\n         if ((len=u_charName(c, U_UNICODE_CHAR_NAME, buf, sizeof(buf), &status)) <= 0 || U_FAILURE(status)) {\n             sprintf(buf, \"U+%04lX\", c);\n-            len = strlen(buf);\n+            len = uprv_strlen(buf);\n         }\n \n         str.truncate(1);\n", "fix_pattern": "<pattern>: if the standard strlen function is used for measuring string length, replace it with uprv_strlen from the ICU library to leverage potential performance optimizations specific to Unicode string handling."}
{"number": 680, "change": "@@ -449,7 +449,7 @@ static UChar * convertFromUTF8(UChar *outBuf, int32_t outBufCapacity, int32_t *o\n     UChar *dest = outBuf;\n     u_strFromUTF8(dest, outBufCapacity, outputLength, in, inLength, status);\n     if (*status == U_BUFFER_OVERFLOW_ERROR) {\n-        dest = static_cast<UChar *>(malloc(*outputLength * sizeof(UChar)));\n+        dest = static_cast<UChar *>(uprv_malloc(*outputLength * sizeof(UChar)));\n         if (dest == NULL) {\n             *status = U_MEMORY_ALLOCATION_ERROR;\n             return NULL;\n", "fix_pattern": "<pattern>: if a call to malloc from the standard C library is replaced with uprv_malloc from the ICU library, then it likely indicates an improvement in memory management specific to the ICU library, which is optimized for performance and compatibility within its ecosystem."}
{"number": 684, "change": "@@ -120,7 +120,8 @@ void KLoadFileMetaDataThread::run()\n             if (variants.isEmpty()) {\n                 // the file has not been indexed, query the meta data\n                 // directly from the file\n-                KFileMetaInfo metaInfo(urls.first());\n+                const QString path = urls.first().toLocalFile();\n+                KFileMetaInfo metaInfo(path, QString(), KFileMetaInfo::Fastest);\n                 const QHash<QString, KFileMetaInfoItem> metaInfoItems = metaInfo.items();\n                 foreach (const KFileMetaInfoItem& metaInfoItem, metaInfoItems) {\n                     const QString uriString = metaInfoItem.name();\n", "fix_pattern": "<pattern>: if the KFileMetaInfo constructor is called with a QString that can be directly converted to a local file path, replace it with a direct call to toLocalFile() to improve performance by avoiding unnecessary conversions and using the Fastest option for efficiency."}
{"number": 685, "change": "@@ -56,7 +56,8 @@ static QString lookupIconNameFor(const KUrl &url, KUriFilterData::UriTypes type)\n             if (service && service->icon() != QLatin1String( \"unknown\" ))\n                 iconName = service->icon();\n             // Try to find an icon with the same name as the binary (useful for non-kde apps)\n-            else if ( !KIconLoader::global()->loadIcon( exeName, KIconLoader::NoGroup, 16, KIconLoader::DefaultState, QStringList(), 0, true ).isNull() )\n+            // Use iconPath rather than loadIcon() as the latter uses QPixmap (not threadsafe)\n+            else if ( !KIconLoader::global()->iconPath( exeName, KIconLoader::NoGroup, true ).isNull() )\n                 iconName = exeName;\n             else\n                 // not found, use default\n", "fix_pattern": "<pattern>: if an API method loads heavy graphical resources (QPixmap) that may not be thread-safe, replace it with a method that retrieves a path to the resource (iconPath) instead to improve performance and ensure thread safety."}
{"number": 686, "change": "@@ -1442,8 +1442,8 @@ void Applet::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QW\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, \"Wallpaper\");\n                     wallpaperConfig = KConfigGroup(&wallpaperConfig, w->pluginName());\n                     w->restore(wallpaperConfig);\n-                    disconnect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n-                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)));\n+                    connect(w, SIGNAL(update(QRectF)), this, SLOT(updateRect(QRectF)),\n+                            Qt::UniqueConnection);\n                 }\n \n                 painter->save();\n", "fix_pattern": "<pattern>: if a disconnect and then immediate reconnect is detected for a Qt signal, use Qt::UniqueConnection in the connect call to avoid redundant signals and improve performance by ensuring the connection is only made if it doesn't already exist."}
{"number": 688, "change": "@@ -87,7 +87,7 @@ QVariant TransferModelItem::data(int role) const\n                 //store the icon for speed improvements, KIconLoader should make sure, that\n                 //the icon data gets shared\n                 if (m_mimeType.isNull()) {\n-                    m_mimeType = KIcon(KMimeType::findByPath(m_transferHandler->dest().url())->iconName());\n+                    m_mimeType = KIcon(KMimeType::iconNameForUrl(m_transferHandler->dest().url()));\n                 }\n \n                 return m_mimeType;\n", "fix_pattern": "<pattern>: if a method finds a MIME type by path and then retrieves its icon name, replace the two-step process with a direct call to a method that retrieves the icon name based on the URL to reduce overhead and improve performance."}
{"number": 689, "change": "@@ -37,10 +37,10 @@\n StyledCalendarDelegate::StyledCalendarDelegate(QObject *parent)\n     : QStyledItemDelegate(parent)\n {\n-    mPixmap.insert(Enable, KIconLoader().loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n-    mPixmap.insert(RemoveFromList, KIconLoader().loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n-    mPixmap.insert(AddToList, KIconLoader().loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n-    mPixmap.insert(Quickview, KIconLoader().loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n+    mPixmap.insert(Enable, KIconLoader::global()->loadIcon(QStringLiteral(\"bookmarks\"), KIconLoader::Small));\n+    mPixmap.insert(RemoveFromList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-remove\"), KIconLoader::Small));\n+    mPixmap.insert(AddToList, KIconLoader::global()->loadIcon(QStringLiteral(\"list-add\"), KIconLoader::Small));\n+    mPixmap.insert(Quickview, KIconLoader::global()->loadIcon(QStringLiteral(\"quickview\"), KIconLoader::Small));\n }\n \n StyledCalendarDelegate::~StyledCalendarDelegate()\n", "fix_pattern": "<pattern>: if multiple calls are made to `KIconLoader().loadIcon`, replace them with calls to `KIconLoader::global()->loadIcon` to utilize a singleton instance of `KIconLoader`, which reduces overhead from repeated constructions of the `KIconLoader` object."}
{"number": 690, "change": "@@ -567,7 +567,7 @@ StandardShortcut find(const QKeySequence &seq)\n StandardShortcut findByName(const QString &name)\n {\n     for (const KStandardShortcutInfo &shortcutInfo : g_infoStandardShortcut) {\n-        if (QString::fromLatin1(shortcutInfo.name) == name) {\n+        if (QLatin1StringView(shortcutInfo.name) == name) {\n             return shortcutInfo.id;\n         }\n     }\n", "fix_pattern": "<pattern>: if QString::fromLatin1 is used to convert a char string for comparison, replace it with QLatin1StringView for more efficient string handling without unnecessary allocation and conversion overhead."}
{"number": 692, "change": "@@ -154,7 +154,12 @@ bool store_statistics_record(THD *thd, T *object) {\n     return true;\n   }\n \n-  return trans_commit_stmt(thd) || trans_commit(thd);\n+  /*\n+    Ignore global read lock when committing attachable transaction,\n+    so we can update statistics tables even if some other thread\n+    owns GRL, similarly to how ANALYZE TABLE is allowed to do this.\n+  */\n+  return trans_commit_stmt(thd, true) || trans_commit(thd, true);\n }\n \n template bool store_statistics_record(THD *thd, dd::Table_stat *);\n", "fix_pattern": "<pattern>: if performance-related bottlenecks are suspected due to global read locks when committing transactions, refactor the code to use the version of the trans_commit and trans_commit_stmt functions that allow ignoring these locks, thereby improving concurrency and performance in multi-threaded scenarios."}
{"number": 693, "change": "@@ -433,8 +433,9 @@ void ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n         }\n     }\n     if (useModSeq > 0) {\n-        // FIXME: issue the corresponding command\n-        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n+        QMap<QByteArray, quint64> fetchModifier;\n+        fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n+        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n     } else {\n         flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n     }\n", "fix_pattern": "<pattern>: if a command fetch is being issued without optional modifiers that could improve behavior or performance, refactor the fetch call to include and pass additional parameters like `fetchModifier` for enhanced functionality."}
{"number": 694, "change": "@@ -278,12 +278,12 @@ zmsg_t *cmb_msg_encode (char *tag, json_object *o)\n \n     if (!(zmsg = zmsg_new ()))\n         err_exit (\"zmsg_new\");\n-    if (zmsg_addstr (zmsg, \"%s\", tag) < 0)\n-        err_exit (\"zmsg_addstr\");\n+    if (zmsg_addmem (zmsg, tag, strlen (tag)) < 0)\n+        err_exit (\"zmsg_addmem\");\n     if (o) {\n         const char *s = json_object_to_json_string (o);\n-        if (zmsg_addstr (zmsg, \"%s\", s) < 0)\n-            err_exit (\"zmsg_addstr\");\n+        if (zmsg_addmem (zmsg, s, strlen (s)) < 0)\n+            err_exit (\"zmsg_addmem\");\n     }\n     return zmsg;\n }\n", "fix_pattern": "<pattern>: if the code is using zmsg_addstr to add strings to the zmsg, replace it with zmsg_addmem to directly add the memory representation of the strings along with their length, improving efficiency by eliminating the need for the function to determine the string length internally."}
{"number": 695, "change": "@@ -417,8 +417,7 @@ static json_object *deep_copy (plugin_ctx_t *p, json_object *dir,\n     }\n     return dcpy;\n stall:\n-    if (dcpy)\n-        free (dcpy);\n+    json_object_put (dcpy);\n     return NULL;\n }\n \n", "fix_pattern": "<pattern>: if dynamically allocated memory is managed by a library's specific API, replace the standard `free` call with the appropriate library function to avoid potential memory management issues and improve performance by taking advantage of the library's optimized handling for its objects."}
{"number": 696, "change": "@@ -90,13 +90,20 @@ void ref_eltwise_fwd_t<data_type>::execute_forward_dense() {\n     src += data_d.blocking_desc().offset_padding;\n     dst += data_d.blocking_desc().offset_padding;\n \n+    if (alg_kind == eltwise_relu) {\n+        // a fast path for relu as the most popular activation\n+#       pragma omp parallel for schedule(static)\n+        for (size_t e = 0; e < nelems; ++e)\n+            dst[e] = relu_fwd(src[e], alpha);\n+        return;\n+    }\n+\n #   pragma omp parallel for schedule(static)\n     for (size_t e = 0; e < nelems; ++e) {\n         const data_t s = src[e];\n         data_t &d = dst[e];\n \n         switch (alg_kind) {\n-        case eltwise_relu: d = relu_fwd(s, alpha); break;\n         case eltwise_tanh: d = tanh_fwd(s); break;\n         case eltwise_elu: d = elu_fwd(s, alpha); break;\n         case eltwise_square: d = square_fwd(s); break;\n", "fix_pattern": "<pattern>: if an activation function is detected that can benefit from parallel execution, refactor the code to utilize OpenMP for parallelizing the operation across elements, thus improving performance significantly for large inputs."}
{"number": 697, "change": "@@ -51,11 +51,13 @@ int fill_memory(const rnn_prb_t *p, rnn_data_kind_t kind, dnn_mem_t &mem1,\n         size_t idx_end = MIN2(idx_start + chunk_size, nelems);\n \n         std::minstd_rand msr;\n-        std::uniform_real_distribution<float> gen(-1, 1);\n+        std::normal_distribution<float> gen(.0f, .001f);\n         msr.discard(idx_start);\n \n-        for (size_t idx = idx_start; idx < idx_end; ++idx)\n-            mem2.set_elem(idx, gen(msr));\n+        for (size_t idx = idx_start; idx < idx_end; ++idx){\n+            auto val = gen(msr);\n+            mem2.set_elem(idx, MAX2(MIN2(val, 1.0f), -1.0f));\n+        }\n     });\n \n     mem1.reorder(mem2);\n", "fix_pattern": "<pattern>: if random number generation is done in a loop using a non-deterministic uniform distribution, consider switching to a normal distribution if it provides better control over the output range, and apply clamping with MAX2 and MIN2 to ensure the values remain within the desired bounds."}
{"number": 699, "change": "@@ -2525,13 +2525,14 @@ void BlockchainLMDB::get_output_key(const uint64_t &amount, const std::vector<ui\n   if (global_indices.size() > 0)\n   {\n     TXN_PREFIX_RDONLY();\n+    lmdb_cur cur(*txn_ptr, m_output_keys);\n \n     for (const uint64_t &index : global_indices)\n     {\n       MDB_val_copy<uint64_t> k(index);\n       MDB_val v;\n \n-      auto get_result = mdb_get(*txn_ptr, m_output_keys, &k, &v);\n+      auto get_result = mdb_cursor_get(cur, &k, &v, MDB_SET);\n       if (get_result == MDB_NOTFOUND)\n         throw1(OUTPUT_DNE(\"Attempting to get output pubkey by global index, but key does not exist\"));\n       else if (get_result)\n", "fix_pattern": "<pattern>: if the original code uses the mdb_get function with a transaction pointer and a database identifier, refactor it to use mdb_cursor_get with an initialized cursor object for better performance by avoiding transaction overhead and improving data retrieval speed."}
{"number": 701, "change": "@@ -338,7 +338,7 @@ void showSplashScreen()\n #if defined(Q_OS_UNIX)\n void setupDpi()\n {\n-    if (qgetenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\").isEmpty())\n+    if (qEnvironmentVariableIsEmpty(\"QT_AUTO_SCREEN_SCALE_FACTOR\"))\n         qputenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\", \"1\");\n }\n #endif  // Q_OS_UNIX\n", "fix_pattern": "<pattern>: if a call is made to qgetenv followed by an isEmpty check, replace it with a direct call to qEnvironmentVariableIsEmpty for better performance, as it avoids the overhead of creating a QString object."}
{"number": 702, "change": "@@ -28,6 +28,8 @@\n \n #include \"apicontroller.h\"\n \n+#include <algorithm>\n+\n #include <QJsonDocument>\n #include <QMetaObject>\n \n@@ -69,9 +71,13 @@ const DataMap &APIController::data() const\n \n void APIController::checkParams(const QSet<QString> &requiredParams) const\n {\n-    const QSet<QString> params {this->params().keys().toSet()};\n+    const bool hasAllRequiredParams = std::all_of(requiredParams.cbegin(), requiredParams.cend()\n+        , [this](const QString &requiredParam)\n+    {\n+        return params().contains(requiredParam);\n+    });\n \n-    if (!params.contains(requiredParams))\n+    if (!hasAllRequiredParams)\n         throw APIError(APIErrorType::BadParams);\n }\n \n", "fix_pattern": "<pattern>: if an operation involves checking for the presence of multiple required parameters in a set, replace the set construction and lookup with a more efficient method using std::all_of to directly check each required parameter's existence, minimizing temporary object creation and improving readability."}
{"number": 703, "change": "@@ -791,8 +791,9 @@ v8::Local<v8::Value> TNodeJsStore::Field(const TQm::TRec& Rec, const int FieldId\n \t\t// which is just a wrapper around v8::Local<> that \"enforces a check\n \t\t// ehther v8::Local<> is empty before it can be used.\" For details, see\n \t\t// http://v8.paulfryzel.com/docs/master/singletonv8_1_1_maybe_local.html\n-\t\tprintf(\"Using TMEM\\n\");\n-\t\tv8::Local<v8::Object> Bf = node::Buffer::New(Isolate, Val.GetBf(), Val.Len()).ToLocalChecked();\n+\t\tv8::MaybeLocal<v8::Object> TmpBf = node::Buffer::Copy(Isolate, Val.GetBf(), Val.Len());\n+\t\tEAssertR(!TmpBf.IsEmpty(), \"The handle is empty.\");\n+\t\tv8::Local<v8::Object> Bf = TmpBf.ToLocalChecked();\n \t\treturn HandleScope.Escape(Bf);\n #else\n \t\tv8::Local<v8::Object> Bf = node::Buffer::New(Isolate, Val.GetBf(), Val.Len());\n", "fix_pattern": "<pattern>: if a buffer is created using `node::Buffer::New`, switch to `node::Buffer::Copy` to leverage the safer and more efficient API that includes error handling for empty handles when creating a new buffer using V8."}
{"number": 704, "change": "@@ -221,8 +221,7 @@ void Tst_QMqttClient::retainMessage()\n         auto subscription = sub.subscribe(testTopic);\n         QTRY_COMPARE(subscription->state(), QMqttSubscription::Subscribed);\n \n-        QTest::qWait(5000);\n-        QVERIFY(msgCount == i);\n+        QTRY_VERIFY(msgCount == i);\n     }\n     publisher.disconnect();\n }\n", "fix_pattern": "<pattern>: when using QTest::qWait to poll for a condition, replace it with QTRY_VERIFY to perform a more efficient wait that automatically checks the condition repeatedly until it becomes true or a timeout occurs."}
{"number": 705, "change": "@@ -775,13 +775,12 @@ namespace orb\n \t\t\t\t\tusing ptr_t = void( ORB_GL_CALL* )( Args... );\n \n \t\t\t\t\t// Reset error code to 0\n-\t\t\t\t\tGLenum err = glGetError();\n+\t\t\t\t\twhile( glGetError() != GL_NO_ERROR )\n+\t\t\t\t\t{ }\n \n \t\t\t\t\treinterpret_cast< ptr_t >( m_ptr )( args... );\n \n-\t\t\t\t\terr = glGetError();\n-\t\t\t\t\tif( err != GL_NO_ERROR )\n-\t\t\t\t\t\torb::gl::handle_error( err );\n+\t\t\t\t\torb::gl::handle_error( glGetError() );\n \t\t\t\t}\n \n \t\t\tprivate:\n", "fix_pattern": "<pattern>: if multiple calls to glGetError() are used to check for errors, replace them with a loop that continuously calls glGetError() until no errors are returned, then handle any remaining error if detected, reducing the overhead of multiple function calls."}
{"number": 706, "change": "@@ -29,8 +29,8 @@ void MPI_Sys::sample(Sys &in)\n \n         for (int i = 0; i < in.num(); i++)\n         {\n-            MPI_Allreduce(MPI_IN_PLACE, in.precMu.at(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n-            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.at(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precMu.col(i).data(), num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n+            MPI_Allreduce(MPI_IN_PLACE, in.precLambda.col(i).data(), num_latent*num_latent, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n         }\n         bcast_sum_cov_norm();\n     }\n", "fix_pattern": "<pattern>: if an API method retrieves a row or column of data using a potentially less efficient method (like at(index)), replace it with a direct method call that accesses the data column directly (like col(index)) for improved performance, specifically in the context of matrix or array data structures."}
{"number": 707, "change": "@@ -189,7 +189,7 @@ TcpSocketImplTest::Test1_HandleRecv (Ptr<Socket> sock)\n   {\n     rxBytes1 += sz;\n     rxPayload = new uint8_t[sz];\n-    memcpy (rxPayload, p->PeekData(), sz);\n+    p->CopyData (rxPayload, sz);\n   }\n   else\n   {\n", "fix_pattern": "<pattern>: if memcpy is used to transfer data from a packet buffer, replace it with the packet's optimized CopyData method to leverage potential internal optimizations and reduce overhead."}
{"number": 709, "change": "@@ -1718,7 +1718,7 @@ static void lCompose(\n #if 1 // def __COMPOSITE_PROFILE\n     double nsendrecvloc = (senddispl[nrank] + recvdispl[nrank])*sizeof(uint16_t);\n     double nsendrecv;\n-    MPI_Allreduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, comm);\n+    MPI_Reduce(&nsendrecvloc, &nsendrecv, 1, MPI_DOUBLE, MPI_SUM, master, comm);\n     const double t1 = MPI_Wtime();\n     if (rank == master)\n     {\n", "fix_pattern": "<pattern>: if the communication pattern allows for reduction to a specific root instead of broadcasting to all processes, replace MPI_Allreduce with MPI_Reduce to optimize performance by reducing the amount of data communicated across the network."}
{"number": 711, "change": "@@ -1533,7 +1533,7 @@ void NJClient::mixInChannel(bool muted, float vol, float pan, DecodeState *chan,\n     // advance the queue\n     chan->decode_samplesout += needed/chan->decode_codec->GetNumChannels();\n     chan->decode_codec->m_samples_used -= needed+chan->dump_samples;\n-    memcpy(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n+    memmove(sptr,sptr+needed+chan->dump_samples,chan->decode_codec->m_samples_used*sizeof(float));\n     chan->dump_samples=0;\n   }\n   else\n", "fix_pattern": "<pattern>: if overlapping memory regions are detected, replace memcpy with memmove to ensure correct behavior since memmove handles such cases properly."}
{"number": 712, "change": "@@ -143,8 +143,8 @@ void convert_inplace_test_do_it( dl_ctx_t       dl_ctx,        dl_typeid_t type,\n \t\t*out_buffer = (unsigned char*)malloc(*out_size + 1);\n \t\tmemset(*out_buffer, 0xFE, *out_size + 1);\n \n-\t\tmemcpy( *out_buffer, convert_buffer, convert_size );\n-\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, *out_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tEXPECT_DL_ERR_OK( dl_convert_inplace( dl_ctx, type, convert_buffer, convert_size, DL_ENDIAN_HOST, sizeof(void*), out_size ) );\n+\t\tmemcpy(*out_buffer, convert_buffer, *out_size);\n \t}\n \n \tfree(convert_buffer);\n", "fix_pattern": "<pattern>: if a memcpy operation is performed after an API call that alters the buffer's content, refactor the code to first call the API and then perform the memcpy only if necessary, using the proper output size calculated from the API call, which avoids potentially copying unnecessary data or incorrect sizes."}
{"number": 714, "change": "@@ -62,7 +62,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             std::vector<bool> vMatch(nTx, false);\n             std::vector<uint256> vMatchTxid1;\n             for (unsigned int j=0; j<nTx; j++) {\n-                bool fInclude = (rand() & ((1 << (att/2)) - 1)) == 0;\n+                bool fInclude = insecure_randbits(att / 2) == 0;\n                 vMatch[j] = fInclude;\n                 if (fInclude)\n                     vMatchTxid1.push_back(vTxid[j]);\n", "fix_pattern": "<pattern>: if a call to the standard `rand()` function is replaced with a custom API that is optimized for generating random bits, use `insecure_randbits(...)` for potentially better performance and more control over the randomness generation."}
{"number": 715, "change": "@@ -14,7 +14,7 @@ int _tflitetensor_name(ErlNifEnv *env, TfLiteTensor * tensor, ERL_NIF_TERM &out)\n     unsigned char * ptr;\n     size_t len = strlen(tensor_name_str);\n     if ((ptr = enif_make_new_binary(env, len, &tensor_name)) != nullptr) {\n-        strncpy((char *)ptr, tensor_name_str, len);\n+        memcpy((char *)ptr, tensor_name_str, len);\n         out = tensor_name;\n         return true;\n     } else {\n", "fix_pattern": "<pattern>: if strncpy is used to copy a fixed length of bytes, replace it with memcpy for better performance since strncpy performs null-termination checks and padding that are unnecessary in this context."}
{"number": 716, "change": "@@ -201,7 +201,7 @@ namespace erlang {\n             unsigned char *ptr;\n             size_t len = strlen(c_string);\n             if ((ptr = enif_make_new_binary(env, len, &binary_str)) != nullptr) {\n-                strcpy((char *) ptr, c_string);\n+                memcpy((char *)ptr, c_string, len);\n                 return binary_str;\n             } else {\n                 fprintf(stderr, \"internal error: cannot allocate memory for binary string\\r\\n\");\n", "fix_pattern": "<pattern>: if a function is copying a string and the length of the source is known, replace strcpy with memcpy for potentially better performance and to handle non-null-terminated data safely."}
{"number": 719, "change": "@@ -51,9 +51,10 @@ void GuiSelection::haveSelection(bool own)\n \t// an application actually requests it.\n \t// This way calling Selection::have() is cheap and we can do it as\n \t// often as we want.\n-\t//LYXERR(Debug::SELECTION, \"GuiSelection: setting dummy selection\");\n-\tif (own)\n+\tif (own && !qApp->clipboard()->ownsSelection()) {\n+\t\tLYXERR(Debug::SELECTION, \"GuiSelection: setting dummy selection\");\n \t\tqApp->clipboard()->setText(QString(), QClipboard::Selection);\n+\t}\n \t// We don't need to do anything if own = false, as this case is\n \t// handled by QT.\n \t// FIXME (gb): This is wrong. What is missing here is rather a call of\n", "fix_pattern": "<pattern>: if a logging statement (LYXERR) is present without prior checks for resource ownership (here, clipboard selection), enhance performance and reduce unnecessary logging by adding a condition to check for clipboard ownership before logging."}
{"number": 720, "change": "@@ -64,10 +64,10 @@ bool FormFieldRestrictedValues::safeForIntegerCoercion(FormRestrictions restrict\n     foreach(SelectRestriction sr, restrictions.first) {\n         if(sr.variable == name) {\n             foreach(QString value, sr.values) {\n-                // TODO: Would prefer to use a more general regex (e.g. allowing zero-padded values or leading/trailing\n-                // spaces) but these values cannot currently be injected back correctly (even though we could coerce\n+                // TODO: Would prefer to use a more general regex (e.g. allowing leading/trailing spaces)\n+                // but these values cannot currently be injected back correctly (even though we could coerce\n                 // and solve them), so we are quite conservative for now.\n-                if(!value.contains(QRegExp(\"^(0|([1-9][0-9]*))$\"))) {\n+                if(!value.contains(QRegExp(\"^([0-9]*)$\"))) {\n                     return false;\n                 }\n             }\n", "fix_pattern": "<pattern>: if a more specific regex pattern that constrains valid input is replaced with a more general pattern that allows additional cases (like leading/trailing spaces), ensure that it doesn't introduce significant performance overhead when the regex engine has to handle a broader set of matches; specific patterns can lead to faster evaluations and less backtracking compared to general patterns."}
{"number": 721, "change": "@@ -419,8 +419,8 @@ void DoublePlugin::Flip()\n \t}\n \t//SDL_UpdateRect(_video,0,0,0,0);\n     wxBitmap bmp(*img);\n-    CapriceApp* MyApp =static_cast<CapriceApp*>(wxTheApp) ;\n-    wxBufferedPaintDC dc(MyApp->frame->getPanel(),bmp);\n+    wxClientDC dc(static_cast<CapriceApp*>(wxTheApp)->frame->getPanel());\n+\tdc.DrawBitmap(bmp,0,0,false);\n #endif\n }\n \n", "fix_pattern": "<pattern>: if wxBufferedPaintDC is used for drawing, which is more suitable for buffered painting, replace it with wxClientDC for direct drawing operations when buffering is not necessary, leading to potential performance improvements."}
{"number": 722, "change": "@@ -130,7 +130,7 @@ static Node *convertToCLinkFormat( xmlDocPtr doc, xmlNodePtr cur, int depth ) {\n \n Node *Parser::parse(const std::string &data, size_t len) {\n   // First, parse the XML memory buffer ito a DOM object\n-  xmlDocPtr doc = xmlParseMemory( data.c_str(), (int)len );\n+  xmlDocPtr doc = xmlReadMemory(data.c_str(), (int)len, NULL, NULL, XML_PARSE_NOERROR);\n   if ( doc == NULL ) {\n     LogWarn(\"XML file parsing failed:\");\n     LogWarn(\"%s\", data.c_str());\n", "fix_pattern": "<pattern>: if an API method for parsing XML is replaced with a different, more configurable method that allows for options (like error handling), then switch from a basic parsing function to a more flexible one (xmlReadMemory) that can handle additional parameters for better error control and customization."}
{"number": 724, "change": "@@ -40,7 +40,8 @@ int main(int argc, char **argv) {\n   // print config.yaml file of current run\n   auto now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n   std::ostringstream nowStrStr;\n-  nowStrStr << std::put_time(std::localtime(&now), \"%Y-%m-%d_%H-%M-%S\");\n+  tm unused;\n+  nowStrStr << std::put_time(localtime_r(&now, &unused), \"%Y-%m-%d_%H-%M-%S\");\n   std::ofstream configFileEnd(\"MDFlex_end_\" + nowStrStr.str() + \".yaml\");\n   configFileEnd << config;\n   configFileEnd.close();\n", "fix_pattern": "<pattern>: if std::localtime is called, replace it with localtime_r to avoid thread-safety issues and improve performance by reusing a provided tm structure."}
{"number": 725, "change": "@@ -270,8 +270,9 @@ extern \"C\" void report_segfault(int signo)\n \n extern \"C\" void report_abort(int signo)\n {\n-    log(CRITICAL, \"Aborted\");\n-    log(NOTICE, \"Please report this bug to \" PACKAGE_BUGREPORT);\n+    //Don't print to the log in signal handler, as that involves memory allocation.\n+    fprintf(stderr, \"Aborted\");\n+    fprintf(stderr, \"Please report this bug to \" PACKAGE_BUGREPORT);\n \n #if !defined(HAVE_SIGACTION)\n     signal(signo, SIG_DFL);\n", "fix_pattern": "<pattern>: if logging functions are called within a signal handler, switch to using fprintf to stderr to avoid memory allocation issues associated with the logging API"}
{"number": 727, "change": "@@ -206,13 +206,8 @@ void VROSoundGVR::setDelegate(std::shared_ptr<VROSoundDelegateInternal> delegate\n \n void VROSoundGVR::dataIsReady() {\n     _ready = true;\n-    if (_gvrAudio) {\n-        bool result = _gvrAudio->PreloadSoundfile(_data->getLocalFilePath());\n-        passert(result);\n-\n-        if (_delegate) {\n-            _delegate->soundIsReady();\n-        }\n+    if (_gvrAudio && _delegate) {\n+        _delegate->soundIsReady();\n     }\n }\n \n", "fix_pattern": "<pattern>: if there's a condition that checks for both a primary object (_gvrAudio) and a delegate, and the response from the primary object is not needed for the logic that follows, combine the conditions to avoid redundant checks and minimize the number of calls made to the delegate."}
{"number": 728, "change": "@@ -45,7 +45,8 @@ OsStunDatagramSocket::OsStunDatagramSocket(int remoteHostPortNum,\n                                            int iRefreshPeriodInSec,\n                                            int iStunOptions,\n                                            OsNotification *pNotification) \n-        : OsDatagramSocket(0, 0, localHostPortNum, localHost)  // make remote hostaddr/port=0, for NOT using udp \"connect\" \n+        : OsDatagramSocket(remoteHostPortNum, remoteHost, \n+                           localHostPortNum, localHost)\n         , mKeepAlivePeriod(0)\n         , mCurrentKeepAlivePeriod(0)\n         , mStunServer(szStunServer)\n", "fix_pattern": "<pattern>: if instantiating the OsDatagramSocket with (0, 0) for remote address is intended to avoid using the \"connect\" method for UDP, refactor the constructor to directly use the intended remote host and its port, improving flexibility and possibly performance by reducing unnecessary network operation configurations."}
{"number": 737, "change": "@@ -431,7 +431,12 @@ void xyUpdate(){\n \n \tgvFPS = 1000 / fLength;\n \t//Wait for FPS limit\n-\tif(gvMaxFPS != 0) SDL_Delay((1000 / gvMaxFPS) - (fLength / gvMaxFPS));\n+\t//\t\tdelay\t4294967290\tunsigned int\n+\tUint32 current_time = (static_cast<Uint32>(fLength) / gvMaxFPS);\n+\tUint32 max_delay = (1000 / gvMaxFPS);\n+\tif (current_time < max_delay) {\n+\t\tif (gvMaxFPS != 0) SDL_Delay(max_delay - current_time);\n+\t}\n \t/*while(fLength < 1000 / gvMaxFPS){\n \t\tgvTicks = SDL_GetTicks();\n \t\tfLength = gvTicks - gvTickLast;\n", "fix_pattern": "<pattern>: if a delay is calculated and potentially called multiple times based on frame length and maximum FPS, first compute `current_time` and `max_delay` once, then perform the delay only if needed, thus avoiding redundant calculations and improving performance."}
{"number": 739, "change": "@@ -382,14 +382,12 @@ nsCanvasRenderingContext2D::StyleVariantToColor(nsIVariant* aStyle, PRInt32 aWhi\n \n         return PR_TRUE;\n     } else if (paramType == nsIDataType::VTYPE_WSTRING_SIZE_IS) {\n-        PRUint32 sz;\n-        PRUnichar* str = nsnull;\n+        nsAutoString str;\n \n-        rv = aStyle->GetAsWStringWithSize(&sz, &str);\n+        rv = aStyle->GetAsAString(str);\n         NS_ENSURE_SUCCESS(rv, rv);\n \n-        rv = mCSSParser->ParseColorString(nsString(str, sz), nsnull, 0, PR_TRUE, &color);\n-        nsMemory::Free(str);\n+        rv = mCSSParser->ParseColorString(str, nsnull, 0, PR_TRUE, &color);\n         if (NS_FAILED(rv))\n             return PR_FALSE;\n \n", "fix_pattern": "<pattern>: if a function retrieves a wide string and requires manual memory management, refactor the code to directly retrieve an `nsAutoString` using `GetAsAString`, which handles memory automatically and avoids the overhead of manual memory allocation and deallocation."}
{"number": 742, "change": "@@ -5,7 +5,7 @@\n         Quesa interactive renderer TriMesh implementation.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2004, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1443,11 +1443,12 @@ IRGeometry_Submit_TriMesh(TQ3ViewObject\t\t\t\ttheView,\n \tTQ3Status\t\t\tqd3dStatus;\n \tCQ3ObjectRef\t\tcachedGeom;\n \tCLockTriMeshData\tlocker;\n+\tbool\t\t\t\twasValid;\n \n \t\n \t// Look for a cached optimized geometry.\n-\tcachedGeom = GetCachedOptimizedTriMesh( theGeom );\n-\tif ( ! cachedGeom.isvalid() )\n+\tcachedGeom = GetCachedOptimizedTriMesh( theGeom, wasValid );\n+\tif ( ! wasValid )\n \t{\n \t\t// no cached data or stale cache\n \t\tcachedGeom = CQ3ObjectRef( Q3TriMesh_Optimize( theGeom ) );\n", "fix_pattern": "<pattern>: if an API method is upgraded to provide additional information about the validity of the cached geometry directly via an output parameter (instead of checking validity through a separate method call), leverage the new API method to potentially reduce the overhead of multiple validations and improve performance."}
{"number": 743, "change": "@@ -5,7 +5,7 @@\n         Implementation of Quesa API calls.\n \n     COPYRIGHT:\n-        Copyright (c) 1999-2007, Quesa Developers. All rights reserved.\n+        Copyright (c) 1999-2008, Quesa Developers. All rights reserved.\n \n         For the current release of Quesa, please see:\n \n@@ -1277,14 +1277,14 @@ OpaqueTQ3Object::GetElement ( TQ3ElementType theType, void *theData )\n \n \t// If we've actually been passed a set, use it directly\n \tif ( Q3_OBJECT_IS_CLASS ( this, E3Set ) )\n-\t\treturn Q3Set_Get ( (TQ3SetObject) this, theType, theData ) ;\n+\t\treturn ( (E3Set*) this )->Get ( theType, theData ) ;\n \t\n \t// otherwise use the set within the instance data\n \t\n \tif ( theSet == NULL )\n \t\treturn kQ3Failure ;\n \t\n-\treturn Q3Set_Get ( theSet, theType, (void*)theData ) ;\n+\treturn ( (E3Set*) theSet )->Get ( theType, theData ) ;\n \t}\n \n \n", "fix_pattern": "<pattern>: if the original Q3Set_Get function is being replaced with the more efficient E3Set::Get member function call, then refactor the API usage to utilize the class method for potentially better performance and cleaner code."}
{"number": 745, "change": "@@ -321,13 +321,13 @@ bool QgsSpatiaLiteFeatureIterator::getFeature( sqlite3_stmt *stmt, QgsFeature &f\n         if ( ic <= mRequest.subsetOfAttributes().size() )\n         {\n           int attrIndex = mRequest.subsetOfAttributes()[ic-1];\n-          feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields[attrIndex].type() ) );\n+          feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields.at( attrIndex ).type() ) );\n         }\n       }\n       else\n       {\n         int attrIndex = ic - 1;\n-        feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields[attrIndex].type() ) );\n+        feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields.at( attrIndex ).type() ) );\n       }\n     }\n   }\n", "fix_pattern": "code removed:\n```cpp\n          feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields[attrIndex].type() ) );\n        feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields[attrIndex].type() ) );\n```\ncode added:\n```cpp\n          feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields.at( attrIndex ).type() ) );\n        feature.setAttribute( attrIndex, getFeatureAttribute( stmt, ic, mSource->mFields.at( attrIndex ).type() ) );\n```\n<pattern>: if accessing elements from a vector or similar container is repeated for the same index, replace the operator[] access with the at() method to emphasize bounds checking and potentially avoid repeated dereferencing overhead in a custom data structure context."}
{"number": 748, "change": "@@ -73,11 +73,11 @@ QgsMapCanvasContextMenu::QgsMapCanvasContextMenu( QgsMapCanvas* canvas, const QP\n   }\n   else if ( mPickResult.feature.isValid() && mPickResult.layer )\n   {\n-    QgsCoordinateTransform ct( mPickResult.layer->crs(), mCanvas->mapSettings().destinationCrs() );\n+    const QgsCoordinateTransform* ct = QgsCoordinateTransformCache::instance()->transform( mPickResult.layer->crs().authid(), mCanvas->mapSettings().destinationCrs().authid() );\n     mRubberBand = new QgsGeometryRubberBand( mCanvas, mPickResult.feature.geometry()->type() );\n     mRubberBand->setIconType( QgsGeometryRubberBand::ICON_NONE );\n     mRubberBand->setOutlineWidth( 2 );\n-    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( ct ) );\n+    mRubberBand->setGeometry( mPickResult.feature.geometry()->geometry()->transformed( *ct ) );\n     if ( mPickResult.layer->type() == QgsMapLayer::RedliningLayer )\n     {\n       addAction( QIcon( \":/images/themes/default/mActionToggleEditing.svg\" ), tr( \"Edit\" ), this, SLOT( editFeature() ) );\n", "fix_pattern": "<pattern>: if a new instance of QgsCoordinateTransform is created every time a transformation is needed, utilize a caching mechanism (QgsCoordinateTransformCache) to retrieve pre-constructed coordinate transforms based on CRS identifiers to improve performance."}
{"number": 749, "change": "@@ -35,10 +35,11 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     PyObject* ret_keypoints = PyList_New(num_keypoints);\n     // import cv2\n     PyObject* cv2_mod = PyImport_ImportModule(\"cv2\");\n+    PyObject* cv2_keypoint_class = PyObject_GetAttrString(cv2_mod, \"KeyPoint\");\n \n     for(size_t i = 0; i < num_keypoints; ++i) {\n         // cv2_keypoint = cv2.KeyPoint()\n-        PyObject* cv2_keypoint = PyObject_CallMethod(cv2_mod, const_cast<char*>(\"KeyPoint\"), NULL);\n+        PyObject* cv2_keypoint = PyObject_CallObject(cv2_keypoint_class, NULL);\n \n         // build values\n         PyObject* cv2_keypoint_size = Py_BuildValue(\"f\", keypoints[i].size);\n@@ -68,6 +69,7 @@ static PyObject* keypoints_ctopy(std::vector<cv::KeyPoint> keypoints) {\n     }\n \n     Py_DECREF(cv2_mod);\n+    Py_DECREF(cv2_keypoint_class);\n \n     return ret_keypoints;\n }\n", "fix_pattern": "<pattern>: if an API call to PyObject_CallMethod is made to create an object, refactor the code to first retrieve the class using PyObject_GetAttrString and then call it using PyObject_CallObject to avoid redundant lookup performance costs. Additionally, manage the reference counts with Py_DECREF to prevent memory leaks."}
{"number": 750, "change": "@@ -1455,11 +1455,10 @@ gboolean EmuLoop(gpointer data)\n     }\n \n     desmume_cycle();    /* Emule ! */\n-    NDS_SkipFrame(true);\n     for (i = 0; i < Frameskip; i++) {\n+        NDS_SkipNextFrame();\n         desmume_cycle();\n     }\n-    NDS_SkipFrame(false);\n \n     _updateDTools();\n     gtk_widget_queue_draw( pDrawingArea );\n", "fix_pattern": "<pattern>: if two consecutive calls to NDS_SkipFrame with different boolean parameters are made, replace them with a single call to NDS_SkipNextFrame for better performance and clarity."}
{"number": 751, "change": "@@ -223,9 +223,9 @@ void DBuiltinIconEngine::paint(QPainter *painter, const QRect &rect,\n \n     // \u5982\u679c\u6709 background \u5219\u7ed8\u5236\u80cc\u666f\u56fe\u5148\n     QString bgFileName = entry->filename + QStringLiteral(\".background\");\n-    QIcon bgIcon = QIcon(bgFileName);\n-    if (!bgIcon.isNull()) {\n-        bgIcon.paint(painter, rect, Qt::AlignCenter, mode, state);\n+\n+    if (QFile::exists(bgFileName)) {\n+        QIcon(bgFileName).paint(painter, rect, Qt::AlignCenter, mode, state);\n     }\n \n     QPixmap pm = entry->pixmap(pixmapSize, mode, state);\n", "fix_pattern": "<pattern>: if a QIcon is created but then checked for nullity before painting, first check for file existence using QFile::exists to avoid unnecessary construction of the QIcon object, which improves performance by preventing the instantiation of an unused QIcon."}
{"number": 754, "change": "@@ -243,8 +243,8 @@ int iat_detour_apply(HMODULE hMod)\n \n size_t detour_next(const char *dll_name, const char *func_name, void *caller, size_t arg_count, ...)\n {\n-\tjson_t *funcs = json_object_get(detours, dll_name);\n-\tjson_t *ptrs = json_object_get(funcs, func_name);\n+\tjson_t *funcs = json_object_get_create(detours, dll_name, JSON_OBJECT);\n+\tjson_t *ptrs = json_object_get_create(funcs, func_name, JSON_ARRAY);\n \tjson_t *ptr = NULL;\n \tFARPROC next = NULL;\n \tsize_t i;\n@@ -269,6 +269,9 @@ size_t detour_next(const char *dll_name, const char *func_name, void *caller, si\n \tif(!next) {\n \t\tHMODULE hDll = GetModuleHandleA(dll_name);\n \t\tnext = GetProcAddress(hDll, func_name);\n+\t\t// Storing the original pointers at the end of the chain\n+\t\t// yields a 5x performance increase!\n+\t\tjson_array_append_new(ptrs, json_integer((size_t)next));\n \t}\n \tif(!next) {\n \t\tlog_printf(\n", "fix_pattern": "<pattern>: if a value is retrieved from a JSON object and may not exist, use a custom API method that creates the key with a default type (JSON_OBJECT or JSON_ARRAY) if it does not exist, instead of relying on json_object_get, which does not create missing keys. This avoids repeated checks for key existence and improves performance by storing pointers in the expected format directly."}
{"number": 755, "change": "@@ -29,11 +29,10 @@ void OpenglManager::createDrawTextureImage(const QImage& image, int displayId)\n     // If there is a texture already stored, delete it.\n     if(textureStored[displayId])\n     {\n-        deleteTexture(textures[displayId]);\n+        glDeleteTextures(1,&textures[displayId]);\n         textureStored[displayId] = false;\n     }\n-    QImage tex;\n-    tex = QGLWidget::convertToGLFormat( image );\n+    QImage tex = QGLWidget::convertToGLFormat( image );\n     glGenTextures( 1, &textures[displayId] );\n \n     // Create Nearest Filtered Texture\n", "fix_pattern": "<pattern>: if a single texture is being deleted using a project-specific API method, replace it with the more efficient OpenGL API method glDeleteTextures, which is designed for such operations and is optimized for performance."}
{"number": 757, "change": "@@ -692,9 +692,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    continue;\n \t}\n \n-\t// This should be safe here.\n-\tchar* theData = NULL;\n-\ttheData = (char*) alloca(blobsize+4);\n+\tchar* theData = (char*) malloc(blobsize+4);\n \n \tif (theData == 0) {\n \t    std::cerr << \"Could Not allocate memory for data!\" << std::endl;\n@@ -709,6 +707,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t    // bad writes to the offline-data files.\n \t    std::cerr << \"Bad read of data for \" << rawfilename\n \t\t<< \" expected: \" << blobsize << \" got:\" << bytesRead << std::endl;\n+\t    if (theData) free(theData);\n \t    continue;\n \t}\n \n@@ -717,6 +716,7 @@ OfflineExperiment::process_data(const std::string rawfilename)\n \t// This is the first index into the DataQueue.\n \tBlob datablob(blobsize, theData);\n \tDataQueues::enqueuePerformanceData(datablob);\n+\tif (theData) free(theData);\n \n     } // while\n \n", "fix_pattern": "<pattern>: if the code is using alloca to allocate memory on the stack, replace it with malloc for heap allocation, ensuring proper memory management, including freeing the allocated memory later in the code."}
{"number": 758, "change": "@@ -61,7 +61,7 @@ pathfinding::render_info lines_to_render;\n \n void __cdecl render_debug_info_game_in_progress()\n {\n-\tif (conf.getBoolean(\"render_pathfinding_debug\", false) || is_debug_build())\n+\tif (conf.getBoolean(\"render_pathfinding_debug\", false))\n \t{\n \t\tauto bsp = get_sbsp();\n \t\tif (bsp)\n", "fix_pattern": "<pattern>: if a debug condition relies on a project-specific API call that checks for debug builds and its result is not used elsewhere, remove the redundant check to improve performance."}
{"number": 760, "change": "@@ -39,6 +39,7 @@\n #include <sstream>\n #include <stdexcept>\n #include <string>\n+#include <fstream>\n \n namespace rocksdb {\n \n@@ -835,7 +836,10 @@ void DBLoaderCommand::DoCommand() {\n \n   int bad_lines = 0;\n   std::string line;\n-  while (getline(std::cin, line, '\\n')) {\n+  // prefer ifstream getline performance vs that from std::cin istream\n+  std::ifstream ifs_stdin(\"/dev/stdin\");\n+  std::istream* istream_p = ifs_stdin.is_open() ? &ifs_stdin : &std::cin;\n+  while (getline(*istream_p, line, '\\n')) {\n     std::string key;\n     std::string value;\n     if (ParseKeyValue(line, &key, &value, is_key_hex_, is_value_hex_)) {\n", "fix_pattern": "<pattern>: if a loop is detected that reads input using std::cin directly with getline, then refactor the code to first attempt opening \"/dev/stdin\" via an std::ifstream and use that stream if available; otherwise, fall back to std::cin to improve getline performance."}
{"number": 761, "change": "@@ -517,8 +517,10 @@ class Repairer {\n       }\n     }\n     if (status.ok()) {\n+      ReadOptions ropts;\n+      ropts.total_order_seek = true;\n       InternalIterator* iter = table_cache_->NewIterator(\n-          ReadOptions(), env_options_, cfd->internal_comparator(), t->meta,\n+          ropts, env_options_, cfd->internal_comparator(), t->meta,\n           nullptr /* range_del_agg */,\n           cfd->GetLatestMutableCFOptions()->prefix_extractor.get());\n       bool empty = true;\n", "fix_pattern": "<pattern>: if ReadOptions are created directly within a function call, refactor it to create an instance of ReadOptions outside the call and configure it with necessary settings before using it, which can improve readability and performance by avoiding repeated construction in cases where the object can be reused or configured."}
{"number": 762, "change": "@@ -79,7 +79,7 @@ static void initAWS()\n \n S3Helper::S3Helper(const string & region)\n     : config(makeConfig(region))\n-    , client(make_ref<Aws::S3::S3Client>(*config))\n+    , client(make_ref<Aws::S3::S3Client>(*config, true, false))\n {\n }\n \n", "fix_pattern": "<pattern>: if the constructor of Aws::S3::S3Client is called without specifying options for thread safety and error handling, enhance the performance by specifying the additional parameters (true, false) explicitly, thus optimizing the configuration of the client instance."}
{"number": 763, "change": "@@ -10,7 +10,6 @@\n #include \"archive.hh\"\n #include \"callback.hh\"\n #include \"remote-store.hh\"\n-#include \"sync.hh\"\n \n #include <nlohmann/json.hpp>\n #include <regex>\n@@ -1103,7 +1102,7 @@ std::map<StorePath, StorePath> copyPaths(\n     };\n \n     // total is accessed by each copy, which are each handled in separate threads\n-    Sync<uint64_t> _total = 0;\n+    std::atomic<uint64_t> total = 0;\n \n     for (auto & missingPath : sortedMissing) {\n         auto info = srcStore.queryPathInfo(missingPath);\n@@ -1126,9 +1125,8 @@ std::map<StorePath, StorePath> copyPaths(\n             PushActivity pact(act.id);\n \n             LambdaSink progressSink([&](std::string_view data) {\n-                auto total(_total.lock());\n-                *total += data.size();\n-                act.progress(*total, info->narSize);\n+                total += data.size();\n+                act.progress(total, info->narSize);\n             });\n             TeeSink tee { sink, progressSink };\n \n", "fix_pattern": "<pattern>: if a synchronization mechanism like a lock is used on an integer to ensure thread safety, replace it with an atomic variable to improve performance by avoiding the overhead of locking while still ensuring thread safety with atomic operations."}
{"number": 765, "change": "@@ -1040,7 +1040,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n         loadLibrary(id_lib);\n \n     uint nPage = 0;\n-    if(!QFileInfo(url).exists())\n+    if(!QFileInfo::exists(url))\n     {\n         if(strings.count()>0)\n         {\n@@ -1099,7 +1099,7 @@ void opds_server::process(QString url, QTextStream &ts, QString session)\n             ts.device()->write(file.readAll());\n         }\n     }\n-    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo(url).exists())\n+    else if((url.endsWith(\"cover.jpg/\",Qt::CaseInsensitive) || url.endsWith(\"cover.jpg\",Qt::CaseInsensitive)) && !QFileInfo::exists(url))\n     {\n         QString id=strings[2];\n         fb2mobi fb;\n", "fix_pattern": "<pattern>: if QFileInfo is used to check the existence of a file multiple times in conditions, replace the object creation with a static call to QFileInfo::exists to optimize performance by avoiding unnecessary instantiation."}
{"number": 767, "change": "@@ -295,7 +295,7 @@ static bool CreateMainSurface(int w, int h)\n \n \tDEBUG(misc, 0) (\"sdl: using mode %dx%d\", w, h);\n \n-\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_HWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n+\tnewscreen = SDL_CALL SDL_SetVideoMode(w, h, 8, SDL_SWSURFACE + SDL_HWPALETTE + (_fullscreen?SDL_FULLSCREEN:SDL_RESIZABLE));\n \tif(newscreen == NULL)\n \t\treturn false;\n \n", "fix_pattern": "<pattern>: if the SDL_SetVideoMode function is called with SDL_HWSURFACE, replace it with SDL_SWSURFACE for potentially better performance in environments that may not fully support hardware surfaces, thus avoiding unnecessary overhead associated with hardware surface rendering."}
{"number": 768, "change": "@@ -240,7 +240,7 @@ void DeleteWindow(Window *w)\n \n \tv = --_last_window;\n \tcount = (byte*)v - (byte*)w;\n-\tmemcpy(w, w + 1, count);\n+\tmemmove(w, w + 1, count);\n }\n \n Window *FindWindowById(WindowClass cls, WindowNumber number)\n", "fix_pattern": "<pattern>: if a source and destination overlap in a memory copy operation, replace memcpy with memmove to prevent undefined behavior and ensure correctness. memmove handles overlapping regions correctly, which can lead to performance improvements in cases where safety is a concern."}
{"number": 769, "change": "@@ -212,7 +212,7 @@ ssize_t file_description::read(int fd_in_source, void *buf, size_t nbyte) {\n //\n off_t file_description::lseek(int fd_in_source, size_t nbyte, int whence) {\n     pthread_mutex_lock(&m_mutex);\n-    off_t new_offset = lseek(fd_in_source, nbyte, whence); // should be call_real_lseek, when we implement it.\n+    off_t new_offset = call_real_lseek(fd_in_source, nbyte, whence);\n     this->m_offset = new_offset;\n     pthread_mutex_unlock(&m_mutex);\n     return new_offset;\n", "fix_pattern": "<pattern>: if there is a need to improve performance by using a specific implementation of lseek to potentially optimize the call or add extra logic (as indicated by the comment), replace the standard lseek call with a project-specific optimized version."}
{"number": 770, "change": "@@ -131,7 +131,10 @@ void CFileDataIO::WriteString(const wxString& rstr)\n \t// We dont include the NULL terminator. Dont know why.\n \t// It is because we write the size, so the NULL is not necessary.\n \t// \n-\tconst wxCharBuffer tmp = unicode2char(rstr);\n+\t// From wx docs: \n+\t// The macro wxWX2MBbuf reflects the correct return value of cWX2MB \n+\t// (either char* or wxCharBuffer), except for the const.\n+\tconst wxWX2MBbuf tmp = aMuleConv.cWX2MB(rstr);\n \tconst char *s = (const char *)tmp;\n \t//\n \t// This avoids a crash in case unicode2char cannot perform the conversion,\n", "fix_pattern": "<pattern>: if a conversion from wxString to wxCharBuffer is done using the function unicode2char, then replace it with wxWX2MBbuf using a project-specific conversion method (cWX2MB) to improve performance and ensure type correctness while handling strings."}
{"number": 771, "change": "@@ -380,7 +380,7 @@ ClientManager::Wait(void)\n   pthread_mutex_lock(&this->condMutex);\n   pthread_cond_wait(&this->cond,&this->condMutex);\n   pthread_mutex_unlock(&this->condMutex);\n-  pthread_cleanup_pop(1);\n+  pthread_cleanup_pop(0);\n }\n \n // Signal that new data is available (calls pthread_cond_broadcast()\n", "fix_pattern": "<pattern>: if the pthread_cleanup_pop function is used, changing the argument from 1 to 0 indicates that the cleanup handler that was pushed onto the thread's cleanup stack should not be executed, which can improve performance by avoiding unnecessary cleanup operations when the handler is not needed."}
{"number": 772, "change": "@@ -571,16 +571,11 @@ struct Converter_std_map\n         PyObject* value;\n         Py_ssize_t pos = 0;\n \n-        Py_INCREF(pyobj);\n-\n         while (PyDict_Next(pyobj, &pos, &key, &value)) {\n             result.insert(typename StdMap::value_type(\n                     Converter<typename StdMap::key_type>::toCpp(key),\n                     Converter<typename StdMap::mapped_type>::toCpp(value)));\n         }\n-\n-        Py_DECREF(pyobj);\n-\n         return result;\n     }\n };\n", "fix_pattern": "<pattern>: if Py_INCREF and Py_DECREF are called consecutively on the same PyObject, remove the redundant calls to improve performance as they balance each other out without any net change."}
{"number": 773, "change": "@@ -36,7 +36,7 @@ extern \"C\" int LLVMFuzzerTestOneInput(const char *Data, size_t Size) {\n     static QApplication a(c, nullptr);\n     static QImage image(377, 233, QImage::Format_RGB32);\n     static QPainter painter(&image);\n-    QSvgRenderer renderer(QByteArray(Data, Size));\n+    QSvgRenderer renderer(QByteArray::fromRawData(Data, Size));\n     renderer.render(&painter);\n     return 0;\n }\n", "fix_pattern": "<pattern>: if creating a QByteArray from raw data, use QByteArray::fromRawData(...) instead of constructing a QByteArray with the constructor for better performance and to avoid unnecessary copying of the data."}
{"number": 775, "change": "@@ -6,7 +6,7 @@\n #include <QByteArray>\n #include <QtEndian>\n #include <QCryptographicHash>\n-#include <QRegExp>\n+#include <QRegularExpression>\n #include <QStringList>\n #include <QHostAddress>\n #include <QNetworkProxy>\n@@ -808,14 +808,15 @@ void WebSocket::processHandshake(QTcpSocket *pSocket)\n \tQString errorDescription;\n \n \tconst QString regExpStatusLine(\"^(HTTP/1.1)\\\\s([0-9]+)\\\\s(.*)\");\n-\tconst QRegExp regExp(regExpStatusLine);\n+\tconst QRegularExpression regExp(regExpStatusLine);\n \tQString statusLine = readLine(pSocket);\n \tQString httpProtocol;\n \tint httpStatusCode;\n \tQString httpStatusMessage;\n-\tif (regExp.indexIn(statusLine) != -1)\n+\tQRegularExpressionMatch match = regExp.match(statusLine);\n+\tif (match.hasMatch())\n \t{\n-\t\tQStringList tokens = regExp.capturedTexts();\n+\t\tQStringList tokens = match.capturedTexts();\n \t\ttokens.removeFirst();\t//remove the search string\n \t\tif (tokens.length() == 3)\n \t\t{\n", "fix_pattern": "<pattern>: if using QRegExp for regex matching, replace it with QRegularExpression for better performance and modern API usage, as QRegularExpression is optimized for performance and provides a more robust matching mechanism."}
{"number": 776, "change": "@@ -290,7 +290,7 @@ void QWaveDecoder::discardBytes(qint64 numBytes)\n     // If the iodevice doesn't have this many bytes in it,\n     // remember how much more junk we have to skip.\n     if (source->isSequential()) {\n-        QByteArray r = source->read(numBytes); // uggh, wasted memory\n+        QByteArray r = source->read(qMin(numBytes, qint64(16384))); // uggh, wasted memory, limit to a max of 16k\n         if (r.size() < numBytes)\n             junkToSkip = numBytes - r.size();\n         else\n", "fix_pattern": "<pattern>: if reading from a QIODevice with read() potentially allocates more memory than necessary, limit the number of bytes read by using qMin to cap the read size to a maximum threshold (e.g., 16k) to avoid wasted memory allocation."}
{"number": 778, "change": "@@ -119,16 +119,12 @@ QList<QCameraDevice> QGstreamerVideoDevices::videoDevices() const\n \n void QGstreamerVideoDevices::addDevice(GstDevice *device)\n {\n-    gchar *type = gst_device_get_device_class(device);\n-    gst_object_ref(device);\n-    if (!strcmp(type, \"Video/Source\") || !strcmp(type, \"Source/Video\")) {\n+    if (gst_device_has_classes(device, \"Video/Source\")) {\n+        gst_object_ref(device);\n         m_videoSources.push_back({device, QByteArray::number(m_idGenerator)});\n         videoInputsChanged();\n         m_idGenerator++;\n-    } else {\n-        gst_object_unref(device);\n     }\n-    g_free(type);\n }\n \n void QGstreamerVideoDevices::removeDevice(GstDevice *device)\n", "fix_pattern": "<pattern>: if a comparison of device classes is performed using strcmp, replace it with the more efficient function gst_device_has_classes to avoid the overhead of string comparison and potentially streamline the logic flow for checking device classes."}
{"number": 780, "change": "@@ -55,7 +55,7 @@ std::string raw_text(const GumboNode * node)\n     else if( child_node->type == GUMBO_NODE_ELEMENT )\n     {\n       inner_text.push_back(' ');\n-      inner_text.append(text(child_node));\n+      inner_text.append(raw_text(child_node));\n     }\n   }\n \n", "fix_pattern": "<pattern>: if an API method used for text extraction (text) is replaced by a more efficient method (raw_text), it indicates that the new method offers better performance or fewer overheads in the context of extracting text from nodes in the HTML parsing process."}
{"number": 781, "change": "@@ -93,7 +93,7 @@ void thread_func(void* arg) {\n     }\n \n     // May sleep if unsollicited and not main thread\n-    if(local_thread_index>0 && Time::now()-starve_start >= Time(500)) {\n+    if(local_thread_index>0 && Time::now()-starve_start >= Time(10)) {\n       semaphore.get();\n       starve_start = Time::now();\n     }\n", "fix_pattern": "<pattern>: if a timing condition checks for a duration and it's currently set to a larger threshold (500 ms), consider reducing it significantly (to 10 ms) for more responsive performance in multithreaded scenarios."}
{"number": 782, "change": "@@ -166,11 +166,12 @@ Platform::Guid M2CreateGuid()\n byte* M2GetPointer(Windows::Storage::Streams::IBuffer^ Buffer)\n {\n \tbyte* pBuffer = nullptr;\n-\tComPtr<Windows::Storage::Streams::IBufferByteAccess> bufferByteAccess;\n-\tif (SUCCEEDED(ComPtr<IInspectable>(M2GetInspectable(Buffer)).As(\n-\t\t&bufferByteAccess)))\n+\tWindows::Storage::Streams::IBufferByteAccess* pBufferByteAccess = nullptr;\n+\tIInspectable* pBufferABIObject = M2GetInspectable(Buffer);\n+\tif (SUCCEEDED(pBufferABIObject->QueryInterface(&pBufferByteAccess)))\n \t{\t\n-\t\tbufferByteAccess->Buffer(&pBuffer);\n+\t\tpBufferByteAccess->Buffer(&pBuffer);\n+\t\tpBufferByteAccess->Release();\n \t}\n \n \treturn pBuffer;\n", "fix_pattern": "<pattern>: if a ComPtr is being used to manage a resource that only requires a raw pointer for a temporary call, switch to using raw pointers and manage the lifetime explicitly to avoid potential overhead associated with smart pointer management; also ensure proper release of the raw pointer after use."}
{"number": 783, "change": "@@ -41,7 +41,10 @@ auto lg(logger_factory(\"utility.xml.text_reader\"));\n  */\n class libxml_scope_guard {\n public:\n-    libxml_scope_guard() { xmlInitParser(); }\n+    libxml_scope_guard() {\n+        xmlInitParser();\n+        xmlSetBufferAllocationScheme(XML_BUFFER_ALLOC_DOUBLEIT);\n+    }\n     ~libxml_scope_guard() { xmlCleanupParser(); }\n };\n \n", "fix_pattern": "<pattern>: when initializing the libxml2 parser, in addition to calling `xmlInitParser()`, invoke `xmlSetBufferAllocationScheme(XML_BUFFER_ALLOC_DOUBLEIT)` to optimize memory allocation for buffers, providing better performance during XML processing."}
{"number": 788, "change": "@@ -125,7 +125,7 @@ AsyncConnection::AsyncConnection(CephContext *cct, AsyncMessenger *m, DispatchQu\n     out_seq(0), ack_left(0), in_seq(0), state(STATE_NONE), state_after_send(STATE_NONE), sd(-1), port(-1),\n     dispatch_queue(q), write_lock(\"AsyncConnection::write_lock\"), can_write(WriteStatus::NOWRITE),\n     open_write(false), keepalive(false), lock(\"AsyncConnection::lock\"), recv_buf(NULL),\n-    recv_max_prefetch(MIN(msgr->cct->_conf->ms_tcp_prefetch_max_size, TCP_PREFETCH_MIN_SIZE)),\n+    recv_max_prefetch(MAX(msgr->cct->_conf->ms_tcp_prefetch_max_size, TCP_PREFETCH_MIN_SIZE)),\n     recv_start(0), recv_end(0),\n     last_active(ceph::coarse_mono_clock::now()),\n     inactive_timeout_us(cct->_conf->ms_tcp_read_timeout*1000*1000),\n", "fix_pattern": "<pattern>: if a function call uses MIN to set a maximum value constraint, consider switching to MAX to ensure the resulting value meets a minimum threshold, likely to avoid potential underflow or improper bounds."}
{"number": 790, "change": "@@ -8,8 +8,11 @@ namespace pink {\n \n PinkEpoll::PinkEpoll()\n {\n-  epfd_ = epoll_create(1024); \n-  fcntl(epfd_, F_SETFD, fcntl(epfd_, F_GETFD) | FD_CLOEXEC);\n+  epfd_ = epoll_create1(EPOLL_CLOEXEC);\n+  if (epfd_ < 0) {\n+    log_err(\"epoll create fail\")\n+    exit(1)\n+  }\n   events_ = (struct epoll_event *)malloc(sizeof(struct epoll_event) * PINK_MAX_CLIENTS);\n   if (!events_) {\n     log_err(\"init epoll_event error\");\n", "fix_pattern": "<pattern>: if epoll_create is used without the additional flags for better security and atomicity, replace it with epoll_create1 with appropriate flags, which provides a more robust and safer method for creating epoll instances."}
{"number": 792, "change": "@@ -1050,7 +1050,9 @@ InfRcTransport::sendZeroCopy(uint64_t nonce, Buffer* message, QueuePair* qp,\n     uint32_t sgesUsed = 0;\n     BufferDescriptor* bd = getTransmitBuffer();\n     bd->messageBytes = message->size();\n-    bd->remoteLid = qp->getRemoteLid();\n+    // The following operation is extremely slow (50 us)!! Need to find\n+    // a better way to get this information.\n+    // bd->remoteLid = qp->getRemoteLid();\n     bd->response = response;\n \n     // The variables below allow us to collect several chunks from the\n", "fix_pattern": "<pattern>: if a method is identified as having significant performance overhead (e.g., 50 us for getRemoteLid), consider alternatives or optimizations to retrieve the necessary information more efficiently, or document the performance issue clearly for future reference."}
{"number": 794, "change": "@@ -350,12 +350,15 @@ void DrawSelection(wxDC &dc, wxRect &rect)\n {\n    if (selbitmap) {\n       // draw translucent rect\n-      dc.DrawBitmap(selbitmap->GetSubBitmap(rect), rect.x, rect.y, true);\n-      /* wxGTK Blit doesn't support alpha channel\n-      wxMemoryDC memdc;\n-      memdc.SelectObject(*selbitmap);\n-      dc.Blit(rect.x, rect.y, rect.width, rect.height, &memdc, 0, 0, wxCOPY, true);\n-      */\n+      #ifdef __WXGTK__\n+         // wxGTK Blit doesn't support alpha channel\n+         dc.DrawBitmap(selbitmap->GetSubBitmap(rect), rect.x, rect.y, true);\n+      #else\n+         // Blit seems to be about 10% faster (on Mac at least)\n+         wxMemoryDC memdc;\n+         memdc.SelectObject(*selbitmap);\n+         dc.Blit(rect.x, rect.y, rect.width, rect.height, &memdc, 0, 0, wxCOPY, true);\n+      #endif\n    } else {\n       // no alpha channel so just invert rect\n       dc.Blit(rect.x, rect.y, rect.width, rect.height, &dc, rect.x, rect.y, wxINVERT);\n", "fix_pattern": "<pattern>: if wxGTK is detected and the DrawBitmap function is used, draw the bitmap directly; otherwise, if not wxGTK, use wxMemoryDC and Blit for potentially better performance, as indicated by the comment about speed improvements on Mac."}
{"number": 795, "change": "@@ -2585,8 +2585,12 @@ QString QWebPage::userAgentForUrl(const QUrl& url) const\n \n     QChar securityStrength(QLatin1Char('N'));\n #if !defined(QT_NO_OPENSSL)\n-    if (QSslSocket::supportsSsl())\n-        securityStrength = QLatin1Char('U');\n+    // we could check QSslSocket::supportsSsl() here, but this makes\n+    // OpenSSL, certificates etc being loaded in all cases were QWebPage\n+    // is used. This loading is not needed for non-https.\n+    securityStrength = QLatin1Char('U');\n+    // this may lead to a false positive: We indicate SSL since it is\n+    // compiled in even though supportsSsl() might return false\n #endif\n     ua = ua.arg(securityStrength);\n \n", "fix_pattern": "<pattern>: if a method call (like QSslSocket::supportsSsl()) introduces unnecessary overhead for performance-sensitive paths, remove that call and set a derived security property (like securityStrength) directly, while noting the implications of potential false positives."}
{"number": 798, "change": "@@ -716,7 +716,7 @@ void CreateMainFrame(FrameCreationCallback inOnFrame,int inWidth,int inHeight,\n             }\n \n             sdl_flags |= SDL_OPENGL;\n-            if (!(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags | SDL_OPENGL)))\n+            if (!SDL_VideoModeOK( use_w, use_h, 32, sdl_flags) || !(screen = SDL_SetVideoMode( use_w, use_h, 32, sdl_flags)))\n             {\n                if (pass==2 && aa_pass==0)\n                {\n", "fix_pattern": "<pattern>: if a call to SDL_SetVideoMode is made without a prior check for video mode validity, first validate with SDL_VideoModeOK to potentially avoid an unnecessary set video mode operation, improving performance by preventing failures or retries."}
{"number": 799, "change": "@@ -846,8 +846,7 @@ QScriptEnginePrivate::~QScriptEnginePrivate()\n \n QScriptValue QScriptEnginePrivate::scriptValueFromVariant(const QVariant &v)\n {\n-    Q_Q(QScriptEngine);\n-    QScriptValue result = q->create(v.userType(), v.data());\n+    QScriptValue result = create(v.userType(), v.data());\n     Q_ASSERT(result.isValid());\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is called on a pointer context (Q_Q), and the method being called is already a member function of the same context (i.e., `create`), remove the pointer context and call the method directly to improve code readability and possibly reduce overhead."}
{"number": 801, "change": "@@ -2606,9 +2606,7 @@ std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pc\n \n std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct)\n {\n-    SOCKET socket;\n-    WITH_LOCK(requestor.cs_hSocket, socket = requestor.hSocket);\n-    auto local_socket_bytes = GetBindAddress(socket).GetAddrBytes();\n+    auto local_socket_bytes = requestor.addrBind.GetAddrBytes();\n     uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)\n         .Write(requestor.addr.GetNetwork())\n         .Write(local_socket_bytes.data(), local_socket_bytes.size())\n", "fix_pattern": "<pattern>: if a socket is retrieved from a mutex-locked structure to call a method, and if that method can be called without locking by using already available data (like `addrBind`), refactor to directly access and use the data without locking overhead."}
{"number": 803, "change": "@@ -54,15 +54,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made sequentially with the same file descriptor, cache the result of F_GETFD and only call F_SETFD if the flags need to be changed, thus avoiding unnecessary system calls for improved performance."}
{"number": 804, "change": "@@ -326,16 +326,13 @@ static void *load_repo(void *repo_obj)\n \t}\n \n \tfstat(fd, &st);\n-\trepodata = mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);\n+\trepodata = mmap(0, st.st_size, PROT_READ, MAP_SHARED|MAP_POPULATE, fd, 0);\n \tif(repodata == MAP_FAILED) {\n \t\tfprintf(stderr, \"error: failed to map pages for %s: %s\\n\", repofile,\n \t\t\t\tstrerror(errno));\n \t\tgoto cleanup;\n \t}\n \n-\t/* doesn't really matter if this fails */\n-\tmadvise(repodata, st.st_size, MADV_WILLNEED|MADV_SEQUENTIAL);\n-\n \tret = archive_read_open_memory(a, repodata, st.st_size);\n \tif(ret != ARCHIVE_OK) {\n \t\tfprintf(stderr, \"error: failed to load repo: %s: %s\\n\", repofile,\n", "fix_pattern": "<pattern>: if memory mapping is performed using `mmap`, enhance performance by combining `MAP_SHARED` with `MAP_POPULATE` to prepopulate the page cache, thereby potentially reducing the need for explicit prefetching with `madvise`."}
{"number": 805, "change": "@@ -161,7 +161,11 @@ void LLTracker::drawHUDArrow()\n // static \n void LLTracker::render3D()\n {\n-\tif (!gFloaterWorldMap || !gSavedSettings.getBOOL(\"RenderTrackerBeacon\"))\n+\t// Ansariel: Don't go through all this if we don't track anything at all\n+\t//           and also use LLCachedControl instead of the slow\n+\t//           gSavedSettings.getBOOL() call.\n+\tstatic LLCachedControl<bool> renderTrackerBeacon(gSavedSettings, \"RenderTrackerBeacon\");\n+\tif (!instance()->isTracking(NULL) || !gFloaterWorldMap || !renderTrackerBeacon)\n \t{\n \t\treturn;\n \t}\n", "fix_pattern": "<pattern>: if checking a boolean condition involves a repeated and relatively costly call to configuration settings (like gSavedSettings.getBOOL), replace it with a static cached control to improve performance by avoiding multiple calls and instead reusing the stored value."}
{"number": 806, "change": "@@ -797,10 +797,10 @@ bool RageDisplay_OGL::BeginFrame()\n \n void RageDisplay_OGL::EndFrame()\n {\n-\t// Give up the CPU to the OpenGL host if it wants it; in any case, make\n-\t// sure the frame is done. This helps graphics smoothness a lot by\n-\t// making sure we get the most out of each frame.\n-\tglFinish();\n+\t// glFlush(), not glFinish(); NVIDIA_GLX's glFinish()'s behavior is\n+\t// nowhere near performance-friendly and uses unholy amounts of CPU for\n+\t// Gog-knows-what.\n+\tglFlush();\n \n \twind->SwapBuffers();\n \tProcessStatsOnFlip();\n", "fix_pattern": "<pattern>: if glFinish() is used as a means to sync with the GPU, replace it with glFlush() to improve performance, as glFinish() can introduce significant CPU overhead that affects rendering efficiency."}
{"number": 807, "change": "@@ -236,8 +236,6 @@ void GLC_Texture::glcBindTexture(void)\n \t\tglLoadTexture();\n \t}\n \tglBindTexture(GL_TEXTURE_2D, m_GlTextureID);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n }\n \n QImage GLC_Texture::loadFromFile(const QString& fileName)\n", "fix_pattern": "<pattern>: if multiple OpenGL texture parameter settings with the same target are called consecutively, consolidate them into a single function call to improve performance and reduce state changes."}
{"number": 808, "change": "@@ -230,7 +230,11 @@ LSValue* LSString::add(LSValue* v) {\n }\n \n LSValue* LSString::add_eq(LSValue* v) {\n-\tappend(v->to_string());\n+\tif (auto s = dynamic_cast<LSString*>(v)) {\n+\t\tappend(*(const std::string*) s);\n+\t} else {\n+\t\tappend(v->to_string());\n+\t}\n \tLSValue::delete_temporary(v);\n \treturn this;\n }\n", "fix_pattern": "<pattern>: if a method directly calls `to_string()` on a polymorphic type, first check if the object can be dynamically cast to a more specific type to potentially avoid the overhead of a virtual function call, thereby improving performance."}
{"number": 810, "change": "@@ -101,16 +101,14 @@ Painter& Painter::draw(const std::string& str, bool difference)\n     if (str.empty())\n         return *this;\n \n+    if (!cairo_has_current_point(m_cr.get()))\n+        return *this;\n+\n     double x, y;\n-    cairo_font_extents_t fe;\n     cairo_text_extents_t textext;\n \n-    cairo_font_extents(m_cr.get(), &fe);\n     cairo_text_extents(m_cr.get(), str.c_str(), &textext);\n \n-    if (!cairo_has_current_point(m_cr.get()))\n-        return *this;\n-\n     AutoSaveRestore sr(*this);\n \n     cairo_get_current_point(m_cr.get(), &x, &y);\n", "fix_pattern": "<pattern>: if a function call to cairo_font_extents is unnecessary and does not affect the outcome of subsequent logic (like checking cairo_has_current_point), remove it to improve performance by avoiding redundant API calls."}
{"number": 811, "change": "@@ -838,15 +838,10 @@ void FolderView::selectAll() {\n         // can only select the first column of every row. I consider this discripancy yet\n         // another design flaw of Qt. To make them consistent, we do it ourselves by only\n         // selecting the first column of every row and do not select all columns as Qt does.\n-        // This will trigger one selectionChanged event per row, which is very inefficient,\n-        // but we have no other choices to workaround the Qt bug.\n         // I'll report a Qt bug for this later.\n         if(model_) {\n-            int rowCount = model_->rowCount();\n-            for(int row = 0; row < rowCount; ++row) {\n-                QModelIndex index = model_->index(row, 0);\n-                selectionModel()->select(index, QItemSelectionModel::Select);\n-            }\n+            const QItemSelection sel{model_->index(0, 0), model_->index(model_->rowCount() - 1, 0)};\n+            selectionModel()->select(sel, QItemSelectionModel::Select);\n         }\n     }\n }\n", "fix_pattern": "<pattern>: if a loop is used to select each row individually in a QItemSelectionModel, replace it with a single call to select using a QItemSelection that encompasses all rows to reduce the number of events triggered and improve efficiency."}
{"number": 812, "change": "@@ -112,7 +112,7 @@ namespace\n         DBusActivateTimeout()\n         {\n             bool ok;\n-            mTimeoutMs = qgetenv(\"QTXDG_DBUSACTIVATE_TIMEOUT\").toInt(&ok);\n+            mTimeoutMs = qEnvironmentVariableIntValue(\"QTXDG_DBUSACTIVATE_TIMEOUT\", &ok);\n             if (!ok)\n                 mTimeoutMs = 1500;\n         }\n", "fix_pattern": "<pattern>: if using qgetenv() followed by toInt() to retrieve an environment variable as an integer, replace it with qEnvironmentVariableIntValue() to reduce overhead and improve performance by directly reading and converting in one call."}
{"number": 813, "change": "@@ -5639,10 +5639,11 @@ os_is_sparse_file_supported(os_file_t fh)\n \t);\n \n #ifdef _WIN32\n-\tBY_HANDLE_FILE_INFORMATION info;\n-\tif (GetFileInformationByHandle(fh,&info)) {\n-\t\tif (info.dwFileAttributes != INVALID_FILE_ATTRIBUTES) {\n-\t\t\treturn (info.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0;\n+\tFILE_ATTRIBUTE_TAG_INFO info;\n+\tif (GetFileInformationByHandleEx(fh, FileAttributeTagInfo,\n+\t\t&info, (DWORD)sizeof(info))) {\n+\t\tif (info.FileAttributes != INVALID_FILE_ATTRIBUTES) {\n+\t\t\treturn (info.FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0;\n \t\t}\n \t}\n \treturn false;\n", "fix_pattern": "<pattern>: if the original code uses `GetFileInformationByHandle` to retrieve basic file information, replace it with `GetFileInformationByHandleEx` for enhanced file attribute retrieval, which provides more detailed information and better performance."}
{"number": 814, "change": "@@ -123,7 +123,7 @@ ListDirHandle BeginListDir( Allocator * a, const char * path ) {\n \twchar_t * wide = UTF8ToWide( a, path_and_wildcard );\n \tdefer { Free( a, wide ); };\n \n-\thandle.handle = FindFirstFileW( wide, handle.ffd );\n+\thandle.handle = FindFirstFileExW( wide, FindExInfoBasic, handle.ffd, FindExSearchNameMatch, NULL, FIND_FIRST_EX_LARGE_FETCH );\n \tif( handle.handle == INVALID_HANDLE_VALUE ) {\n \t\tFree( handle.a, handle.ffd );\n \t\thandle.handle = NULL;\n", "fix_pattern": "<pattern>: if using FindFirstFileW to retrieve file information, switch to FindFirstFileExW with the FIND_FIRST_EX_LARGE_FETCH flag to improve performance by optimizing the file enumeration process."}
{"number": 816, "change": "@@ -191,7 +191,6 @@ void OverviewOutlinesTool::draw()\n     glDisable(GL_TEXTURE_2D);\n \n     glEnable(GL_BLEND);\n-    glBlendEquation(GL_FUNC_ADD);\n     glColor4f(0,0,0,0.50);        \n     glBlendFunc(GL_ZERO, GL_SRC_ALPHA);\n     drawBackground();\n", "fix_pattern": "<pattern>: if the OpenGL blending equation is set multiple times in a performance-critical section, consider checking if it can be set once outside the loop or used conditionally to avoid unnecessary state changes that can slow down rendering performance."}
{"number": 822, "change": "@@ -407,8 +407,6 @@ void QrcParserPrivate::collectResourceFilesForSourceFile(const QString &sourceFi\n                                                          const QLocale *locale) const\n {\n     // TODO: use FileName from fileutils for file pathes\n-    QTC_CHECK(QFileInfo(sourceFile).isFile());\n-    QTC_CHECK(QFileInfo(sourceFile).isAbsolute());\n \n     QStringList langs = allUiLanguages(locale);\n     SMap::const_iterator file = m_files.find(sourceFile);\n", "fix_pattern": "<pattern>: if multiple QFileInfo instances are created for the same file, instantiate QFileInfo once and reuse it for various checks to avoid unnecessary object creation overhead."}
{"number": 824, "change": "@@ -295,12 +295,13 @@ TextField::display(Renderer& renderer, const Transform& base)\n     const bool drawBorder = getDrawBorder();\n     const bool drawBackground = getDrawBackground();\n \n-    Transform xform = base;\n-    xform.matrix.concatenate(getMatrix(*this));\n-    xform.colorTransform = getEmbedFonts() ? cxform() : get_world_cxform();\n+    Transform xform = base.concatenate(transform());\n \n-    if ((drawBorder || drawBackground) && !_bounds.is_null())\n-    {\n+    // This is a hack to handle device fonts, which are not affected by\n+    // color transform.\n+    if (getEmbedFonts()) xform.colorTransform = cxform();\n+\n+    if ((drawBorder || drawBackground) && !_bounds.is_null()) {\n \n         std::vector<point> coords(4);\n \n", "fix_pattern": "code removed:\n```\n    Transform xform = base;\n    xform.matrix.concatenate(getMatrix(*this));\n    xform.colorTransform = getEmbedFonts() ? cxform() : get_world_cxform();\n    if ((drawBorder || drawBackground) && !_bounds.is_null())\n    {\n\n```\ncode added:\n```\n    Transform xform = base.concatenate(transform());\n    // This is a hack to handle device fonts, which are not affected by\n    // color transform.\n    if (getEmbedFonts()) xform.colorTransform = cxform();\n\n    if ((drawBorder || drawBackground) && !_bounds.is_null()) {\n```\n<pattern>: if an object is being created and then modified in separate statements, leverage method chaining (like concatenate) to simplify and potentially enhance performance by reducing temporary object creation overhead."}
{"number": 827, "change": "@@ -1817,10 +1817,10 @@ void RendererImpl::presentFrame(RenderTargetHandle image) {\n \t}\n \tassert(rt.helperFBO != 0);\n \n-\tglBindFramebuffer(GL_READ_FRAMEBUFFER, rt.helperFBO);\n-\tglBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);\n-\n-\tglBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);\n+\tglBlitNamedFramebuffer(rt.helperFBO, 0\n+\t                     , 0, 0, width, height\n+\t                     , 0, 0, width, height\n+\t                     , GL_COLOR_BUFFER_BIT, GL_NEAREST);\n \n \tSDL_GL_SwapWindow(window);\n \n", "fix_pattern": "<pattern>: if multiple calls to bind framebuffers are made before a blit operation, replace them with a single call to glBlitNamedFramebuffer, which allows specifying the read and draw framebuffers directly for improved performance."}
{"number": 829, "change": "@@ -149,7 +149,7 @@ QString FolderCollection::configGroupName() const\n \n void FolderCollection::readConfig()\n {\n-  KConfigGroup configGroup( KMKernel::config(), configGroupName() );\n+  const KConfigGroup configGroup( KMKernel::config(), configGroupName() );\n   mExpireMessages = configGroup.readEntry( \"ExpireMessages\", false );\n   mReadExpireAge = configGroup.readEntry( \"ReadExpireAge\", 3 );\n   mReadExpireUnits = (ExpireUnits)configGroup.readEntry( \"ReadExpireUnits\", (int)ExpireMonths );\n@@ -184,7 +184,6 @@ void FolderCollection::readConfig()\n     KShortcut sc( shortcut );\n     setShortcut( sc, 0 );\n   }\n-  configGroup.sync();\n }\n \n bool FolderCollection::isValid() const\n", "fix_pattern": "<pattern>: if a KConfigGroup instance is being created and the sync() method is called without needing to synchronize the configuration state, remove the sync() call and make the KConfigGroup instance const since its state will not be modified."}
{"number": 830, "change": "@@ -135,9 +135,8 @@ KMKernel::KMKernel(QObject *parent) :\n     mSystemTray(Q_NULLPTR),\n     mDebugBaloo(false)\n {\n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n+\n     if (!s_networkConfigMgr) {\n         s_networkConfigMgr = new QNetworkConfigurationManager(QCoreApplication::instance());\n     }\n", "fix_pattern": "<pattern>: if there is an environment variable check using qgetenv followed by a check for emptiness with isEmpty(), replace it with a direct call to qEnvironmentVariableIsEmpty to simplify the check and improve performance."}
{"number": 832, "change": "@@ -2120,8 +2120,8 @@ void FProjectedShadowInfo::RenderProjection(FRHICommandListImmediate& RHICmdList\n \t\t// no depth test or writes, Test stencil for non-zero.\n \t\tRHICmdList.SetDepthStencilState(TStaticDepthStencilState<\n \t\t\tfalse,CF_Always,\n-\t\t\ttrue,CF_NotEqual,SO_Keep,SO_Keep,SO_Keep,\n-\t\t\tfalse,CF_Always,SO_Keep,SO_Keep,SO_Keep,\n+\t\t\ttrue,CF_NotEqual,SO_Zero,SO_Zero,SO_Zero,\n+\t\t\tfalse,CF_Always,SO_Zero,SO_Zero,SO_Zero,\n \t\t\t0xff,0xff\n \t\t\t>::GetRHI());\n \t}\n@@ -2229,11 +2229,6 @@ void FProjectedShadowInfo::RenderProjection(FRHICommandListImmediate& RHICmdList\n \t\t// Disable depth bounds testing\n \t\tRHICmdList.EnableDepthBoundsTest(false, 0, 1);\n \t}\n-\telse\n-\t{\n-\t\t// Clear the stencil buffer to 0.\n-\t\tRHICmdList.Clear(false, FColor(0, 0, 0), false, 0, true, 0, FIntRect());\n-\t}\n }\n \n \n", "fix_pattern": "<pattern>: if the stencil state settings are modified from keeping the stencil values to zeroing them out (SO_Keep to SO_Zero), then ensure that stencil operations are optimized to not carry over values unnecessarily, thereby potentially improving performance in rendering scenarios where stencil values do not need to persist."}
{"number": 835, "change": "@@ -77,7 +77,7 @@ bool BasicIndexingJob::index()\n     }\n \n     if (fileInfo.isDir()) {\n-        doc.addBoolTerm(QLatin1String(\"folder\"), QLatin1String(\"T\"));\n+        doc.addBoolTerm(QStringLiteral(\"Tfolder\"));\n \n         // This is an optimization for folders. They do not need to go through\n         // file indexing, so there are no indexers for folders\n", "fix_pattern": "<pattern>: if a QLatin1String is constructed using a string literal for values that will not change, replace it with QStringLiteral for potentially better performance and memory usage."}
{"number": 836, "change": "@@ -15,7 +15,6 @@ void mainjob(void*) {\n   Network::init();\n   Audio::init();\n   glEnable(GL_CULL_FACE);\n-  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n   Engine::add_resource<Font>();\n   Engine::add_resource<Material>();\n   Engine::add_resource<GL::Mesh>();\n", "fix_pattern": "<pattern>: if the `glBlendFunc` method is called repeatedly with the same parameters, consider caching or avoiding the call to improve performance, as it may not need to be set every frame if the blend function remains unchanged."}
{"number": 837, "change": "@@ -180,18 +180,16 @@ void IntegrationPointSet::finalize()\n {\n     // Build a globally contiguous ordering of point global ids.\n     EntityId num_local_ip = d_points.size();\n-    EntityId num_global_ip = 0;\n-    Teuchos::reduceAll( *d_comm, Teuchos::REDUCE_SUM,\n-                        num_local_ip, Teuchos::ptrFromRef(num_global_ip) );\n+\n+    EntityId invalid = Teuchos::OrdinalTraits<Tpetra::global_size_t>::invalid();\n     Teuchos::RCP<const Tpetra::Map<int,EntityId> > map =\n-        Tpetra::createContigMap<int,EntityId>(num_global_ip,num_local_ip,d_comm);\n+        Tpetra::createContigMap<int,EntityId>(invalid, num_local_ip, d_comm);\n \n     // Get the starting id for this node.\n     DTK_CHECK( map->isContiguous() );\n     DTK_CHECK( map->getMaxGlobalIndex() - map->getMinGlobalIndex() + 1 ==\n                num_local_ip );\n     DTK_CHECK( map->getNodeNumElements() == num_local_ip );\n-    DTK_CHECK( map->getGlobalNumElements() == num_global_ip );\n     d_start_gid = map->getMinGlobalIndex();\n \n     // Assign global ids to the points.\n", "fix_pattern": "<pattern>: if a reduction is performed to calculate the global number of elements from local counts using Teuchos::reduceAll, and the result is only checked for validity, use Teuchos::OrdinalTraits<Tpetra::global_size_t>::invalid() to bypass the reduction process when no valid global element count is needed, improving performance by avoiding unnecessary communication and computation."}
{"number": 838, "change": "@@ -264,17 +264,29 @@ void agiGLPipeline::BeginFrame()\n \n     gl_context_->MakeCurrent();\n \n-    if (PARAM_frameclear.get_or(true))\n+    bool frameclear = PARAM_frameclear.get_or(true);\n+\n+    if (frameclear)\n     {\n         agiGL->EnableDisable(GL_SCISSOR_TEST, false);\n+        agiGL->DepthMask(true);\n         glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n-        glClear(GL_COLOR_BUFFER_BIT);\n     }\n \n     if (fbo_ != 0)\n     {\n+        if (frameclear)\n+        {\n+            glClear(GL_COLOR_BUFFER_BIT);\n+        }\n+\n         glBindFramebuffer(GL_FRAMEBUFFER, fbo_);\n     }\n+\n+    if (frameclear)\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n+    }\n }\n \n void agiGLPipeline::BeginScene()\n", "fix_pattern": "<pattern>: if a condition is checked multiple times with the same result, cache the result in a variable to avoid unnecessary repeated calls, and ensure to organize the flow of API calls for better clarity and potential performance improvements."}
{"number": 840, "change": "@@ -527,8 +527,7 @@ vdraw_send_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)\n \t\treturn TCL_ERROR;\n \t}\n \n-\tsprintf(solid_name, RT_VDRW_PREFIX);\n-\tstrncat(solid_name, dgop->dgo_currVHead->vdc_name, RT_VDRW_MAXNAME);\n+\tsnprintf(solid_name, RT_VDRW_MAXNAME+RT_VDRW_PREFIX_LEN+1, \"%s%s\", RT_VDRW_PREFIX, dgop->dgo_currVHead->vdc_name);\n \tif ((dp = db_lookup(dgop->dgo_wdbp->dbip, solid_name, LOOKUP_QUIET)) == DIR_NULL) {\n \t\treal_flag = 0;\n \t} else {\n", "fix_pattern": "<pattern>: if a string is being constructed using sprintf followed by strncat, replace it with snprintf to streamline the operation and enhance performance by eliminating the need for multiple function calls and potential buffer overflow risks."}
{"number": 844, "change": "@@ -1,4 +1,4 @@\n-/* $Id: clearspd.c,v 1.2 2000/04/10 16:25:15 brianp Exp $ */\n+/* $Id: clearspd.c,v 1.3 2000/12/07 21:50:39 brianp Exp $ */\n \n /*\n  * Simple GLUT program to measure glClear() and glutSwapBuffers() speed.\n@@ -7,6 +7,9 @@\n \n /*\n  * $Log: clearspd.c,v $\n+ * Revision 1.3  2000/12/07 21:50:39  brianp\n+ * call glFinish() before getting t1 time\n+ *\n  * Revision 1.2  2000/04/10 16:25:15  brianp\n  * fixed visual selection and reporting results\n  *\n@@ -71,14 +74,15 @@ static void Display( void )\n          glClear( BufferMask );\n          glutSwapBuffers();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n    }\n    else {\n       t0 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       for (i=0;i<Loops;i++) {\n          glClear( BufferMask );\n-         glFlush();\n       }\n+      glFinish();\n       t1 = glutGet(GLUT_ELAPSED_TIME) * 0.001;\n       glutSwapBuffers();\n    }\n", "fix_pattern": "<pattern>: if performance-critical sections involve OpenGL rendering APIs, replace glFlush() with glFinish() when synchronization is needed to ensure all previous rendering commands are complete before proceeding, as glFinish() blocks until all commands are executed, leading to more predictable timing in performance measurements."}
{"number": 847, "change": "@@ -17,10 +17,10 @@\n //===----------------------------------------------------------------------===//\n \n #include \"../SwiftShims/GlobalObjects.h\"\n+#include \"../SwiftShims/LibcShims.h\"\n #include \"swift/Runtime/Metadata.h\"\n #include \"swift/Runtime/Debug.h\"\n #include <stdlib.h>\n-#include <random>\n \n namespace swift {\n // FIXME(ABI)#76 : does this declaration need SWIFT_RUNTIME_STDLIB_INTERFACE?\n@@ -116,18 +116,10 @@ static swift::_SwiftHashingParameters initializeHashingParameters() {\n   if (determinism && 0 == strcmp(determinism, \"1\")) {\n     return { 0, 0, true };\n   }\n-#if defined(__APPLE__)\n-  // Use arc4random if available.\n   __swift_uint64_t seed0 = 0, seed1 = 0;\n-  arc4random_buf(&seed0, sizeof(seed0));\n-  arc4random_buf(&seed1, sizeof(seed1));\n+  swift::_stdlib_random(&seed0, sizeof(seed0));\n+  swift::_stdlib_random(&seed1, sizeof(seed1));\n   return { seed0, seed1, false };\n-#else\n-  std::random_device randomDevice;\n-  std::mt19937_64 engine(randomDevice());\n-  std::uniform_int_distribution<__swift_uint64_t> distribution;\n-  return { distribution(engine), distribution(engine), false };\n-#endif\n }\n \n SWIFT_ALLOWED_RUNTIME_GLOBAL_CTOR_BEGIN\n", "fix_pattern": "<pattern>: if the code is using platform-specific random number generation (arc4random_buf) for macOS, replace it with a more generic and potentially optimized API (swift::_stdlib_random) to improve performance and maintain consistency across different platforms."}
{"number": 848, "change": "@@ -276,11 +276,9 @@ void DecisionMakerNode::initVectorMap(void)\n   {\n     // Map must be populated before setupStateCallback() is called\n     // in DecisionMakerNode constructor\n-    ROS_INFO(\"Subscribing to vector map topics.\");\n-\n     g_vmap.subscribe( nh_, Category::POINT | Category::LINE | Category::VECTOR |\n       Category::AREA | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD,\n-      ros::Duration(5.0));\n+      ros::Duration(1.0));\n \n     vmap_loaded =\n         g_vmap.hasSubscribed(Category::POINT | Category::LINE | Category::AREA |\n@@ -288,8 +286,12 @@ void DecisionMakerNode::initVectorMap(void)\n \n     if (!vmap_loaded)\n     {\n-      ROS_WARN(\"Necessary vectormap topics have not been published.\");\n-      ROS_WARN(\"DecisionMaker will wait until the vectormap has been loaded.\");\n+      ROS_WARN_THROTTLE(5, \"Necessary vectormap topics have not been published.\");\n+      ROS_WARN_THROTTLE(5, \"DecisionMaker will wait until the vectormap has been loaded.\");\n+    }\n+    else\n+    {\n+      ROS_INFO(\"Vectormap loaded.\");\n     }\n   }\n \n", "fix_pattern": "<pattern>: if ROS_WARN is called repeatedly in a tight loop, replace it with ROS_WARN_THROTTLE to limit the frequency of log messages and improve performance by reducing log spam."}
{"number": 850, "change": "@@ -536,8 +536,6 @@ hasMergeGroup(MergeGroupKind Kind) {\n void swift::\n collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n                     llvm::SmallDenseMap<ValueDecl*, ValueDecl*> &DefaultMap) {\n-  Type BaseTy = PD->getDeclaredInterfaceType();\n-  DeclContext *DC = PD->getInnermostDeclContext();\n   auto HandleMembers = [&](DeclRange Members) {\n     for (Decl *D : Members) {\n       auto *VD = dyn_cast<ValueDecl>(D);\n@@ -550,11 +548,8 @@ collectDefaultImplementationForProtocolMembers(ProtocolDecl *PD,\n       if (VD->getBaseName().empty())\n         continue;\n \n-      ResolvedMemberResult Result = resolveValueMember(*DC, BaseTy,\n-                                                       VD->getFullName());\n-      assert(Result);\n-      for (auto *Default : Result.getMemberDecls(InterestedMemberKind::All)) {\n-        if (PD == Default->getDeclContext()->getExtendedProtocolDecl()) {\n+      for (auto *Default: PD->lookupDirect(VD->getFullName())) {\n+        if (Default->getDeclContext()->getExtendedProtocolDecl() == PD) {\n           DefaultMap.insert({Default, VD});\n         }\n       }\n", "fix_pattern": "<pattern>: if a resolved member lookup is performed via resolveValueMember, replace it with a direct lookup using PD->lookupDirect to improve performance by avoiding unnecessary resolution overhead."}
{"number": 853, "change": "@@ -504,11 +504,6 @@ Future<std::shared_ptr<parquet::arrow::FileReader>> ParquetFileFormat::GetReader\n                                                          default_fragment_scan_options));\n   auto properties = MakeReaderProperties(*this, parquet_scan_options.get(), source.path(),\n                                          source.filesystem(), options->pool);\n-  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n-  // TODO(ARROW-12259): workaround since we have Future<(move-only type)>\n-  auto reader_fut = parquet::ParquetFileReader::OpenAsync(\n-      std::move(input), std::move(properties), metadata);\n-  auto path = source.path();\n   auto self = checked_pointer_cast<const ParquetFileFormat>(shared_from_this());\n \n   return source.OpenAsync().Then(\n", "fix_pattern": "<pattern>: NA"}
{"number": 854, "change": "@@ -192,7 +192,7 @@ bool GLResourceManager::Prepare_InitialState(GLResource res)\n \t\t\tqueryType = eGL_TEXTURE_CUBE_MAP_POSITIVE_X;\n \t\tgl.glGetTextureLevelParameterivEXT(res.name, queryType, 0, eGL_TEXTURE_COMPRESSED, &isComp);\n \t\t\n-\t\tint mips = GetNumMips(gl, details.curType, tex, details.width, details.height, details.depth);\n+\t\tint mips = GetNumMips(gl, details.curType, res.name, details.width, details.height, details.depth);\n \n \t\t// create texture of identical format/size to store initial contents\n \t\tif(details.curType == eGL_TEXTURE_2D_MULTISAMPLE)\n", "fix_pattern": "<pattern>: if an API method is being called with a texture handle (GLuint) that\u2019s less efficient than using a resource handle (like a string in this case), refactor the argument to utilize the more efficient or appropriate resource type for better performance."}
{"number": 855, "change": "@@ -181,11 +181,7 @@ wireshark_connector_impl::general_work(int noutput, gr_vector_int& ninput_items,\n \tgr_complex *out = (gr_complex*)output_items[0];\n \n \tif(!d_msg_len) {\n-#ifdef GR_FOO_NEW_API\n-\t\tpmt::pmt_t msg(delete_head_blocking(pmt::mp(\"in\"), 100));\n-#else\n-\t\tpmt::pmt_t msg(delete_head_blocking(pmt::mp(\"in\")));\n-#endif\n+\t\tpmt::pmt_t msg(delete_head_nowait(pmt::mp(\"in\")));\n \n \t\tif(!msg) {\n \t\t\treturn 0;\n", "fix_pattern": "<pattern>: if the original API method `delete_head_blocking` is replaced by a non-blocking version `delete_head_nowait`, it indicates a performance improvement by removing the blocking behavior, enhancing responsiveness and efficiency in handling the deletion process."}
{"number": 858, "change": "@@ -23,12 +23,13 @@\n CSwordVerseKey::CSwordVerseKey(const CSwordModuleInfo *module)\n     : CSwordKey(module)\n {\n-    typedef CSwordBibleModuleInfo CSBMI;\n-    if (const CSBMI *bible = dynamic_cast<const CSBMI*>(module) ) {\n-        // Copy important settings like versification system\n-        copyFrom(static_cast<sword::VerseKey*>(bible->module()->getKey()));\n+    if(module) {\n+        CSwordBibleModuleInfo const * bible = dynamic_cast<CSwordBibleModuleInfo const *>(module);\n+        Q_CHECK_PTR(bible);\n \n-        setKey( bible->lowerBound().key() );\n+        // Copy important settings like versification system\n+        copyFrom(bible->module()->getKey());\n+        setKey(bible->lowerBound().key());\n     }\n     this->VerseKey::setAutoNormalize(true);\n }\n", "fix_pattern": "<pattern>: if a type is being dynamically cast with no prior null check on the source pointer, first check if the pointer is not null before performing the dynamic_cast, and ensure appropriate error handling with Q_CHECK_PTR to maintain code safety and prevent unnecessary casts."}
{"number": 859, "change": "@@ -63,8 +63,7 @@ auto mp::utils::in_bytes(const std::string& mem_value) -> optional<long long>\n \n     if (matcher.exactMatch(QString::fromStdString(mem_value)))\n     {\n-        auto val =\n-            std::stoll(matcher.cap(1).toStdString()); // value is in the second capture (1st one is the whole match)\n+        auto val = matcher.cap(1).toLongLong();       // value is in the second capture (1st one is the whole match)\n         const auto unit = matcher.cap(2);             // unit in the third capture (idem)\n         if (!unit.isEmpty())\n         {\n", "fix_pattern": "<pattern>: if a QString is converted to std::string before using std::stoll to parse it, replace the conversion and the parsing with a direct call to QString::toLongLong for improved performance, avoiding unnecessary string conversion overhead."}
{"number": 863, "change": "@@ -596,11 +596,9 @@ void e6y_PreprocessLevel(void)\n \n void gld_InitGLVersion(void)\n {\n-  char ver[256];\n   int MajorVersion, MinorVersion;\n   glversion = OPENGL_VERSION_1_0;\n-  strncpy(ver, glGetString(GL_VERSION), sizeof(ver));\n-  if (sscanf(ver, \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n+  if (sscanf(glGetString(GL_VERSION), \"%d.%d\", &MajorVersion, &MinorVersion) == 2)\n   {\n     if (MajorVersion > 1)\n     {\n", "fix_pattern": "<pattern>: if the code copies a string from `glGetString` to a temporary buffer using `strncpy`, directly use the result of `glGetString` in `sscanf` to save memory and eliminate an unnecessary copy."}
{"number": 864, "change": "@@ -254,8 +254,14 @@ namespace pos{\n       static void get(T* &data, std::string path, PixelConfigKey key){\n \n       unsigned int theKey=key.key();\n-    \n-      assert(theKey<=getConfig().size());\n+      \n+      static PixelConfigList configList=getConfig();\n+\n+      if (theKey>configList.size()){\n+\tconfigList=getConfig();\n+      }\n+\n+      assert(theKey<=configList.size());\n     \n       unsigned int last=path.find_last_of(\"/\");\n       assert(last!=std::string::npos);\n@@ -278,7 +284,7 @@ namespace pos{\n //      std::cout << \"[pos::PixelConfigFile::get()]\\t\\t\\tExtracted ext :\"<<ext <<std::endl;\n     \n       unsigned int version;\n-      int err=getConfig()[theKey].find(dir,version);   \n+      int err=configList[theKey].find(dir,version);   \n       // assert(err==0);\n       if(0!=err) \n \t{\n", "fix_pattern": "<pattern>: if a configuration list is retrieved multiple times within a function call, store it in a static variable to avoid redundant calls to getConfig() and improve performance, ensuring to check for size validity."}
{"number": 865, "change": "@@ -729,11 +729,8 @@ int QString16::localeAwareCompare(QStringView16 str1, QStringView16 str2)\n    }\n \n #if defined(Q_OS_WIN32)\n-   QString16 tmp1(str1.begin(), str1.end());\n-   QString16 tmp2(str2.begin(), str2.end());\n-\n-   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)tmp1.constData(), tmp1.size_storage(),\n-        (wchar_t *)tmp2.constData(), tmp2.size_storage());\n+   int retval = CompareString(GetUserDefaultLCID(), 0, (wchar_t *)str1.charData(), str1.size_storage(),\n+        (wchar_t *)str2.charData(), str2.size_storage());\n \n    switch (retval) {\n       case CSTR_LESS_THAN:\n", "fix_pattern": "<pattern>: if temporary QString16 objects are created to convert QString data before passing it to an API, replace them with direct access to the char data and size functions of QString to eliminate unnecessary object creation and improve performance."}
{"number": 866, "change": "@@ -10,6 +10,9 @@\n \n cMCLogger * cMCLogger::s_MCLogger = NULL;\n \n+#ifdef _WIN32\n+\tHANDLE g_Console = GetStdHandle(STD_OUTPUT_HANDLE);\n+#endif\n \n \n \n@@ -145,8 +148,7 @@ void cMCLogger::Error(const char* a_Format, va_list a_ArgList)\n void cMCLogger::SetColor( unsigned char a_Color )\n {\n #ifdef _WIN32\n-\tHANDLE  hConsole = GetStdHandle( STD_OUTPUT_HANDLE );\n-\tSetConsoleTextAttribute( hConsole, a_Color );\n+\tSetConsoleTextAttribute(g_Console, a_Color);\n #else\n \t(void)a_Color;\n #endif\n", "fix_pattern": "<pattern>: if GetStdHandle is called repeatedly for the same handle in a function, store the handle in a static variable (or global variable) to avoid redundant API calls and improve performance."}
{"number": 867, "change": "@@ -46,7 +46,18 @@ bool IsSteamRunning()\n \n static void ForceInputAppId(int appId)\n {\n-\tShellExecute(nullptr, L\"open\", va(L\"steam://forceinputappid/%d\", appId), nullptr, nullptr, SW_HIDE);\n+\tSHELLEXECUTEINFOW shinfo = { 0 };\n+\tshinfo.cbSize = sizeof(SHELLEXECUTEINFO);\n+\tshinfo.fMask = SEE_MASK_ASYNCOK;\n+\tshinfo.hwnd = NULL;\n+\tshinfo.lpVerb = NULL;\n+\tshinfo.lpFile = va(L\"steam://forceinputappid/%d\", appId);\n+\tshinfo.lpParameters = NULL;\n+\tshinfo.lpDirectory = NULL;\n+\tshinfo.nShow = SW_HIDE;\n+\tshinfo.hInstApp = NULL;\n+\n+\tShellExecuteEx(&shinfo);\n }\n \n void SteamInput_Initialize()\n", "fix_pattern": "<pattern>: if using ShellExecute for asynchronous file execution, replace it with ShellExecuteEx that provides better control and allows for additional parameters through the SHELLEXECUTEINFO structure, potentially improving performance and readability."}
{"number": 868, "change": "@@ -453,7 +453,7 @@ SoGLRenderAction::beginTraversal(SoNode * node)\n     // light model\n     float lgt[4] = {0.2f, 0.2f, 0.2f, 1.0f};\n     glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lgt);\n-    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);\n+    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE); // GL_TRUE for higher quality\n \n     // no texturing unless textures in model\n     glDisable(GL_TEXTURE_2D);\n@@ -465,7 +465,7 @@ SoGLRenderAction::beginTraversal(SoNode * node)\n     glEnable(GL_NORMALIZE);\n \n     glDisable(GL_CULL_FACE);\n-    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);\n+    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);\n     glFrontFace(GL_CCW);\n     glShadeModel(GL_SMOOTH);\n \n", "fix_pattern": "<pattern>: if OpenGL lighting model settings are being changed to improve performance, replace GL_TRUE with GL_FALSE to reduce computational overhead, even if it may result in lower quality rendering."}
{"number": 869, "change": "@@ -491,7 +491,6 @@ SbBool\n SoOffscreenRenderer::renderFromBase(SoBase * base)\n {\n   if (this->internaldata && this->internaldata->makeContextCurrent()) {\n-    glEnable(GL_DEPTH_TEST);\n     glClearColor(this->backgroundcolor[0],\n                  this->backgroundcolor[1],\n                  this->backgroundcolor[2],\n", "fix_pattern": "<pattern>: if glEnable(GLenum cap) is called without checking if the capability is already enabled, refactor the code to check the current state before enabling to avoid unnecessary state changes."}
{"number": 873, "change": "@@ -1314,7 +1314,9 @@ void GPU_state_init(void)\n \tglCullFace(GL_BACK);\n \tglDisable(GL_CULL_FACE);\n \n-\tglDisable(GL_MULTISAMPLE_ARB);\n+\t/* calling this makes drawing very slow when AA is not set up in ghost\n+\t   on Linux/NVIDIA.\n+\tglDisable(GL_MULTISAMPLE); */\n }\n \n /* debugging aid */\n", "fix_pattern": "<pattern>: if disabling multisampling with `glDisable(GL_MULTISAMPLE_ARB)` causes performance issues when anti-aliasing is not set up properly on certain systems (like Linux/NVIDIA), comment out the call to prevent unnecessary performance degradation."}
{"number": 874, "change": "@@ -270,9 +270,8 @@ SolverBicgstab<VECTOR>::start(const MATRIX& A)\n   \n   Vp->reinit(*Vx);\n   Vv->reinit(*Vx);\n-  Vrbar->equ(1.,*Vr);\n-  SolverControl::State state = control().check(step, res);\n-  return state;\n+  *Vrbar = *Vr;\n+  return state = control().check(step, res);\n }\n \n \n", "fix_pattern": "<pattern>: if an API method modifies a target object when the source object can be directly assigned without invoking it, then replace the method call with a direct assignment to improve performance."}
{"number": 875, "change": "@@ -1901,13 +1901,19 @@ void Jit64::cntlzwx(UGeckoInstruction inst)\n \telse\n \t{\n \t\tgpr.Lock(a, s);\n-\t\tgpr.KillImmediate(s, true, false);\n-\t\tgpr.BindToRegister(a, (a == s), true);\n-\t\tBSR(32, gpr.R(a).GetSimpleReg(), gpr.R(s));\n-\t\tFixupBranch gotone = J_CC(CC_NZ);\n-\t\tMOV(32, gpr.R(a), Imm32(63));\n-\t\tSetJumpTarget(gotone);\n-\t\tXOR(32, gpr.R(a), Imm8(0x1f));  // flip order\n+\t\tgpr.BindToRegister(a, a == s, true);\n+\t\tif (cpu_info.bLZCNT)\n+\t\t{\n+\t\t\tLZCNT(32, gpr.RX(a), gpr.R(s));\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tBSR(32, gpr.RX(a), gpr.R(s));\n+\t\t\tFixupBranch gotone = J_CC(CC_NZ);\n+\t\t\tMOV(32, gpr.R(a), Imm32(63));\n+\t\t\tSetJumpTarget(gotone);\n+\t\t\tXOR(32, gpr.R(a), Imm8(0x1f));  // flip order\n+\t\t}\n \t\tgpr.UnlockAll();\n \t}\n \n", "fix_pattern": "<pattern>: if the API calls involve a choice between different instructions based on a condition (in this case, cpu_info.bLZCNT), replace the serial execution of operations with a conditional branch to avoid unnecessary calls and make the execution path more efficient."}
{"number": 877, "change": "@@ -37,9 +37,15 @@ static void dx_create_back_buffer()\n \n \tgpBuffer = (BYTE *)pal_surface->pixels;\n \n-\tif (SDLC_SetSurfaceColors(pal_surface, palette) <= -1) {\n+#ifndef USE_SDL1\n+\t// In SDL2, `pal_surface` points to the global `palette`.\n+\tif (SDL_SetSurfacePalette(pal_surface, palette) < 0)\n \t\tErrSdl();\n-\t}\n+#else\n+\t// In SDL1, `pal_surface` owns its palette and we must update it every\n+\t// time the global `palette` is changed. No need to do anything here as\n+\t// the global `palette` doesn't have any colors set yet.\n+#endif\n \n \tpal_surface_palette_version = 1;\n }\n", "fix_pattern": "<pattern>: When switching from an API that requires manual updates to a palette (like SDLC_SetSurfaceColors) to a more optimized API that leverages a global palette (like SDL_SetSurfacePalette), ensure to conditionally compile the correct usage based on the SDL version being utilized, reducing unnecessary calls and checks while aligning with the library's expectations on palette management for improved performance."}
{"number": 880, "change": "@@ -211,8 +211,11 @@ void AudioManager::Config(const AudioConfigData& data /*= _DefCfg*/)\n       return;\n    }\n \n-   OpenDevice();\n-   CreateContext();   \n+   //Should be opened elsewhere (either by alutInit (in constructor)\n+   // or by SetOpenALDevice)\n+   //OpenDevice();\n+   //Context is automagically setup by alutInit or a call to SetOpenALDevice\n+   //CreateContext();   \n \n    // set up the distance model\n    switch (data.distancemodel)\n", "fix_pattern": "<pattern>: if the OpenDevice() and CreateContext() calls are being managed elsewhere (either during initialization or by another method), then comment them out to avoid unnecessary overhead and potential duplicate setup calls."}
{"number": 885, "change": "@@ -41,7 +41,18 @@ void GLIndexBuf::bind()\n \n void GLIndexBuf::bind_as_ssbo(uint binding)\n {\n-  bind();\n+  if (ibo_id_ == 0 || data_ != nullptr) {\n+    /* Calling `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo_id_)` changes the index buffer\n+     * of the currently bound VAO.\n+     *\n+     * In the OpenGL backend, the VAO state persists even after `GLVertArray::update_bindings`\n+     * is called.\n+     *\n+     * NOTE: For safety, we could call `glBindVertexArray(0)` right after drawing a `GPUBatch`.\n+     * However, for performance reasons, we have chosen not to do so. */\n+    glBindVertexArray(0);\n+    bind();\n+  }\n   BLI_assert(ibo_id_ != 0);\n   glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, ibo_id_);\n }\n", "fix_pattern": "<pattern>: if a binding operation is performed via glBindVertexArray before a specific condition (like checking if ibo_id_ is 0 or data_ is not null), it is refactored to avoid unnecessary binding calls, which can lead to performance improvements by preventing redundant state changes in the OpenGL pipeline."}
{"number": 886, "change": "@@ -1583,7 +1583,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\tglClear(GL_COLOR_BUFFER_BIT);\n \t\tif (sdl.opengl.pixel_buffer_object) {\n \t\t\tglUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, sdl.draw.width,\n \t\t\t                sdl.draw.height, GL_BGRA_EXT,\n \t\t\t                GL_UNSIGNED_INT_8_8_8_8_REV, 0);\n@@ -1591,7 +1590,6 @@ void GFX_EndUpdate( const Bit16u *changedLines ) {\n \t\t} else if (changedLines) {\n \t\t\tint y = 0;\n \t\t\tsize_t index = 0;\n-\t\t\tglBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);\n \t\t\twhile (y < sdl.draw.height) {\n \t\t\t\tif (!(index & 1)) {\n \t\t\t\t\ty += changedLines[index];\n", "fix_pattern": "<pattern>: if glBindTexture is called multiple times with the same parameters consecutively, remove redundant calls to improve performance."}
{"number": 887, "change": "@@ -211,11 +211,14 @@ static int insert_attributes_from_list(GPUVertFormat *format, PyObject *list)\n \n static PyObject *bpygpu_VertFormat_new(PyTypeObject *UNUSED(type), PyObject *args, PyObject *kwds)\n {\n-\n \tPyObject *format_list;\n \n-\tstatic const char *keywords[] = {\"format\", NULL};\n-\tif (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!\", (char**)keywords, &PyList_Type, &format_list)) {\n+\tstatic const char *_keywords[] = {\"format\", NULL};\n+\tstatic _PyArg_Parser _parser = {\"O!:VertFormat.__new__\", _keywords, 0};\n+\tif (!_PyArg_ParseTupleAndKeywordsFast(\n+\t        args, kwds, &_parser,\n+\t        &PyList_Type, &format_list))\n+\t{\n \t\treturn NULL;\n \t}\n \n", "fix_pattern": "<pattern>: if the code uses PyArg_ParseTupleAndKeywords, refactor it to use _PyArg_ParseTupleAndKeywordsFast with a pre-defined static _PyArg_Parser structure to improve performance by reducing the overhead associated with parsing the keywords."}
{"number": 888, "change": "@@ -332,10 +332,10 @@ PluginUIState PluginUI_updateInstance(ViewPluginInstance* instance, PDReader* re\n     PDUI* uiInstance = &instance->ui;\n     PrivateData* data = (PrivateData*)uiInstance->privateData;\n \n-    ImGui::Begin(data->name, &data->showWindow, ImVec2(0, 0), true, 0);\n+\tImGui::SetNextWindowPos(ImVec2((float)instance->rect.x, (float)instance->rect.y));\n+\tImGui::SetNextWindowSize(ImVec2((float)instance->rect.width, (float)instance->rect.height));\n \n-\tImGui::SetWindowPos(ImVec2((float)instance->rect.x, (float)instance->rect.y));\n-\tImGui::SetWindowSize(ImVec2((float)instance->rect.width, (float)instance->rect.height));\n+    ImGui::Begin(data->name, &data->showWindow, ImVec2(0, 0), true, 0);\n \n     instance->plugin->update(instance->userData, uiInstance, reader, writer);\n \n", "fix_pattern": "<pattern>: if a window's position and size are being set after the ImGui::Begin call, use ImGui::SetNextWindowPos and ImGui::SetNextWindowSize before ImGui::Begin to optimize layout setting, as these calls are meant to influence the next window creation rather than modifying an already created window."}
{"number": 889, "change": "@@ -43,13 +43,7 @@ static int gr_installed;\n \n void gr_flip()\n {\n-\tSDL_Rect src, dest;\n-\n-\tdest.x = src.x = dest.y = src.y = 0;\n-\tdest.w = src.w = canvas->w;\n-\tdest.h = src.h = canvas->h;\n-\n-\tSDL_BlitSurface(canvas, &src, screen, &dest);\n+\tSDL_BlitSurface(canvas, nullptr, screen, nullptr);\n \tSDL_Flip(screen);\n }\n \n", "fix_pattern": "<pattern>: If the source and destination rectangles (`src` and `dest`) are set to cover the entire surface area, replace them with `nullptr` when calling `SDL_BlitSurface` to improve performance and reduce unnecessary initialization."}
{"number": 890, "change": "@@ -15,6 +15,7 @@\n #endif\n #include <folly/ScopeGuard.h>\n #include <folly/String.h>\n+#include <folly/system/Pid.h>\n \n #if defined(_WIN32) || defined(O_PATH)\n #define CAN_OPEN_SYMLINKS 1\n@@ -453,9 +454,19 @@ w_string FileDescriptor::getOpenedPath() const {\n #elif defined(__linux__) || defined(__sun)\n   char procpath[1024];\n #if defined(__linux__)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/fd/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/fd/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #elif defined(__sun)\n-  snprintf(procpath, sizeof(procpath), \"/proc/%d/path/%d\", getpid(), fd_);\n+  snprintf(\n+      procpath,\n+      sizeof(procpath),\n+      \"/proc/%d/path/%d\",\n+      folly::get_cached_pid(),\n+      fd_);\n #endif\n \n   // Avoid an extra stat by speculatively attempting to read into\n", "fix_pattern": "<pattern>: if a process ID is repeatedly fetched using getpid(), replace it with a cached version provided by folly::get_cached_pid() to avoid the performance overhead of system calls."}
{"number": 892, "change": "@@ -430,6 +430,8 @@ void SDL20VideoDriver::DrawRect(const Region& rgn, const Color& color, bool fill\n void SDL20VideoDriver::DrawPolygon(Gem_Polygon* poly, const Point& origin, const Color& color, bool fill, unsigned int flags)\n {\n \tif (fill) {\n+\t\tUpdateRenderTarget(&color, flags);\n+\n \t\tconst std::vector<Point>& lines = poly->rasterData;\n \t\tsize_t count = lines.size();\n \t\tassert(count%2==0);\n@@ -438,7 +440,9 @@ void SDL20VideoDriver::DrawPolygon(Gem_Polygon* poly, const Point& origin, const\n \t\t\t// SDL_RenderDrawLines actually is for drawing polygons so it is, ironically, not what we want\n \t\t\t// when drawing the \"rasterized\" data. doing so would work ok most of the time, but other times\n \t\t\t// the reconnection of the last to first point (done by SDL) will be visible\n-\t\t\tDrawLine(lines[i] + origin, lines[i+1] + origin, color, flags);\n+\t\t\tPoint p1(lines[i] + origin);\n+\t\t\tPoint p2(lines[i+1] + origin);\n+\t\t\tSDL_RenderDrawLine(renderer, p1.x, p1.y, p2.x, p2.y);\n \t\t}\n \t} else {\n \t\tstd::vector<SDL_Point> points(poly->Count());\n", "fix_pattern": "<pattern>: if a line drawing operation is performed repeatedly using a custom DrawLine method, refactor to use SDL_RenderDrawLine directly for improved performance by eliminating unnecessary overhead from the custom API and using more optimized drawing logic. Additionally, ensure that any color updates are managed through a centralized method like UpdateRenderTarget."}
{"number": 896, "change": "@@ -845,10 +845,10 @@ public:\n \t\tint const index_type(use_32_bit ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT);\n \n \t\tif (num_instances > 1) { // instanced drawing not supported/efficient on some cards, so only enabled it when needed\n-\t\t\tglDrawElementsInstancedBaseVertex(GL_TRIANGLES, num_tri_verts, index_type, nullptr, num_instances, start_quad_vert);\n+\t\t\tglDrawElementsInstancedBaseVertex(GL_TRIANGLES, num_tri_verts, index_type, 0, num_instances, start_quad_vert);\n \t\t}\n \t\telse {\n-\t\t\tglDrawElementsBaseVertex(GL_TRIANGLES, num_tri_verts, index_type, nullptr, start_quad_vert);\n+\t\t\tglDrawElementsBaseVertex(GL_TRIANGLES, num_tri_verts, index_type, 0, start_quad_vert);\n \t\t}\n \t\tbind_vbo(0, 1);\n \t}\n", "fix_pattern": "<pattern>: if a call to OpenGL API methods contains a nullptr for the indices parameter, replace it with 0 for better clarity and potentially improved performance in interpretation."}
{"number": 898, "change": "@@ -905,17 +905,18 @@ void CVideoPlayer::OpenDefaultStreams(bool reset)\n     CloseStream(m_CurrentVideo, true);\n \n   // open audio stream\n-  if(m_PlayerOptions.video_only)\n-    streams.clear();\n-  else\n-    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n   valid   = false;\n-\n-  for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+  if(!m_PlayerOptions.video_only)\n   {\n-    if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n-      valid = true;\n+    streams = m_SelectionStreams.Get(STREAM_AUDIO, PredicateAudioPriority);\n+\n+    for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)\n+    {\n+      if(OpenStream(m_CurrentAudio, it->demuxerId, it->id, it->source, reset))\n+        valid = true;\n+    }\n   }\n+\n   if(!valid)\n     CloseStream(m_CurrentAudio, true);\n \n", "fix_pattern": "<pattern>: if a conditionally clearing a collection (streams.clear()) is followed by a reassignment based on the same condition, restructure the code to eliminate the unnecessary clearing operation and directly assign when conditions allow, improving performance by reducing redundant operations."}
{"number": 899, "change": "@@ -3745,7 +3745,7 @@ void CVideoDatabase::SetVideoSettings(const CStdString& strFilenameAndPath, cons\n     int idFile = AddFile(strFilenameAndPath);\n     if (idFile < 0)\n       return;\n-    CStdString strSQL = StringUtils::Format(\"select * from settings where idFile=%i\", idFile);\n+    CStdString strSQL = PrepareSQL(\"select * from settings where idFile=%i\", idFile);\n     m_pDS->query( strSQL.c_str() );\n     if (m_pDS->num_rows() > 0)\n     {\n", "fix_pattern": "<pattern>: if a format string operation using StringUtils::Format is detected, replace it with a more optimized project-specific function like PrepareSQL, which might offer better performance or security (e.g., by preventing SQL injection through sanitization)."}
{"number": 901, "change": "@@ -45,13 +45,14 @@ GeoPatch::GeoPatch(const GeoPatch& rhs, const CopyOp& copyop)\n \n float GeoPatch::getEdgeError(const osg::Vec3& eye, int edge)\n {\n-    // Massive hack to get back to face parameters.\n-    MatrixList worldmats = getWorldMatrices();\n-    Vec3d worldEye = Vec3d(eye) * worldmats[0];\n-    Group* parent = getParent(0);\n+    // Hack to get back to face parameters and world coordinates.\n+    Transform* parent = static_cast<Transform*>(getParent(0));\n     PatchGroup* pgroup = static_cast<PatchGroup*>(parent->getParent(0));\n     GeographicOptions* goptions\n         = static_cast<GeographicOptions*>(pgroup->getDatabaseOptions());\n+    Matrix worldMat;\n+    parent->computeLocalToWorldMatrix(worldMat, 0);\n+    Vec3d worldEye = Vec3d(eye) * worldMat;\n     TileKey* tk = goptions->getTileKey();\n     int face;\n     const GeoExtent& extent = tk->getGeoExtent();\n", "fix_pattern": "<pattern>: if the code retrieves world matrices and performs a matrix multiplication separately, replace this operation by directly computing the local-to-world matrix using a Transform class method, thus avoiding unnecessary data retrieval and improving performance by working directly with the parent transform's matrix computation."}
{"number": 904, "change": "@@ -180,7 +180,16 @@ void DrawCallPerfBenchmark::destroyBenchmark()\n \n void DrawCallPerfBenchmark::drawBenchmark()\n {\n-    glClear(GL_COLOR_BUFFER_BIT);\n+    // This workaround fixes a huge queue of graphics commands accumulating on the GL\n+    // back-end. The GL back-end doesn't have a proper NULL device at the moment.\n+    // TODO(jmadill): Remove this when/if we ever get a proper OpenGL NULL device.\n+    const auto &eglParams = GetParam().eglParameters;\n+    if (eglParams.deviceType != EGL_PLATFORM_ANGLE_DEVICE_TYPE_NULL_ANGLE ||\n+        (eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE &&\n+         eglParams.renderer != EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE))\n+    {\n+        glClear(GL_COLOR_BUFFER_BIT);\n+    }\n \n     const auto &params = GetParam();\n \n", "fix_pattern": "<pattern>: if calling glClear is causing performance issues due to excessive accumulation of graphics commands in the GL back-end, conditionally execute glClear based on the type of EGL device to mitigate the performance impact."}
{"number": 905, "change": "@@ -938,7 +938,10 @@ egl::ConfigSet Renderer11::generateConfigs()\n         // Additional high bit depth formats added in D3D 10.0\n         // https://msdn.microsoft.com/en-us/library/windows/desktop/bb173064.aspx\n         colorBufferFormats.push_back(GL_RGBA16F);\n-        colorBufferFormats.push_back(GL_RGB10_A2);\n+\n+        // TODO(geofflang): Re-enable once client code has been updated to filter configs better and\n+        // not use RGB10A2 accidentally when requesting RGBA8\n+        // colorBufferFormats.push_back(GL_RGB10_A2);\n     }\n \n     if (!mPresentPathFastEnabled)\n", "fix_pattern": "<pattern>: if a call to push back an invalid or unoptimized color format is detected, comment it out until client code can be updated to filter configurations properly, thus avoiding unnecessary overhead or potential misconfigurations."}
{"number": 906, "change": "@@ -82,10 +82,6 @@ void BufferedDrawer::_updateBuffer(Buffer & _buffer, u32 _count, u32 _dataSize,\n \n \tif (m_glInfo.bufferStorage) {\n \t\tmemcpy(&_buffer.data[_buffer.offset], _data, _dataSize);\n-#ifdef GL_DEBUG\n-\t\tm_bindBuffer->bind(Parameter(_buffer.type), ObjectHandle(_buffer.handle));\n-\t\tglFlushMappedBufferRange(_buffer.type, _buffer.offset, _dataSize);\n-#endif\n \t} else {\n \t\tm_bindBuffer->bind(Parameter(_buffer.type), ObjectHandle(_buffer.handle));\n \t\tvoid* buffer_pointer = glMapBufferRange(_buffer.type, _buffer.offset, _dataSize, GL_MAP_WRITE_BIT | GL_MAP_UNSYNCHRONIZED_BIT);\n", "fix_pattern": "<pattern>: if the original code is wrapped in a debug condition (e.g., `#ifdef GL_DEBUG`), and no operations are performed in the added code block, it likely indicates that the debug-related operations are removed or optimized out in a release build. This suggests opportunities for simplifying or optimizing debug checks and ensuring no unnecessary API calls are made during performance-critical paths."}
{"number": 907, "change": "@@ -75,7 +75,12 @@ std::vector<uint32_t> preprocessSpirv(\n \t}\n \n \tstd::vector<uint32_t> optimized;\n-\topt.Run(code.data(), code.size(), &optimized);\n+\tspvtools::OptimizerOptions options;\n+#if defined(NDEBUG)\n+\toptions.set_run_validator(false);\n+#endif\n+\n+\topt.Run(code.data(), code.size(), &optimized, options);\n \n \tif(false)\n \t{\n", "fix_pattern": "<pattern>: if an API method call is made without options that may control performance-sensitive features, enhance the call by utilizing options like disabling unnecessary validation in release builds to improve performance."}
{"number": 908, "change": "@@ -144,7 +144,7 @@ void ScreenshotRenderer::render()\n \n     // Bind to screenshot FBO\n     glBindFramebuffer(GL_FRAMEBUFFER, _screenshotFBO);\n-    glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, _screenshotTex, 0);\n+    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _screenshotTex, 0);\n \n     GLenum drawBuffers[] = {GL_COLOR_ATTACHMENT0};\n     glDrawBuffers(1, static_cast<GLenum*>(drawBuffers));\n", "fix_pattern": "<pattern>: replace glFramebufferTexture with glFramebufferTexture2D to provide a specific texture target type (GL_TEXTURE_2D) for better clarity and performance when binding a 2D texture to a framebuffer attachment."}
{"number": 910, "change": "@@ -2877,7 +2877,7 @@ void OpenGLDriver::blit(TargetBufferFlags buffers,\n     if (mask) {\n         GLRenderTarget const* s = handle_cast<GLRenderTarget const*>(src);\n         GLRenderTarget const* d = handle_cast<GLRenderTarget const*>(dst);\n-        bindFramebuffer(GL_READ_FRAMEBUFFER, s->gl.fbo);\n+        bindFramebuffer(GL_READ_FRAMEBUFFER, s->gl.fbo_draw ? s->gl.fbo_draw : s->gl.fbo);\n         bindFramebuffer(GL_DRAW_FRAMEBUFFER, d->gl.fbo);\n         disable(GL_SCISSOR_TEST);\n         glBlitFramebuffer(\n", "fix_pattern": "<pattern>: if a framebuffer is being bound and there is an additional draw framebuffer available, first check if the draw framebuffer (`fbo_draw`) is valid; if it is, bind it instead of the default framebuffer (`fbo`). This optimization helps avoid unnecessary state changes by selecting the appropriate framebuffer based on availability, which can lead to performance improvements in rendering operations."}
{"number": 912, "change": "@@ -94,7 +94,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\t    node_type != abnode_type::equipment)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_server_dn(pnode, dn, sizeof(dn));\n-\t\tstrcat(dn, \"/cn=Microsoft Private MDB\");\n+\t\tHX_strlcat(dn, \"/cn=Microsoft Private MDB\", arsizeof(dn));\n \t\tif (NULL == pbuff) {\n \t\t\tpprop->value.pv = ndr_stack_alloc(\n \t\t\t\tNDR_STACK_OUT, strlen(dn) + 1);\n@@ -471,7 +471,7 @@ static uint32_t nsp_interface_fetch_property(const SIMPLE_TREE_NODE *pnode,\n \t\tif (node_type != abnode_type::person)\n \t\t\treturn ecNotFound;\n \t\tab_tree_get_user_info(pnode, USER_STORE_PATH, dn, GX_ARRAY_SIZE(dn));\n-\t\tstrcat(dn, \"/config/portrait.jpg\");\n+\t\tHX_strlcat(dn, \"/config/portrait.jpg\", arsizeof(dn));\n \t\tif (!common_util_load_file(dn, &pprop->value.bin))\n \t\t\treturn ecNotFound;\n \t\treturn ecSuccess;\n", "fix_pattern": "<pattern>: if using strcat to concatenate strings where buffer size is a concern, replace it with a safer alternative such as HX_strlcat which takes the size of the destination buffer to prevent buffer overflows."}
{"number": 914, "change": "@@ -167,9 +167,10 @@ void EPollEngine::DelFd(EventHandler* eh)\n \t\treturn;\n \t}\n \n+\t// Do not initialize epoll_event because for EPOLL_CTL_DEL operations the event is ignored and can be NULL.\n+\t// In kernel versions before 2.6.9, the EPOLL_CTL_DEL operation required a non-NULL pointer in event,\n+\t// even though this argument is ignored. Since Linux 2.6.9, event can be specified as NULL when using EPOLL_CTL_DEL.\n \tstruct epoll_event ev;\n-\tmemset(&ev, 0, sizeof(ev));\n-\tev.data.fd = fd;\n \tint i = epoll_ctl(EngineHandle, EPOLL_CTL_DEL, fd, &ev);\n \n \tif (i < 0)\n", "fix_pattern": "<pattern>: if an epoll_event is being initialized for an EPOLL_CTL_DEL operation, avoid unnecessary initialization with memset or setting its fields, as the event data can be NULL and is ignored in this context."}
{"number": 916, "change": "@@ -73,13 +73,14 @@ void OMPLRNStateSpace::SetBounds(SamplingProblemPtr &prob)\n {\n     unsigned int dim = prob->N;\n     addSubspace(ompl::base::StateSpacePtr(new ompl::base::RealVectorStateSpace(dim)), 1.0);\n-    ompl::base::RealVectorBounds bounds(dim);\n+    ompl::base::RealVectorBounds ompl_bounds(dim);\n+    auto bounds = prob->GetBounds();\n     for (int i = 0; i < dim; ++i)\n     {\n-        bounds.setHigh(i, prob->GetBounds()[i + dim]);\n-        bounds.setLow(i, prob->GetBounds()[i]);\n+        ompl_bounds.setHigh(i, bounds[i + dim]);\n+        ompl_bounds.setLow(i, bounds[i]);\n     }\n-    getSubspace(0)->as<ompl::base::RealVectorStateSpace>()->setBounds(bounds);\n+    getSubspace(0)->as<ompl::base::RealVectorStateSpace>()->setBounds(ompl_bounds);\n     setLongestValidSegmentFraction(init_.LongestValidSegmentFraction);\n     lock();\n }\n", "fix_pattern": "<pattern>: if a new `ompl::base::RealVectorBounds` object is being created with each invocation, reuse the object and avoid unnecessary constructor calls by initializing with a more descriptive name and using `GetBounds()` only once to reduce function call overhead."}
{"number": 917, "change": "@@ -65,7 +65,7 @@ void setup_audio_stream(AVFormatContext *format_ctx, MpegTSCodecSettings *settin\n   AVStream *audio_stream;\n   int ret;\n \n-  aac_codec = avcodec_find_encoder(AV_CODEC_ID_AAC);\n+  aac_codec = avcodec_find_encoder_by_name(\"libfdk_aac\");\n   if (!aac_codec) {\n     fprintf(stderr, \"codec not found\\n\");\n     exit(EXIT_FAILURE);\n", "fix_pattern": "<pattern>: if the codec ID is known and a specific encoder is required, prefer using `avcodec_find_encoder_by_name()` with the encoder name to avoid potential overhead or misconfiguration associated with using `avcodec_find_encoder()` with a codec ID."}
{"number": 921, "change": "@@ -1654,7 +1654,7 @@ void CGSH_OpenGL::DoRenderPass()\n \tif((m_validGlState & GLSTATE_VERTEX_PARAMS) == 0)\n \t{\n \t\tglBindBuffer(GL_UNIFORM_BUFFER, m_vertexParamsBuffer);\n-\t\tglBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(VERTEXPARAMS), &m_vertexParams);\n+\t\tglBufferData(GL_UNIFORM_BUFFER, sizeof(VERTEXPARAMS), &m_vertexParams, GL_STREAM_DRAW);\n \t\tCHECKGLERROR();\n \t\tm_validGlState |= GLSTATE_VERTEX_PARAMS;\n \t}\n@@ -1662,7 +1662,7 @@ void CGSH_OpenGL::DoRenderPass()\n \tif((m_validGlState & GLSTATE_FRAGMENT_PARAMS) == 0)\n \t{\n \t\tglBindBuffer(GL_UNIFORM_BUFFER, m_fragmentParamsBuffer);\n-\t\tglBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(FRAGMENTPARAMS), &m_fragmentParams);\n+\t\tglBufferData(GL_UNIFORM_BUFFER, sizeof(FRAGMENTPARAMS), &m_fragmentParams, GL_STREAM_DRAW);\n \t\tCHECKGLERROR();\n \t\tm_validGlState |= GLSTATE_FRAGMENT_PARAMS;\n \t}\n", "fix_pattern": "<pattern>: if glBufferSubData is used multiple times to update buffer data, replace it with glBufferData to allocate and initialize the buffer in one go for better performance and potentially reduce overhead. Additionally, utilize GL_STREAM_DRAW to hint that the data will be changed frequently, which can optimize performance."}
{"number": 922, "change": "@@ -460,7 +460,7 @@ float DeserializeFloat(const char *str, const char **outEndStr)\n \t\treturn FLOAT_NAN;\n \tif (MATH_NEXT_WORD_IS(str, \"NaN(\"))\n \t{\n-\t\tMATH_SKIP_WORD(str, \"NaN(\");\n+\t\tstr += strlen(\"NaN(\"); //MATH_SKIP_WORD(str, \"NaN(\");\n \t\tu32 x;\n \t\tint n = sscanf(str, \"%X\", (unsigned int *)&x);\n \t\tif (n != 1)\n", "fix_pattern": "<pattern>: if a specific word is skipped using a function that likely incurs function call overhead, replace the function call with a direct manipulation of the pointer to improve performance by reducing function call overhead."}
{"number": 924, "change": "@@ -375,7 +375,7 @@ void pqxx::connection_base::RemoveTrigger(pqxx::trigger *T) throw ()\n     else\n     {\n       if (m_Conn && (R.second == ++R.first))\n-\tresult(PQexec(m_Conn,(\"UNLISTEN \\\"\" + T->name() + \"\\\"\").c_str()));\n+\tExec((\"UNLISTEN \\\"\" + T->name() + \"\\\"\").c_str(), 0);\n \n       m_Triggers.erase(i);\n     }\n", "fix_pattern": "<pattern>: if the code uses the PQexec function from the libpq library to execute a command, refactor it to use a more efficient wrapper method (like Exec) that may reduce overhead or improve performance by not returning a PGresult* when not necessary."}
{"number": 927, "change": "@@ -28,9 +28,10 @@ void QKlamptDisplay::initializeGL(){\n }\n \n void QKlamptDisplay::paintGL(){\n-  glClear(0);\n   if(gui != NULL)\n     gui->SendGLRender();\n+  else\n+    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n }\n \n \n", "fix_pattern": "<pattern>: if glClear is called without any bitmask during a certain condition (like a clear operation being redundant), then ensure it explicitly clears the color and depth buffers only when necessary by combining the relevant bitmasks in one call."}
{"number": 928, "change": "@@ -13,7 +13,7 @@ namespace cq::api {\n     }\n \n     void __init() {\n-        const auto dll = LoadLibraryW(L\"CQP.dll\");\n+        const auto dll = GetModuleHandleW(L\"CQP.dll\");\n         for (const auto &initializer : api_func_initializers) {\n             initializer(dll);\n         }\n", "fix_pattern": "<pattern>: if a dynamic library is being loaded using LoadLibraryW, replace it with GetModuleHandleW if the intention is to retrieve a handle to an already loaded module, avoiding the overhead of loading the library again."}
{"number": 929, "change": "@@ -420,11 +420,9 @@ void PrimeGenerator::fillNextPrimes(std::vector<uint64_t>& primes,\n       sieveIdx_ += 8;\n \n       // Convert 1 bits from the sieve array (bits64) into prime\n-      // bit values using the avxBitValues lookup table.\n-      __m512i bitValues = _mm512_maskz_loadu_epi8(bits64, &avxBitValues);\n-\n-      // Move all non zero bytes (prime bit values) to the beginning\n-      bitValues = _mm512_maskz_compress_epi8(bits64, bitValues);\n+      // bit values (bytes) using the avxBitValues lookup table and\n+      // move all non zero bytes (bit values) to the beginning.\n+      __m512i bitValues = _mm512_maskz_compress_epi8(bits64, &avxBitValues);\n \n       // Convert the first 8 bytes (prime bit values)\n       // into eight 64-bit prime numbers.\n", "fix_pattern": "<pattern>: if the API method _mm512_maskz_loadu_epi8 is used to load data followed by _mm512_maskz_compress_epi8 to move non-zero bytes, combine these operations by directly using _mm512_maskz_compress_epi8 with the lookup table, thereby eliminating the redundant load operation for improved performance."}
{"number": 931, "change": "@@ -1096,7 +1096,7 @@ grLfbWriteRegion( GrBuffer_t dst_buffer,\n       }\n \n       glBindTexture(GL_TEXTURE_2D, default_texture);\n-      glTexImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n+      glTexSubImage2D(GL_TEXTURE_2D, 0, 4, tex_width, tex_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);\n \n       set_copy_shader();\n \n", "fix_pattern": "<pattern>: if a texture is already created and needs to be updated, replace glTexImage2D with glTexSubImage2D to improve performance by avoiding the overhead of reallocating texture memory."}
{"number": 933, "change": "@@ -265,7 +265,7 @@ void Tess_DrawElements()\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tglDrawElements( GL_TRIANGLES, tess.numIndexes, GL_INDEX_TYPE, BUFFER_OFFSET( 0 ) );\n+\t\t\tglDrawRangeElements( GL_TRIANGLES, 0, tess.numVertexes, tess.numIndexes, GL_INDEX_TYPE, BUFFER_OFFSET( 0 ) );\n \n \t\t\tbackEnd.pc.c_drawElements++;\n \n", "fix_pattern": "<pattern>: if using glDrawElements, and the vertex range can be specified, refactor the call to glDrawRangeElements to potentially improve performance by reducing overhead associated with vertex attribute fetching."}
{"number": 935, "change": "@@ -26,13 +26,6 @@ dLogger::~dLogger() {\n }\n \n void dLogger::vLog(const char* format, va_list args) {\n-\tconst char* tempPtr = format; // strlen_s implementation for Linux and Windows\n-\tfor (; *tempPtr != '\\0'; ++tempPtr) {\n-\t\tsize_t size = tempPtr - format;\n-\t\tif (size > 600) {\n-\t\t\treturn;\n-\t\t}\n-\t}\n #ifdef _WIN32\n \ttime_t t = time(NULL);\n \tstruct tm time;\n@@ -40,7 +33,7 @@ void dLogger::vLog(const char* format, va_list args) {\n \tchar timeStr[70];\n \tstrftime(timeStr, sizeof(timeStr), \"%d-%m-%y %H:%M:%S\", &time);\n \tchar message[2048];\n-\tvsprintf_s(message, format, args);\n+\tvsnprintf(message, 2048, format, args);\n \n \tif (m_logToConsole) std::cout << \"[\" << timeStr << \"] \" << message;\n \tmFile << \"[\" << timeStr << \"] \" << message;\n@@ -50,7 +43,7 @@ void dLogger::vLog(const char* format, va_list args) {\n \tchar timeStr[70];\n \tstrftime(timeStr, sizeof(timeStr), \"%d-%m-%y %H:%M:%S\", time);\n \tchar message[2048];\n-\tvsprintf(message, format, args);\n+\tvsnprintf(message, 2048, format, args);\n \n \tif (m_logToConsole) {\n \t\tfputs(\"[\", stdout);\n", "fix_pattern": "<pattern>: if a loop is used to calculate the length of a format string and its length is checked against a maximum size, replace it with a single call to vsnprintf that inherently manages string length and avoids unnecessary looping."}
{"number": 936, "change": "@@ -147,20 +147,11 @@ Mesh_sizing_field<Tr,B>::\n operator()(const Point_3& p, const Cell_handle& c) const  \n {  \n #ifdef CGAL_MESH_3_SIZING_FIELD_INEXACT_LOCATE  \n-  Cell_handle cell = tr_.inexact_locate(p,c);\n-\n-  const Point_3& p0 = cell->vertex(0)->point();\n-  const Point_3& p1 = cell->vertex(1)->point();\n-  const Point_3& p2 = cell->vertex(2)->point();\n-  const Point_3& p3 = cell->vertex(3)->point();\n-\n-  if(tr_.inexact_orientation(p0, p1, p2, p3) == NEGATIVE ||\n-     tr_.inexact_orientation(p0, p1, p2, p3) == NEGATIVE ||\n-     tr_.inexact_orientation(p0, p1, p2, p3) == NEGATIVE ||\n-     tr_.inexact_orientation(p0, p1, p2, p3) == NEGATIVE)\n-  {\n-    cell = tr_.locate(p, cell);\n-  }\n+  //use the inexact locate (much faster than locate) to get a hint\n+  //and then use locate to check whether p is really inside hint\n+  // if not, an exact locate will be performed\n+  Cell_handle hint = tr_.inexact_locate(p,c);\n+  const Cell_handle cell = tr_.locate(p, hint);\n #else\n   const Cell_handle cell = tr_.locate(p,c);\n #endif\n", "fix_pattern": "<pattern>: if multiple calls to an expensive function (tr_.inexact_orientation) are made with the same arguments, refactor to minimize the number of function calls by caching results or reorganizing logic to perform the orientation check more efficiently. In this case, replace the repeated calls to `inexact_orientation` with a single call and use its result for the logic flow. Additionally, if `inexact_locate` is significantly faster, use it as a hint for the next `locate` call to optimize performance."}
{"number": 939, "change": "@@ -240,8 +240,8 @@ ConVar filesystem_unbuffered_io( \"filesystem_unbuffered_io\", \"1\", 0, \"\" );\n #define UseUnbufferedIO() true\n #endif\n \n-ConVar filesystem_native( \"filesystem_native\", \"1\", 0, \"Use native FS or STDIO\" );\n-ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", IsX360() ? \"64\" : \"16\", 0, \"\" );\n+ConVar filesystem_native( \"filesystem_native\", \"0\", 0, \"Use native FS or STDIO\" );\n+ConVar filesystem_max_stdio_read( \"filesystem_max_stdio_read\", \"64\", 0, \"\" );\n ConVar filesystem_report_buffered_io( \"filesystem_report_buffered_io\", \"0\" );\n \n //-----------------------------------------------------------------------------\n@@ -417,7 +417,7 @@ FILE *CFileSystem_Stdio::FS_fopen( const char *filenameT, const char *options, u\n \n \tCBaseFileSystem::FixUpPath ( filenameT, filename, sizeof( filename ) );\n \n-#ifdef _WIN32\n+#if defined(_WIN32) && 0\n \tif ( CWin32ReadOnlyFile::CanOpen( filename, options ) )\n \t{\n \t\tpFile = CWin32ReadOnlyFile::FS_fopen( filename, options, size );\n", "fix_pattern": "<pattern>: if there are changes to configuration variables (ConVar) that affect performance, ensure the values are optimized for the specific platform or environment, such as setting \"filesystem_native\" to \"0\" to potentially favor the STDIO approach over native file system access for performance reasons."}
{"number": 942, "change": "@@ -136,19 +136,14 @@ void OpenGL::setupContext()\n \tstate.boundTextures.clear();\n \tstate.boundTextures.resize(maxTextureUnits, 0);\n \n-\tGLenum curgltextureunit;\n-\tglGetIntegerv(GL_ACTIVE_TEXTURE, (GLint *) &curgltextureunit);\n-\n-\tstate.curTextureUnit = (int) curgltextureunit - GL_TEXTURE0;\n-\n-\t// Retrieve currently bound textures for each texture unit.\n \tfor (int i = 0; i < (int) state.boundTextures.size(); i++)\n \t{\n \t\tglActiveTexture(GL_TEXTURE0 + i);\n-\t\tglGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint *) &state.boundTextures[i]);\n+\t\tglBindTexture(GL_TEXTURE_2D, 0);\n \t}\n \n-\tglActiveTexture(curgltextureunit);\n+\tglActiveTexture(GL_TEXTURE0);\n+\tstate.curTextureUnit = 0;\n \n \tcreateDefaultTexture();\n \n", "fix_pattern": "<pattern>: if OpenGL calls are used to query the current active texture unit and bound textures, replace the querying logic with direct calls to set the texture state, minimizing API calls and redundant state retrievals."}
{"number": 943, "change": "@@ -101,8 +101,15 @@ void Buffer::unmapStream()\n \t// \"orphan\" current buffer to avoid implicit synchronisation on the GPU:\n \t// http://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-AsynchronousBufferTransfers.pdf\n \tgl.bindBuffer(type, vbo);\n-\tglBufferData(target, (GLsizeiptr) getSize(), nullptr,    glusage);\n-\tglBufferData(target, (GLsizeiptr) getSize(), memory_map, glusage);\n+\tglBufferData(target, (GLsizeiptr) getSize(), nullptr, glusage);\n+\n+#if LOVE_WINDOWS\n+\t// TODO: Verify that this codepath is a useful optimization.\n+\tif (gl.getVendor() == OpenGL::VENDOR_INTEL)\n+\t\tglBufferData(target, (GLsizeiptr) getSize(), memory_map, glusage);\n+\telse\n+#endif\n+\t\tglBufferSubData(target, 0, (GLsizeiptr) getSize(), memory_map);\n }\n \n void Buffer::unmap()\n", "fix_pattern": "<pattern>: if glBufferData is called with a nullptr for the data parameter followed by another call with actual data, check the vendor and use glBufferSubData instead for the second call for better performance when applicable (especially for non-Intel vendors on Windows)."}
{"number": 945, "change": "@@ -66,7 +66,7 @@ namespace mapnik\n         if (!png_ptr) return;\n \n         // switch on optimization only if supported\n-#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)\n+#if defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_MMX_CODE_SUPPORTED)\n         png_uint_32 mask, flags;\n \n         flags = png_get_asm_flags(png_ptr);\n", "fix_pattern": "<pattern>: if an API directive checks for specific library versions or features, ensure that the check is using the correct defined macros for the intended assembly optimizations (i.e., update from PNG_ASSEMBLER_CODE_SUPPORTED to PNG_MMX_CODE_SUPPORTED)."}
{"number": 946, "change": "@@ -236,10 +236,11 @@ namespace Mantid\n \t\t\tQuat rot(unit,axis);\n \t\t\trot.GLMatrix(mat);\n \t\t\tglMultMatrixd(mat);\n-\t\t\tgluCylinder(qobj,radius,radius,height,10,5);\n-\t\t\tgluDisk(qobj,0,radius,10,1);\n+\t\t\tGLint nslices(10);\n+\t\t\tgluCylinder(qobj,radius,radius,height,nslices, 1);\n+\t\t\tgluDisk(qobj,0,radius,nslices, 1);\n \t\t\tglTranslated(0.0,0.0,height);\n-\t\t\tgluDisk(qobj,0,radius,10,1);\n+\t\t\tgluDisk(qobj,0,radius,nslices,1);\n \t\t\tglPopMatrix();\n \t\t}\n \t}\n", "fix_pattern": "<pattern>: if the same integer literal is repeatedly passed as an argument to OpenGL functions, store it in a variable to enhance readability and maintainability, while also potentially optimizing performance through reduced parsing overhead and avoiding repeated literal evaluations."}
{"number": 948, "change": "@@ -246,17 +246,23 @@ int main(int argc, char *argv[])\n    e_var /= (nsteps + 1);\n    double e_sd = sqrt(e_var);\n \n+   double e_loc_stats[2];\n+   double *e_stats = (myid == 0) ? new double[2 * num_procs] : (double*)NULL;\n+\n+   e_loc_stats[0] = e_mean;\n+   e_loc_stats[1] = e_sd;\n+   MPI_Gather(e_loc_stats, 2, MPI_DOUBLE, e_stats, 2, MPI_DOUBLE, 0, comm);\n+\n    if (myid == 0)\n    {\n-      cout << endl << \"Mean and standard deviation of the energy\" << endl;\n-   }\n-   for (int i = 0; i < num_procs; i++)\n-   {\n-      if (myid == i)\n+      cout << endl << \"Mean and standard deviation of the energy \"\n+           << \"for different initial conditions\" << endl;\n+      for (int i = 0; i < num_procs; i++)\n       {\n-         cout << myid << \": \" << e_mean << \"\\t\" << e_sd << endl;\n+         cout << i << \": \" << e_stats[2 * i + 0]\n+              << \"\\t\" << e_stats[2 * i + 1] << endl;\n       }\n-      MPI_Barrier(comm);\n+      delete [] e_stats;\n    }\n \n    // 9. Finalize the GnuPlot output\n", "fix_pattern": "<pattern>: if individual process statistics are printed one by one, replace the loop with a collective operation (MPI_Gather) to gather the statistics at the root process and print them from there, reducing the number of output operations and synchronizing data more efficiently."}
{"number": 949, "change": "@@ -155,10 +155,13 @@ inline BOOL Win32uiHostGlue::DynamicApplicationInit(const TCHAR *cmd, const TCHA\n     TCHAR err_buf[256];\n     // It's critical Python is loaded *and initialized* before we load win32ui\n     // as just loading win32ui will cause it to call into Python.\n-    const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n-    for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n-        wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n-        hModCore = LoadLibrary(fname);\n+    hModCore = GetModuleHandle(py_dll);  // Check if Python is already loaded\n+    if (hModCore == NULL) {\n+        const int ncandidates = sizeof(py_dll_candidates) / sizeof(py_dll_candidates[0]);\n+        for (int i = 0; i < ncandidates && hModCore == NULL; i++) {\n+            wsprintf(fname, _T(\"%s\\\\%s\\\\%s\"), app_dir, py_dll_candidates[i], py_dll);\n+            hModCore = LoadLibrary(fname);\n+        }\n     }\n     if (hModCore == NULL) {\n         wsprintf(err_buf, _T(\"The application can not locate %s (%d)\\n\"), py_dll, GetLastError());\n", "fix_pattern": "<pattern>: if loading a library using LoadLibrary, first check if the library is already loaded using GetModuleHandle to avoid unnecessary calls to LoadLibrary, which can improve performance by reducing the overhead of multiple library load attempts."}
{"number": 952, "change": "@@ -167,11 +167,7 @@ NvPairingManager::signMessage(const QByteArray& message)\n     EVP_MD_CTX *ctx = EVP_MD_CTX_create();\n     THROW_BAD_ALLOC_IF_NULL(ctx);\n \n-    const EVP_MD *md = EVP_get_digestbyname(\"SHA256\");\n-    THROW_BAD_ALLOC_IF_NULL(md);\n-\n-    EVP_DigestInit_ex(ctx, md, NULL);\n-    EVP_DigestSignInit(ctx, NULL, md, NULL, m_PrivateKey);\n+    EVP_DigestSignInit(ctx, NULL, EVP_sha256(), NULL, m_PrivateKey);\n     EVP_DigestSignUpdate(ctx, reinterpret_cast<unsigned char*>(const_cast<char*>(message.data())), message.length());\n \n     size_t signatureLength = 0;\n", "fix_pattern": "<pattern>: if a specific digest (like \"SHA256\") is requested using EVP_get_digestbyname, replace it with a direct call to EVP_sha256 for improved performance by avoiding string comparison and lookup overhead."}
{"number": 954, "change": "@@ -378,14 +378,8 @@ bool PlVkRenderer::initialize(PDECODER_PARAMETERS params)\n \n     pl_vk_inst_params vkInstParams = pl_vk_inst_default_params;\n     {\n-        bool ok;\n-        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\", &ok);\n-        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\", &ok);\n-#ifdef QT_DEBUG\n-        if (!ok) {\n-            vkInstParams.debug = true;\n-        }\n-#endif\n+        vkInstParams.debug_extra = !!qEnvironmentVariableIntValue(\"PLVK_DEBUG_EXTRA\");\n+        vkInstParams.debug = vkInstParams.debug_extra || !!qEnvironmentVariableIntValue(\"PLVK_DEBUG\");\n     }\n     vkInstParams.get_proc_addr = (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();\n     vkInstParams.extensions = instanceExtensions.data();\n", "fix_pattern": "<pattern>: if the second parameter of `qEnvironmentVariableIntValue` is not utilized, remove it to avoid unnecessary performance overhead associated with passing an unused pointer."}
{"number": 955, "change": "@@ -174,24 +174,14 @@ public:\n \t\tif (bHasMovementBase)\n \t\t{\n \t\t\tAr << ClientMovementBase;\n+\n+\t\t\tbool bValidName = ClientBaseBoneName != NAME_None;\n+\t\t\tAr.SerializeBits(&bValidName, 1);\n \n-\t\t\t// String replicating the FName, it doesn't automatically do this - I Checked\n-\t\t\tif (Ar.IsSaving())\n-\t\t\t{\n-\t\t\t\t// send by string\n-\t\t\t\tFString OutString = ClientBaseBoneName.GetPlainNameString();\n-\t\t\t\tint32 OutNumber = ClientBaseBoneName.GetNumber();\n-\t\t\t\tAr << OutString;\n-\t\t\t\tAr << OutNumber;\n-\t\t\t}\n-\t\t\telse if (Ar.IsLoading())\n-\t\t\t{\n-\t\t\t\t// replicated by string\n-\t\t\t\tFString InString;\n-\t\t\t\tint32 InNumber;\n-\t\t\t\tAr << InString;\n-\t\t\t\tAr << InNumber;\n-\t\t\t\tClientBaseBoneName = FName(*InString, InNumber);\n+\t\t\t// This saves 9 bits on average, we almost never have a valid bone name and default rep goes to 9 bits for hardcoded\n+\t\t\tif (bValidName)\n+\t\t\t{\n+\t\t\t\tAr << ClientBaseBoneName;\n \t\t\t}\n \t\t}\n \n", "fix_pattern": "<pattern>: if a complex structure (like FName) is being serialized with separate string and number components, check if a simpler representation can be used. If so, utilize bit serialization for optimal performance, particularly when the default state (like NAME_None) is common."}
{"number": 956, "change": "@@ -1133,13 +1133,14 @@ promise::Promise<Message*> ProtocolHandler::handleManagementMessage(\n \n void ProtocolHandler::fetchUserKeys(karere::Id userid)\n {\n-    mUserAttrCache.getAttr(userid, ::mega::MegaApi::USER_ATTR_ED25519_PUBLIC_KEY, nullptr, nullptr, false, mPh);\n-\n-    if (!previewMode())\n+    if (!isPublicChat())\n     {\n-        // preload keys for the new participant\n+        mUserAttrCache.getAttr(userid, ::mega::MegaApi::USER_ATTR_ED25519_PUBLIC_KEY, nullptr, nullptr);\n         mUserAttrCache.getAttr(userid, ::mega::MegaApi::USER_ATTR_CU25519_PUBLIC_KEY, nullptr, nullptr);\n     }\n+    // else (if chat is public) we don't need to fetch:\n+    //   - ATTR_CU25519_PUBLIC_KEY: as messages are encrypyted/decrypted with unified key\n+    //   - ATTR_ED25519_PUBLIC_KEY: as we don't verify signature for received messages if chat is public\n }\n \n //We should have already received and decrypted the key in advance\n", "fix_pattern": "<pattern>: if fetching user attributes is unnecessary in public chat scenarios, check the public chat status before calling `mUserAttrCache.getAttr()`, reducing the number of API calls made and improving performance by avoiding redundant data retrieval."}
{"number": 958, "change": "@@ -591,8 +591,6 @@ uint16_t RF24Network::read(RF24NetworkHeader& header,void* message, uint16_t max\n   uint16_t bufsize = 0;\n \n  #if defined (RF24_LINUX)\n-   if (available())\n-   {\n     RF24NetworkFrame frame = frame_queue.front();\n \n     // How much buffer size should we actually copy?\n@@ -606,10 +604,8 @@ uint16_t RF24Network::read(RF24NetworkHeader& header,void* message, uint16_t max\n     IF_SERIAL_DEBUG(printf_P(PSTR(\"%u: NET read %s\\n\\r\"),millis(),header.toString()));\n \n     frame_queue.pop();\n-  }\n+\n #else\n-  if (available())\n-  {\n \n \tmemcpy(&header,frame_queue,8);\n     memcpy(&bufsize,frame_queue+8,2);\n@@ -634,7 +630,7 @@ uint16_t RF24Network::read(RF24NetworkHeader& header,void* message, uint16_t max\n     #endif\n     memmove(frame_queue,frame_queue+bufsize+10+padding,sizeof(frame_queue)- bufsize);\n \t//IF_SERIAL_DEBUG(printf_P(PSTR(\"%lu: NET Received %s\\n\\r\"),millis(),header.toString()));\n-  }\n+\n #endif\n   return bufsize;\n }\n", "fix_pattern": "<pattern>: if the same check (in this case, `available()`) is performed multiple times consecutively, consolidate it to a single check to avoid redundant function calls and improve performance."}
{"number": 959, "change": "@@ -38,15 +38,15 @@ void UpdateDetector::versionCheck( Theme *theme )\n     QUrl url(\"http://download.owncloud.com/clientupdater.php\");\n     QString ver = QString(\"%1.%2.%3\").arg(MIRALL_VERSION_MAJOR).arg(MIRALL_VERSION_MINOR).arg(MIRALL_VERSION_MICRO);\n \n-    QString platform = QString::fromLocal8Bit(\"stranger\");\n+    QString platform = QLatin1String(\"stranger\");\n #ifdef Q_OS_LINUX\n-    platform = QString::fromLocal8Bit(\"linux\");\n+    platform = QLatin1String(\"linux\");\n #endif\n #ifdef Q_OS_WIN32\n-    platform = QString::fromLocal8Bit( \"win32\" );\n+    platform = QLatin1String( \"win32\" );\n #endif\n #ifdef Q_OS_MACOS\n-    platform = QString::fromLocal8Bit( \"macos\" );\n+    platform = QLatin1String( \"macos\" );\n #endif\n \n     url.addQueryItem( \"version\", ver );\n", "fix_pattern": "<pattern>: if QString::fromLocal8Bit is used with static strings, replace it with QLatin1String for better performance since QLatin1String is optimized for such use cases in the Qt framework."}
{"number": 961, "change": "@@ -2608,9 +2608,7 @@ std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pc\n \n std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct)\n {\n-    SOCKET socket;\n-    WITH_LOCK(requestor.cs_hSocket, socket = requestor.hSocket);\n-    auto local_socket_bytes = GetBindAddress(socket).GetAddrBytes();\n+    auto local_socket_bytes = requestor.addrBind.GetAddrBytes();\n     uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)\n         .Write(requestor.addr.GetNetwork())\n         .Write(local_socket_bytes.data(), local_socket_bytes.size())\n", "fix_pattern": "<pattern>: if a socket's address bytes are being fetched inside a locked region due to a mutex, and the address can be accessed directly from an object instead of fetching it via the socket, replace the socket call with a direct access to the address to avoid unnecessary locking overhead."}
{"number": 962, "change": "@@ -8,6 +8,7 @@\n  * */\n \n #include <sys/time.h>\n+#include <unistd.h>\n \n #include <charconv>\n \n@@ -73,7 +74,7 @@ int main(int argc, char *argv[]) {\n     }\n \n     // We will build dmenu out of commands found in $PATH if nothing has been passed by stdin\n-    dmenu_run = isatty(fileno(stdin)) == 1;\n+    dmenu_run = isatty(STDIN_FILENO) == 1;\n \n     if (input.cmdOptionExists(\"-run\")){\n         dmenu_run = true;\n", "fix_pattern": "<pattern>: if the fileno() function is used to get the file descriptor from stdin to check for interactivity, replace it with the predefined constant STDIN_FILENO for better readability and potentially improved performance."}
{"number": 963, "change": "@@ -218,8 +218,6 @@ void table_t::stop()\n         time(&start);\n \n         fprintf(stderr, \"Sorting data and creating indexes for %s\\n\", name.c_str());\n-        pgsql_exec_simple(sql_conn, PGRES_COMMAND_OK, (fmt(\"ANALYZE %1%\") % name).str());\n-        fprintf(stderr, \"Analyzing %s finished\\n\", name.c_str());\n \n         // Special handling for empty geometries because geohash chokes on\n         // empty geometries on postgis 1.5.\n", "fix_pattern": "<pattern>: if a call to `pgsql_exec_simple` is immediately followed by a logging statement using `fprintf`, consider using a logging mechanism that combines both actions to reduce overhead from executing two separate functions in tight succession."}
{"number": 965, "change": "@@ -349,9 +349,16 @@ void SDLRenderTarget::blitRenderTarget(RenderTarget *s, int x, int y, int w, int\n \tSDLRenderTarget *src = dynamic_cast<SDLRenderTarget *>(s);\n \tassert(src);\n \n-\t// TODO: evil use of internal SDL api\n+\tSDL_Renderer *renderer = SDL_CreateSoftwareRenderer(surface);\n+\tassert(renderer);\n+\tSDL_Texture *tex = SDL_CreateTextureFromSurface(renderer, src->surface);\n+\tassert(tex);\n+\n \tSDL_Rect r; r.x = x; r.y = y; r.w = w; r.h = h;\n-\tSDL_SoftStretch(src->surface, 0, surface, &r);\n+\tSDL_RenderCopy(renderer, tex, nullptr, &r);\n+\n+\tSDL_DestroyTexture(tex);\n+\tSDL_DestroyRenderer(renderer);\n }\n \n RenderTarget *SDLBackend::newRenderTarget(unsigned int w, unsigned int h) {\n", "fix_pattern": "<pattern>: if the SDL_SoftStretch function is used for scaling surfaces, refactor the code to create a software renderer, create a texture from the source surface, and use SDL_RenderCopy to perform the copy operation, as it can provide better performance through hardware acceleration or more optimized rendering."}
{"number": 969, "change": "@@ -1100,9 +1100,11 @@ void Loader::fillEvaluationObject(const ScopeChain::Ptr &scope, LanguageObject *\n void Loader::fillEvaluationObjectBasics(const ScopeChain::Ptr &scopeChain, LanguageObject *object, EvaluationObject *evaluationObject)\n {\n     // append the property declarations\n-    foreach (const PropertyDeclaration &pd, object->propertyDeclarations)\n-        if (!evaluationObject->scope->declarations.contains(pd.name))\n-            evaluationObject->scope->declarations.insert(pd.name, pd);\n+    foreach (const PropertyDeclaration &pd, object->propertyDeclarations) {\n+        PropertyDeclaration &scopePropertyDeclaration = evaluationObject->scope->declarations[pd.name];\n+        if (!scopePropertyDeclaration.isValid())\n+            scopePropertyDeclaration = pd;\n+    }\n \n     applyFunctions(&m_engine, object, evaluationObject, scopeChain);\n     applyBindings(object, scopeChain);\n", "fix_pattern": "<pattern>: if multiple calls to check for existence and then insert into a map are detected, refactor the code to access the map once and modify the existing value if it is invalid, which reduces the overhead of multiple lookups."}
{"number": 970, "change": "@@ -219,16 +219,8 @@ bool QDirSortItemComparator::operator()(const QDirSortItem &n1, const QDirSortIt\n \n     switch (sortBy) {\n       case QDir::Time: {\n-        QDateTime firstModified = f1->item.lastModified();\n-        QDateTime secondModified = f2->item.lastModified();\n-\n-        // QDateTime by default will do all sorts of conversions on these to\n-        // find timezones, which is incredibly expensive. As we aren't\n-        // presenting these to the user, we don't care (at all) about the\n-        // local timezone, so force them to UTC to avoid that conversion.\n-        firstModified.setTimeZone(QTimeZone::UTC);\n-        secondModified.setTimeZone(QTimeZone::UTC);\n-\n+        const QDateTime firstModified = f1->item.lastModified(QTimeZone::UTC);\n+        const QDateTime secondModified = f2->item.lastModified(QTimeZone::UTC);\n         r = firstModified.msecsTo(secondModified);\n         break;\n       }\n", "fix_pattern": "<pattern>: if QDateTime is being created and then modified to avoid expensive timezone conversions, replace with a direct call to the method that allows for timezone specification to skip unnecessary conversions."}
{"number": 971, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if string join operations are performed with regular char or QString, replace them with QLatin1Char for improved performance when dealing with Latin-1 encoded strings, as it avoids unnecessary conversions."}
{"number": 973, "change": "@@ -1,5 +1,6 @@\n #include \"TextureGL.h\"\n #include <cassert>\n+#include \"utils.h\"\n \n namespace Graphics {\n \n@@ -109,16 +110,18 @@ TextureGL::~TextureGL()\n void TextureGL::Update(const void *data, const vector2f &dataSize, ImageFormat format, ImageType type)\n {\n \tglEnable(m_target);\n+\tglBindTexture(m_target, m_texture);\n \n \tswitch (m_target) {\n \t\tcase GL_TEXTURE_2D:\n-\t\t\tglTexImage2D(m_target, 0, GLTextureFormat(GetDescriptor().format), dataSize.x, dataSize.y, 0, GLImageFormat(format), GLImageType(type), data);\n+\t\t\tglTexSubImage2D(m_target, 0, 0, 0, dataSize.x, dataSize.y, GLImageFormat(format), GLImageType(type), data);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tassert(0);\n \t}\n \n+\tglBindTexture(m_target, 0);\n \tglDisable(m_target);\n }\n \n", "fix_pattern": "<pattern>: if a texture is being created or updated with glTexImage2D, replace it with glBindTexture and glTexSubImage2D to optimize the texture upload process, as the latter can update an existing texture without recreating it, reducing overhead and potentially improving performance."}
{"number": 974, "change": "@@ -32,14 +32,16 @@ bool header_match( const string & env_var_name,\n                    const string & header_name,\n                    const HTTPRequest & saved_response )\n {\n+    const char * const env_value = getenv( env_var_name.c_str() );\n+\n     /* case 1: neither header exists (OK) */\n-    if ( (not getenv( env_var_name.c_str() )) and (not saved_response.has_header( header_name )) ) {\n+    if ( (not env_value) and (not saved_response.has_header( header_name )) ) {\n         return true;\n     }\n \n     /* case 2: headers both exist (OK if values match) */\n-    if ( getenv( env_var_name.c_str() ) and saved_response.has_header( header_name ) ) {\n-        return saved_response.get_header_value( header_name ) == string( getenv( env_var_name.c_str() ) );\n+    if ( env_value and saved_response.has_header( header_name ) ) {\n+        return saved_response.get_header_value( header_name ) == string( env_value );\n     }\n \n     /* case 3: one exists but the other doesn't (failure) */\n", "fix_pattern": "<pattern>: if getenv() is called multiple times with the same variable, store the result in a local variable to avoid redundant calls and improve performance."}
{"number": 975, "change": "@@ -153,7 +153,7 @@ void CSettings::AddHowToHandleSetting ()\n \tAddHandler(Rdb_SMM_Protect,         new CSettingTypeRomDatabase(\"SMM-Protect\",false));\n \tAddHandler(Rdb_SMM_ValidFunc,       new CSettingTypeRomDatabase(\"SMM-FUNC\",true));\n \tAddHandler(Rdb_GameCheatFix,        new CSettingTypeRomDatabaseIndex(\"Cheat\",\"\",\"\"));\n-\tAddHandler(Rdb_ViRefreshRate,       new CSettingTypeRomDatabase(\"ViRefresh\",2200));\n+\tAddHandler(Rdb_ViRefreshRate,       new CSettingTypeRomDatabase(\"ViRefresh\",1500));\n \tAddHandler(Rdb_AiCountPerBytes,     new CSettingTypeRomDatabase(\"AiCountPerBytes\",500));\n \t\n \tAddHandler(Game_IniKey,             new CSettingTypeTempString(\"\"));\n", "fix_pattern": "<pattern>: if a fixed value is passed to the constructor of CSettingTypeRomDatabase, update it to use a more optimal value based on performance analysis or specific requirements. In this case, the value has been changed from 2200 to 1500, suggesting a tuning for performance."}
{"number": 976, "change": "@@ -631,7 +631,8 @@ QXcbConnection::QXcbConnection(QXcbNativeInterface *nativeInterface, bool canGra\n     initializeXRender();\n #if defined(XCB_USE_XINPUT2)\n     m_xi2Enabled = false;\n-    initializeXInput2();\n+    if (!qEnvironmentVariableIsSet(\"QT_XCB_NO_XI2\"))\n+        initializeXInput2();\n #endif\n     initializeXShape();\n     initializeXKB();\n", "fix_pattern": "<pattern>: if the method initializeXInput2() is called unconditionally, modify the code to check the environment variable \"QT_XCB_NO_XI2\" to conditionally invoke initializeXInput2() only when the variable is not set, preventing unnecessary calls and improving performance."}
{"number": 977, "change": "@@ -760,10 +760,8 @@ static QRegion scaleRegion(const QRegion &region, qreal factor)\n {\n     if (region.isEmpty() || qFuzzyCompare(factor, qreal(1)))\n         return region;\n-    if (region.rectCount() == 1)\n-        return QRegion(scaleRect(QRectF(region.boundingRect()), factor).toRect());\n     QRegion result;\n-    foreach (const QRect &rect, region.rects())\n+    for (const QRect &rect : region)\n         result += QRectF(QPointF(rect.topLeft()) * factor, QSizeF(rect.size() * factor)).toRect();\n     return result;\n }\n", "fix_pattern": "<pattern>: if a method is checking the count of rectangles in a QRegion and then iterating through them, replace the check and foreach with a range-based for loop directly on the QRegion to enhance readability and potentially improve performance by avoiding an extra function call."}
{"number": 978, "change": "@@ -2214,10 +2214,12 @@ bool QQuickWindowPrivate::deliverUpdatedTouchPoints(QQuickPointerTouchEvent *eve\n {\n     const auto grabbers = event->grabbers();\n     for (auto grabber : grabbers) {\n-        if (QQuickItem *grabberItem = qmlobject_cast<QQuickItem *>(grabber))\n-            deliverMatchingPointsToItem(grabberItem, event, hasFiltered);\n-        else if (QQuickPointerHandler *grabberHandler = qmlobject_cast<QQuickPointerHandler *>(grabber))\n-            deliverMatchingPointsToItem(grabberHandler->target(), event, hasFiltered);\n+        // The grabber is guaranteed to be either an item or a handler, but\n+        // we need the item in order to call deliverMatchingPointsToItem().\n+        QQuickItem *receiver = qmlobject_cast<QQuickItem *>(grabber);\n+        if (!receiver)\n+            receiver = static_cast<QQuickPointerHandler *>(grabber)->target();\n+        deliverMatchingPointsToItem(receiver, event, hasFiltered);\n     }\n \n     return false;\n", "fix_pattern": "<pattern>: if there are multiple casts and subsequent calls to the same function, consolidate the logic to eliminate the redundancy and improve readability, ensuring the correct type is resolved first before the function call."}
{"number": 979, "change": "@@ -1078,11 +1078,12 @@ void QIcon::addFile(const QString &fileName, const QSize &size, Mode mode, State\n     if (!d) {\n \n         QFileInfo info(fileName);\n-        QIconEngine *engine = iconEngineFromSuffix(fileName, info.suffix());\n+        QString suffix = info.suffix();\n #ifndef QT_NO_MIMETYPE\n-        if (!engine)\n-            engine = iconEngineFromSuffix(fileName, QMimeDatabase().mimeTypeForFile(info).preferredSuffix());\n+        if (suffix.isEmpty())\n+            suffix = QMimeDatabase().mimeTypeForFile(info).preferredSuffix(); // determination from contents\n #endif // !QT_NO_MIMETYPE\n+        QIconEngine *engine = iconEngineFromSuffix(fileName, suffix);\n         d = new QIconPrivate(engine ? engine : new QPixmapIconEngine);\n     }\n \n", "fix_pattern": "<pattern>: if an icon engine is retrieved using a suffix derived from the filename that depends on file info, first check if the suffix is empty and retrieve it conditionally only once, storing it in a variable to avoid redundant calls for the same operation."}
{"number": 982, "change": "@@ -2860,7 +2860,7 @@ Q_WIDGETS_EXPORT void _q_requireVersion(int argc, char *argv[], QAnyStringView r\n                                     .arg(qAppName(), required.toString(), current.toString());\n     QMessageBox::critical(nullptr, QApplication::tr(\"Incompatible Qt Library Error\"),\n                           message, QMessageBox::Abort);\n-    qFatal(\"%s\", qPrintable(message));\n+    qFatal(\"%ls\", qUtf16Printable(message));\n }\n \n #if QT_DEPRECATED_SINCE(6,2)\n", "fix_pattern": "<pattern>: if an API method is using qPrintable to convert a QString to a const char* for a function that expects a UTF-8 string, replace it with qUtf16Printable to provide a const char16_t* instead, ensuring proper character encoding support."}
{"number": 984, "change": "@@ -859,9 +859,9 @@ void GLPaintContour::finalize_geometry()\n \n     if (!this->contour_indices.empty()) {\n         glsafe(::glGenBuffers(1, &this->m_contour_EBO_id));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, this->m_contour_EBO_id));\n-        glsafe(::glBufferData(GL_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n-        glsafe(::glBindBuffer(GL_ARRAY_BUFFER, 0));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this->m_contour_EBO_id));\n+        glsafe(::glBufferData(GL_ELEMENT_ARRAY_BUFFER, this->contour_indices.size() * sizeof(unsigned int), this->contour_indices.data(), GL_STATIC_DRAW));\n+        glsafe(::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));\n         this->contour_indices.clear();\n     }\n }\n", "fix_pattern": "<pattern>: if the OpenGL API is being used to bind and buffer a data array, ensure to use the appropriate buffer type that matches the intended usage; replace `GL_ARRAY_BUFFER` with `GL_ELEMENT_ARRAY_BUFFER` when dealing with element indices to enhance performance and correctness."}
{"number": 985, "change": "@@ -172,7 +172,7 @@ QEvdevTouchScreenHandler::QEvdevTouchScreenHandler(const QString &specification,\n {\n     setObjectName(QLatin1String(\"Evdev Touch Handler\"));\n \n-    bool printDeviceInfo = qgetenv(\"QT_QPA_EVDEV_DEBUG\").toInt();\n+    bool printDeviceInfo = qEnvironmentVariableIntValue(\"QT_QPA_EVDEV_DEBUG\");\n \n     // only the first device argument is used for now\n     QString spec = QString::fromLocal8Bit(qgetenv(\"QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS\"));\n", "fix_pattern": "<pattern>: replace the combination of qgetenv and QString::toInt to read an environment variable as an integer directly using qEnvironmentVariableIntValue for improved performance."}
{"number": 986, "change": "@@ -461,7 +461,7 @@ void QPainterPrivate::draw_helper(const QPainterPath &originalPath, DrawOperatio\n     p.drawPath(originalPath);\n \n #ifndef QT_NO_DEBUG\n-    static bool do_fallback_overlay = qgetenv(\"QT_PAINT_FALLBACK_OVERLAY\").size() > 0;\n+    static bool do_fallback_overlay = !qEnvironmentVariableIsEmpty(\"QT_PAINT_FALLBACK_OVERLAY\");\n     if (do_fallback_overlay) {\n         QImage block(8, 8, QImage::Format_ARGB32_Premultiplied);\n         QPainter pt(&block);\n", "fix_pattern": "<pattern>: if checking for the existence of an environment variable using qgetenv and then calling size() on its return is done, replace it with directly using qEnvironmentVariableIsEmpty for better performance and clarity."}
{"number": 987, "change": "@@ -152,11 +152,8 @@ QModelIndex QIdentityProxyModel::index(int row, int column, const QModelIndex& p\n {\n     Q_ASSERT(parent.isValid() ? parent.model() == this : true);\n     Q_D(const QIdentityProxyModel);\n-    if (!hasIndex(row, column, parent))\n-        return QModelIndex();\n     const QModelIndex sourceParent = mapToSource(parent);\n     const QModelIndex sourceIndex = d->model->index(row, column, sourceParent);\n-    Q_ASSERT(sourceIndex.isValid());\n     return mapFromSource(sourceIndex);\n }\n \n", "fix_pattern": "<pattern>: if the method is checking for a valid QModelIndex by calling sourceIndex.isValid() and there's an early exit when the index does not exist, ensure that the check for hasIndex() is optimized or rearranged to minimize unnecessary calls or checks that lead to early returns. Since there are no actual code changes to analyze, it suggests that the handling of index validity should prioritize efficiency, but more context would be necessary for specific patterns."}
{"number": 988, "change": "@@ -562,9 +562,9 @@ void DapEngine::updateItem(const QString &iname)\n void DapEngine::reexpandItems(const QSet<QString> &inames)\n {\n     QSet<QString> expandedInames = inames;\n-    const QList<QString> &watcherNames = watchHandler()->watcherNames().keys();\n-    for (const QString &inames : watcherNames)\n-        expandedInames.insert(watchHandler()->watcherName(inames));\n+    const auto &watcherNames = watchHandler()->watcherNames();\n+    for (auto it = watcherNames.begin(); it != watcherNames.end(); ++it)\n+        expandedInames.insert(watchHandler()->watcherName(it.key()));\n \n     QList<QString> inamesVector = expandedInames.values();\n     inamesVector.sort();\n", "fix_pattern": "<pattern>: if a QList's keys() method is used to retrieve keys, then refactor the code to operate directly on the QList to reduce unnecessary intermediate copies and improve iterator access for performance."}
{"number": 989, "change": "@@ -197,11 +197,11 @@ QMakeGlobals::ArgumentReturn QMakeGlobals::addCommandLineArguments(\n void QMakeGlobals::commitCommandLineArguments(QMakeCmdLineParserState &state)\n {\n     if (!state.preconfigs.isEmpty())\n-        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(fL1S(\" \")));\n-    precmds = state.precmds.join(fL1S(\"\\n\"));\n+        state.precmds << (fL1S(\"CONFIG += \") + state.preconfigs.join(QLatin1Char(' ')));\n+    precmds = state.precmds.join(QLatin1Char('\\n'));\n     if (!state.postconfigs.isEmpty())\n-        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(fL1S(\" \")));\n-    postcmds = state.postcmds.join(fL1S(\"\\n\"));\n+        state.postcmds << (fL1S(\"CONFIG += \") + state.postconfigs.join(QLatin1Char(' ')));\n+    postcmds = state.postcmds.join(QLatin1Char('\\n'));\n \n     if (xqmakespec.isEmpty())\n         xqmakespec = qmakespec;\n", "fix_pattern": "<pattern>: if the code is using QString to perform string joining and manipulation, replace character literals with QLatin1Char() to optimize performance and reduce overhead in character operations within QString methods."}
{"number": 992, "change": "@@ -184,7 +184,7 @@ void QXcbConnection::xi2Select(xcb_window_t window)\n     mask.mask_len = sizeof(bitMask);\n     mask.mask = xiBitMask;\n     // Enable each touchscreen\n-    foreach (XInput2DeviceData *dev, m_touchDevices.values()) {\n+    foreach (XInput2DeviceData *dev, m_touchDevices) {\n         mask.deviceid = dev->xiDeviceInfo->deviceid;\n         Status result = XISelectEvents(xDisplay, window, &mask, 1);\n         // If we have XInput >= 2.2 and successfully enable a touchscreen, then\n", "fix_pattern": "<pattern>: if accessing elements of a QList via the values() method results in performance overhead, replace it by directly iterating over the QList to avoid unnecessary copying of the underlying data."}
{"number": 995, "change": "@@ -2289,21 +2289,12 @@ TClass *TClass::GetBaseClass(const char *classname)\n \n    if (!fClassInfo) return 0;\n \n-   TObjLink *lnk = GetListOfBases() ? fBase->FirstLink() : 0;\n+   // Make sure we deal with possible aliases, we could also have normalized\n+   // the name.\n+   TClass *search = TClass::GetClass(classname);\n \n-   // otherwise look at inheritance tree\n-   while (lnk) {\n-      TClass     *c, *c1;\n-      TBaseClass *base = (TBaseClass*) lnk->GetObject();\n-      c = base->GetClassPointer();\n-      if (c) {\n-         if (strcmp(c->GetName(), classname) == 0) return c;\n-         c1 = c->GetBaseClass(classname);\n-         if (c1) return c1;\n-      }\n-      lnk = lnk->Next();\n-   }\n-   return 0;\n+   if (search) return GetBaseClass(search);\n+   else return 0;\n }\n \n //______________________________________________________________________________\n", "fix_pattern": "<pattern>: instead of iterating through a linked list to find class information, use a direct lookup via TClass::GetClass for better performance and efficiency in accessing the desired base class."}
{"number": 996, "change": "@@ -1,4 +1,4 @@\n-// @(#)root/base:$Name:  $:$Id: TDatime.cxx,v 1.10 2005/06/23 10:49:19 rdm Exp $\n+// @(#)root/base:$Name:  $:$Id: TDatime.cxx,v 1.11 2005/06/23 13:33:47 rdm Exp $\n // Author: Rene Brun   05/01/95\n \n /*************************************************************************\n@@ -251,13 +251,14 @@ void TDatime::Set()\n \n #ifndef WIN32\n    time_t tloc   = time(0);\n-   struct tm *tp = localtime(&tloc);\n-   UInt_t year   = tp->tm_year;\n-   UInt_t month  = tp->tm_mon + 1;\n-   UInt_t day    = tp->tm_mday;\n-   UInt_t hour   = tp->tm_hour;\n-   UInt_t min    = tp->tm_min;\n-   UInt_t sec    = tp->tm_sec;\n+   struct tm tp;\n+   localtime_r(&tloc, &tp);\n+   UInt_t year   = tp.tm_year;\n+   UInt_t month  = tp.tm_mon + 1;\n+   UInt_t day    = tp.tm_mday;\n+   UInt_t hour   = tp.tm_hour;\n+   UInt_t min    = tp.tm_min;\n+   UInt_t sec    = tp.tm_sec;\n #else\n    SYSTEMTIME tp;\n    GetLocalTime(&tp);\n", "fix_pattern": "<pattern>: if the code uses the non-thread-safe version of localtime, replace it with the thread-safe version localtime_r to avoid race conditions and improve performance in multi-threaded environments."}
{"number": 997, "change": "@@ -253,11 +253,6 @@ void OpenGLShaderRenderer::renderCrossair(const Common::Point crossairPosition)\n \t_triangleShader->setUniform(\"useStipple\", false);\n \t_triangleShader->setUniform(\"mvpMatrix\", identity);\n \n-\tglMatrixMode(GL_PROJECTION);\n-\tglLoadIdentity();\n-\tglOrtho(0, _screenW, _screenH, 0, 0, 1);\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglLoadIdentity();\n \tglEnable(GL_BLEND);\n \tglBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ZERO);\n \n", "fix_pattern": "<pattern>: if multiple OpenGL matrix operations are called in a sequence, it's beneficial to group them under a single matrix mode and minimize state changes to improve performance."}
{"number": 998, "change": "@@ -116,11 +116,7 @@ void Mesh::render() const {\n void Mesh::render(uint32_t mode, int count, int offset) const {\n     glBindVertexArray(_vao);\n     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _ibo);\n-\n     glDrawElements(mode, count, GL_UNSIGNED_SHORT, reinterpret_cast<void *>(offset));\n-\n-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n-    glBindVertexArray(0);\n }\n \n void Mesh::computeAABB() {\n", "fix_pattern": "<pattern>: if glBindBuffer and glBindVertexArray are being called with the argument 0, it may indicate an intention to unbind or reset state. This can be simplified or optimized by considering whether these calls are necessary, or if their logic can be handled more effectively within the rendering pipeline. If performance is a priority, it may be beneficial to review and restrict unnecessary state changes."}
{"number": 1000, "change": "@@ -194,7 +194,7 @@ inline void GlTexture::Upload(\n     GLenum data_format, GLenum data_type\n ) {\n     Bind();\n-    glTexSubImage2D(GL_TEXTURE_2D,0,0,0,width,height,data_format,data_type,data);\n+    glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, data_format, data_type, data);\n     CheckGlDieOnError();\n }\n \n", "fix_pattern": "<pattern>: when updating texture data for the whole texture, use glTexImage2D instead of glTexSubImage2D for improved performance, as the former can handle the entire texture in one call versus modifying sub-regions."}
{"number": 1002, "change": "@@ -32,14 +32,7 @@ GlobeGPS::GlobeGPS(QWidget* parent) : MarbleWidget(parent), loadedDives(0), edit\n \tQStringList list = mtm.mapThemeIds();\n \tQString  subsurfaceDataPath;\n \tQDir marble;\n-\tbool foundGoogleMap = false;\n-\tQ_FOREACH(const QString& theme, list){\n-\t\tif (theme == \"earth/googlesat/googlesat.dgml\"){\n-\t\t\tfoundGoogleMap = true;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tif (!foundGoogleMap) {\n+\tif (!list.contains(\"earth/googlesat/googlesat.dgml\")) {\n \t\tsubsurfaceDataPath = getSubsurfaceDataPath(\"marbledata\");\n \t\tif (subsurfaceDataPath != \"\") {\n \t\t\tMarbleDirs::setMarbleDataPath(subsurfaceDataPath);\n", "fix_pattern": "<pattern>: if a loop is used to check for the existence of an item in a QStringList, replace it with the QStringList::contains() method for better performance and readability."}
{"number": 1004, "change": "@@ -15,9 +15,8 @@ TextEmbedder::TextEmbedder(const std::string& model_name) {\n         if(provider == \"CUDAExecutionProvider\") {\n \n             // check existence of so file\n-            void* handle = dlopen(\"libonnxruntime_providers_cuda.so\", RTLD_NOW | RTLD_GLOBAL);\n+            void* handle = dlopen(\"libonnxruntime_providers_cuda.so\", RTLD_LAZY);\n             if(!handle) {\n-                LOG(ERROR) << \"Cannot load libonnxruntime_providers_cuda.so\";\n                 continue;\n             }\n \n", "fix_pattern": "<pattern>: if dynamic library loading is done using `dlopen`, change the flag from `RTLD_NOW` to `RTLD_LAZY` to improve performance by deferring resolution of undefined symbols until they are actually needed."}
{"number": 1007, "change": "@@ -178,12 +178,12 @@ DatabaseCommand_Resolve::fullTextResolve( DatabaseImpl* lib )\n     QList< QPair<int, float> > trackPairs = lib->search( m_query );\n     QList< QPair<int, float> > albumPairs = lib->searchAlbum( m_query, 20 );\n \n+    TomahawkSqlQuery query = lib->newquery();\n+    query.prepare( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = ?\" );\n+\n     foreach ( const scorepair_t& albumPair, albumPairs )\n     {\n-        TomahawkSqlQuery query = lib->newquery();\n-\n-        QString sql = QString( \"SELECT album.name, artist.id, artist.name FROM album, artist WHERE artist.id = album.artist AND album.id = %1\" ).arg( albumPair.first );\n-        query.prepare( sql );\n+        query.bindValue( 0, albumPair.first );\n         query.exec();\n \n         QList<Tomahawk::album_ptr> albumList;\n", "fix_pattern": "<pattern>: if constructing a SQL query with QString::arg is used for value substitution, replace it with parameterized queries using bindValue to improve performance and security (prevent SQL injection)."}
{"number": 1009, "change": "@@ -151,11 +151,8 @@ OpenGLDisplay::~OpenGLDisplay()\n void OpenGLDisplay::EnableOpenGL()\n {\n \tPIXELFORMATDESCRIPTOR pfd;\n-\tint format;\n-\n \t// get the device context (DC)\n \thDC = GetDC( theApp.m_pMainWnd->GetSafeHwnd() );\n-\n \t// set the pixel format for the DC\n \tZeroMemory( &pfd, sizeof( pfd ) );\n \tpfd.nSize = sizeof( pfd );\n@@ -165,12 +162,8 @@ void OpenGLDisplay::EnableOpenGL()\n \tpfd.cColorBits = 24;\n \tpfd.cDepthBits = 16;\n \tpfd.iLayerType = PFD_MAIN_PLANE;\n-\tformat = ChoosePixelFormat( hDC, &pfd );\n-\tSetPixelFormat( hDC, format, &pfd );\n-\n-\t// create and enable the render context (RC)\n-\thRC = wglCreateContext( hDC );\n-\twglMakeCurrent( hDC, hRC );\n+    SetPixelFormat (GetDC (theApp.m_pMainWnd->GetSafeHwnd()), ChoosePixelFormat ( GetDC (theApp.m_pMainWnd->GetSafeHwnd()), &pfd), &pfd);\n+    wglMakeCurrent (GetDC (theApp.m_pMainWnd->GetSafeHwnd()), wglCreateContext(GetDC (theApp.m_pMainWnd->GetSafeHwnd()) ) );\n }\n \n void OpenGLDisplay::DisableOpenGL()\n", "fix_pattern": "<pattern>: if multiple calls to GetDC are made to retrieve the device context, eliminate redundant calls by storing the result of GetDC in a variable, thus reducing overhead and improving performance."}
{"number": 1010, "change": "@@ -89,9 +89,6 @@ void vw_Start2DMode(GLdouble zNear, GLdouble zFar)\n  */\n void vw_End2DMode()\n {\n-\tglMatrixMode(GL_MODELVIEW);\n-\tglPopMatrix();\n-\n \t// we don't switch to 0 unit, in 2D mode only 0 unit should be used\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n@@ -100,6 +97,7 @@ void vw_End2DMode()\n \tglPopMatrix();\n \n \tglMatrixMode(GL_MODELVIEW);\n+\tglPopMatrix();\n \n \tglPopAttrib();\n }\n", "fix_pattern": "<pattern>: if glMatrixMode(GL_MODELVIEW) is called immediately before glPopMatrix(), it can be removed to avoid unnecessary state changes, as glPopMatrix() resets the matrix without needing to set the mode first."}
{"number": 1011, "change": "@@ -2317,7 +2317,8 @@ bool wxMSWDCImpl::DoStretchBlit(wxCoord xdest, wxCoord ydest,\n         // than the wxWidgets fall-back implementation. So we need\n         // to be able to switch this on and off at runtime.\n #if wxUSE_SYSTEM_OPTIONS\n-        if (wxSystemOptions::GetOptionInt(wxT(\"no-maskblt\")) == 0)\n+        static bool s_maskBltAllowed = wxSystemOptions::GetOptionInt(\"no-maskblt\") == 0;\n+        if ( s_maskBltAllowed )\n #endif\n         {\n             if ( dstWidth == srcWidth && dstHeight == srcHeight )\n", "fix_pattern": "<pattern>: if a method retrieves a configuration option multiple times (especially within a function), cache the result in a static variable to avoid repeated calls and improve performance."}
{"number": 1012, "change": "@@ -269,7 +269,6 @@ wxString wxStaticTextBase::Ellipsize(const wxString& label) const\n     }\n \n     wxClientDC dc(const_cast<wxStaticTextBase*>(this));\n-    dc.SetFont(GetFont());\n \n     wxEllipsizeMode mode;\n     if ( HasFlag(wxST_ELLIPSIZE_START) )\n", "fix_pattern": "<pattern>: if a font is retrieved from a window using wxWindow::GetFont() and immediately set on a device context using wxClientDC::SetFont(), consider caching the font rather than retrieving it each time to reduce the overhead of function calls and possible duplicate calculations."}
{"number": 1014, "change": "@@ -567,12 +567,10 @@ bool wxICOResourceHandler::LoadIcon(wxIcon *icon,\n \n wxSize wxGetHiconSize(HICON WXUNUSED_IN_WINCE(hicon))\n {\n-    // default icon size on this hardware\n-    // usually 32x32 but can be other (smaller) on pocket devices\n-    wxSize size(::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON));\n+    wxSize size;\n \n #ifndef __WXWINCE__\n-    if (hicon)\n+    if ( hicon )\n     {\n         ICONINFO info;\n         if ( !::GetIconInfo(hicon, &info) )\n@@ -596,7 +594,14 @@ wxSize wxGetHiconSize(HICON WXUNUSED_IN_WINCE(hicon))\n                 ::DeleteObject(info.hbmColor);\n         }\n     }\n-#endif\n+\n+    if ( !size.x )\n+#endif // !__WXWINCE__\n+    {\n+        // use default icon size on this hardware\n+        size.x = ::GetSystemMetrics(SM_CXICON);\n+        size.y = ::GetSystemMetrics(SM_CYICON);\n+    }\n \n     return size;\n }\n", "fix_pattern": "<pattern>: if a direct call to ::GetSystemMetrics is made unconditionally for default icon size, refactor the code to check a condition (in this case, whether hicon is valid) before attempting to retrieve the system metrics, which avoids unnecessary calls."}
{"number": 1015, "change": "@@ -2331,8 +2331,10 @@ void wxListMainWindow::SendNotify( size_t line,\n                                    wxEventType command,\n                                    const wxPoint& point )\n {\n-    wxListEvent le( command, GetParent()->GetId() );\n-    le.SetEventObject( GetParent() );\n+    wxGenericListCtrl* const listctrl = GetListCtrl();\n+\n+    wxListEvent le( command, listctrl->GetId() );\n+    le.SetEventObject( listctrl );\n \n     le.m_item.m_itemId =\n     le.m_itemIndex = line;\n@@ -2349,12 +2351,12 @@ void wxListMainWindow::SendNotify( size_t line,\n \n     // provide information about the (first column of the) item in the event if\n     // we have a valid item and any columns at all\n-    if ( line != (size_t)-1 && GetListCtrl()->GetColumnCount() )\n+    if ( line != (size_t)-1 && listctrl->GetColumnCount() )\n     {\n         GetLine(line)->GetItem( 0, le.m_item );\n     }\n \n-    GetParent()->GetEventHandler()->ProcessEvent( le );\n+    listctrl->GetEventHandler()->ProcessEvent( le );\n }\n \n bool wxListMainWindow::ChangeCurrentWithoutEvent(size_t current)\n", "fix_pattern": "<pattern>: if there are multiple calls to GetListCtrl() and GetParent() that access the same object repeatedly, store the results in a local variable to minimize the number of method calls, improving performance by reducing overhead and potential cache misses."}
{"number": 1017, "change": "@@ -6,6 +6,10 @@\n \n #include \"private.h\"\n \n+#ifdef __x86_64__\n+#include <x86intrin.h>\n+#endif\n+\n zx_ticks_t _zx_ticks_get(void) {\n #if __aarch64__\n     // read the virtual counter\n@@ -13,10 +17,7 @@ zx_ticks_t _zx_ticks_get(void) {\n     __asm__ volatile(\"mrs %0, cntvct_el0\" : \"=r\" (ticks));\n     return ticks;\n #elif __x86_64__\n-    uint32_t ticks_low;\n-    uint32_t ticks_high;\n-    __asm__ volatile(\"rdtsc\" : \"=a\" (ticks_low), \"=d\" (ticks_high));\n-    return ((zx_ticks_t)ticks_high << 32) | ticks_low;\n+    return __rdtsc();\n #else\n #error Unsupported architecture\n #endif\n", "fix_pattern": "<pattern>: if the code directly reads timestamps using inline assembly instructions (like rdtsc), replace it with the standardized API provided by `<x86intrin.h>` to enhance readability, maintainability, and potentially leverage compiler optimizations."}
{"number": 1018, "change": "@@ -602,12 +602,20 @@ void Database::PurgeExpiredInstances()\n \t\treturn;\n \t}\n \n+\tstd::vector<std::string> instance_ids;\n \tfor (auto row = results.begin(); row != results.end(); ++row) {\n-\t\tquery = StringFormat(\"DELETE FROM instance_list WHERE id=%u\", atoi(row[0]));\n-\t\tQueryDatabase(query);\n-\n-\t\tDeleteInstance(atoi(row[0]));\n+\t\tinstance_ids.emplace_back(row[0]);\n \t}\n+\n+\tstd::string imploded_instance_ids = implode(\",\", instance_ids);\n+\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM instance_list_player WHERE id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM respawn_times WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"DELETE FROM spawn_condition_values WHERE instance_id IN ({})\", imploded_instance_ids));\n+\tQueryDatabase(fmt::format(\"UPDATE character_corpses SET is_buried = 1, instance_id = 0 WHERE instance_id IN ({})\", imploded_instance_ids));\n+\n+\t\n }\n \n void Database::SetInstanceDuration(uint16 instance_id, uint32 new_duration)\n", "fix_pattern": "<pattern>: if multiple deletes and an update are performed on the same instance_id, consolidate them into a single query for better performance by using a formatted string that incorporates instance_ids as a comma-separated list. This reduces the number of separate database calls and can improve overall efficiency."}
{"number": 1019, "change": "@@ -177,7 +177,12 @@ void DressUp::onChanged(const App::Property* prop)\n             BaseFeature.setValue (Base.getValue());\n         }\n     } else if (prop == &Shape || prop == &SupportTransform) {\n-        if (!isRestoring() && !getDocument()->isPerformingTransaction()) {\n+        // This is an expensive operation and to avoid to perform it unnecessarily it's not sufficient\n+        // to check for the 'Restore' flag of the dress-up feature because at that time it's already reset.\n+        // Instead the 'Restore' flag of the document must be checked.\n+        // For more details see: https://forum.freecadweb.org/viewtopic.php?f=3&t=43799 (and issue 4276)\n+        if (!getDocument()->testStatus(App::Document::Restoring) &&\n+            !getDocument()->isPerformingTransaction()) {\n             Part::TopoShape s;\n             auto base = Base::freecad_dynamic_cast<FeatureAddSub>(getBaseObject(true));\n             if(!base) {\n", "fix_pattern": "<pattern>: if an expensive operation is detected that relies on the state of a status flag, replace the check that only considers a local state with a check that references the document's status, minimizing unnecessary operations and improving performance."}
{"number": 1020, "change": "@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,\n         return false;\n     }\n \n-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of\n-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */\n-\n-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),\n-                               descr.attributes() | JSPROP_PERMANENT,\n-                               JS_PROPERTYOP_GETTER(descr.getter()),\n-                               JS_PROPERTYOP_SETTER(descr.setter()))) {\n+    descr.setConfigurable(false);\n+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {\n         gjs_debug(GJS_DEBUG_IMPORTER,\n                   \"Failed to redefine attributes to seal '%s' in importer\",\n                   name);\n", "fix_pattern": "<pattern>: if a property descriptor is being modified before being passed to the JS_DefinePropertyById function, and to simplify the call, set the configurable attribute directly on the descriptor and pass it without individually specifying getter, setter, and attributes. This reduces the overhead of constructing the property descriptor with multiple parameters and improves readability."}
{"number": 1021, "change": "@@ -23,6 +23,7 @@\n #include <map>\n #include <tuple>\n #include <chrono>\n+#include <cassert>\n \n #include \"async_handler.h\"\n #include \"cache.h\"\n@@ -274,13 +275,13 @@ namespace {\n \t\t\treturn LoadDummyBitmap<T>(s.directory, f);\n \t\t}\n \n+#ifndef NDEBUG\n \t\t// Test if the file was requested asynchronously before.\n \t\t// If not the file can't be expected to exist -> bug.\n-\t\tFileRequestAsync* request = AsyncHandler::RequestFile(s.directory, f);\n-\t\tif (!request->IsReady()) {\n-\t\t\tOutput::Debug(\"BUG: File Not Requested: %s/%s\", s.directory, f.c_str());\n-\t\t\treturn BitmapRef();\n-\t\t}\n+\t\t// This test is expensive and turned off in release builds.\n+\t\tauto* req = AsyncHandler::RequestFile(s.directory, f);\n+\t\tassert(req != nullptr && req->IsReady());\n+#endif\n \n \t\tBitmapRef ret = LoadBitmap(s.directory, f, transparent, Bitmap::Flag_ReadOnly | (\n \t\t\t\t\t\t\t\t\t\t T == Material::Chipset? Bitmap::Flag_Chipset:\n", "fix_pattern": "<pattern>: if a check for readiness is performed during debugging, replace the runtime check with an assert to avoid performance overhead in release builds while still ensuring the condition is verified during development."}
{"number": 1025, "change": "@@ -518,7 +518,8 @@ namespace spades {\n \n #ifndef __sun\n \t\t\t\t\tif (rtype == RendererType::GL) {\n-\t\t\t\t\t\tif (r_vsync != 0 && SDL_GL_SetSwapInterval(r_vsync) != 0) {\n+\t\t\t\t\t\tint vsync = r_vsync;\n+\t\t\t\t\t\tif (vsync != 0 && SDL_GL_SetSwapInterval(vsync) != 0) {\n \t\t\t\t\t\t\tSPRaise(\"SDL_GL_SetSwapInterval failed: %s\", SDL_GetError());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n", "fix_pattern": "<pattern>: if a value is read from a variable multiple times for performance-sensitive code, store the value in a local variable to avoid redundant accesses."}
{"number": 1026, "change": "@@ -7482,8 +7482,7 @@ namespace Breeze\n     //____________________________________________________________________\n     bool Style::showIconsInMenuItems() const\n     {\n-        const KConfigGroup g(KSharedConfig::openConfig(), \"KDE\");\n-        return g.readEntry(\"ShowIconsInMenuItems\", true);\n+        return !QApplication::testAttribute(Qt::AA_DontShowIconsInMenus);\n     }\n \n     //____________________________________________________________________\n", "fix_pattern": "<pattern>: if retrieving configuration from KConfig is replaced by a direct query of QApplication attributes for performance optimization, indicating a shift from a potentially disk I/O bound operation to a faster in-memory attribute check."}
{"number": 1028, "change": "@@ -118,7 +118,8 @@ KFileItemModelRolesUpdater::KFileItemModelRolesUpdater(KFileItemModel *model, QO\n     m_directoryContentsCounter = new KDirectoryContentsCounter(m_model, this);\n     connect(m_directoryContentsCounter, &KDirectoryContentsCounter::result, this, &KFileItemModelRolesUpdater::slotDirectoryContentsCountReceived);\n \n-    const auto plugins = KPluginMetaData::findPlugins(QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\"));\n+    const QString pluginNamespace = QStringLiteral(\"kf\" QT_STRINGIFY(QT_VERSION_MAJOR)) + QStringLiteral(\"/overlayicon\");\n+    const auto plugins = KPluginMetaData::findPlugins(pluginNamespace, {}, KPluginMetaData::AllowEmptyMetaData);\n     for (const KPluginMetaData &data : plugins) {\n         auto instance = QPluginLoader(data.fileName()).instance();\n         auto plugin = qobject_cast<KOverlayIconPlugin *>(instance);\n", "fix_pattern": "<pattern>: if constructing a namespace string for KPluginMetaData::findPlugins involves repeated string manipulations, refactor the creation of the string into a separate variable to enhance readability and performance, while ensuring consistent use of the API."}
{"number": 1029, "change": "@@ -172,7 +172,8 @@ void SignalHistoryModel::onObjectAdded(QObject* object)\n   Q_ASSERT(thread() == QThread::currentThread());\n \n   // blacklist event dispatchers\n-  if (QString(object->metaObject()->className()).startsWith(\"QPAEventDispatcher\"))\n+  if (qstrncmp(object->metaObject()->className(), \"QPAEventDispatcher\", 18) == 0\n+    || qstrncmp(object->metaObject()->className(), \"QGuiEventDispatcher\", 19) == 0)\n     return;\n \n   beginInsertRows(QModelIndex(), m_tracedObjects.size(), m_tracedObjects.size());\n", "fix_pattern": "<pattern>: if a QString method is used to check for a prefix, replace it with qstrncmp for improved performance by avoiding QString overhead, especially in scenarios where only a few characters of comparison are needed."}
{"number": 1035, "change": "@@ -274,8 +274,13 @@ HRESULT ParaEngine::CViewport::Render(double dTimeDelta, int nPipelineOrder)\n \t\t\tif (m_pRenderTarget)\n \t\t\t{\n #ifdef USE_DIRECTX_RENDERER\n-\t\t\t\t// for multiple render targets (/shader 2 of fancy block rendering) to work, the render target must be the same size of the back buffer. \n-\t\t\t\tm_pRenderTarget->SetRenderTargetSize(Vector2((float)(CGlobals::GetDirectXEngine().GetBackBufferWidth()), (float)(CGlobals::GetDirectXEngine().GetBackBufferHeight())));\n+\t\t\t\tif (CGlobals::GetSceneState()->IsDeferredShading()) {\n+\t\t\t\t\t// for multiple render targets (/shader 2 of fancy block rendering) to work, the render target must be the same size of the back buffer. \n+\t\t\t\t\t// if we are using deferred shading, we must use the back buffer size.\n+\t\t\t\t\tm_pRenderTarget->SetRenderTargetSize(Vector2((float)(CGlobals::GetDirectXEngine().GetBackBufferWidth()), (float)(CGlobals::GetDirectXEngine().GetBackBufferHeight())));\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t\tm_pRenderTarget->SetRenderTargetSize(Vector2((float)GetWidth(), (float)GetHeight()));\n #else\n \t\t\t\tm_pRenderTarget->SetRenderTargetSize(Vector2((float)GetWidth(), (float)GetHeight()));\n #endif\n", "fix_pattern": "<pattern>: if the render target size is set based on specific conditions (such as deferred shading), ensure that the size is only set to the back buffer dimensions when required; otherwise, use the current size to avoid unnecessary API calls that could affect performance."}
{"number": 1040, "change": "@@ -30,7 +30,7 @@\n #include \"vtkIdTypeArray.h\"\n #include \"vtkObjectFactory.h\"\n \n-vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18\");\n+vtkCxxRevisionMacro(vtkDataSetAttributes, \"1.18.6.1\");\n vtkStandardNewMacro(vtkDataSetAttributes);\n \n //--------------------------------------------------------------------------\n@@ -1470,16 +1470,16 @@ void vtkDataSetAttributes::CopyData(vtkDataSetAttributes::FieldList& list,\n                                     vtkDataSetAttributes* fromDSA,\n                                     int idx, vtkIdType fromId, vtkIdType toId)\n {\n-  vtkDataArray *fromDA;\n-  vtkDataArray *toDA;\n+  vtkAbstractArray *fromDA;\n+  vtkAbstractArray *toDA;\n   \n   int i;\n   for (i=0; i < list.NumberOfFields; i++)\n     {\n     if ( list.FieldIndices[i] >= 0 )\n       {\n-      toDA = this->GetArray(list.FieldIndices[i]);\n-      fromDA = fromDSA->GetArray(list.DSAIndices[idx][i]);\n+      toDA = this->GetAbstractArray(list.FieldIndices[i]);\n+      fromDA = fromDSA->GetAbstractArray(list.DSAIndices[idx][i]);\n       this->CopyTuple(fromDA, toDA, fromId, toId);\n       }\n     }\n", "fix_pattern": "<pattern>: if a specific API (vtkDataArray*) is replaced by a more generalized one (vtkAbstractArray*), it may indicate a move to more versatile or polymorphic data handling, which can improve performance through more efficient memory management and reduced type-checking overhead when handling datasets."}
{"number": 1041, "change": "@@ -57,7 +57,7 @@ extern \"C\" vtkglX::__GLXextFuncPtr glXGetProcAddressARB(const GLubyte *);\n // GLU is currently not linked in VTK.  We do not support it here.\n #define GLU_SUPPORTED   0\n \n-vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.29\");\n+vtkCxxRevisionMacro(vtkOpenGLExtensionManager, \"1.30\");\n vtkStandardNewMacro(vtkOpenGLExtensionManager);\n \n namespace vtkgl\n@@ -180,7 +180,7 @@ int vtkOpenGLExtensionManager::ExtensionSupported(const char *name)\n   // Workaround for a bug on renderer string=\"Quadro4 900 XGL/AGP/SSE2\"\n   // version string=\"1.5.8 NVIDIA 96.43.01\" or \"1.5.6 NVIDIA 87.56\"\n   // The driver reports it supports 1.5 but the 1.4 core promoted extension\n-  // GL_EXT_blend_func_separate is implemented in software.\n+  // GL_EXT_blend_func_separate is implemented in software (poor performance).\n   // All the NV2x chipsets are probably affected. NV2x chipsets are used\n   // in GeForce4 and Quadro4.\n   // It will make this method return false with \"GL_VERSION_1_4\" and true\n", "fix_pattern": "<pattern>: If a revision macro is updated to reflect a change in performance characteristics (from version 1.29 to 1.30) and includes a comment indicating poor performance related to a feature, then document the revision change alongside a performance note to provide context for why the change is notable."}
{"number": 1043, "change": "@@ -90,7 +90,7 @@ namespace rwe\n \n         glGenerateMipmap(GL_TEXTURE_2D);\n \n-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if the texture magnification filter could impact performance, and a performance improvement can be achieved by changing the filter from GL_LINEAR to GL_NEAREST, then update the parameter to use GL_NEAREST for better performance in scenarios where linear filtering is not necessary."}
{"number": 1044, "change": "@@ -453,8 +453,8 @@ Plasma::Types::ItemStatus AppletInterface::status() const\n \n int AppletInterface::screen() const\n {\n-    if (applet()->containment()) {\n-        return applet()->containment()->screen();\n+    if (Plasma::Containment* c = applet()->containment()) {\n+        return c->screen();\n     }\n \n     return -1;\n", "fix_pattern": "<pattern>: if an API method is called multiple times for the same pointer, store the pointer in a local variable before invoking methods on it to avoid repeated dereferencing for potential performance gains."}
{"number": 1048, "change": "@@ -403,9 +403,6 @@ void CAIRO_GAL::DrawPolygon( const std::deque<VECTOR2D>& aPointList )\n         }\n     }\n \n-    cairo_set_source_rgba( cairoImage, fillColor.r, fillColor.g, fillColor.b, fillColor.a );\n-    cairo_fill_preserve( cairoImage );\n-\n     isElementAdded = true;\n }\n \n", "fix_pattern": "<pattern>: NA"}
{"number": 1051, "change": "@@ -247,9 +247,24 @@ std::shared_ptr<SHAPE_SEGMENT> BOARD_ITEM::GetEffectiveHoleShape() const\n \n FOOTPRINT* BOARD_ITEM::GetParentFootprint() const\n {\n+    // EDA_ITEM::IsType is too slow here.\n+    auto isContainer = []( BOARD_ITEM_CONTAINER* aTest )\n+    {\n+        switch( aTest->Type() )\n+        {\n+        case PCB_GROUP_T:\n+        case PCB_GENERATOR_T:\n+        case PCB_TABLE_T:\n+            return true;\n+\n+        default:\n+            return false;\n+        }\n+    };\n+\n     BOARD_ITEM_CONTAINER* ancestor = GetParent();\n \n-    while( ancestor && ancestor->IsType( { PCB_GROUP_T, PCB_GENERATOR_T, PCB_TABLE_T } ) )\n+    while( ancestor && isContainer( ancestor ) )\n         ancestor = ancestor->GetParent();\n \n     if( ancestor && ancestor->Type() == PCB_FOOTPRINT_T )\n", "fix_pattern": "<pattern>: if a slow API call is detected within a loop (specifically, a method like EDA_ITEM::IsType), replace it with a faster alternative by implementing a custom lambda function to check types efficiently."}
{"number": 1052, "change": "@@ -64,7 +64,7 @@\n #define VTK_PV_ANIMATION_GROUP \"animateable\"\n \n vtkStandardNewMacro(vtkPVAnimationManager);\n-vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.47\");\n+vtkCxxRevisionMacro(vtkPVAnimationManager, \"1.48\");\n vtkCxxSetObjectMacro(vtkPVAnimationManager, HorizantalParent, vtkKWWidget);\n vtkCxxSetObjectMacro(vtkPVAnimationManager, VerticalParent, vtkKWWidget);\n //*****************************************************************************\n@@ -205,7 +205,6 @@ void vtkPVAnimationManager::Create(vtkKWApplication* app, const char* )\n \n   this->ActiveTrackSelector->SetParent(\n     this->VAnimationInterface->GetSelectorFrame());\n-  this->ActiveTrackSelector->SetAnimationManager(this);\n   this->ActiveTrackSelector->Create(app, \"-relief flat\");\n   this->Script(\"pack %s -anchor n -side top -expand t -fill both\",\n     this->ActiveTrackSelector->GetWidgetName());\n", "fix_pattern": "<pattern>: if the vtkCxxRevisionMacro is updated to a new version number without changing any other logic or behavior in the code, correctly increment the versioning to reflect updates, indicating a potential change in functionality or fixes within the class."}
{"number": 1055, "change": "@@ -1374,7 +1374,14 @@ std::tuple<NvrtcFunction, std::string, std::vector<char>> getCompiledKernel(\n     bool return_compiled_binary) {\n   FUSER_PERF_SCOPE(\"executor_utils::NVRTC\");\n \n-  at::cuda::jit::initializeCudaContext();\n+  int device = 0;\n+  cudaGetDevice(&device);\n+  if (!at::detail::getCUDAHooks().hasPrimaryContext(device)) {\n+    // CUDA>=12 creates a context when cudaSetDevice is called. However, before\n+    // cu12, that context is not necessarily created. In that case, we create\n+    // one here implicitly. See https://github.com/NVIDIA/Fuser/issues/429\n+    cudaFree(nullptr);\n+  }\n \n   const auto prop = at::cuda::getCurrentDeviceProperties();\n \n", "fix_pattern": "<pattern>: if at::cuda::jit::initializeCudaContext() is called to initialize the CUDA context, replace it with a check for the existing primary context and conditionally call cudaFree(nullptr) if it does not exist, improving performance by avoiding unnecessary context initialization."}
{"number": 1056, "change": "@@ -50,22 +50,15 @@ void dirvec_sort(struct dirvec *dv)\n \n struct directory *dirvec_find(const struct dirvec *dv, const char *path)\n {\n-\tchar *base;\n \tint i;\n-\tstruct directory *ret = NULL;\n-\n-\tbase = g_path_get_basename(path);\n \n \tdb_lock();\n \tfor (i = dv->nr; --i >= 0; )\n-\t\tif (!strcmp(directory_get_name(dv->base[i]), base)) {\n-\t\t\tret = dv->base[i];\n-\t\t\tbreak;\n-\t\t}\n+\t\tif (!strcmp(directory_get_name(dv->base[i]), path))\n+\t\t\treturn dv->base[i];\n \tdb_unlock();\n \n-\tg_free(base);\n-\treturn ret;\n+\treturn NULL;\n }\n \n int dirvec_delete(struct dirvec *dv, struct directory *del)\n", "fix_pattern": "<pattern>: if a temporary variable is used to hold the result of g_path_get_basename(path) only for comparison purposes, remove the unnecessary allocation of the temporary variable and directly compare the directory name with the original path instead."}
{"number": 1057, "change": "@@ -77,17 +77,16 @@ class InjectionBootstrapper final : private OculusEndFrameHook,\n   void SetD3DFlags(IDXGISwapChain* swapChain) {\n     dprint(\"Detected DXGI frame...\");\n \n-    winrt::com_ptr<ID3D11Device> d3d11;\n-    swapChain->GetDevice(IID_PPV_ARGS(d3d11.put()));\n-    if (d3d11) {\n+    winrt::com_ptr<IUnknown> device;\n+    swapChain->GetDevice(IID_PPV_ARGS(device.put()));\n+\n+    if (device.try_as<ID3D11Device>()) {\n       dprint(\"... found D3D11\");\n       mFlags |= FLAG_D3D11;\n       return;\n     }\n \n-    winrt::com_ptr<ID3D12Device> d3d12;\n-    swapChain->GetDevice(IID_PPV_ARGS(d3d12.put()));\n-    if (d3d12) {\n+    if (device.try_as<ID3D12Device>()) {\n       dprint(\"... found D3D12\");\n       mFlags |= FLAG_D3D12;\n       return;\n", "fix_pattern": "<pattern>: if multiple calls are made to `swapChain->GetDevice` to retrieve different device types, consolidate the calls by first retrieving the device as a generic `IUnknown` and then using `try_as<T>()` to conditionally convert to the specific device types, thereby reducing the number of API calls made."}
{"number": 1061, "change": "@@ -478,7 +478,6 @@ int doIOForInterfaces(void)\n \tfd_set rfds;\n \tfd_set wfds;\n \tfd_set efds;\n-\tstruct timeval tv, *tvp = NULL;\n \tint i;\n \tint selret;\n \tint fdmax;\n@@ -492,7 +491,7 @@ int doIOForInterfaces(void)\n \n \t\tregistered_IO_add_fds(&fdmax, &rfds, &wfds, &efds);\n \n-\t\tselret = select(fdmax + 1, &rfds, &wfds, &efds, tvp);\n+\t\tselret = select(fdmax + 1, &rfds, &wfds, &efds, NULL);\n \n \t\tif (selret < 0 && errno == EINTR)\n \t\t\tbreak;\n@@ -525,9 +524,7 @@ int doIOForInterfaces(void)\n \t\t\t}\n \t\t}\n \n-\t\ttv.tv_sec = 0;\n-\t\ttv.tv_usec = 0;\n-\t\ttvp = &tv;\n+\t\tbreak;\n \t}\n \n \treturn 1;\n", "fix_pattern": "<pattern>: if a select call is made with a timeout that is always set to zero, replace the timeout argument with NULL to indicate that the call should block until an event occurs, thereby potentially improving performance by avoiding unnecessary setup of the timeval structure."}
{"number": 1063, "change": "@@ -478,8 +478,7 @@ bool Engine::InitSDL()\n \n     SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n     SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);\n-    //SDL_GL_SetAttribute( SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG ); // May be a performance booster in *nix?\n-    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_COMPATIBILITY);\n+    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n     SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n \n     mWindow = SDL_CreateWindow(ALIVE_VERSION_NAME_STR,\n", "fix_pattern": "<pattern>: if the OpenGL context profile mask is set to compatibility, replace it with core profile to potentially enhance performance by utilizing modern OpenGL features and optimizations."}
{"number": 1064, "change": "@@ -58,15 +58,17 @@\n static int\n fd_mask_flags(int fd, int and_mask, int xor_mask)\n {\n-\tint ret;\n-\n \tassert(fd >= 0);\n \n-\tret = fcntl(fd, F_GETFD, 0);\n-\tif (ret < 0)\n-\t\treturn ret;\n+\tconst int old_flags = fcntl(fd, F_GETFD, 0);\n+\tif (old_flags < 0)\n+\t\treturn old_flags;\n+\n+\tconst int new_flags = (old_flags & and_mask) ^ xor_mask;\n+\tif (new_flags == old_flags)\n+\t\treturn old_flags;\n \n-\treturn fcntl(fd, F_SETFD, (ret & and_mask) ^ xor_mask);\n+\treturn fcntl(fd, F_SETFD, new_flags);\n }\n \n #endif /* !WIN32 */\n", "fix_pattern": "<pattern>: if multiple calls to fcntl are made to get and set file descriptor flags, combine them to reduce the number of system calls and avoid unnecessary operations when the new flags are equal to the old flags."}
{"number": 1067, "change": "@@ -373,15 +373,25 @@ int main(int argc, char *argv[])\n     unsigned int win_height = 1;\n \n     char const* dev_video = \"/dev/video0\";\n+    mir_eglapp_bool ultrafast = 0;\n     struct mir_eglapp_arg custom_args[] =\n     {\n         {\"-d <path>\", \"=\", &dev_video, \"Path to camera device\"},\n+        {\"-u\", \"!\", &ultrafast, \"Ultra fast mode (low resolution)\"},\n         {NULL, NULL, NULL, NULL},\n     };\n     if (!mir_eglapp_init(argc, argv, &win_width, &win_height, custom_args))\n         return 1;\n \n-    Camera *cam = open_camera(dev_video, camera_pref_resolution, 1);\n+    // By default we prefer high resolution and low CPU usage but if you\n+    // ask for ultrafast mode expect low resultion and high CPU usage...\n+    enum CameraPref pref = camera_pref_resolution;\n+    if (ultrafast)\n+    {\n+        pref = camera_pref_speed;\n+        mir_surface_set_swapinterval(mir_eglapp_native_surface(), 0);\n+    }\n+    Camera *cam = open_camera(dev_video, pref, 1);\n     if (!cam)\n     {\n         fprintf(stderr, \"Failed to set up camera device\\n\");\n", "fix_pattern": "<pattern>: if an \"ultrafast\" mode is requested, switch from a preferred resolution setting for camera initialization to a speed-focused setting to optimize performance for low-latency scenarios, thereby potentially enhancing frame rates at the cost of resolution quality."}
{"number": 1070, "change": "@@ -20,6 +20,8 @@\n #include \"paddle/fluid/imperative/infer_shape_context.h\"\n #include \"paddle/fluid/imperative/infer_var_type_context.h\"\n \n+DECLARE_bool(use_mkldnn);\n+\n namespace paddle {\n namespace imperative {\n \n@@ -91,8 +93,10 @@ PreparedOp PrepareOpImpl(const NameVarMap<VarType>& ins,\n   // MKLDNN variant of code reads attributes in some of GetKernelTypeForVar and\n   // GetKernelType functions, so we need to copy the attributes there.\n   // Const qualifier of Attrs had to be discarded to overwrite it.\n-  auto& mutable_op_attrs = const_cast<framework::AttributeMap&>(op.Attrs());\n-  mutable_op_attrs = attrs;\n+  if (FLAGS_use_mkldnn) {\n+    auto& mutable_op_attrs = const_cast<framework::AttributeMap&>(op.Attrs());\n+    mutable_op_attrs = attrs;\n+  }\n #endif\n   auto expected_kernel_key =\n       op.GetExpectedKernelType(DygraphExecutionContext<VarType>(\n", "fix_pattern": "<pattern>: if an operation involving mutable attributes is conditionally executed based on a flag, check if the flag can optimize the operation's execution path, thereby avoiding unnecessary overhead in cases where the flag is set to false."}
{"number": 1072, "change": "@@ -180,11 +180,8 @@ DOM::ExceptionOr<void> XMLHttpRequest::send()\n \n     if (should_enforce_same_origin_policy && !m_window->associated_document().origin().is_same(request_url_origin)) {\n         dbgln(\"XHR failed to load: Same-Origin Policy violation: {} may not load {}\", m_window->associated_document().url(), request_url);\n-        auto weak_this = make_weak_ptr();\n-        if (!weak_this)\n-            return {};\n-        const_cast<XMLHttpRequest&>(*weak_this).set_ready_state(ReadyState::Done);\n-        const_cast<XMLHttpRequest&>(*weak_this).dispatch_event(DOM::Event::create(HTML::EventNames::error));\n+        set_ready_state(ReadyState::Done);\n+        dispatch_event(DOM::Event::create(HTML::EventNames::error));\n         return {};\n     }\n \n", "fix_pattern": "<pattern>: if a weak pointer is used solely to perform operations on an object, replace the use of weak pointers and const_cast with direct method calls to improve performance and simplify the code."}
{"number": 1073, "change": "@@ -1072,13 +1072,13 @@ static void propagate_overflow_to_viewport(Element& root_element, Layout::Viewpo\n \n void Document::update_layout()\n {\n-    if (!is_active())\n+    auto navigable = this->navigable();\n+    if (!navigable || navigable->active_document() != this)\n         return;\n \n     // NOTE: If our parent document needs a relayout, we must do that *first*.\n     //       This is necessary as the parent layout may cause our viewport to change.\n-    auto navigable = this->navigable();\n-    if (navigable && navigable->container())\n+    if (navigable->container())\n         navigable->container()->document().update_layout();\n \n     update_style();\n@@ -1090,11 +1090,8 @@ void Document::update_layout()\n     if (m_created_for_appropriate_template_contents)\n         return;\n \n-    if (!navigable)\n-        return;\n-\n     auto* document_element = this->document_element();\n-    auto viewport_rect = this->viewport_rect();\n+    auto viewport_rect = navigable->viewport_rect();\n \n     if (!m_layout_root) {\n         Layout::TreeBuilder tree_builder;\n", "fix_pattern": "<pattern>: if a method checks for activity on a navigable object and retrieves its viewport rectangle, consolidate the checks to ensure that the navigable object is queried only once, reducing potential redundant calls and improving performance."}
{"number": 1077, "change": "@@ -13,7 +13,10 @@ Desktop::Desktop( const sf::FloatRect& viewport ) :\n }\n \n Desktop::Desktop( const sf::Window& window ) :\n-\tm_view( sf::FloatRect( 0.f, 0.f, static_cast<float>( window.GetWidth() ), static_cast<float>( window.GetHeight() ) ) )\n+\tm_view( sf::FloatRect( 0.f, 0.f, static_cast<float>( window.GetWidth() ), static_cast<float>( window.GetHeight() ) ) ),\n+\tm_engine( 0 ),\n+\tm_children_size( 0 ),\n+\tm_skip_refresh( false )\n {\n }\n \n", "fix_pattern": "<pattern>: NA"}
{"number": 1078, "change": "@@ -45,11 +45,18 @@ ErrorOr<int> serenity_main(Main::Arguments arguments)\n \n     TRY(Core::System::pledge(\"stdio rpath exec\"));\n \n-    Vector<String> exec_environment_strings;\n     Vector<StringView> exec_environment;\n-    if (auto* term = getenv(\"TERM\")) {\n-        exec_environment_strings.append(String::formatted(\"TERM={}\", term));\n-        exec_environment.append(exec_environment_strings.last());\n+    for (size_t i = 0; environ[i]; ++i) {\n+        StringView env_view { environ[i] };\n+        auto maybe_needle = env_view.find('=');\n+\n+        if (!maybe_needle.has_value())\n+            continue;\n+\n+        if (env_view.substring_view(0, maybe_needle.value()) != \"TERM\"sv)\n+            continue;\n+\n+        exec_environment.append(env_view);\n     }\n \n     Vector<String> exec_arguments;\n", "fix_pattern": "<pattern>: if the code checks for a specific environment variable using getenv, refactor it to iterate through the `environ` array for potentially better performance and to handle cases where the environment variable may not exist or might be defined differently. This avoids the overhead of a string formatting operation unless necessary."}
{"number": 1082, "change": "@@ -76,7 +76,7 @@ static int newPage(const char *name, int level, int width, int height, int count\n \tglTexImage2D(GL_TEXTURE_2D, level, wz_texture_compression, width, height, 0,\n \t             GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n \tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n-\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n+\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n \tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n", "fix_pattern": "<pattern>: if a texture filtering parameter is set using glTexParameteri(), consider switching from GL_LINEAR_MIPMAP_LINEAR to GL_NEAREST_MIPMAP_LINEAR to potentially improve performance due to the reduced computational cost of nearest filtering compared to linear filtering."}
{"number": 1083, "change": "@@ -180,12 +180,18 @@ double getThreadTime() {\n \t\treturn 0.0;\n \treturn info.user_time.seconds + info.user_time.microseconds * 1e-6;\n #elif defined ARCH_WIN\n-\tFILETIME creationTime;\n-\tFILETIME exitTime;\n-\tFILETIME kernelTime;\n-\tFILETIME userTime;\n-\tGetThreadTimes(GetCurrentThread(), &creationTime, &exitTime, &kernelTime, &userTime);\n-\treturn ((((uint64_t) userTime.dwHighDateTime) << 32) + userTime.dwLowDateTime) * 1e-7;\n+\t// FILETIME creationTime;\n+\t// FILETIME exitTime;\n+\t// FILETIME kernelTime;\n+\t// FILETIME userTime;\n+\t// GetThreadTimes(GetCurrentThread(), &creationTime, &exitTime, &kernelTime, &userTime);\n+\t// return ((uint64_t(userTime.dwHighDateTime) << 32) + userTime.dwLowDateTime) * 1e-7;\n+\n+\tuint64_t cycles;\n+\tQueryThreadCycleTime(GetCurrentThread(), &cycles);\n+\t// HACK Assume that the RDTSC Time-Step Counter instruction is fixed at 2.5GHz. This should only be within a factor of 2 on all PCs.\n+\tconst double freq = 2.5e9;\n+\treturn (double) cycles / freq;\n #endif\n }\n \n", "fix_pattern": "<pattern>: if measuring thread execution time using GetThreadTimes, replace it with QueryThreadCycleTime for improved performance by obtaining cycle counts directly, avoiding the overhead of converting FILETIME structures."}
{"number": 1084, "change": "@@ -343,7 +343,9 @@ void VertexBuffer::Draw(unsigned int & vbuffer, const Segment & s) const\n \n \tif (s.icount != 0)\n \t{\n-\t\tglDrawElements(GL_TRIANGLES, s.icount, GL_UNSIGNED_INT, (const void *)(size_t)s.ioffset);\n+\t\tglDrawRangeElements(\n+\t\t\tGL_TRIANGLES, s.voffset, s.voffset + s.vcount - 1, s.icount,\n+\t\t\tGL_UNSIGNED_INT, (const void *)(size_t)s.ioffset);\n \t}\n \telse\n \t{\n", "fix_pattern": "<pattern>: if a draw call is made using glDrawElements, replace it with glDrawRangeElements while specifying the range of vertex indices to enhance performance by potentially reducing overdraw and improving batching efficiency."}
{"number": 1085, "change": "@@ -600,11 +600,8 @@ int iV_DrawFormattedText(const char* String, UDWORD x, UDWORD y, UDWORD Width, U\n \n void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotation)\n {\n-\tGLint matrix_mode = 0;\n-\n \tpie_SetTexturePage(TEXPAGE_FONT);\n \n-\tglGetIntegerv(GL_MATRIX_MODE, &matrix_mode);\n \tglMatrixMode(GL_TEXTURE);\n \tglPushMatrix();\n \tglLoadIdentity();\n@@ -630,7 +627,7 @@ void iV_DrawTextRotated(const char* string, float XPos, float YPos, float rotati\n \tglPopMatrix();\n \tglMatrixMode(GL_TEXTURE);\n \tglPopMatrix();\n-\tglMatrixMode(matrix_mode);\n+\tglMatrixMode(GL_MODELVIEW);\n \n \t// Reset the current model view matrix\n \tglLoadIdentity();\n", "fix_pattern": "<pattern>: if retrieving the current matrix mode using glGetIntegerv(GL_MATRIX_MODE, ...) is unnecessary and a specific mode (e.g., GL_MODELVIEW) can be assumed or set directly, replace the call with a direct glMatrixMode(...) invocation to improve performance."}
{"number": 1086, "change": "@@ -76,15 +76,14 @@ void GlLine::draw(float,Camera *) {\n \t\tglLineStipple(factor,pattern);\n \t\tglEnable(GL_LINE_STIPPLE);\n \t}\n-\tglBegin(GL_LINE_STRIP);\n \n-\tfor(unsigned int i=0; i < _points.size(); ++i) {\n-\t\tif (i < _colors.size()) {\n-\t\t\tsetColor(_colors[i]);\n-\t\t}\n-\t\tglVertex3fv((float *)&_points[i]);\n-\t}\n-\tglEnd();\n+\tglEnableClientState(GL_VERTEX_ARRAY);\n+\tglEnableClientState(GL_COLOR_ARRAY);\n+\tglVertexPointer(3, GL_FLOAT, 3 * sizeof(float), &_points[0]);\n+\tglColorPointer(4, GL_UNSIGNED_BYTE, 4 * sizeof(unsigned char), &_colors[0]);\n+\tglDrawArrays(GL_LINE_STRIP, 0, _points.size());\n+\tglDisableClientState(GL_VERTEX_ARRAY);\n+\tglDisableClientState(GL_COLOR_ARRAY);\n \n \tOpenGlConfigManager::getInst().desactivateLineAndPointAntiAliasing();\n \n", "fix_pattern": "<pattern>: if OpenGL drawing commands use `glBegin` and `glEnd` for drawing multiple vertices and colors, refactor the code to use vertex array capabilities, enabling the appropriate client states and using `glDrawArrays` for improved performance and reduced overhead."}
{"number": 1087, "change": "@@ -74,8 +74,8 @@ namespace TrenchBroom {\n                 if (m_textureBuffer != NULL) {\n                     glGenTextures(1, &m_textureId);\n                     glBindTexture(GL_TEXTURE_2D, m_textureId);\n-                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n-                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n+                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n+                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n                     glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n                     glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n                     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, static_cast<GLsizei>(m_width), static_cast<GLsizei>(m_height), 0, GL_RGB, GL_UNSIGNED_BYTE, m_textureBuffer);\n", "fix_pattern": "<pattern>: if the texture filtering parameters for glTexParameterf are set to GL_LINEAR, replace them with GL_NEAREST to improve performance when setting texture parameters where linear filtering is unnecessary."}
{"number": 1088, "change": "@@ -847,7 +847,7 @@ void filter::blur::blur_instance::video_render(gs_effect_t* effect)\n \t\t\t\tgs_clear(GS_CLEAR_COLOR | GS_CLEAR_DEPTH, &black, 0, 0);\n \n \t\t\t\t// Render\n-\t\t\t\tif (obs_source_process_filter_begin(this->m_self, GS_RGBA, OBS_NO_DIRECT_RENDERING)) {\n+\t\t\t\tif (obs_source_process_filter_begin(this->m_self, GS_RGBA, OBS_ALLOW_DIRECT_RENDERING)) {\n \t\t\t\t\tobs_source_process_filter_end(this->m_self, defaultEffect, baseW, baseH);\n \t\t\t\t} else {\n \t\t\t\t\tthrow std::runtime_error(\"Failed to render source\");\n", "fix_pattern": "<pattern>: if the API method obs_source_process_filter_begin is called with OBS_NO_DIRECT_RENDERING, change the flag to OBS_ALLOW_DIRECT_RENDERING to potentially enable direct rendering, enhancing performance by leveraging hardware acceleration if supported."}
{"number": 1089, "change": "@@ -563,7 +563,6 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n     int return_code;\n     LSTATUS status;\n     unsigned int i;\n-    char str[256];\n     VkResult res;\n \n     WINE_TRACE(\"Starting VR info initialization.\\n\");\n@@ -587,14 +586,8 @@ static DWORD WINAPI initialize_vr_data(void *arg)\n         WINE_ERR(\"Could not get IVRClientCore, error %d.\\n\", return_code);\n     }\n \n-    if ((env_str = getenv(\"SteamGameId\")))\n-        app_id = atoi(env_str);\n-    else\n-        app_id = 1245040; /* Proton 5.0 */\n-\n     /* Without overriding the app_key vrclient waits 2 seconds for a valid appkey before returning. */\n-    sprintf(str, \"{ \\\"app_key\\\" : \\\"steam.app.%u\\\" }\", app_id);\n-    error = client_core->Init(vr::VRApplication_Background, str);\n+    error = client_core->Init(vr::VRApplication_Background, NULL);\n     if (error != vr::VRInitError_None)\n     {\n         if (error == vr::VRInitError_Init_NoServerForBackgroundApp)\n", "fix_pattern": "<pattern>: if the initialization of a string with `sprintf` for API calls is unnecessary (as seen in the removal of dynamic app_id generation), directly pass `NULL` to avoid unnecessary string manipulation and potential performance overhead."}
{"number": 1091, "change": "@@ -21,6 +21,7 @@\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Support/Chrono.h\"\n #include \"llvm/Support/CommandLine.h\"\n+#include \"llvm/Support/ConvertUTF.h\"\n #include \"llvm/Support/Errc.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Format.h\"\n@@ -518,8 +519,8 @@ static bool comparePaths(StringRef Path1, StringRef Path2) {\n // binary equivalence and allows for case insensitivity.\n #ifdef _WIN32\n   SmallVector<wchar_t, 128> WPath1, WPath2;\n-  failIfError(sys::path::widenPath(normalizePath(Path1), WPath1));\n-  failIfError(sys::path::widenPath(normalizePath(Path2), WPath2));\n+  failIfError(sys::windows::UTF8ToUTF16(normalizePath(Path1), WPath1));\n+  failIfError(sys::windows::UTF8ToUTF16(normalizePath(Path2), WPath2));\n \n   return CompareStringOrdinal(WPath1.data(), WPath1.size(), WPath2.data(),\n                               WPath2.size(), true) == CSTR_EQUAL;\n", "fix_pattern": "<pattern>: if a function is changed from using sys::path::widenPath to sys::windows::UTF8ToUTF16 for converting paths, it may indicate a more efficient or appropriate API usage for converting UTF-8 paths to UTF-16 on Windows, which could lead to performance improvements in handling string conversions."}
{"number": 1092, "change": "@@ -88,13 +88,18 @@ QVariant DateFilter::doFilter(const QVariant &input, const QVariant &argument,\n                               bool autoescape) const\n {\n   Q_UNUSED(autoescape)\n-  auto d = QDateTime::fromString(getSafeString(input),\n+    QDateTime d;\n+    if (input.type() == QVariant::DateTime) {\n+        d = input.toDateTime();\n+    } else if (input.type() == QVariant::Date) {\n+        d.setDate(input.toDate());\n+    } else {\n #if QT_VERSION < QT_VERSION_CHECK(5, 11, 0)\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss\"));\n #else\n-                                 QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\")\n+        d = QDateTime::fromString(getSafeString(input), QStringLiteral(\"yyyy-MM-ddThh:mm:ss.zzz\"));\n #endif\n-  );\n+    }\n \n   auto argString = getSafeString(argument);\n \n", "fix_pattern": "<pattern>: if the input type is checked for QVariant::DateTime or QVariant::Date, avoid calling QDateTime::fromString multiple times and directly use toDateTime() and setDate() methods to improve performance by reducing redundant string conversions."}
{"number": 1093, "change": "@@ -213,7 +213,12 @@ void EffectChain::render_to_screen(unsigned char *src)\n \t\tassert(false);\n \t}\n \n-\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\tstatic bool first = true;\n+\tif (first) {\n+\t\tglTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, GL_UNSIGNED_BYTE, src);\n+\t} else {\n+\t\tglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, format, GL_UNSIGNED_BYTE, src);\n+\t}\n \tcheck_error();\n \tglUniform1i(glGetUniformLocation(glsl_program_num, \"input_tex\"), 0);\n \n", "fix_pattern": "<pattern>: if the initial texture data is uploaded once using glTexImage2D, subsequent updates should be performed using glTexSubImage2D to improve performance by avoiding full texture reallocation. Use a flag to track whether it is the first call or not."}
{"number": 1095, "change": "@@ -300,10 +300,6 @@ char* AFMFileName= aFontName.name.ToNewUTF8String(); // file we will open\n   mAFMFile = fopen((const char *)AFMFileName,\"r\");\n   Recycle(AFMFileName);\n \n-\n-\n-  mAFMFile = fopen((const char *)AFMFileName,\"r\");\n-\n   if(nsnull != mAFMFile) {\n     // create the structure to put the information in\n     mPSFontInfo = new AFMFontInformation;\n", "fix_pattern": "<pattern>: if fopen is called multiple times in a performance-critical section, consider caching the FILE* pointer or managing file access more efficiently to reduce overhead associated with repeated calls to fopen."}
{"number": 1096, "change": "@@ -413,13 +413,9 @@ nsParseMailMessageState::nsParseMailMessageState()\n \tm_IgnoreXMozillaStatus = PR_FALSE;\n \tm_state = nsIMsgParseMailMsgState::ParseBodyState;\n \tClear();\n+  NS_DEFINE_CID(kMsgHeaderParserCID, NS_MSGHEADERPARSER_CID);\n \n-    NS_DEFINE_CID(kMsgHeaderParserCID, NS_MSGHEADERPARSER_CID);\n-    \n-    nsComponentManager::CreateInstance(kMsgHeaderParserCID,\n-                                       nsnull,\n-                                       nsIMsgHeaderParser::GetIID(),\n-                                       (void **) getter_AddRefs(m_HeaderAddressParser));\n+  m_HeaderAddressParser = do_GetService(kMsgHeaderParserCID);\n }\n \n nsParseMailMessageState::~nsParseMailMessageState()\n", "fix_pattern": "<pattern>: when creating instances via nsComponentManager::CreateInstance, switch to using do_GetService for improved performance and cleaner code management; do_GetService typically performs better for retrieving already-existing services."}
{"number": 1097, "change": "@@ -267,9 +267,8 @@ NS_IMETHODIMP\n nsHTMLOptionElement::SetSelectedInternal(PRBool aValue, PRBool aNotify)\n {\n   mIsInitialized = PR_TRUE;\n+\n   // This affects the display, but what the hey, it's a good place for it\n-  PRInt32 ind;\n-  GetIndex(&ind);\n   if (aValue) {\n     return SetAttr(kNameSpaceID_None,\n                    nsLayoutAtoms::optionSelectedPseudo,\n", "fix_pattern": "<pattern>: if a function modifies an output parameter through a pointer, while indirect leads to potential extra overhead, consider using a reference or returning the value directly instead to increase performance and simplify the API."}
{"number": 1098, "change": "@@ -36,16 +36,11 @@ NS_GetSpecialDirectory(const char* specialDirName, nsIFile* *result)\n     nsresult rv;\n     static NS_DEFINE_CID(kDirectoryServiceCID, NS_DIRECTORY_SERVICE_CID);\n     nsCOMPtr<nsIProperties> serv(do_GetService(kDirectoryServiceCID, &rv));\n-    if (NS_FAILED(rv)) return rv;\n+    if (NS_FAILED(rv))\n+        return rv;\n \n-    nsCOMPtr<nsISupports> dir;\n-    rv = serv->Get(specialDirName, NS_GET_IID(nsIFile), getter_AddRefs(dir));\n-    if (NS_FAILED(rv)) return rv;\n-\n-    *result = NS_STATIC_CAST(nsIFile*, NS_STATIC_CAST(nsISupports*, dir));\n-    if (*result)\n-        NS_ADDREF(*result);\n-    return NS_OK;\n+    return serv->Get(specialDirName, NS_GET_IID(nsIFile),\n+                     NS_REINTERPRET_CAST(void**, result));\n }\n \n #endif\n", "fix_pattern": "<pattern>: if the code uses NS_STATIC_CAST and getter_AddRefs to retrieve an object, replace it with a direct call to the API method that returns the object and use NS_REINTERPRET_CAST for type conversion to improve performance and reduce code complexity."}
{"number": 1100, "change": "@@ -83,10 +83,6 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n \n using namespace std;\n \n-#include <GdiPlus.h>\n-\n-using namespace Gdiplus;\n-\n #define HAVE_REMOTE\n #define WPCAP\n #define PACKET_SIZE 65535\n@@ -1262,17 +1258,6 @@ int WINAPI WinMain (HINSTANCE hThisInstance,\n {\n \tdriver = new WinDriver();\n \n-\tULONG_PTR GdiplusToken;\n-\tGdiplusStartupInput GdiplusSI;\n-\n-\tGdiplusSI.GdiplusVersion = 1;\n-\n-\tif(GdiplusStartup(&GdiplusToken, &GdiplusSI, NULL) != Ok)\n-\t{\n-\t\tMessageBox(0, \"Failed to initialize GDI+ !\", \"Severe error\", MB_OK | MB_ICONERROR);\n-\t\treturn 1;\n-\t}\n-\n \tInitializeCriticalSection(&win_sync);\n \n #ifdef GDB_STUB\n@@ -1634,8 +1619,6 @@ int WINAPI WinMain (HINSTANCE hThisInstance,\n \n \tCloseConsole();\n \n-\tGdiplusShutdown(GdiplusToken);\n-\n \treturn 0;\n }\n \n@@ -3460,5 +3443,3 @@ LRESULT CALLBACK SoundSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARA\n \n \treturn FALSE;\n }\n-\n-\n", "fix_pattern": "<pattern>: if GdiplusStartup is called and then immediately followed by GdiplusShutdown, remove the redundant initialization and cleanup, as it does not contribute to any performance improvement or resource handling in its current form."}
{"number": 1101, "change": "@@ -502,7 +502,6 @@ void Renderer::link_batch(GraphicsBatch& batch) {\n     GLuint ssao_vbo;\n     glGenBuffers(1, &ssao_vbo);\n     glBindBuffer(GL_ARRAY_BUFFER, ssao_vbo);\n-    glUseProgram(program);\n     glBufferData(GL_ARRAY_BUFFER, sizeof(quad), &quad, GL_STATIC_DRAW);\n     glEnableVertexAttribArray(glGetAttribLocation(program, \"position\"));\n     glVertexAttribPointer(glGetAttribLocation(program, \"position\"), 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), nullptr);\n@@ -516,7 +515,6 @@ void Renderer::link_batch(GraphicsBatch& batch) {\n     GLuint blur_vbo;\n     glGenBuffers(1, &blur_vbo);\n     glBindBuffer(GL_ARRAY_BUFFER, blur_vbo);\n-    glUseProgram(program);\n     glBufferData(GL_ARRAY_BUFFER, sizeof(quad), &quad, GL_STATIC_DRAW);\n     glEnableVertexAttribArray(glGetAttribLocation(program, \"position\"));\n     glVertexAttribPointer(glGetAttribLocation(program, \"position\"), 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), nullptr);\n", "fix_pattern": "<pattern>: if the OpenGL function glUseProgram is called multiple times with the same program, avoid redundant calls by calling it only once."}
{"number": 1102, "change": "@@ -326,15 +326,12 @@ void Renderer::render(uint32_t delta) {\n   for (auto &transform : transformations) { transform.update(delta); }\n   lights[0].position = transformations[0].current_position; // FIXME: Transforms are not updating their Entities..\n   \n-  \n   /// Geometry pass\n   {\n     glBindFramebuffer(GL_FRAMEBUFFER, gl_depth_fbo);\n     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n     glEnable(GL_DEPTH_TEST);\n     glDepthMask(GL_TRUE);\n-    glEnable(GL_MULTISAMPLE);\n-    glClearColor(0.8f, 0.5f, 0.5f, 1.0f);\n     glEnable(GL_CULL_FACE);\n     glCullFace(GL_BACK);\n     glFrontFace(GL_CCW);\n", "fix_pattern": "<pattern>: if OpenGL state changes (such as enabling capabilities like GL_MULTISAMPLE or setting clear colors) are scattered, consider grouping them for better performance and to minimize state changes, though no specific addition is provided in this case."}
{"number": 1103, "change": "@@ -383,8 +383,6 @@ void Renderer::render(uint32_t delta) {\n       const auto& batch = graphics_batches[i];\n       const auto program = batch.depth_shader.gl_program;\n       glUseProgram(program);\n-      glBindVertexArray(batch.gl_depth_vao);\n-\n       glUniformMatrix4fv(glGetUniformLocation(program, \"camera_view\"), 1, GL_FALSE, glm::value_ptr(camera_transform));\n       \n       // FIXME: These copies should happen outside of the render loop\n", "fix_pattern": "<pattern>: if glBindVertexArray is called redundantly, ensure that it's only called when necessary, potentially by checking if the current VAO is different from the one being bound to avoid unnecessary state changes."}
{"number": 1107, "change": "@@ -19,7 +19,7 @@\n  \n      For further information visit http://plib.sourceforge.net\n \n-     $Id: fnt.cc,v 1.1.2.5 2003-12-04 02:12:47 olly Exp $\n+     $Id: fnt.cc,v 1.1.2.6 2004-03-02 12:28:58 olly Exp $\n */\n \n #include \"fnt.h\"\n@@ -177,9 +177,6 @@ fntTexFont::load(const char *fname)\n \t\t (GLvoid *)teximage);\n     delete [] teximage;\n \n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n-\n     glAlphaFunc(GL_GREATER, 0.5f);\n \n     fseek(fd, fpos, SEEK_SET);\n", "fix_pattern": "<pattern>: NA"}
{"number": 1109, "change": "@@ -255,7 +255,6 @@ struct blade_hw {\n \t\tbladerf_log_set_verbosity(BLADERF_LOG_LEVEL_DEBUG);\n \t\tbladerf_set_usb_reset_on_open(true);\n \n-\t\tsetenv(\"BLADERF_DEFAULT_TUNING_MODE\",\"fpga\",1); // ensure blade 2 does not spend 10 seconds initializing host control\n \t\tblade_check(bladerf_open, &dev, \"\");\n \t\tif (!dev) {\n \t\t\tstd::cerr << \"open failed, device missing?\" << std::endl;\n", "fix_pattern": "<pattern>: NA"}
{"number": 1110, "change": "@@ -2459,7 +2459,6 @@ void MainScene(HDC hDC)\n \n         if (Success)\n         {\n-            glFlush();\n             SwapBuffers(hDC);\n         }\n \n", "fix_pattern": "<pattern>: if glFlush() is called without subsequent rendering commands that require completion, consider removing it or consolidating it to reduce unnecessary sync point overhead in OpenGL rendering."}
{"number": 1112, "change": "@@ -85,7 +85,7 @@ void SdlSWBackend::update(void)\n \t}\n \n \t// Update the screen.\n-\tSDL_UpdateRect(m_screen, 0, 0, 0, 0);\n+\tSDL_Flip(m_screen);\n }\n \n }\n", "fix_pattern": "<pattern>: replace calls to SDL_UpdateRect with SDL_Flip when the intention is to update the entire screen, as SDL_Flip can provide better performance by reducing the overhead of individual rectangle updates."}
{"number": 1114, "change": "@@ -19,7 +19,7 @@\n #include \"kexirelationdesignshape.h\"\n \n KexiRelationDesignToolFactory::KexiRelationDesignToolFactory( QObject* parent)\n-: KoToolFactory( parent, \"KexiRelationDesignToolFactoryId\", i18n( \"Kexi Relation Design Tool\" ) )\n+: KoToolFactory(parent, \"KexiRelationDesignToolFactoryId\")\n {\n     setToolTip( i18n( \"Relation design tool\" ) );\n     setIcon( \"kexi\" );\n", "fix_pattern": "<pattern>: if a call to the i18n function for internationalization is not required (as seen in the removal of the \"i18n(...)\" call), then directly use the string literal in the constructor instead to improve performance by avoiding unnecessary overhead from internationalization processing."}
{"number": 1115, "change": "@@ -1573,7 +1573,7 @@ void KStartupInfoData::setApplicationId(const QString &desktop)\n     // the spec requires this is always a full path, in order for everyone to be able to find it\n     QString desk = QStandardPaths::locate(QStandardPaths::ApplicationsLocation, desktop);\n     if (desk.isEmpty()) {\n-        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, \"kservices5/\" + desktop);\n+        desk = QStandardPaths::locate(QStandardPaths::GenericDataLocation, QLatin1String(\"kservices5/\") + desktop);\n     }\n     if (desk.isEmpty()) {\n         return;\n", "fix_pattern": "<pattern>: if a QString created from a literal is concatenated with another QString, use QLatin1String to avoid unnecessary conversion overhead for better performance."}
{"number": 1116, "change": "@@ -517,11 +517,14 @@ void Core::emitRichNotification(const QString &evid, const QString &title, const\n \n bool Core::emitBatteryChargePercentNotification(int currentPercent, int previousPercent, const QString &udi, Core::ChargeNotificationFlags flags)\n {\n-    using namespace Solid;\n-    Device device(udi);\n-    Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+    if (m_peripheralBatteriesPercent.contains(udi)) {\n+        using namespace Solid;\n+        Device device(udi);\n+        Battery *b = qobject_cast<Battery *>(device.asDeviceInterface(DeviceInterface::Battery));\n+        if (!b) {\n+            return false;\n+        }\n \n-    if (b && !b->isPowerSupply()) {\n         // if you leave the device out of reach or it has not been initialized yet\n         // it won't be \"there\" and report 0%, don't show anything in this case\n         if (!b->isPresent() || b->chargePercent() == 0) {\n", "fix_pattern": "<pattern>: if there is a need to check for a specific device's power supply status through an API call that is potentially costly, add a quick lookup check in a map or set to determine if further API usage is necessary, thus avoiding unnecessary calls when the information can be derived from a pre-checked structure."}
{"number": 1118, "change": "@@ -95,9 +95,9 @@ KAboutPerson KAboutPerson::fromJSON(const QJsonObject &obj)\n {\n     const QString name = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Name\"));\n     const QString task = KJsonUtils::readTranslatedString(obj, QStringLiteral(\"Task\"));\n-    const QString email = obj[QStringLiteral(\"Email\")].toString();\n-    const QString website = obj[QStringLiteral(\"Website\")].toString();\n-    const QUrl avatarUrl = obj[QStringLiteral(\"AvatarUrl\")].toVariant().toUrl();\n+    const QString email = obj.value(QLatin1String(\"Email\")).toString();\n+    const QString website = obj.value(QLatin1String(\"Website\")).toString();\n+    const QUrl avatarUrl = obj.value(QLatin1String(\"AvatarUrl\")).toVariant().toUrl();\n     return KAboutPerson(name, task, email, website, avatarUrl);\n }\n \n", "fix_pattern": "<pattern>: if accessing keys in a QJsonObject using QStringLiteral results in potential repeated conversions from QString to QByteArray, use QLatin1String instead for improved performance."}
{"number": 1119, "change": "@@ -99,9 +99,7 @@ KNotesApp::KNotesApp()\n {\n     Akonadi::ControlGui::widgetNeedsAkonadi(this);\n \n-    if (!qgetenv(\"KDEPIM_BALOO_DEBUG\").isEmpty()) {\n-        mDebugBaloo = true;\n-    }\n+    mDebugBaloo = !qEnvironmentVariableIsEmpty(\"KDEPIM_BALOO_DEBUG\");\n \n     if (KNotesGlobalConfig::self()->autoCreateResourceOnStart()) {\n         NoteShared::LocalResourceCreator *creator = new NoteShared::LocalResourceCreator(this);\n", "fix_pattern": "<pattern>: if checking for an environment variable and its value's emptiness, replace qgetenv and isEmpty with the more direct qEnvironmentVariableIsEmpty for improved performance."}
{"number": 1120, "change": "@@ -675,7 +675,12 @@ void KHTMLView::viewportToContents(int x, int y, int& cx, int& cy) const\n void KHTMLView::updateContents(int x, int y, int w, int h)\n {\n     applyTransforms(x, y, w, h);\n-    widget()->update(x, y, w, h);\n+    if (m_kwp->isRedirected()) {\n+        QPoint off = m_kwp->absolutePos();\n+        KHTMLView* pview = m_part->parentPart()->view();\n+        pview->updateContents(x+off.x(), y+off.y(), w, h);\n+    } else\n+        widget()->update(x, y, w, h);\n }\n \n void KHTMLView::updateContents( const QRect& r )\n", "fix_pattern": "<pattern>: if the `update` method is conditionally called based on whether `m_kwp->isRedirected()` returns true, replace the single call to `widget()->update(x, y, w, h);` with the more specific call to `pview->updateContents(...)` when redirected, which prevents unnecessary calls to `widget()->update()` when not needed, thus optimizing the update process based on the state of the object."}
{"number": 1121, "change": "@@ -2,9 +2,6 @@\n #define \tBLEND_CR   (*(vuint16*)0x04000050)\n #define \tBLEND_AB   (*(vuint16*)0x04000052)\n #define \tBLEND_Y   (*(vuint16*)0x04000054)\n-float rotateX = 0.0;\n-float rotateY = 0.0;\n-\n void init3D()\n {\n \t// initialize gl\n@@ -23,7 +20,7 @@ void init3D()\n \t//any floating point gl call is being converted to fixed prior to being implemented\n \tglMatrixMode(GL_PROJECTION);\n \tglLoadIdentity();\n-  glOrtho(0.0,0.0625,0.046875,0.0,0.0,1.0);\n+  glOrthof32(0,256,192,0,0,512);\n \tglPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE | POLY_ID(2)); //*/\n }\n \n", "fix_pattern": "<pattern>: if using OpenGL's glOrtho function with double precision for orthographic projection, replace it with the corresponding libnds function glOrthof32 that operates with float precision to achieve better performance on the Nintendo DS platform."}
